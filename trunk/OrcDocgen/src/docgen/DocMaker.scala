//
// DocMaker.scala -- Scala class/trait/object DocMaker
// Project OrcDocgen
//
// $Id$
//
// Created by dkitchin on Dec 16, 2010.
//
// Copyright (c) 2010 The University of Texas at Austin. All rights reserved.
//
// Use and redistribution of this file is governed by the license terms in
// the LICENSE file found in the project's top-level directory and also found at
// URL: http://orc.csres.utexas.edu/license.shtml .
//
package docgen

import java.io.File
import scala.xml._

/**
 * 
 *
 * @author dkitchin
 */
object DocMaker {
  
  def nonblank(line: String): Boolean = !line.trim().isEmpty
  
  /* Split a chunk of text into paragraphs */
  def paragraphs(s: String): List[String] = {
    def groupLines(lines: List[String]): List[String] = {
      lines match {
        case first :: _ if nonblank(first) => {
          val (nonblankLines, rest) = lines span nonblank
          val para = (nonblankLines foldLeft "") { (s: String, t: String) => s + t }
          para :: groupLines(rest)
        }
        case _ :: rest => groupLines(rest)
        case _ => Nil
      }
    }
    groupLines(s.linesWithSeparators.toList)
  }
  
  
  def makeDoc(files: List[File]): Node = {
    val leadingComment = {
      Comment( 
      "Generated by orc.doc.MakeDoc from: " +
      ({ (files map { f:File => f.getName() }).mkString("{",",","}") } : String) + 
      " on " + 
      { java.text.DateFormat.getDateTimeInstance().format(new java.util.Date()) }
      )
    }
    <section>
      { leadingComment }
      <title>Reference</title>
      { files map renderSection }
    </section>
  } 
    
  def renderSection(f: File) = {
    val docItemList = DocParsers.parseFile(f)
    val optionalHeader = {
      docItemList match {
        case DocText(s) :: _ if nonblank(s) => ": " + s.lines.next()
        case _ => "" 
      }
    }
    <section> 
      <title>{ f.getName() + optionalHeader }</title>
      { renderItems(docItemList)("") }
    </section>
  }
  
  def renderItems(items: List[DocItem])(implicit nextCode: String): List[Node] = {
    items match {
      case DocText(s) :: rest => {
        val paraNodes = paragraphs(s) map { p: String => <para>{ Unparsed(p) }</para> }
        paraNodes ::: renderItems(rest)
      }
      case (_ : DocDecl) :: _ => {
        val (decls, rest) = items span { _.isInstanceOf[DocDecl] }
        val newNextCode = {
          items find { _.isInstanceOf[DocOutside] } match {
            case Some(DocOutside(body)) => body
            case None => ""
          }
        }
        val declChunk = {
          <variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            { decls map { d: DocItem => renderDecl(d.asInstanceOf[DocDecl])(newNextCode) } }
          </variablelist>  
        }
        declChunk :: renderItems(rest)
      }
      case DocImpl :: rest => {
        renderImplementation(nextCode) :: renderItems(rest)
      }
      // If we encounter uncommented content, ignore it.
      case (_ : DocOutside) :: rest => renderItems(rest)
      
      // No more input
      case Nil => Nil
    }
    
  }
  
    
  def renderDecl(decl: DocDecl)(implicit nextCode: String) = {
    <varlistentry>
      <term><code>{ decl.name }</code></term>
      <listitem>
        <para><code>{ decl.keyword + decl.typeDeclaration }</code></para>
        { renderItems(decl.body) }
      </listitem>
    </varlistentry>
  }  
  
  
  def renderImplementation(code: String) = {
    <formalpara>
      <title>Implementation</title>
      <programlisting>
        { PCData(code) }
      </programlisting>
    </formalpara>
  }
   
}