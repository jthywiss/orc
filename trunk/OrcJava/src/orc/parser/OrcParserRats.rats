module orc.parser.OrcParserRats;

import orc.parser.OrcLiteralParser;

header {
	import java.util.List;
	import java.util.LinkedList;
	import java.util.ListIterator;
	import java.io.FileNotFoundException;
	import java.io.File;
	import java.io.Reader;
	import java.math.BigInteger;
	import java.math.BigDecimal;
	
	import xtc.util.Utilities;
	import xtc.util.Action;
	import xtc.util.Pair;
	import xtc.tree.Location;
	
	import orc.Config;
	import orc.ast.extended.*;
	import orc.ast.extended.expression.*;
	import orc.ast.extended.pattern.*;
	import orc.ast.extended.type.*;
	import orc.ast.extended.declaration.*;
	import orc.ast.extended.declaration.def.*;
	import orc.ast.extended.declaration.type.*;
	import orc.error.*;

	import orc.runtime.values.Value;
	import orc.runtime.values.ListValue;
	import orc.runtime.values.TupleValue;
}

body {
	private Config config;
	
	public OrcParserRats(Config config, Reader reader, String filename) {
		this(reader, filename);
		this.config = config;
	}

	/**
	 * Attach a source location to an expression. Used like this:
	 * <code>yyValue = at(yyStart, yyCount, yyValue)</code>
	 */
	protected final <E extends Locatable> E at(int start, int end, E e) {
		Location startl = location(start);
		Location endl = location(end-2);
		e.setSourceLocation(new SourceLocation(
			new File(startl.file), start, startl.line, startl.column,
			end-2, endl.line, endl.column));
		return e;
	}
	/**
	 * Attach a source location to an infix binary operator.
	 */
	protected final <E extends Locatable> E at(Locatable start, Locatable end, E e) {
		SourceLocation startl = start.getSourceLocation();
		SourceLocation endl = end.getSourceLocation();
		e.setSourceLocation(new SourceLocation(
			startl.file, startl.offset, startl.line, startl.column,
			endl.endOffset, endl.endLine, endl.endColumn));
		return e;
	}
	/**
	 * Attach a source location to a postfix operator.
	 */
	protected final <E extends Locatable> E at(Locatable start, int end, E e) {
		SourceLocation startl = start.getSourceLocation();
		Location endl = location(end-2);
		e.setSourceLocation(new SourceLocation(
			startl.file, startl.offset, startl.line, startl.column,
			end-2, endl.line, endl.column));
		return e;
	}
	
	/**
	 * Signal an unrecoverable error in the parse. See
	 * examples of how this is used in productions to
	 * prevent unwanted backtracking.  This should be
	 * used with extreme care to ensure that it doesn't
	 * prevent necessary backtracking.
	 */
	protected final void abort(ParseError error) throws IOException {
		throw new AbortParse(format(error), error);
	}
}

option constant;

/////////////////////////////////////////////
// Declarations
/////////////////////////////////////////////

public Expression Program = Space yyValue:Body EndOfFile;
	
/*
 * Include files are treated differently than programs;
 * the may not have a goal expression.
 */
public List<Declaration> Module =
	Space yyValue:Declarations EndOfFile
	;

/*
 * The body of a program or definition may include
 * declarations and must include a goal expression.
 */
Expression Body =
	ds:Declarations g:GoalExpression {
		Expression out = g;
		ListIterator<Declaration> it = ds.listIterator(ds.size());
		while (it.hasPrevious()) {
			out = new Declare(it.previous(), out);
		}
		yyValue = out;
	}
	;

List<Declaration> Declarations =
	ds:Include ds2:Declarations {
		ds.addAll(ds2);
		yyValue = ds;
	}
	/ d:Declaration ds:Declarations {
		ds.add(0, d);
		yyValue = ds;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Declaration>();
	}
	;
	
/*
 * Include files are parsed in place.
 */
List<Declaration> Include =
	INCLUDE filename:StringLiteral Space ^{
		File thisfile = new File(location(yyStart).file);
		String thisdir = thisfile.getParent();
		OrcParserRats parser = new OrcParserRats(config, config.openInclude(filename, thisdir), new File(thisdir, filename).getPath());
		Result result = parser.pModule(0);
		if (result.hasValue()) {
			yyResult = new SemanticValue(result.semanticValue(), yyBase);
		} else {
			parser.abort(result.parseError());
		}
	}
	;

Declaration Declaration =
	SITE name:RequiredSiteName Space RequiredEQ className:RequiredClassName {
		yyValue = new SiteDeclaration(name, className);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ CLASS name:RequiredIdentifier Space RequiredEQ className:RequiredClassName {
		yyValue = new ClassDeclaration(name, className);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ defs:Definition+ {
		// a block of definitions is treated as a single
		// declaration (akin to a letrec)
		yyValue = new DefsDeclaration(defs.list());
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ VAL p:Pattern RequiredEQ e:Body {
		yyValue = new ValDeclaration(p, e);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ TYPE name:Identifier tf:TypeFormals Space EQ cs:ConstructorList {
		yyValue = new DatatypeDeclaration(name, cs, tf);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ TYPE name:Identifier Space EQ className:ClassName {
		yyValue = new TypeDeclaration(name, className);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ TYPE name:RequiredIdentifier tf:TypeFormals Space RequiredEQ t:Type {
		yyValue = new TypeAliasDeclaration(name, t, tf);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;


Constructor Constructor =
	name:Identifier &{ !name.equals("lambda") } LPAREN ts:TypeList RPAREN Space {
		yyValue = new Constructor(name,ts);
	}
	;

List<Constructor> ConstructorList = 
	c:Constructor cs:(void:BAR cs:Constructor)* {
		List<Constructor> out = cs.list();
		out.add(0, c);
		yyValue = out;
	}
	;


DefMember Definition =
	DEF name:RequiredSiteName Space LPAREN formals:PatternList RPAREN Space
	curried0:(LPAREN yyValue:PatternList RPAREN Space)*
	resultType:MaybeResultType
	EQ body0:Body {
		Type linearResultType = resultType;
		List<List<Pattern>> curried = curried0.list();
		ListIterator<List<Pattern>> it = curried.listIterator(curried.size());
		Expression body = body0;
		while (it.hasPrevious()) {
			body = new Lambda(it.previous(), body, linearResultType);
			linearResultType = null;
		}
		yyValue = new DefMemberClause(name, formals, body, linearResultType);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ DEF name:RequiredSiteName Space typeFormals:TypeFormals LPAREN argTypes:TypeList RPAREN Space
	curried0:(LPAREN yyValue:TypeList RPAREN Space)*
	resultType:MaybeResultType {
		Type curriedType = resultType;
		List<List<Type>> curried = curried0.list();
		ListIterator<List<Type>> it = curried.listIterator(curried.size());
		while (it.hasPrevious()) {
			curriedType = new ArrowType(it.previous(), curriedType, new LinkedList<String>() /* curried type params not allowed */);
		}
		yyValue = new DefMemberType(name, argTypes, curriedType, typeFormals);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;

List<String> IdentifierList =
	f:Identifier fs:(void:COMMA fs:Identifier)* {
		List<String> out = fs.list();
		out.add(0, f);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<String>();
	}
	;

List<Pattern> PatternList =
	f:Pattern fs:(void:COMMA fs:Pattern)* {
		List<Pattern> out = fs.list();
		out.add(0, f);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Pattern>();
	}
	;
	
/*---------------------------------------------------------
Expressions

For reference, here are Orc's operators sorted
and grouped in order of increasing precedence.

Symbol   Assoc       Name
----------------------------------------------------
 lambda  prefix[3]   anonymous function
 if      prefix[3]   if/then/else
----------------------------------------------------
 ;       left        semicolon
----------------------------------------------------
 <<      left        where
----------------------------------------------------
 |       right[2]    parallel
----------------------------------------------------
 >>      right       sequence
----------------------------------------------------
 ::      right       type annotation
 atomic  prefix      atomic transaction
 :=      none        ref assignment
----------------------------------------------------
 ||      right[2]    boolean or
 &&      right[2]    boolean and
----------------------------------------------------
 =       none        equal
 /=      none        not equal
 :>      none        greater
 >       none[1]     greater
 >=      none        greater or equal
 <:      none        less
 <       none[1]     less
 <=      none        less or equal
----------------------------------------------------
 ~       prefix      boolean not
 :       right       cons
 +       left        addition
 -       left[4]     subtraction
----------------------------------------------------
 *       left        multiplication
 /       left        division
 %       left        modulus
----------------------------------------------------
 **      left        exponent
----------------------------------------------------
 -       prefix      unary minus
----------------------------------------------------
 ?       postfix     dereference
 .       postfix     field projection
 ()      postfix[4]  application

[1] An expression like (a > b > c > d) could be read as
either ((a >b> c) > d) or (a > (b >c> d)). We could resolve
this ambiguity with precedence, but that's likely to
violate the principle of least suprise. So instead we just
disallow these operators unparenthesized inside << or >>.
This results in some unfortunate duplication of the lower-
precedence operators: see the NoCmp_ productions.

[2] These operators are semantically fully associative, but
they are implemented as right-associative because it's
slightly more efficient in Rats!.

[3] I'm not sure whether I'd call lambda and if operators,
but the point is they bind very loosely, so everything to
their right is considered part of their body.

[4] These operators may not be preceded by a newline, to
avoid ambiguity about where an expression ends.  So if you
have a newline in front of a minus, the parser assumes
it's a unary minus, and if you have a newline in front of
a paren, the parser assumes it's a tuple (as opposed to a
function application).  Hopefully these rules match how
people intuitively use these operators.
-----------------------------------------------------------*/

Expression GoalExpression =
	Lambda
	/ MaybeOtherwiseExpression
	;
	
Expression MaybeOtherwiseExpression =
	seed:MaybePruningExpression actions:OtherwiseExpressionTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> OtherwiseExpressionTail =
	SEMICOLON right:MaybePruningExpression {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				Expression yyValue = new Otherwise(left, right);
				yyValue = at(left, right, yyValue);
				return yyValue;
			}
		};
	}
	;

Expression Lambda = 
	LAMBDA LPAREN formals:PatternList RPAREN Space
	curried0:(LPAREN yyValue:PatternList RPAREN Space)*
	resultType:MaybeResultType
	RequiredEQ body0:Body {
		List<List<Pattern>> curried = curried0.list();
		ListIterator<List<Pattern>> it = curried.listIterator(curried.size());
		Type linearResultType = resultType;
		Expression body = body0;
		while (it.hasPrevious()) {
			body = new Lambda(it.previous(), body, linearResultType);
			linearResultType = null;
		}
		yyValue = new Lambda(formals, body, linearResultType);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;
	
Expression MaybePruningExpression =
	// A "NoCmp" expression is one which does not contain
	// the unparenthesized comparison operators < and >,
	// which might confuse the parser
	seed:NoCmpMaybeBarExpression actions:PruningExpressionTail+ {
		yyValue = apply(actions, seed);
	}
	/ MaybeBarExpression
	;
Action<Expression> PruningExpressionTail = 
	LANGLE p:Pattern? LANGLE right:NoCmpMaybeBarExpression {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				Expression yyValue;
				if (p == null) yyValue = new Pruning(left, right);
				else yyValue = new Pruning(left, right, p);
				yyValue = at(left, right, yyValue);
				return yyValue;
					
			}
		};
	}
	;

Expression MaybeBarExpression =
	left:MaybeSeqExpression BAR right:MaybeBarExpression {
		yyValue = new Parallel(left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ MaybeSeqExpression
	;
Expression NoCmpMaybeBarExpression =
	left:NoCmpMaybeSeqExpression BAR right:NoCmpMaybeBarExpression {
		yyValue = new Parallel(left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ NoCmpMaybeSeqExpression
	;
	
Expression SeqExpression =
	left:NoCmpMaybeAtomic RANGLE p:Pattern? RANGLE right:NoCmpMaybeSeqExpression {
		if (p == null) yyValue = new Sequential(left, right);
		else yyValue = new Sequential(left, right, p);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;
Expression MaybeSeqExpression = SeqExpression / IfThenElse / TryCatch / MaybeTyped;
Expression NoCmpMaybeSeqExpression = SeqExpression / IfThenElse / TryCatch / NoCmpMaybeTyped;
	
Expression IfThenElse =
	IF condition:MaybeDisjunction THEN consequent:MaybeOtherwiseExpression ELSE alternative:MaybeOtherwiseExpression {
		yyValue = new IfThenElse(condition, consequent, alternative);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ IF condition:MaybeDisjunction THEN consequent:MaybeOtherwiseExpression {
		yyValue = new IfThenElse(condition, consequent);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;

CatchHandler CatchHandler = CATCH LPAREN formals:PatternList RPAREN Space handler:MaybeOtherwiseExpression {
    yyValue = new CatchHandler(formals, handler);
}
;

Expression TryCatch =
    TRY tryblock:MaybeDisjunction catches:CatchHandler+ {
    yyValue = new Catch(tryblock, catches.list());
    yyValue = at(yyStart, yyCount, yyValue);
}
;
    
Expression MaybeTyped =
	body:MaybeAtomic void:DOUBLE_COLON_BANG type:Type {
		yyValue = new HasType(body, new AssertedType(type));
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ body:MaybeAtomic void:DOUBLE_COLON type:Type {
		yyValue = new HasType(body, type);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ MaybeAtomic
	;

Expression NoCmpMaybeTyped =
	body:NoCmpMaybeAtomic void:DOUBLE_COLON_BANG type:Type {
		yyValue = new HasType(body, new AssertedType(type));
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ body:NoCmpMaybeAtomic void:DOUBLE_COLON type:Type {
		yyValue = new HasType(body,type);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ NoCmpMaybeAtomic
	;

Expression MaybeAtomic =
	void:ATOMIC body:MaybeAssignment {
		yyValue = new Atomic(body);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ void:ISOLATED body:MaybeAssignment {
		yyValue = new Isolated(body);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ void:THROW exception:MaybeAssignment {
		yyValue = new Throw(exception);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ MaybeAssignment
	;

Expression NoCmpMaybeAtomic =
	void:ATOMIC body:NoCmpMaybeAssignment {
		yyValue = new Atomic(body);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ void:ISOLATED body:NoCmpMaybeAssignment {
		yyValue = new Isolated(body);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ void:THROW exception:NoCmpMaybeAssignment {
		yyValue = new Throw(exception);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ NoCmpMaybeAssignment
	; 

Expression MaybeAssignment =
    left:DotExpression void:COLON_EQUALS right:MaybeDisjunction {
		yyValue = new Call(":=", left, right);
		yyValue = at(yyStart, yyCount, yyValue);
    }
    / MaybeDisjunction
    ;
Expression NoCmpMaybeAssignment =
    left:DotExpression void:COLON_EQUALS right:NoCmpMaybeDisjunction {
		yyValue = new Call(":=", left, right);
		yyValue = at(yyStart, yyCount, yyValue);
    }
    / NoCmpMaybeDisjunction
    ;

Expression MaybeDisjunction =
	left:MaybeConjunction void:OROR right:MaybeDisjunction {
		yyValue = new Call("||", left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ MaybeConjunction
	;
Expression NoCmpMaybeDisjunction =
	left:NoCmpMaybeConjunction void:OROR right:NoCmpMaybeDisjunction {
		yyValue = new Call("||", left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ NoCmpMaybeConjunction
	;
	
Expression MaybeConjunction = 
	left:MaybeComparison void:ANDAND right:MaybeConjunction {
		yyValue = new Call("&&", left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ MaybeComparison
	;
Expression NoCmpMaybeConjunction = 
	left:NoCmpMaybeComparison void:ANDAND right:NoCmpMaybeConjunction {
		yyValue = new Call("&&", left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ NoCmpMaybeComparison
	;


Expression MaybeComparison = 
	left:Comparable op:Comparator right:Comparable {
		yyValue = new Call(op, left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ NoCmpMaybeComparison
	;
String Comparator = RANGLE / LANGLE ;
	
Expression NoCmpMaybeComparison = 
	left:Comparable op:NoCmpComparator right:Comparable {
		yyValue = new Call(op, left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ Comparable
	;
String NoCmpComparator = EQ / NEQ / GT / GEQ / LT / LEQ ;

Expression Comparable =
	NOT x:DotExpression Space {
		yyValue = new Call("~", x);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ Cons
	/ MaybeSum Space
	;
	
Expression Cons =
	left:MaybeSigned Space void:COLON right:(Cons / MaybeSigned Space) {
		yyValue = new ConsExpr(left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;

///////////////////////////////////////////////////////////
// NOTE: from here down, in the expression syntax,
// expression productions cannot end with a newline.
// Anywhere a newline is permitted, it must be explicitly
// by following the production with "Space".
	
/* Ends without newline */
Expression MaybeSum =
	seed:MaybeProduct actions:SumTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> SumTail =
	op:SumOperator right:MaybeProduct {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				Expression yyValue = new Call(op, left, right);
				yyValue = at(left, right, yyValue);
				return yyValue;
			}
		};
	}
	;
String SumOperator = Space PLUS / MINUS ;
	
/* Ends without newline */
Expression MaybeProduct =
	seed:MaybeExponent Space actions:ProductTail {
		yyValue = apply(actions, seed);
	}
	/ MaybeExponent
	;
Pair<Action<Expression>> ProductTail =
	op:ProductOperator right:MaybeExponent rest:(Space ProductTail)? {
		yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
				public Expression run(Expression left) {
					Expression yyValue = new Call(op, left, right);
					yyValue = at(left, right, yyValue);
					return yyValue;
				}
			}, rest == null ? Pair.EMPTY : rest);
	}
	;
String ProductOperator = DIV / MOD / TIMES ;
	
/* Ends without newline */
Expression MaybeExponent =
	seed:MaybeSigned Space actions:ExponentTail {
		yyValue = apply(actions, seed);
	}
	/ MaybeSigned
	;
Pair<Action<Expression>> ExponentTail =
	op:ExponentOperator right:MaybeSigned rest:(Space ExponentTail)? {
		yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
				public Expression run(Expression left) {
					Expression yyValue = new Call(op, left, right);
					yyValue = at(left, right, yyValue);
					return yyValue;
				}
			}, rest == null ? Pair.EMPTY : rest);
	}
	;
String ExponentOperator = EXPONENT ;
	
/* Ends without newline */
Expression MaybeSigned =
	MINUS x:DotExpression {
		yyValue = new Call("0-", x);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ DotExpression
	;

/* Ends without newline */
Expression DotExpression =
	SIGNAL {
		yyValue = new Let();
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ STOP {
		yyValue = new Stop();
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ seed:BasicExpression tail:CallTail {
		yyValue = apply(tail, seed);
	}
	/ seed:BasicExpression
	;
	
/* Ends without newline */
Pair<Action<Expression>> CallTail =
	types:MaybeTypeActuals LPAREN args:ExpressionList RPAREN rest:CallTail? {
		yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
				public Expression run(Expression left) {
					Expression yyValue = new Call(left, args, types);
					yyValue = at(left, yyCount, yyValue);
					return yyValue;
				}
			}, rest == null ? Pair.EMPTY : rest);
	}
	/ Space DOT right:RequiredIdentifier rest:CallTail? {
		yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
				public Expression run(Expression left) {
					Expression yyValue = new Dot(left, right);
					yyValue = at(left, yyCount, yyValue);
					return yyValue;
				}
			}, rest == null ? Pair.EMPTY : rest);
	}
	/ Space QMARK rest:CallTail? {
		yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
				public Expression run(Expression left) {
					Expression yyValue = new Call("?", left);
					yyValue = at(left, yyCount, yyValue);
					return yyValue;
				}
			}, rest == null ? Pair.EMPTY : rest);
	}
	;
	
/* Ends without newline */
Expression BasicExpression =
	Literal
	/ Variable
	/ op:BareOperator {
		yyValue = new Name(op);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ LPAREN args:ExpressionList RPAREN {
		if (args.size() == 1) {
			yyValue = args.get(0);
		} else {
			yyValue = new Let(args);
			yyValue = at(yyStart, yyCount, yyValue);
		}
	}
	/ LBRACKET args:ExpressionList RBRACKET {
		yyValue = new ListExpr(args);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;

Expression Throw =
	THROW exception:BasicExpression {
		yyValue = new Throw(exception);
		yyValue = at(yyStart, yyCount, yyValue);
	};

/* Ends without newline */
String BareOperator =
	LPAREN yyValue:(
		NoCmpComparator / Comparator / COLON_EQUALS / QMARK
		/ ANDAND / OROR / NOT / COLON
		/ ExponentOperator / ProductOperator / SumOperator
		/ "0" MINUS { yyValue = "0-"; }
	) RPAREN
	;

/* Ends without newline */
Literal Literal =
	literal:(
		Number
		/ StringLiteral
		/ TRUE { yyValue = true; }
		/ FALSE { yyValue = false; }
		/ NULL { yyValue = null; }
	) {
		yyValue = new Literal(literal);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;

/* Ends without newline */
Expression Variable =
	name:Identifier {
		yyValue = new Name(name);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;
	
List<Expression> ExpressionList =
	f:Body fs:(COMMA yyValue:Body)* {
		List<Expression> out = fs.list();
		out.add(0, f);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Expression>();
	}
	;
	
/////////////////////////////////////////////
// Patterns
/////////////////////////////////////////////

Pattern Pattern =
		p:AsPattern index:DOUBLE_COLON t:Type Space {
		yyValue = new TypedPattern(p, t);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ AsPattern
	;

Pattern AsPattern =
	p:ConsPattern index:AS v:RequiredIdentifier Space {
		yyValue = new AsPattern(p, v);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ ConsPattern
	;

Pattern ConsPattern =
	left:BasicPattern index:COLON right:ConsPattern {
		yyValue = new ConsPattern(left, right);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ BasicPattern
	;
	
Pattern BasicPattern =
	UNDERSCORE {
		yyValue = new WildcardPattern();
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ literal:Literal Space {
		yyValue = new LiteralPattern(literal);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ SIGNAL {
		yyValue = new TuplePattern();
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ name:Identifier Space LPAREN formals:PatternList RPAREN Space {
		yyValue = new CallPattern(name, formals);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ name:Identifier Space {
		yyValue = new VariablePattern(name);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	/ LPAREN formals:PatternList RPAREN Space {
		if (formals.size() == 1) {
			yyValue = formals.get(0);
		} else {
			yyValue = new TuplePattern(formals);
			yyValue = at(yyStart, yyCount, yyValue);
		}
	}
	/ LBRACKET formals:PatternList RBRACKET Space {
		yyValue = new ListPattern(formals);
		yyValue = at(yyStart, yyCount, yyValue);
	}
	;

/////////////////////////////////////////////
// Types
/////////////////////////////////////////////

Type Type =
	LPAREN ts:TypeList RPAREN Space { 
		if (ts.size() > 1) {
			yyValue = new TupleType(ts);
		} else if (ts.size() == 1) {
			yyValue = ts.get(0);
		} else {
			yyValue = Type.TOP;
		}
	}
	/ UNDERSCORE { yyValue = Type.BLANK; }
	/ LAMBDA typeFormals:TypeFormals LPAREN argTypes:TypeList RPAREN Space
	  curried0:(LPAREN yyValue:TypeList RPAREN Space)*
	  DOUBLE_COLON resultType:Type {
		Type curriedType = resultType;
		List<List<Type>> curried = curried0.list();
		ListIterator<List<Type>> it = curried.listIterator(curried.size());
		while (it.hasPrevious()) {
			curriedType = new ArrowType(it.previous(), curriedType, new LinkedList<String>() /* curried type params not allowed */);
		}
		yyValue = new ArrowType(argTypes, curriedType, typeFormals);
	}
	/ name:Identifier actualTypes:TypeActuals Space { yyValue = new TypeApplication(name, actualTypes); }
	/ name:Identifier Space { yyValue = new NamedType(name); }
	;
	


/*
VariantTypeFormal VariantTypeFormal =
	  name:Identifier PLUS  { yyValue = new VariantTypeFormal(name, Variance.COVARIANT); }
	/ name:Identifier MINUS { yyValue = new VariantTypeFormal(name, Variance.CONTRAVARIANT); }
	/ name:Identifier TIMES { yyValue = new VariantTypeFormal(name, Variance.INVARIANT); }
	/ name:Identifier { yyValue = new VariantTypeFormal(name, Variance.COVARIANT); }
	;	
*/

List<Type> TypeList = 
	t:Type ts:(void:COMMA ts:Type)* {
		List<Type> out = ts.list();
		out.add(0, t);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Type>();
	}
	;
	

List<String> TypeFormals = 
	LBRACKET tf:RequiredIdentifier tfs:(void:COMMA tfs:Identifier)* RBRACKET {
		List<String> out = tfs.list();
		out.add(0, tf);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<String>();
	}
	;

/*
List<VariantTypeFormal> VariantTypeFormals =
	LBRACKET vtf:VariantTypeFormal vtfs:(void:COMMA vtfs:VariantTypeFormal)* RBRACKET {
		List<VariantTypeFormal> out = vtfs.list();
		out.add(0, vtf);
		yyValue = out;
	}
	/ {
		yyValue = new LinkedList<VariantTypeFormal>();
	}
	;
*/

List<Type> MaybeTypeActuals =
	ta:TypeActuals {
		yyValue = ta;
	}
	/ /* empty */ {
		yyValue = null;
	}
	;

List<Type> TypeActuals = 
	LBRACKET t:Type ts:(void:COMMA ts:Type)* RBRACKET {
		List<Type> out = ts.list();
		out.add(0, t);
		yyValue = out;
	}
	;
	
Type MaybeResultType =
	DOUBLE_COLON resultType:Type
		{ yyValue = resultType; }
	/ DOUBLE_COLON_BANG resultType:Type
		{ yyValue = new AssertedType(resultType); }
	/ /* empty */ 
	    { yyValue = null; }	
	;
	
/////////////////////////////////////////////
// Identifiers
/////////////////////////////////////////////
	
String SiteName = Identifier / BareOperator;
String RequiredSiteName = SiteName / ^{ abort(yyError); };
String ClassName = ClassNameToken Space;
String RequiredClassName = ClassName / ^{ abort(yyError); };
String ClassNameToken = Word ('.' Word)+;
String Identifier = Word HSpace;
String RequiredIdentifier = Identifier / ^{ abort(yyError); };

/////////////////////////////////////////////
// Keywords
/////////////////////////////////////////////

transient String DEF = "def":Word Space;
transient String VAL = "val":Word Space;
transient String CLASS = "class":Word Space;
transient String SITE = "site":Word Space;
transient String INCLUDE = "include":Word Space;
transient String TYPE = "type":Word Space;
transient String LAMBDA = "lambda":Word Space;
transient String ATOMIC = "atomic":Word Space;
transient String ISOLATED = "isolated":Word Space;
transient String TRY = "try":Word Space;
transient String THROW = "throw":Word Space;
transient String CATCH = "catch":Word Space;
transient String AS = "as":Word Space;
transient String IF = "if":Word Space;
transient String THEN = "then":Word Space;
transient String ELSE = "else":Word Space;
transient String STOP = "stop":Word HSpace;
transient String SIGNAL = "signal":Word HSpace;
transient String DOUBLE_COLON = "::" Space;
transient String DOUBLE_COLON_BANG = ":!:" Space;
transient String EQ = "=" Space;
transient String RequiredEQ = EQ / ^{ abort(yyError); };
transient String LBRACE = "{" ![\-] Space; // make sure it's not a comment
transient String RBRACE = "}" Space;
transient String LANGLE = "<" Space;
transient String RANGLE = ">" Space;
transient String DOT = "." Space;
transient String BANG = "!" Space;
transient String BAR = "|" Space;
transient String UNDERSCORE = "_" Space;
transient String SEMICOLON = ";" Space;
transient String ANDAND = "&&" Space;
transient String OROR = "||" Space;
transient String NOT = "~" Space;
transient String PLUS = "+" Space;
transient String MINUS = "-" ![\-] Space; // make sure it's not a comment
transient String DIV = "/" Space;
transient String MOD = "%" Space;
transient String TIMES = "*" Space;
transient String EXPONENT = "**" Space;
transient String COLON = ":" Space;
transient String LT = "<:" Space;
transient String LEQ = "<=" Space;
transient String GT = ":>" Space;
transient String GEQ = ">=" Space;
transient String NEQ = "/=" Space;
transient String COLON_EQUALS = ":=" Space;
transient String QMARK = "?" HSpace;