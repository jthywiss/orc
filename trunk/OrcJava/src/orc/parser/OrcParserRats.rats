module orc.parser.OrcParserRats;

header {
	import java.util.*;
	import java.io.FileNotFoundException;
	import java.math.BigInteger;
	import java.math.BigDecimal;
	import orc.ast.extended.*;
	import orc.ast.extended.declaration.*;
	import orc.ast.extended.pattern.*;
	import orc.error.*;
	import orc.Orc;
	import xtc.util.Utilities;
	import xtc.util.Action;
}

option constant;

/////////////////////////////////////////////
// Declarations
/////////////////////////////////////////////

public Expression Program = Space yyValue:Body EndOfFile;
	
/*
 * Include files are treated differently than programs;
 * the may not have a goal experssion.
 */
public List<Declaration> Module =
	Space yyValue:Declarations EndOfFile
	;

/*
 * The body of a program or definition may include
 * declarations and must include a goal expression.
 */
Expression Body =
	ds:Declarations g:GoalExpression {
		Expression out = g;
		ListIterator<Declaration> it = ds.listIterator(ds.size());
		while (it.hasPrevious()) {
			out = new Declare(it.previous(), out);
		}
		yyValue = out;
	}
	;

List<Declaration> Declarations =
	ds:Include ds2:Declarations {
		ds.addAll(ds2);
		yyValue = ds;
	}
	/ d:Declaration ds:Declarations {
		ds.add(0, d);
		yyValue = ds;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Declaration>();
	}
	;
	
/*
 * Include files are parsed in place.
 */
List<Declaration> Include =
	INCLUDE filename:StringLiteral ^{
		try {
			OrcParserRats parser = new OrcParserRats(Orc.openInclude(filename), filename);
			Result result = parser.pDeclarations(0);
			if (result.hasValue()) {
				yyResult = new SemanticValue(result.semanticValue(), yyBase);
			} else {
				yyResult = new ParseError(result.parseError().msg, yyBase);
			}
		} catch (FileNotFoundException e) {
			yyResult = new ParseError("File not found: " + filename, yyBase);
		}
	}
	;

Declaration Declaration =
	SITE name:(Identifier / StringLiteral) EQ className:ClassName {
		yyValue = new SiteDeclaration(name, className);
	}
	/ CLASS name:Identifier EQ className:ClassName {
		yyValue = new ClassDeclaration(name, className);
	}
	/ defs:Definition+ {
		// a block of definitions is treated as a single
		// declaration (akin to a letrec)
		yyValue = new DefsDeclaration(defs.list());
	}
	/ VAL p:Pattern EQ e:Body {
		yyValue = new ValDeclaration(p, e);
	}
	;

Definition Definition =
	DEF name:Identifier LPAREN formals:PatternList RPAREN EQ body:Body {
		yyValue = new Definition(name, formals, body);
	}
	;

List<Pattern> PatternList =
	f:Pattern fs:(void:COMMA fs:Pattern)* {
		List<Pattern> out = fs.list();
		out.add(0, f);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Pattern>();
	}
	;
	
/////////////////////////////////////////////
// Expressions
/////////////////////////////////////////////
	
Expression GoalExpression =
	seed:WhereExpression actions:SemiExpressionTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> SemiExpressionTail =
	SEMICOLON right:WhereExpression {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				return new Semi(left, right);
			}
		};
	}
	;
	
Expression WhereExpression =
	seed:BarExpression actions:WhereExpressionTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> WhereExpressionTail =
	LANGLE p:Pattern? LANGLE right:BarExpression {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				if (p == null) return new Where(left, right);
				else return new Where(left, right, p);
			}
		};
	}
	;
	
Expression BarExpression =
	seed:SeqExpression actions:BarExpressionTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> BarExpressionTail =
	BAR right:SeqExpression {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				return new Parallel(left, right);
			}
		};
	}
	;
	
Expression SeqExpression =
	left:Sequent RANGLE p:Pattern? RANGLE right:SeqExpression {
		if (p == null) yyValue = new Sequential(left, right);
		else yyValue = new Sequential(left, right, p);
	}
	/ Sequent
	;

Expression Sequent =
	LAMBDA LPAREN formals:PatternList RPAREN EQ body:Body {
		yyValue = new Lambda(formals, body);
	}
	/ Disjunction
	;

Expression Disjunction = 
	left:Conjunction OROR right:Disjunction {
		yyValue = new Call("op||", left, right);
	}
	/ Conjunction
	;
	
Expression Conjunction = 
	left:Comparison ANDAND right:Conjunction {
		yyValue = new Call("op&&", left, right);
	}
	/ Comparison
	;
	
Expression Comparison = 
	left:Comparable op:Comparator right:Comparable {
		yyValue = new Call(op, left, right);
	}
	/ Comparable
	;

String Comparator =
	EQ { yyValue = "op="; }
	/ NEQ { yyValue = "op/="; }
	/ GT { yyValue = "op>"; }
	/ GEQ { yyValue = "op>="; }
	/ LT { yyValue = "op<"; }
	/ LEQ { yyValue = "op<="; }
	;

Expression Comparable =
	NOT x:BasicExpression {
		yyValue = new Call("op~", x);
	}
	/ Cons
	/ Sum
	;
	
Expression Cons =
	left:Signed COLON right:(Cons / Signed) {
		yyValue = new ConsExpr(left, right);
	}
	;
	
Expression Sum =
	seed:Product actions:SumTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> SumTail =
	op:SumOperator right:Product {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				return new Call(op, left, right);
			}
		};
	}
	;
String SumOperator =
	PLUS { yyValue = "op+"; }
	/ MINUS { yyValue = "op-"; }
	;
	
Expression Product =
	seed:Signed actions:ProductTail* {
		yyValue = apply(actions, seed);
	}
	;
Action<Expression> ProductTail =
	op:ProductOperator right:Signed {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				return new Call(op, left, right);
			}
		};
	}
	;

String ProductOperator =
	DIV { yyValue = "op/"; }
	/ MOD { yyValue = "op%"; }
	/ TIMES { yyValue = "op*"; }
	;

Expression Signed =
	MINUS x:BasicExpression {
		yyValue = new Call("opu-", x);
	}
	/ BasicExpression
	;

Expression BasicExpression =
	Literal
	/ NULL {
		yyValue = new Silent();
	}
	/ Call
	/ LPAREN args:ExpressionList RPAREN {
		if (args.size() == 1) {
			yyValue = args.get(0);
		} else {
			yyValue = new Let(args);
		}
	}
	/ LBRACKET args:ExpressionList RBRACKET {
		yyValue = new ListExpr(args);
	}
	;
	
Expression Call =
	seed:Identifier actions:CallTail* {
		yyValue = apply(actions, new Name(seed));
	}
	;
Action<Expression> CallTail =
	DOT right:Identifier {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				return new Dot(left, right);
			}
		};
	}
	/ LPAREN args:ExpressionList RPAREN {
		yyValue = new Action<Expression>() {
			public Expression run(Expression left) {
				return new Call(left, args);
			}
		};
	}
	;
	
List<Expression> ExpressionList =
	f:Body fs:(COMMA yyValue:Body)* {
		List<Expression> out = fs.list();
		out.add(0, f);
		yyValue = out;
	}
	/ /* empty */ {
		yyValue = new LinkedList<Expression>();
	}
	;
	
/////////////////////////////////////////////
// Patterns
/////////////////////////////////////////////

Pattern Pattern =
	p:ConsPattern AS v:Identifier {
		yyValue = new AsPattern(p, v);
	}
	/ ConsPattern
	;

Pattern ConsPattern =
	left:BasicPattern COLON right:ConsPattern {
		yyValue = new ConsPattern(left, right);
	}
	/ BasicPattern
	;
	
Pattern BasicPattern =
	UNDERSCORE {
		yyValue = new WildcardPattern();
	}
	/ literal:Literal {
		yyValue = new LiteralPattern(literal);
	}
	/ name:Identifier LPAREN formals:PatternList RPAREN {
		yyValue = new CallPattern(name, new TuplePattern(formals));
	}
	/ name:Identifier {
		yyValue = new VariablePattern(name);
	}
	/ BANG p:BasicPattern {
		yyValue = new PublishPattern(p);
	}
	/ LPAREN formals:PatternList RPAREN {
		yyValue = new TuplePattern(formals);
	}
	/ LBRACKET formals:PatternList RBRACKET {
		yyValue = new ListPattern(formals);
	}
	;

/////////////////////////////////////////////
// Literals
/////////////////////////////////////////////

Literal Literal =
	literal:(
		Number
		/ StringLiteral
		/ TRUE { yyValue = true; }
		/ FALSE { yyValue = false; }
	) {
		yyValue = new Literal(literal);
	}
	;
	
Number Number = Float / Integer;
BigDecimal Float =
	rep:FloatToken Space {
		try {
			yyValue = BigDecimal.valueOf(Double.parseDouble(rep));
		} catch (NumberFormatException e) {
			// impossible by construction
			throw new AssertionError(e);
		}
	}
	;
// Note that even if a number has no decimal, having an exponent
// is enough to make it floating point
String FloatToken = SignedIntegerToken ('.' [0-9]+ Exponent? / Exponent);
String Exponent = [eE] [+\-]? IntegerToken;
BigInteger Integer =
	rep:SignedIntegerToken Space {
		try {
			yyValue = BigInteger.valueOf(Long.parseLong(rep));
		} catch (NumberFormatException e) {
			// impossible by construction
			throw new AssertionError(e);
		}
	}
	;
String SignedIntegerToken = '-'? IntegerToken;
String IntegerToken = '0' / [1-9] [0-9]*;
	
String StringLiteral =
	string:StringLiteralToken Space {
		yyValue = Utilities.unescape(string.substring(1, string.length()-1));
	}
	;
String StringLiteralToken = ["] ( EscapeSequence / !["\\] _ )* ["] ;
transient String EscapeSequence =
   '\\' [btnfr"'\-\[\\\]] / UnicodeEscape / OctalEscape
   ;
transient String UnicodeEscape = '\\' 'u' HexDigit HexDigit HexDigit HexDigit ;
transient String HexDigit = [0-9a-fA-F] ;
transient String OctalEscape =
	'\\' [0-3] OctalDigit OctalDigit
	/ '\\' OctalDigit OctalDigit
	/ '\\' OctalDigit
	;
transient String OctalDigit = [0-7];
	
String ClassName = ClassNameToken Space;
String ClassNameToken = WordToken ('.' WordToken)*;
String Identifier = WordToken Space;
String WordToken = [a-zA-Z_] [a-zA-Z0-9_]*;

/////////////////////////////////////////////
// Keywords
/////////////////////////////////////////////

String DEF = "def" Space;
String TRUE = "true" Space;
String FALSE = "false" Space;
String VAL = "val" Space;
String CLASS = "class" Space;
String SITE = "site" Space;
String NULL = "null" Space;
String INCLUDE = "include" Space;
String LAMBDA = "lambda" Space;
String AS = "as" Space;
transient String EQ = "=" Space;
transient String LBRACE = "{" Space;
transient String RBRACE = "}" Space;
transient String LANGLE = "<" Space;
transient String RANGLE = ">" Space;
transient String LPAREN = "(" Space;
transient String RPAREN = ")" Space;
transient String LBRACKET = "[" Space;
transient String RBRACKET = "]" Space;
transient String DOT = "." Space;
transient String BANG = "!" Space;
transient String BAR = "|" Space;
transient String UNDERSCORE = "_" Space;
transient String COMMA = "," Space;
transient String SEMICOLON = ";" Space;
transient String ANDAND = "&&" Space;
transient String OROR = "||" Space;
transient String NOT = "~" Space;
transient String PLUS = "+" Space;
transient String MINUS = "-" Space;
transient String DIV = "/" Space;
transient String MOD = "%" Space;
transient String TIMES = "*" Space;
transient String COLON = ":" Space;
transient String LT = "<:" Space;
transient String LEQ = "<=" Space;
transient String GT = ":>" Space;
transient String GEQ = ">=" Space;
transient String NEQ = "/=" Space;
	
/////////////////////////////////////////////
// Whitespace, Comments, etc.
/////////////////////////////////////////////

transient void Space = (' ' / '\t' / '\f' / '\r' / '\n' / SingleLineComment / MultiLineComment)*;

transient void SingleLineComment = "--" ( ![\n\r] _ )* (EndOfLine / EndOfFile);
transient void MultiLineComment = "{-" ( [\-] ![}] / EndOfLine / ![\-\n\r] _ )* "-}";
	
transient void EndOfFile = !_;
transient void EndOfLine = "\r\n" / '\r' / '\n';
