// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.0,
// (C) 2004-2008 Robert Grimm,
// on Tuesday, August 18, 2009 at 12:37:31 PM.
// Edit at your own risk.
// ===========================================================================

package orc.parser;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.List;
import java.util.LinkedList;
import java.util.ListIterator;
import java.io.FileNotFoundException;
import java.io.File;
import java.io.Reader;
import java.math.BigInteger;
import java.math.BigDecimal;

import xtc.util.Utilities;
import xtc.util.Action;
import xtc.util.Pair;
import xtc.tree.Location;

import orc.Config;
import orc.ast.extended.*;
import orc.ast.extended.declaration.*;
import orc.ast.extended.declaration.defn.*;
import orc.ast.extended.declaration.type.*;
import orc.ast.extended.pattern.*;
import orc.error.*;
import orc.ast.simple.type.*;
import orc.runtime.values.Value;
import orc.runtime.values.ListValue;
import orc.runtime.values.TupleValue;
import java.util.List;
import java.util.LinkedList;
import java.math.BigInteger;
import java.math.BigDecimal;

import xtc.util.Utilities;

import orc.runtime.values.ListValue;
import orc.runtime.values.TupleValue;

/**
 * Packrat parser for grammar <code>orc.parser.OrcParserRats</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.0, (C) 2004-2008 Robert Grimm.
 */
public final class OrcParserRats extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fBody;
    Result fDeclarations;
    Result fConstructor;
    Result fPatternList;
    Result fPatternList$$Star1;
    Result fMaybeSemiExpression;
    Result fMaybeSemiExpression$$Star1;
    Result fMaybeWhereExpression;
    Result fMaybeWhereExpression$$Plus1;
    Result fMaybeBarExpression;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fNoCmpMaybeBarExpression;
    Result fSeqExpression;
    Result fMaybeSeqExpression;
    Result fNoCmpMaybeSeqExpression;
    Result fIfThenElse;
    Result fTryCatch;
    Result fTryCatch$$Plus1;
    Result fMaybeAtomic;
    Result fNoCmpMaybeAtomic;
    Result fMaybeAssignment;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fNoCmpMaybeAssignment;
    Result fMaybeDisjunction;
    Result fNoCmpMaybeDisjunction;
    Result fMaybeConjunction;
    Result fNoCmpMaybeConjunction;
    Result fMaybeComparison;
    Result fComparator;
    Result fNoCmpMaybeComparison;
    Result fNoCmpComparator;
    Result fComparable;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fCons;
    Result fSumOperator;
    Result fMaybeProduct;
    Result fProductTail;
    Result fProductOperator;
    Result fMaybeExponent;
    Result fExponentTail;
    Result fExponentOperator;
    Result fMaybeSigned;
    Result fDotExpression;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fCallTail;
    Result fBareOperator;
    Result fLiteral;
    Result fExpressionList;
    Result fExpressionList$$Star1;
    Result fPattern;
    Result fAsPattern;
    Result fConsPattern;
    Result fBasicPattern;
    Result fType;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result fType$$Star1;
    Result fTypeList;
    Result f$$Shared2;
    Result fTypeFormals;
    Result fTypeFormals$$Star1;
    Result fTypeActuals;
    Result fMaybeResultType;
    Result fRequiredSiteName;
    Result fClassName;
    Result fRequiredClassName;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fIdentifier;
    Result fRequiredIdentifier;
    Result fExponent;
    Result fSignedIntegerToken;
    Result fIntegerToken;
    Result fIntegerToken$$Star1;
    Result fStringLiteral;
    Result fWord;
    Result fWord$$Star1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class OrcParserRatsColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public OrcParserRats(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public OrcParserRats(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new OrcParserRatsColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBody(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    Result            yyResult;
    List<Declaration> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Body.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBody(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fBody) 
      yyColumn.chunk1.fBody = pBody$1(yyStart);
    return yyColumn.chunk1.fBody;
  }

  /** Actually parse orc.parser.OrcParserRats.Body. */
  private Result pBody$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclarations(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Declaration> ds = yyResult.semanticValue();

      yyResult = pGoalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression g = yyResult.semanticValue();

        Expression out = g;
        ListIterator<Declaration> it = ds.listIterator(ds.size());
        while (it.hasPrevious()) {
          out = new Declare(it.previous(), out);
        }
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Declarations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclarations) 
      yyColumn.chunk1.fDeclarations = pDeclarations$1(yyStart);
    return yyColumn.chunk1.fDeclarations;
  }

  /** Actually parse orc.parser.OrcParserRats.Declarations. */
  private Result pDeclarations$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<Declaration> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInclude(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Declaration> ds = yyResult.semanticValue();

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Declaration> ds2 = yyResult.semanticValue();

        ds.addAll(ds2);
        yyValue = ds;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Declaration d = yyResult.semanticValue();

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Declaration> ds = yyResult.semanticValue();

        ds.add(0, d);
        yyValue = ds;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = new LinkedList<Declaration>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Include.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInclude(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyBase;
    List<Declaration> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pINCLUDE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pStringLiteral(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String filename = yyResult.semanticValue();

        yyResult = pSpace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;

          File thisfile = new File(location(yyStart).file);
          String thisdir = thisfile.getParent();
          OrcParserRats parser = new OrcParserRats(config, config.openInclude(filename, thisdir), filename);
          Result result = parser.pModule(0);
          if (result.hasValue()) {
            yyResult = new SemanticValue(result.semanticValue(), yyBase);
          } else {
            parser.abort(result.parseError());
          }

          yyError = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            yyValue = yyResult.semanticValue();
            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    boolean     yyRepeated1;
    Pair<Defn>  yyRepValue1;
    Declaration yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSITE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRequiredSiteName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pSpace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRequiredEQ(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRequiredClassName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String className = yyResult.semanticValue();

              yyValue = new SiteDeclaration(name, className);
              yyValue = at(yyStart, yyCount, yyValue);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pCLASS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRequiredIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pSpace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRequiredEQ(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRequiredClassName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String className = yyResult.semanticValue();

              yyValue = new ClassDeclaration(name, className);
              yyValue = at(yyStart, yyCount, yyValue);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDefinition(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Defn v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Defn>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Defn> defs = yyRepValue1.reverse();

      // a block of definitions is treated as a single
      // declaration (akin to a letrec)
      yyValue = new DefsDeclaration(defs.list());
      yyValue = at(yyStart, yyCount, yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Alternative 4.

    yyResult = pVAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern p = yyResult.semanticValue();

        yyResult = pRequiredEQ(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBody(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression e = yyResult.semanticValue();

            yyValue = new ValDeclaration(p, e);
            yyValue = at(yyStart, yyCount, yyValue);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pTYPE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pIdentifier(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pTypeFormals(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<String> tf = yyResult.semanticValue();

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEQ(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pConstructorList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final List<Constructor> cs = yyResult.semanticValue();

                yyValue = new DatatypeDeclaration(name, cs, tf);
                yyValue = at(yyStart, yyCount, yyValue);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pSpace(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEQ(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pClassName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String className = yyResult.semanticValue();

              yyValue = new TypeDeclaration(name, className);
              yyValue = at(yyStart, yyCount, yyValue);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      yyResult = pRequiredIdentifier(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pTypeFormals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<String> tf = yyResult.semanticValue();

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pRequiredEQ(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Type t = yyResult.semanticValue();

                yyValue = new TypeAliasDeclaration(name, t, tf);
                yyValue = at(yyStart, yyCount, yyValue);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Constructor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstructor(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fConstructor) 
      yyColumn.chunk1.fConstructor = pConstructor$1(yyStart);
    return yyColumn.chunk1.fConstructor;
  }

  /** Actually parse orc.parser.OrcParserRats.Constructor. */
  private Result pConstructor$1(final int yyStart) throws IOException {
    Result      yyResult;
    Constructor yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      if (!name.equals("lambda")) {

        yyResult = pLPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTypeList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Type> ts = yyResult.semanticValue();

            yyResult = pRPAREN(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSpace(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Constructor(name,ts);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("constructor expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ConstructorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstructorList(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<Constructor> yyRepValue1;
    List<Constructor> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstructor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Constructor c = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBAR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pConstructor(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Constructor cs = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Constructor>(cs, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for cs.
        final Pair<Constructor> cs = yyRepValue1.reverse();

        List<Constructor> out = cs.list();
        out.add(0, c);
        yyValue = out;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for cs.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Definition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefinition(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    Defn         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDEF(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRequiredSiteName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pSpace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pLPAREN(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pPatternList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final List<Pattern> formals = yyResult.semanticValue();

              yyResult = pRPAREN(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSpace(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = Pair.empty();
                  while (true) {

                    yyResult = p$$Shared1(yyRepetition1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final List<Pattern> v$el$1 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
                      continue;
                    }
                    break;
                  }
                  { // Start scope for curried0.
                    final Pair<List<Pattern>> curried0 = cast(yyRepValue1.reverse());

                    yyResult = pMaybeResultType(yyRepetition1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final Type resultType = yyResult.semanticValue();

                      yyResult = pEQ(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pBody(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          final Expression body0 = yyResult.semanticValue();

                          Type linearResultType = resultType;
                          List<List<Pattern>> curried = curried0.list();
                          ListIterator<List<Pattern>> it = curried.listIterator(curried.size());
                          Expression body = body0;
                          while (it.hasPrevious()) {
                            body = new Lambda(it.previous(), body, linearResultType);
                            linearResultType = null;
                          }
                          yyValue = new DefnClause(name, formals, body, linearResultType);
                          yyValue = at(yyStart, yyCount, yyValue);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  } // End scope for curried0.
                }
              }
            }
          }

          // Nested alternative 2.

          yyResult = pTypeFormals(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<String> typeFormals = yyResult.semanticValue();

            yyResult = pLPAREN(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTypeList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final List<Type> argTypes = yyResult.semanticValue();

                yyResult = pRPAREN(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pSpace(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = Pair.empty();
                    while (true) {

                      yyResult = pDefinition$$Choice2(yyRepetition1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final List<Type> v$el$2 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = new Pair<Object>(v$el$2, yyRepValue1);
                        continue;
                      }
                      break;
                    }
                    { // Start scope for curried0.
                      final Pair<List<Type>> curried0 = cast(yyRepValue1.reverse());

                      yyResult = pMaybeResultType(yyRepetition1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final Type resultType = yyResult.semanticValue();

                        Type curriedType = resultType;
                        List<List<Type>> curried = curried0.list();
                        ListIterator<List<Type>> it = curried.listIterator(curried.size());
                        while (it.hasPrevious()) {
                          curriedType = new ArrowType(it.previous(), curriedType, new LinkedList<String>() /* curried type params not allowed */);
                        }
                        yyValue = new DefnType(name, argTypes, curriedType, typeFormals);
                        yyValue = at(yyStart, yyCount, yyValue);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    } // End scope for curried0.
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * orc.parser.OrcParserRats.Definition$$Choice1 
   * and orc.parser.OrcParserRats.Lambda$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    Result        yyResult;
    List<Pattern> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPatternList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Definition$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefinition$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pTypeList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.PatternList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternList(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternList) 
      yyColumn.chunk1.fPatternList = pPatternList$1(yyStart);
    return yyColumn.chunk1.fPatternList;
  }

  /** Actually parse orc.parser.OrcParserRats.PatternList. */
  private Result pPatternList$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<Pattern> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern f = yyResult.semanticValue();

      yyResult = pPatternList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Pattern> fs = yyResult.semanticValue();

        List<Pattern> out = fs.list();
        out.add(0, f);
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = new LinkedList<Pattern>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.PatternList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternList$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternList$$Star1) 
      yyColumn.chunk1.fPatternList$$Star1 = pPatternList$$Star1$1(yyStart);
    return yyColumn.chunk1.fPatternList$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.PatternList$$Star1. */
  private Result pPatternList$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<Pattern> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern fs = yyResult.semanticValue();

        yyResult = pPatternList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Pattern> v$1 = yyResult.semanticValue();

          yyValue = new Pair<Pattern>(fs, v$1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.GoalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoalExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLambda(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMaybeSemiExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSemiExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSemiExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeSemiExpression) 
      yyColumn.chunk1.fMaybeSemiExpression = pMaybeSemiExpression$1(yyStart);
    return yyColumn.chunk1.fMaybeSemiExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeSemiExpression. */
  private Result pMaybeSemiExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeWhereExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pMaybeSemiExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.MaybeSemiExpression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSemiExpression$$Star1(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeSemiExpression$$Star1) 
      yyColumn.chunk1.fMaybeSemiExpression$$Star1 = pMaybeSemiExpression$$Star1$1(yyStart);
    return yyColumn.chunk1.fMaybeSemiExpression$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeSemiExpression$$Star1. */
  private Result pMaybeSemiExpression$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSemiExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pMaybeSemiExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SemiExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSemiExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSEMICOLON(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeWhereExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression left) {
            Expression yyValue = new Semi(left, right);
            yyValue = at(left, right, yyValue);
            return yyValue;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Lambda.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLambda(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<List<Pattern>> yyRepValue1;
    Expression          yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLAMBDA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLPAREN(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPatternList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Pattern> formals = yyResult.semanticValue();

          yyResult = pRPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSpace(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = p$$Shared1(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final List<Pattern> v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = 
                    new Pair<List<Pattern>>(v$el$1, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for curried0.
                final Pair<List<Pattern>> curried0 = yyRepValue1.reverse();

                yyResult = pMaybeResultType(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Type resultType = yyResult.semanticValue();

                  yyResult = pRequiredEQ(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBody(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final Expression body0 = yyResult.semanticValue();

                      List<List<Pattern>> curried = curried0.list();
                      ListIterator<List<Pattern>> it = curried.listIterator(curried.size());
                      Type linearResultType = resultType;
                      Expression body = body0;
                      while (it.hasPrevious()) {
                        body = new Lambda(it.previous(), body, linearResultType);
                        linearResultType = null;
                      }
                      yyValue = new Lambda(formals, body, linearResultType);
                      yyValue = at(yyStart, yyCount, yyValue);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              } // End scope for curried0.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeWhereExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeWhereExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeWhereExpression) 
      yyColumn.chunk1.fMaybeWhereExpression = pMaybeWhereExpression$1(yyStart);
    return yyColumn.chunk1.fMaybeWhereExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeWhereExpression. */
  private Result pMaybeWhereExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpMaybeBarExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pMaybeWhereExpression$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMaybeBarExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.MaybeWhereExpression$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeWhereExpression$$Plus1(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeWhereExpression$$Plus1) 
      yyColumn.chunk1.fMaybeWhereExpression$$Plus1 = pMaybeWhereExpression$$Plus1$1(yyStart);
    return yyColumn.chunk1.fMaybeWhereExpression$$Plus1;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeWhereExpression$$Plus1. */
  private Result pMaybeWhereExpression$$Plus1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pMaybeWhereExpression$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Expression>>(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.WhereExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    Pattern            yyOpValue1;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLANGLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pPattern(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for p.
        final Pattern p = yyOpValue1;

        yyResult = pLANGLE(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoCmpMaybeBarExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression right = yyResult.semanticValue();

            yyValue = new Action<Expression>() {
              public Expression run(Expression left) {
                Expression yyValue;
                if (p == null) yyValue = new Where(left, right);
                else yyValue = new Where(left, right, p);
                yyValue = at(left, right, yyValue);
                return yyValue;
                
              }
            };

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for p.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeBarExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeBarExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeBarExpression) 
      yyColumn.chunk1.fMaybeBarExpression = pMaybeBarExpression$1(yyStart);
    return yyColumn.chunk1.fMaybeBarExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeBarExpression. */
  private Result pMaybeBarExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pBAR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMaybeBarExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Parallel(left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeBarExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeBarExpression(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNoCmpMaybeBarExpression) 
      yyColumn.chunk2.fNoCmpMaybeBarExpression = pNoCmpMaybeBarExpression$1(yyStart);
    return yyColumn.chunk2.fNoCmpMaybeBarExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeBarExpression. */
  private Result pNoCmpMaybeBarExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pBAR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoCmpMaybeBarExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Parallel(left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoCmpMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SeqExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSeqExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSeqExpression) 
      yyColumn.chunk2.fSeqExpression = pSeqExpression$1(yyStart);
    return yyColumn.chunk2.fSeqExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.SeqExpression. */
  private Result pSeqExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Pattern    yyOpValue1;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpMaybeAtomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pRANGLE(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pPattern(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pattern v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for p.
          final Pattern p = yyOpValue1;

          yyResult = pRANGLE(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoCmpMaybeSeqExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expression right = yyResult.semanticValue();

              if (p == null) yyValue = new Sequential(left, right);
              else yyValue = new Sequential(left, right, p);
              yyValue = at(yyStart, yyCount, yyValue);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for p.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSeqExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSeqExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeSeqExpression) 
      yyColumn.chunk2.fMaybeSeqExpression = pMaybeSeqExpression$1(yyStart);
    return yyColumn.chunk2.fMaybeSeqExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeSeqExpression. */
  private Result pMaybeSeqExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIfThenElse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTryCatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pMaybeTyped(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeSeqExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeSeqExpression(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNoCmpMaybeSeqExpression) 
      yyColumn.chunk2.fNoCmpMaybeSeqExpression = pNoCmpMaybeSeqExpression$1(yyStart);
    return yyColumn.chunk2.fNoCmpMaybeSeqExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeSeqExpression. */
  private Result pNoCmpMaybeSeqExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIfThenElse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTryCatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pNoCmpMaybeTyped(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.IfThenElse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIfThenElse(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fIfThenElse) 
      yyColumn.chunk2.fIfThenElse = pIfThenElse$1(yyStart);
    return yyColumn.chunk2.fIfThenElse;
  }

  /** Actually parse orc.parser.OrcParserRats.IfThenElse. */
  private Result pIfThenElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIF(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeDisjunction(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression condition = yyResult.semanticValue();

        yyResult = pTHEN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMaybeSemiExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression consequent = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pELSE(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pMaybeSemiExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Expression alternative = yyResult.semanticValue();

                yyValue = new IfThenElse(condition, consequent, alternative);
                yyValue = at(yyStart, yyCount, yyValue);

                return yyResult.createValue(yyValue, yyError);
              }
            }

            // Nested alternative 2.

            yyValue = new IfThenElse(condition, consequent);
            yyValue = at(yyStart, yyCount, yyValue);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.CatchHandler.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchHandler(final int yyStart) throws IOException {
    Result       yyResult;
    CatchHandler yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCATCH(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLPAREN(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPatternList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Pattern> formals = yyResult.semanticValue();

          yyResult = pRPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSpace(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pMaybeSemiExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Expression handler = yyResult.semanticValue();

                yyValue = new CatchHandler(formals, handler);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TryCatch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTryCatch(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTryCatch) 
      yyColumn.chunk2.fTryCatch = pTryCatch$1(yyStart);
    return yyColumn.chunk2.fTryCatch;
  }

  /** Actually parse orc.parser.OrcParserRats.TryCatch. */
  private Result pTryCatch$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTRY(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeDisjunction(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression tryblock = yyResult.semanticValue();

        yyResult = pTryCatch$$Plus1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<CatchHandler> catches = yyResult.semanticValue();

          yyValue = new Catch(tryblock, catches.list());
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.TryCatch$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTryCatch$$Plus1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTryCatch$$Plus1) 
      yyColumn.chunk2.fTryCatch$$Plus1 = pTryCatch$$Plus1$1(yyStart);
    return yyColumn.chunk2.fTryCatch$$Plus1;
  }

  /** Actually parse orc.parser.OrcParserRats.TryCatch$$Plus1. */
  private Result pTryCatch$$Plus1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<CatchHandler> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCatchHandler(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final CatchHandler v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pTryCatch$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<CatchHandler> v$2 = yyResult.semanticValue();

        yyValue = new Pair<CatchHandler>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<CatchHandler>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeTyped.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeTyped(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeAtomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression body = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDOUBLE_COLON_BANG(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Type type = yyResult.semanticValue();

          yyValue = new HasType(body, new AssertedType(type));
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pDOUBLE_COLON(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Type type = yyResult.semanticValue();

          yyValue = new HasType(body, type);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeAtomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeTyped.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeTyped(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpMaybeAtomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression body = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDOUBLE_COLON_BANG(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Type type = yyResult.semanticValue();

          yyValue = new HasType(body, new AssertedType(type));
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pDOUBLE_COLON(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Type type = yyResult.semanticValue();

          yyValue = new HasType(body,type);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoCmpMaybeAtomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeAtomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeAtomic(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeAtomic) 
      yyColumn.chunk2.fMaybeAtomic = pMaybeAtomic$1(yyStart);
    return yyColumn.chunk2.fMaybeAtomic;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeAtomic. */
  private Result pMaybeAtomic$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pATOMIC(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeAssignment(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression body = yyResult.semanticValue();

        yyValue = new Atomic(body);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pISOLATED(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeAssignment(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression body = yyResult.semanticValue();

        yyValue = new Isolated(body);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pTHROW(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeAssignment(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression exception = yyResult.semanticValue();

        yyValue = new Throw(exception);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pMaybeAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeAtomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeAtomic(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fNoCmpMaybeAtomic) 
      yyColumn.chunk2.fNoCmpMaybeAtomic = pNoCmpMaybeAtomic$1(yyStart);
    return yyColumn.chunk2.fNoCmpMaybeAtomic;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeAtomic. */
  private Result pNoCmpMaybeAtomic$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pATOMIC(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoCmpMaybeAssignment(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression body = yyResult.semanticValue();

        yyValue = new Atomic(body);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pISOLATED(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoCmpMaybeAssignment(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression body = yyResult.semanticValue();

        yyValue = new Isolated(body);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pTHROW(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoCmpMaybeAssignment(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression exception = yyResult.semanticValue();

        yyValue = new Throw(exception);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pNoCmpMaybeAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeAssignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeAssignment(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeAssignment) 
      yyColumn.chunk2.fMaybeAssignment = pMaybeAssignment$1(yyStart);
    return yyColumn.chunk2.fMaybeAssignment;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeAssignment. */
  private Result pMaybeAssignment$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDotExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pCOLON_EQUALS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMaybeDisjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call(":=", left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeDisjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeAssignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeAssignment(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNoCmpMaybeAssignment) 
      yyColumn.chunk3.fNoCmpMaybeAssignment = pNoCmpMaybeAssignment$1(yyStart);
    return yyColumn.chunk3.fNoCmpMaybeAssignment;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeAssignment. */
  private Result pNoCmpMaybeAssignment$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDotExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pCOLON_EQUALS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoCmpMaybeDisjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call(":=", left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoCmpMaybeDisjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeDisjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeDisjunction(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMaybeDisjunction) 
      yyColumn.chunk3.fMaybeDisjunction = pMaybeDisjunction$1(yyStart);
    return yyColumn.chunk3.fMaybeDisjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeDisjunction. */
  private Result pMaybeDisjunction$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pOROR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMaybeDisjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call("||", left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeDisjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeDisjunction(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNoCmpMaybeDisjunction) 
      yyColumn.chunk3.fNoCmpMaybeDisjunction = pNoCmpMaybeDisjunction$1(yyStart);
    return yyColumn.chunk3.fNoCmpMaybeDisjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeDisjunction. */
  private Result pNoCmpMaybeDisjunction$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pOROR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoCmpMaybeDisjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call("||", left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoCmpMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeConjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeConjunction(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMaybeConjunction) 
      yyColumn.chunk3.fMaybeConjunction = pMaybeConjunction$1(yyStart);
    return yyColumn.chunk3.fMaybeConjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeConjunction. */
  private Result pMaybeConjunction$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pANDAND(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMaybeConjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call("&&", left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeConjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeConjunction(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNoCmpMaybeConjunction) 
      yyColumn.chunk3.fNoCmpMaybeConjunction = pNoCmpMaybeConjunction$1(yyStart);
    return yyColumn.chunk3.fNoCmpMaybeConjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeConjunction. */
  private Result pNoCmpMaybeConjunction$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pANDAND(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoCmpMaybeConjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call("&&", left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoCmpMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeComparison.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeComparison(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMaybeComparison) 
      yyColumn.chunk3.fMaybeComparison = pMaybeComparison$1(yyStart);
    return yyColumn.chunk3.fMaybeComparison;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeComparison. */
  private Result pMaybeComparison$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComparable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pComparator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String op = yyResult.semanticValue();

        yyResult = pComparable(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call(op, left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNoCmpMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Comparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComparator(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fComparator) 
      yyColumn.chunk3.fComparator = pComparator$1(yyStart);
    return yyColumn.chunk3.fComparator;
  }

  /** Actually parse orc.parser.OrcParserRats.Comparator. */
  private Result pComparator$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRANGLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLANGLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpMaybeComparison.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpMaybeComparison(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNoCmpMaybeComparison) 
      yyColumn.chunk3.fNoCmpMaybeComparison = pNoCmpMaybeComparison$1(yyStart);
    return yyColumn.chunk3.fNoCmpMaybeComparison;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpMaybeComparison. */
  private Result pNoCmpMaybeComparison$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComparable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pNoCmpComparator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String op = yyResult.semanticValue();

        yyResult = pComparable(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Call(op, left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pComparable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NoCmpComparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCmpComparator(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fNoCmpComparator) 
      yyColumn.chunk3.fNoCmpComparator = pNoCmpComparator$1(yyStart);
    return yyColumn.chunk3.fNoCmpComparator;
  }

  /** Actually parse orc.parser.OrcParserRats.NoCmpComparator. */
  private Result pNoCmpComparator$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pGT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pGEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pLEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Comparable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComparable(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fComparable) 
      yyColumn.chunk3.fComparable = pComparable$1(yyStart);
    return yyColumn.chunk3.fComparable;
  }

  /** Actually parse orc.parser.OrcParserRats.Comparable. */
  private Result pComparable$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDotExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression x = yyResult.semanticValue();

        yyResult = pSpace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Call("~", x);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pCons(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMaybeSum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Cons.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCons(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fCons) 
      yyColumn.chunk4.fCons = pCons$1(yyStart);
    return yyColumn.chunk4.fCons;
  }

  /** Actually parse orc.parser.OrcParserRats.Cons. */
  private Result pCons$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pCOLON(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pCons$$Choice1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression right = yyResult.semanticValue();

            yyValue = new ConsExpr(left, right);
            yyValue = at(yyStart, yyCount, yyValue);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Cons$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCons$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCons(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSum.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSum(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyRepetition1;
    Pair<Action<Expression>> yyRepValue1;
    Expression               yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeProduct(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSumTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for actions.
        final Pair<Action<Expression>> actions = yyRepValue1.reverse();

        yyValue = apply(actions, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for actions.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SumTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSumTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSumOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String op = yyResult.semanticValue();

      yyResult = pMaybeProduct(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression left) {
            Expression yyValue = new Call(op, left, right);
            yyValue = at(left, right, yyValue);
            return yyValue;
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SumOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSumOperator(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fSumOperator) 
      yyColumn.chunk4.fSumOperator = pSumOperator$1(yyStart);
    return yyColumn.chunk4.fSumOperator;
  }

  /** Actually parse orc.parser.OrcParserRats.SumOperator. */
  private Result pSumOperator$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPLUS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMINUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeProduct.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeProduct(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fMaybeProduct) 
      yyColumn.chunk4.fMaybeProduct = pMaybeProduct$1(yyStart);
    return yyColumn.chunk4.fMaybeProduct;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeProduct. */
  private Result pMaybeProduct$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeExponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pProductTail(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Action<Expression>> actions = yyResult.semanticValue();

          yyValue = apply(actions, seed);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeExponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ProductTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductTail(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fProductTail) 
      yyColumn.chunk4.fProductTail = pProductTail$1(yyStart);
    return yyColumn.chunk4.fProductTail;
  }

  /** Actually parse orc.parser.OrcParserRats.ProductTail. */
  private Result pProductTail$1(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyOption1;
    Pair<Action<Expression>> yyOpValue1;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProductOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String op = yyResult.semanticValue();

      yyResult = pMaybeExponent(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pSpace(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pProductTail(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<Action<Expression>> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for rest.
          final Pair<Action<Expression>> rest = yyOpValue1;

          yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
            public Expression run(Expression left) {
              Expression yyValue = new Call(op, left, right);
              yyValue = at(left, right, yyValue);
              return yyValue;
            }
          }, rest == null ? Pair.EMPTY : rest);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for rest.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ProductOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductOperator(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fProductOperator) 
      yyColumn.chunk4.fProductOperator = pProductOperator$1(yyStart);
    return yyColumn.chunk4.fProductOperator;
  }

  /** Actually parse orc.parser.OrcParserRats.ProductOperator. */
  private Result pProductOperator$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDIV(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMOD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTIMES(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeExponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeExponent(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fMaybeExponent) 
      yyColumn.chunk4.fMaybeExponent = pMaybeExponent$1(yyStart);
    return yyColumn.chunk4.fMaybeExponent;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeExponent. */
  private Result pMaybeExponent$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExponentTail(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Action<Expression>> actions = yyResult.semanticValue();

          yyValue = apply(actions, seed);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ExponentTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentTail(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExponentTail) 
      yyColumn.chunk4.fExponentTail = pExponentTail$1(yyStart);
    return yyColumn.chunk4.fExponentTail;
  }

  /** Actually parse orc.parser.OrcParserRats.ExponentTail. */
  private Result pExponentTail$1(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyOption1;
    Pair<Action<Expression>> yyOpValue1;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExponentOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String op = yyResult.semanticValue();

      yyResult = pMaybeSigned(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pSpace(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExponentTail(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<Action<Expression>> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for rest.
          final Pair<Action<Expression>> rest = yyOpValue1;

          yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
            public Expression run(Expression left) {
              Expression yyValue = new Call(op, left, right);
              yyValue = at(left, right, yyValue);
              return yyValue;
            }
          }, rest == null ? Pair.EMPTY : rest);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for rest.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ExponentOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentOperator(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExponentOperator) 
      yyColumn.chunk4.fExponentOperator = pExponentOperator$1(yyStart);
    return yyColumn.chunk4.fExponentOperator;
  }

  /** Actually parse orc.parser.OrcParserRats.ExponentOperator. */
  private Result pExponentOperator$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEXPONENT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSigned.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSigned(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fMaybeSigned) 
      yyColumn.chunk4.fMaybeSigned = pMaybeSigned$1(yyStart);
    return yyColumn.chunk4.fMaybeSigned;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeSigned. */
  private Result pMaybeSigned$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMINUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDotExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression x = yyResult.semanticValue();

        yyValue = new Call("0-", x);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pDotExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DotExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDotExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fDotExpression) 
      yyColumn.chunk4.fDotExpression = pDotExpression$1(yyStart);
    return yyColumn.chunk4.fDotExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.DotExpression. */
  private Result pDotExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSIGNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Let();
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSTOP(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Silent();
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBasicExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCallTail(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> tail = yyResult.semanticValue();

        yyValue = apply(tail, seed);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = seed;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.CallTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallTail(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fCallTail) 
      yyColumn.chunk5.fCallTail = pCallTail$1(yyStart);
    return yyColumn.chunk5.fCallTail;
  }

  /** Actually parse orc.parser.OrcParserRats.CallTail. */
  private Result pCallTail$1(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyOption1;
    Pair<Action<Expression>> yyOpValue1;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeTypeActuals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Type> types = yyResult.semanticValue();

      yyResult = pLPAREN(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpressionList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expression> args = yyResult.semanticValue();

          yyResult = pRPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCallTail(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Pair<Action<Expression>> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for rest.
              final Pair<Action<Expression>> rest = yyOpValue1;

              yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
                public Expression run(Expression left) {
                  Expression yyValue = new Call(left, args, types);
                  yyValue = at(left, yyCount, yyValue);
                  return yyValue;
                }
              }, rest == null ? Pair.EMPTY : rest);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for rest.
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDOT(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pRequiredIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String right = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCallTail(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<Action<Expression>> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for rest.
            final Pair<Action<Expression>> rest = yyOpValue1;

            yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
              public Expression run(Expression left) {
                Expression yyValue = new Dot(left, right);
                yyValue = at(left, yyCount, yyValue);
                return yyValue;
              }
            }, rest == null ? Pair.EMPTY : rest);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for rest.
        }
      }

      // Nested alternative 2.

      yyResult = pQMARK(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCallTail(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Action<Expression>> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for rest.
          final Pair<Action<Expression>> rest = yyOpValue1;

          yyValue = new Pair<Action<Expression>>(new Action<Expression>() {
            public Expression run(Expression left) {
              Expression yyValue = new Call("?", left);
              yyValue = at(left, yyCount, yyValue);
              return yyValue;
            }
          }, rest == null ? Pair.EMPTY : rest);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for rest.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BasicExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBasicExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBareOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String op = yyResult.semanticValue();

      yyValue = new Name(op);
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpressionList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expression> args = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          if (args.size() == 1) {
            yyValue = args.get(0);
          } else {
            yyValue = new Let(args);
            yyValue = at(yyStart, yyCount, yyValue);
          }

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpressionList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expression> args = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new ListExpr(args);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BareOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBareOperator(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBareOperator) 
      yyColumn.chunk5.fBareOperator = pBareOperator$1(yyStart);
    return yyColumn.chunk5.fBareOperator;
  }

  /** Actually parse orc.parser.OrcParserRats.BareOperator. */
  private Result pBareOperator$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBareOperator$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.BareOperator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBareOperator$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoCmpComparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pComparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pCOLON_EQUALS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pQMARK(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pANDAND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pOROR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pNOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pCOLON(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pExponentOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pProductOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pSumOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pMINUS(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = "0-";

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bare operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fLiteral) 
      yyColumn.chunk5.fLiteral = pLiteral$1(yyStart);
    return yyColumn.chunk5.fLiteral;
  }

  /** Actually parse orc.parser.OrcParserRats.Literal. */
  private Result pLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    Literal    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Object literal = yyResult.semanticValue();

      yyValue = new Literal(literal);
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Literal$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTRUE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = true;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pFALSE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = false;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pNULL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Variable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      yyValue = new Name(name);
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExpressionList) 
      yyColumn.chunk5.fExpressionList = pExpressionList$1(yyStart);
    return yyColumn.chunk5.fExpressionList;
  }

  /** Actually parse orc.parser.OrcParserRats.ExpressionList. */
  private Result pExpressionList$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBody(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression f = yyResult.semanticValue();

      yyResult = pExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Expression> fs = yyResult.semanticValue();

        List<Expression> out = fs.list();
        out.add(0, f);
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = new LinkedList<Expression>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.ExpressionList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBody(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.ExpressionList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList$$Star1(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExpressionList$$Star1) 
      yyColumn.chunk5.fExpressionList$$Star1 = pExpressionList$$Star1$1(yyStart);
    return yyColumn.chunk5.fExpressionList$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.ExpressionList$$Star1. */
  private Result pExpressionList$$Star1$1(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Pair<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpressionList$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression v$el$1 = yyResult.semanticValue();

      yyResult = pExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Expression> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Expression>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Pattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fPattern) 
      yyColumn.chunk5.fPattern = pPattern$1(yyStart);
    return yyColumn.chunk5.fPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.Pattern. */
  private Result pPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern p = yyResult.semanticValue();

      yyResult = pDOUBLE_COLON(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String index = yyResult.semanticValue();

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Type t = yyResult.semanticValue();

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new TypedPattern(p, t);
            yyValue = at(yyStart, yyCount, yyValue);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pAsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.AsPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAsPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fAsPattern) 
      yyColumn.chunk5.fAsPattern = pAsPattern$1(yyStart);
    return yyColumn.chunk5.fAsPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.AsPattern. */
  private Result pAsPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern p = yyResult.semanticValue();

      yyResult = pAS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String index = yyResult.semanticValue();

        yyResult = pRequiredIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v = yyResult.semanticValue();

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new AsPattern(p, v);
            yyValue = at(yyStart, yyCount, yyValue);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pConsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ConsPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConsPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fConsPattern) 
      yyColumn.chunk5.fConsPattern = pConsPattern$1(yyStart);
    return yyColumn.chunk5.fConsPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.ConsPattern. */
  private Result pConsPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBasicPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern left = yyResult.semanticValue();

      yyResult = pCOLON(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String index = yyResult.semanticValue();

        yyResult = pConsPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pattern right = yyResult.semanticValue();

          yyValue = new ConsPattern(left, right);
          yyValue = at(yyStart, yyCount, yyValue);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pBasicPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BasicPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBasicPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBasicPattern) 
      yyColumn.chunk5.fBasicPattern = pBasicPattern$1(yyStart);
    return yyColumn.chunk5.fBasicPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.BasicPattern. */
  private Result pBasicPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUNDERSCORE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new WildcardPattern();
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Literal literal = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new LiteralPattern(literal);
        yyValue = at(yyStart, yyCount, yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSIGNAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new TuplePattern();
      yyValue = at(yyStart, yyCount, yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pLPAREN(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pPatternList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Pattern> formals = yyResult.semanticValue();

            yyResult = pRPAREN(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSpace(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new CallPattern(name, formals);
                yyValue = at(yyStart, yyCount, yyValue);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }

        // Nested alternative 2.

        yyValue = new VariablePattern(name);
        yyValue = at(yyStart, yyCount, yyValue);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 5.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPatternList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Pattern> formals = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (formals.size() == 1) {
              yyValue = formals.get(0);
            } else {
              yyValue = new TuplePattern(formals);
              yyValue = at(yyStart, yyCount, yyValue);
            }

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPatternList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Pattern> formals = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new ListPattern(formals);
            yyValue = at(yyStart, yyCount, yyValue);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fType) 
      yyColumn.chunk5.fType = pType$1(yyStart);
    return yyColumn.chunk5.fType;
  }

  /** Actually parse orc.parser.OrcParserRats.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pTypeList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Type> ts = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (ts.size() > 1) {
              yyValue = new TupleType(ts);
            } else if (ts.size() == 1) {
              yyValue = ts.get(0);
            } else {
              yyValue = Type.TOP;
            }

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pUNDERSCORE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Type.BLANK;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLAMBDA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pTypeFormals(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<String> typeFormals = yyResult.semanticValue();

        yyResult = pLPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTypeList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Type> argTypes = yyResult.semanticValue();

            yyResult = pRPAREN(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSpace(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pType$$Star1(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Pair<List<Type>> curried0 = yyResult.semanticValue();

                  yyResult = pDOUBLE_COLON(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pType(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final Type resultType = yyResult.semanticValue();

                      Type curriedType = resultType;
                      List<List<Type>> curried = curried0.list();
                      ListIterator<List<Type>> it = curried.listIterator(curried.size());
                      while (it.hasPrevious()) {
                        curriedType = new ArrowType(it.previous(), curriedType, new LinkedList<String>() /* curried type params not allowed */);
                      }
                      yyValue = new ArrowType(argTypes, curriedType, typeFormals);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pTypeActuals(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Type> actualTypes = yyResult.semanticValue();

        yyResult = pSpace(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new TypeApplication(name, actualTypes);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pSpace(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new NamedType(name);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Type$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pTypeList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSpace(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Type$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fType$$Star1) 
      yyColumn.chunk6.fType$$Star1 = pType$$Star1$1(yyStart);
    return yyColumn.chunk6.fType$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.Type$$Star1. */
  private Result pType$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<List<Type>> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Type> v$el$1 = yyResult.semanticValue();

      yyResult = pType$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<List<Type>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<List<Type>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeList(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeList) 
      yyColumn.chunk6.fTypeList = pTypeList$1(yyStart);
    return yyColumn.chunk6.fTypeList;
  }

  /** Actually parse orc.parser.OrcParserRats.TypeList. */
  private Result pTypeList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Type t = yyResult.semanticValue();

      yyResult = p$$Shared2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Type> ts = yyResult.semanticValue();

        List<Type> out = ts.list();
        out.add(0, t);
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = new LinkedList<Type>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * orc.parser.OrcParserRats.TypeList$$Star1 
   * and orc.parser.OrcParserRats.TypeActuals$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.f$$Shared2) 
      yyColumn.chunk6.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk6.f$$Shared2;
  }

  /** Actually parse orc.parser.OrcParserRats.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Type ts = yyResult.semanticValue();

        yyResult = p$$Shared2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Type> v$1 = yyResult.semanticValue();

          yyValue = new Pair<Type>(ts, v$1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TypeFormals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeFormals(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeFormals) 
      yyColumn.chunk6.fTypeFormals = pTypeFormals$1(yyStart);
    return yyColumn.chunk6.fTypeFormals;
  }

  /** Actually parse orc.parser.OrcParserRats.TypeFormals. */
  private Result pTypeFormals$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRequiredIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String tf = yyResult.semanticValue();

        yyResult = pTypeFormals$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<String> tfs = yyResult.semanticValue();

          yyResult = pRBRACKET(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            List<String> out = tfs.list();
            out.add(0, tf);
            yyValue = out;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyValue = new LinkedList<String>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.TypeFormals$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeFormals$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeFormals$$Star1) 
      yyColumn.chunk6.fTypeFormals$$Star1 = pTypeFormals$$Star1$1(yyStart);
    return yyColumn.chunk6.fTypeFormals$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.TypeFormals$$Star1. */
  private Result pTypeFormals$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String tfs = yyResult.semanticValue();

        yyResult = pTypeFormals$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<String> v$1 = yyResult.semanticValue();

          yyValue = new Pair<String>(tfs, v$1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeTypeActuals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeTypeActuals(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeActuals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Type> ta = yyResult.semanticValue();

      yyValue = ta;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TypeActuals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeActuals(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeActuals) 
      yyColumn.chunk6.fTypeActuals = pTypeActuals$1(yyStart);
    return yyColumn.chunk6.fTypeActuals;
  }

  /** Actually parse orc.parser.OrcParserRats.TypeActuals. */
  private Result pTypeActuals$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Type t = yyResult.semanticValue();

        yyResult = p$$Shared2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Type> ts = yyResult.semanticValue();

          yyResult = pRBRACKET(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            List<Type> out = ts.list();
            out.add(0, t);
            yyValue = out;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeResultType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeResultType(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fMaybeResultType) 
      yyColumn.chunk6.fMaybeResultType = pMaybeResultType$1(yyStart);
    return yyColumn.chunk6.fMaybeResultType;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeResultType. */
  private Result pMaybeResultType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDOUBLE_COLON(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Type resultType = yyResult.semanticValue();

        yyValue = resultType;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pDOUBLE_COLON_BANG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Type resultType = yyResult.semanticValue();

        yyValue = new AssertedType(resultType);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SiteName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSiteName(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBareOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RequiredSiteName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequiredSiteName(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fRequiredSiteName) 
      yyColumn.chunk6.fRequiredSiteName = pRequiredSiteName$1(yyStart);
    return yyColumn.chunk6.fRequiredSiteName;
  }

  /** Actually parse orc.parser.OrcParserRats.RequiredSiteName. */
  private Result pRequiredSiteName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSiteName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyBase = yyStart;

    abort(yyError);

    yyError = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ClassName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassName(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fClassName) 
      yyColumn.chunk6.fClassName = pClassName$1(yyStart);
    return yyColumn.chunk6.fClassName;
  }

  /** Actually parse orc.parser.OrcParserRats.ClassName. */
  private Result pClassName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pClassNameToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RequiredClassName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequiredClassName(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fRequiredClassName) 
      yyColumn.chunk6.fRequiredClassName = pRequiredClassName$1(yyStart);
    return yyColumn.chunk6.fRequiredClassName;
  }

  /** Actually parse orc.parser.OrcParserRats.RequiredClassName. */
  private Result pRequiredClassName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pClassName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyBase = yyStart;

    abort(yyError);

    yyError = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ClassNameToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassNameToken(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if ('.' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pWord(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            continue;
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("class name token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fIdentifier) 
      yyColumn.chunk7.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk7.fIdentifier;
  }

  /** Actually parse orc.parser.OrcParserRats.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RequiredIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequiredIdentifier(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fRequiredIdentifier) 
      yyColumn.chunk7.fRequiredIdentifier = pRequiredIdentifier$1(yyStart);
    return yyColumn.chunk7.fRequiredIdentifier;
  }

  /** Actually parse orc.parser.OrcParserRats.RequiredIdentifier. */
  private Result pRequiredIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyBase = yyStart;

    abort(yyError);

    yyError = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DEF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDEF(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("def")) {
      yyValue = "def";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DEF expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.VAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVAL(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("val")) {
      yyValue = "val";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("VAL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.CLASS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCLASS(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("class")) {
      yyValue = "class";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("CLASS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SITE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSITE(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("site")) {
      yyValue = "site";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("SITE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.INCLUDE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pINCLUDE(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("include")) {
      yyValue = "include";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("INCLUDE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TYPE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTYPE(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("type")) {
      yyValue = "type";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("TYPE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LAMBDA.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLAMBDA(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("lambda")) {
      yyValue = "lambda";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LAMBDA expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ATOMIC.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pATOMIC(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("atomic")) {
      yyValue = "atomic";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ATOMIC expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ISOLATED.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pISOLATED(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("isolated")) {
      yyValue = "isolated";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ISOLATED expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TRY.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTRY(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("try")) {
      yyValue = "try";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("TRY expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.THROW.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTHROW(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("throw")) {
      yyValue = "throw";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("THROW expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.CATCH.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCATCH(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("catch")) {
      yyValue = "catch";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("CATCH expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.AS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAS(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("as")) {
      yyValue = "as";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("AS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.IF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIF(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("if")) {
      yyValue = "if";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("IF expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.THEN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTHEN(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("then")) {
      yyValue = "then";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("THEN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ELSE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pELSE(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("else")) {
      yyValue = "else";

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ELSE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.STOP.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSTOP(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("stop")) {
      yyValue = "stop";

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("STOP expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SIGNAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSIGNAL(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("signal")) {
      yyValue = "signal";

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("SIGNAL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DOUBLE_COLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOUBLE_COLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "::";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("d o u b l e_ c o l o n expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DOUBLE_COLON_BANG.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOUBLE_COLON_BANG(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if (':' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = ":!:";

          yyResult = pSpace(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("d o u b l e_ c o l o n_ b a n g expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.EQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("EQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RequiredEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequiredEQ(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyBase = yyStart;

    abort(yyError);

    yyError = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LANGLE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLANGLE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LANGLE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RANGLE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRANGLE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ">";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RANGLE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ".";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BAR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBAR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "|";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("BAR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.UNDERSCORE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUNDERSCORE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "_";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("UNDERSCORE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SEMICOLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSEMICOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ";";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("SEMICOLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ANDAND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pANDAND(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "&&";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ANDAND expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.OROR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOROR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "||";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("OROR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('~' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "~";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("NOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.PLUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPLUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("PLUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MINUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMINUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('-' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("MINUS expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("MINUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DIV.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDIV(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "/";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DIV expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MOD.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMOD(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "%";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("MOD expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TIMES.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTIMES(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "*";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("TIMES expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.EXPONENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEXPONENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "**";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("EXPONENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.COLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ":";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<:";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("LT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("LEQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.GT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ":>";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("GT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.GEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">=";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("GEQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "/=";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("NEQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.COLON_EQUALS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOLON_EQUALS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ":=";

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("c o l o n_ e q u a l s expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.QMARK.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQMARK(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "?";

      yyResult = pHSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("QMARK expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.Number.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumber(final int yyStart) throws IOException {
    Result     yyResult;
    Number     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pInteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.Float.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloat(final int yyStart) throws IOException {
    Result     yyResult;
    BigDecimal yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String rep = yyResult.semanticValue();

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        try {
          yyValue = new BigDecimal(rep);
        } catch (NumberFormatException e) {
          // impossible by construction
          throw new AssertionError(e);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.FloatToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatToken(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSignedIntegerToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('.' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyOption1  = yyRepetition1;

          yyResult = pExponent(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyValue = difference(yyStart, yyOption1);

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pExponent(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("float token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fExponent) 
      yyColumn.chunk7.fExponent = pExponent$1(yyStart);
    return yyColumn.chunk7.fExponent;
  }

  /** Actually parse orc.parser.OrcLiteralParser.Exponent. */
  private Result pExponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }

            default:
              /* No match. */
            }
          }

          yyResult = pIntegerToken(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.Integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInteger(final int yyStart) throws IOException {
    Result     yyResult;
    BigInteger yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSignedIntegerToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String rep = yyResult.semanticValue();

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        try {
          yyValue = BigInteger.valueOf(Long.parseLong(rep));
        } catch (NumberFormatException e) {
          // impossible by construction
          throw new AssertionError(e);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.SignedIntegerToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSignedIntegerToken(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fSignedIntegerToken) 
      yyColumn.chunk7.fSignedIntegerToken = pSignedIntegerToken$1(yyStart);
    return yyColumn.chunk7.fSignedIntegerToken;
  }

  /** Actually parse orc.parser.OrcLiteralParser.SignedIntegerToken. */
  private Result pSignedIntegerToken$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if ('-' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }

    yyResult = pIntegerToken(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("signed integer token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.IntegerToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerToken(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fIntegerToken) 
      yyColumn.chunk7.fIntegerToken = pIntegerToken$1(yyStart);
    return yyColumn.chunk7.fIntegerToken;
  }

  /** Actually parse orc.parser.OrcLiteralParser.IntegerToken. */
  private Result pIntegerToken$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pIntegerToken$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("integer token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.IntegerToken$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerToken$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fIntegerToken$$Star1) 
      yyColumn.chunk7.fIntegerToken$$Star1 = pIntegerToken$$Star1$1(yyStart);
    return yyColumn.chunk7.fIntegerToken$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.IntegerToken$$Star1. */
  private Result pIntegerToken$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pIntegerToken$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fStringLiteral) 
      yyColumn.chunk7.fStringLiteral = pStringLiteral$1(yyStart);
    return yyColumn.chunk7.fStringLiteral;
  }

  /** Actually parse orc.parser.OrcLiteralParser.StringLiteral. */
  private Result pStringLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String string = yyResult.semanticValue();

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = Utilities.unescape(string.substring(1, string.length()-1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.StringLiteralToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralToken(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if (-1 != yyC) {
                yyIndex = yyChoice2 + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case '-':
                case '[':
                case '\\':
                case ']':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case 'u':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                      case 'A':
                      case 'B':
                      case 'C':
                      case 'D':
                      case 'E':
                      case 'F':
                      case 'a':
                      case 'b':
                      case 'c':
                      case 'd':
                      case 'e':
                      case 'f':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;

                                  switch (yyC) {
                                  case '0':
                                  case '1':
                                  case '2':
                                  case '3':
                                  case '4':
                                  case '5':
                                  case '6':
                                  case '7':
                                  case '8':
                                  case '9':
                                  case 'A':
                                  case 'B':
                                  case 'C':
                                  case 'D':
                                  case 'E':
                                  case 'F':
                                  case 'a':
                                  case 'b':
                                  case 'c':
                                  case 'd':
                                  case 'e':
                                  case 'f':
                                    {
                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;

                                        switch (yyC) {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                        case 'A':
                                        case 'B':
                                        case 'C':
                                        case 'D':
                                        case 'E':
                                        case 'F':
                                        case 'a':
                                        case 'b':
                                        case 'c':
                                        case 'd':
                                        case 'e':
                                        case 'f':
                                          {
                                            yyRepetition1 = yyIndex;
                                            continue;
                                          }

                                        default:
                                          /* No match. */
                                        }
                                      }
                                    }
                                    break;

                                  default:
                                    /* No match. */
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }

              // Nested alternative 2.
              { // Start scope for nested choice.

                final int yyChoice3 = yyChoice2;

                // Nested alternative 1.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                                {
                                  yyRepetition1 = yyIndex;
                                  continue;
                                }

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      final int yyChoice4 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice4);
                      if (-1 != yyC) {
                        yyIndex = yyChoice4 + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyRepetition1 = yyIndex;
                            continue;
                          }

                        default:
                          /* No match. */
                        }
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice4;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }
              } // End scope for nested choice.
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string literal token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fWord) 
      yyColumn.chunk7.fWord = pWord$1(yyStart);
    return yyColumn.chunk7.fWord;
  }

  /** Actually parse orc.parser.OrcLiteralParser.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pWord$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("word expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Word$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fWord$$Star1) 
      yyColumn.chunk7.fWord$$Star1 = pWord$$Star1$1(yyStart);
    return yyColumn.chunk7.fWord$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.Word$$Star1. */
  private Result pWord$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('\'' == yyC) ||
          (('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pWord$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.NULL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNULL(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("null")) {
      yyValue = "null";

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("NULL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.TRUE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTRUE(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("true")) {
      yyValue = "true";

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("TRUE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.FALSE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFALSE(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("false")) {
      yyValue = "false";

      yyResult = pHSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("FALSE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.LPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLPAREN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "(";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.RPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRPAREN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ")";

      yyResult = pHSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.LBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLBRACKET(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "[";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.RBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRBRACKET(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "]";

      yyResult = pHSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.COMMA.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOMMA(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ",";

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COMMA expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.HSpace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pSingleLineComment(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '-':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('-' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  yyC = character(yyRepetition2);
                  if (-1 != yyC) {
                    yyIndex = yyRepetition2 + 1;

                    switch (yyC) {
                    case '\n':
                    case '\r':
                      /* No match. */
                      break;

                    default:
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }
                    }
                  }
                  break;
                }

                final int yyChoice2 = yyRepetition2;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '\r':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if (-1 != yyC) {
                        yyIndex = yyChoice3 + 1;
                        if ('\n' == yyC) {

                          yyRepetition1 = yyIndex;
                          continue;
                        }
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice3;
                      continue;
                    }

                  case '\n':
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice2);
                if (-1 != yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyChoice2;
                  continue;
                } else {
                  yyError = yyError.select("space expected", yyStart);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pMultiLineComment(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.MultiLineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyResult = pMultiLineComment(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '-':
              {
                yyPredMatched = false;

                yyC = character(yyIndex);
                if ('}' == yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyIndex;
                  continue;
                } else {
                  yyError = yyError.select("multi line comment expected", yyStart);
                }
              }
              break;

            case '\r':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('\n' == yyC) {

                    yyRepetition1 = yyIndex;
                    continue;
                  }
                }

                // Nested alternative 2.

                yyRepetition1 = yyChoice2;
                continue;
              }

            case '\n':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 3.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\n':
            case '\r':
            case '-':
              /* No match. */
              break;

            default:
              {
                yyRepetition1 = yyIndex;
                continue;
              }
            }
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('-' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('}' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"-}\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"-}\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("multi line comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.SingleLineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleLineComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyResult = pSingleLineComment(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '-':
              {
                yyPredMatched = false;

                yyC = character(yyIndex);
                if ('}' == yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyIndex;
                  continue;
                } else {
                  yyError = yyError.select("single line comment expected", yyStart);
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 3.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\n':
            case '\r':
            case '-':
              /* No match. */
              break;

            default:
              {
                yyRepetition1 = yyIndex;
                continue;
              }
            }
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('-' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('}' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"-}\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"-}\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("single line comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcLiteralParser.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  private Config config;
  
  public OrcParserRats(Config config, Reader reader, String filename) {
    this(reader, filename);
    this.config = config;
  }
  
  /**
  * Attach a source location to an expression. Used like this:
  * <code>yyValue = at(yyStart, yyCount, yyValue)</code>
  */
  protected final <E extends Locatable> E at(int start, int end, E e) {
    Location startl = location(start);
    Location endl = location(end-2);
    e.setSourceLocation(new SourceLocation(
    new File(startl.file), start, startl.line, startl.column,
    end-2, endl.line, endl.column));
    return e;
  }
  /**
  * Attach a source location to an infix binary operator.
  */
  protected final <E extends Locatable> E at(Locatable start, Locatable end, E e) {
    SourceLocation startl = start.getSourceLocation();
    SourceLocation endl = end.getSourceLocation();
    e.setSourceLocation(new SourceLocation(
    startl.file, startl.offset, startl.line, startl.column,
    endl.endOffset, endl.endLine, endl.endColumn));
    return e;
  }
  /**
  * Attach a source location to a postfix operator.
  */
  protected final <E extends Locatable> E at(Locatable start, int end, E e) {
    SourceLocation startl = start.getSourceLocation();
    Location endl = location(end-2);
    e.setSourceLocation(new SourceLocation(
    startl.file, startl.offset, startl.line, startl.column,
    end-2, endl.line, endl.column));
    return e;
  }
  
  /**
  * Signal an unrecoverable error in the parse. See
  * examples of how this is used in productions to
  * prevent unwanted backtracking.  This should be
  * used with extreme care to ensure that it doesn't
  * prevent necessary backtracking.
  */
  protected final void abort(ParseError error) throws IOException {
    throw new AbortParse(format(error), error);
  }

}
