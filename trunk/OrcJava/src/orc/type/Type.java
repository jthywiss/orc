package orc.type;

import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import orc.ast.oil.arg.Arg;
import orc.env.Env;
import orc.error.compiletime.typing.ArgumentArityException;
import orc.error.compiletime.typing.SubtypeFailureException;
import orc.error.compiletime.typing.TypeArityException;
import orc.error.compiletime.typing.TypeException;
import orc.error.compiletime.typing.UncallableTypeException;

/**
 * 
 * Abstract superclass of all types for the Orc typechecker.
 * 
 * @author dkitchin
 *
 */

public abstract class Type {

	/* Create singleton representatives for some common types */
	public static final Type TOP = new Top();
	public static final Type BOT = new Bot();
	public static final Type NUMBER = new NumberType();
	public static final Type STRING = new StringType();
	public static final Type BOOLEAN = new BooleanType();
	public static final Type INTEGER = new IntegerType();
	public static final Type LET = new LetType();
	
	/* Placeholder for an unspecified type */
	public static final Type BLANK = null;

	
	/* Check if a type is Top */
	public boolean isTop() {
		return false;
	}
	
	/* Check if a type is Bot */
	public boolean isBot() {
		return false;
	}
	
	
	/* We use the Java inheritance hierarchy as a default */
	/* We also require the two types to have the same kind */
	public boolean subtype(Type that) {
		
		return that.isTop() || 
			(that.getClass().isAssignableFrom(this.getClass())
				&& this.sameVariances(that));
	}

	public boolean supertype(Type that) {
		return that.subtype(this);
	}
	
	/* By default, equality is based on mutual subtyping.
	 * TODO: This may not be correct in the presence of bounded quantification.
	 */
	public boolean equal(Type that) {
		return this.subtype(that) && that.subtype(this);
	}
	
	/* Find the join (least upper bound) in the subtype lattice
	 * of this type and another type.
	 */
	public Type join(Type that) {		
		if (this.subtype(that)) {
			return that;
		}
		else if (that.subtype(this)) {
			return this;
		}
		else {
			return TOP;
		}
	}
	
	/* Find the meet (greatest lower bound) in the subtype lattice
	 * of this type and another type.
	 */
	public Type meet(Type that) {
		if (this.subtype(that)) {
			return that;
		}
		else if (that.subtype(this)) {
			return this;
		}
		else {
			return BOT;
		}
		
	}
	
	/* By default, try to synthesize the argument types
	 * and call a different version of this method using
	 * just those types.
	 * 
	 * This may be overridden by types which want to handle calls
	 * in their own way (for example, arrow types).
	 */
	public Type call(Env<Type> ctx, Env<Type> typectx, List<Arg> args, List<Type> typeActuals) throws TypeException {
		
		/* Add each type argument to the type context */
		/* Note that there is no type arity checking here! */
		for(Type targ : typeActuals) {
			typectx = typectx.extend(targ);
		}
		
		/* Synthesize the argument types */
		List<Type> argTypes = new LinkedList<Type>();
		for (Arg a : args) {
			argTypes.add(a.typesynth(ctx, typectx));
		}
		
		/* Attempt to use the simplified call form */
		return call(argTypes);
	}
	
	/* 
	 * Types which use normal argument synthesis will override this method instead.
	 * 
	 * Note that this shortcuts type arity checking! This should only be overridden by
	 * types which either never have type arguments, or types that are generated by the compiler
	 * and are not expected to produce type arity errors under any circumstances.
	 * 
	 * By default, a type is not callable. 
	 */
	public Type call(List<Type> args) throws TypeException {
		throw new UncallableTypeException(this);
	}
	
	
	/* By default, use the class name as the type's string representation */
	public String toString() {
		return this.getClass().toString();
	}
	
	
	/* Replace all free type variables with the types given for them in the context.
	 * 
	 * By default, perform no substitutions.
	 * Types which contain variables or other types will override this.
	 */
	public Type subst(Env<Type> ctx) {
		return this;
	}
	
	/* Perform substitution on a list of types */
	public static List<Type> substAll(List<Type> ts, Env<Type> ctx) {
		
		List<Type> newts = new LinkedList<Type>();
		
		for (Type t : ts) {
			newts.add(t.subst(ctx));
		}
		
		return newts;
	}
	
	
	
	/* Type operators */
	
	/* Note that this checker does not formally check kinding; type operators
	 * are in the space of types, distinguished only by overriding
	 * the variances method to return a nonempty type parameter list.
	 */

	/* Get the variances of each type parameters for this type (by default, an empty list) */
	public List<Variance> variances() {
		return new LinkedList<Variance>();
	}
	
	/* Check that this type has the same variances as another type */
	private boolean sameVariances(Type that) {
		
		List<Variance> thisVariances = this.variances();
		List<Variance> thatVariances = that.variances();
		
		for (int i = 0; i < thisVariances.size(); i++) {
			if (!thisVariances.get(i).equals(thatVariances.get(i))) {
				return false;
			}
		}
		
		return true;
	}
	
	/* Call this type at a particular instantiation */
	/* By default, this will assume type arity 0, make
	 * sure the params list is empty, and delegate to
	 * the ordinary call method.
	 */
	public Type callInstance(List<Type> args, List<Type> params) throws TypeException {
		
		if (params.size() > 0) {
			throw new TypeArityException(0, params.size());
		}
		else {
			return call(args);
		}
	}
	
	/* Make sure that this type is an application of the given type
	 * (or some subtype) to exactly one type parameter. If so, return the parameter, and
	 * if not raise an error.
	 */
	public Type unwrapAs(Type T) throws TypeException {
		throw new SubtypeFailureException(T, this);
	}
	
	
	// INFERENCE AND CONSTRAINT SATISFACTION
	
	/* Find the variance of the given variable in this type.
	 * 
	 * The default implementation assumes that the variable does not occur
	 * and thus reports constant variance.
	 */
	public Variance findVariance(int var) {
		return Variance.CONSTANT;
	}
	
	
	/*
	 * Promote this type until all occurrences of the given variables
	 * have been eliminated.
	 * 
	 * The default implementation assumes none of the variables occur
	 * and returns the type unchanged.
	 */
	public Type promote(Set<Integer> V) { return this; }

	/*
	 * Demote this type until all occurrences of the given variables
	 * have been eliminated.
	 * 
	 * The default implementation assumes none of the variables occur
	 * and returns the type unchanged.
	 */
	public Type demote(Set<Integer> V) { return this; }
	
	/*
	public static void addConstraints(Set<Integer> V, Set<Integer> X, Type S, Type T, Constraints C) {
		
	}
	*/
}
