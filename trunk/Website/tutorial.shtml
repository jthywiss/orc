<!--#include virtual="header.shtml" --> 

<link rel="stylesheet" type="text/css" href="/orchard/orc.css" media="screen"/>
<script src="/orchard/jquery-1.2.6.min.js" type="text/javascript"></script>
<script src="/orchard/orc.js" type="text/javascript"></script>

<h1>Tutorial</h1>

<p>This tutorial is interactive: when you see a code example with a <b>run</b>
button, click it to see the result of running the program.</p>

<h2>Sites</h2>
<p>The fundamental unit of computation in an Orc program is called a
<i>site</i>.  Sites are similar to procedures or functions in other languages,
but they may be distributed and are therefore unreliable. A site can implement
a very simple operation, like adding two numbers...</p>
<pre class="orc">
1 + 2
</pre>
<p>... or a very complex operation, like conversing with a person via an
instant message or email:</p>
<pre class="orc-prelude">
def David(x) = Rtimer(1000) >> "Breakfast tacos"
</pre>
<pre class="orc">
David("What is your favorite food?")
</pre>

<p>For the rest of these samples, we will use <tt>David</tt> and
<tt>Adrian</tt> as examples of sites which query a person and return their
response.</p>

<h2>Combinators</h2>
<p>Two Orc expressions can be evaluated in parallel using the <tt>|</tt>
(symmetric, parallel, or bar) combinator:</p>

<pre class="orc-prelude">
def David(x) = Rtimer(500) >> "Breakfast tacos"
def Adrian(x) = Rtimer(1000) >> "Burnt sienna"
</pre>
<pre class="orc">
  David("What is your favorite food?")
| Adrian("What is your favorite color?")
</pre>

<p>In the above example, <tt>David</tt> and <tt>Adrian</tt> are invoked
simultaneously, and <i>both</i> responses are returned. Note that Orc is unlike
most functional programming languages in that expressions may return more than
one value if they involve more than one concurrent computation.</p>

<p>Sites can also be called in sequence. The <tt>>></tt> (sequencing, or push)
combinator evaluates its right side as soon as the left side returns a
value:</p>

<pre class="orc-prelude">
def David(x) = 
	println("(Talking to David...)") >>
	Rtimer(1000) >>
	println("(David says 'warm')")
def Adrian(x) = println("(Talking to Adrian...)") >>
	Rtimer(1000) >>
	println("(Adrian says 'hot')") >>
	"Hot"
</pre>
<pre class="orc">
David("How is the weather?")

  >>
 
-- Will run as soon as David responds
Adrian("How is the weather?")
</pre>

<p>Push allows you to bind a value produced by its left side and use it in the
right side:</p>

<pre class="orc-prelude">
def David(x) = Rtimer(1000) >>
	println("(David says 'balmy')") >>
	"balmy"
</pre>
<pre class="orc">
David("How is the weather?")

  >weather>
 
cat("The weather in Austin is ", weather)
</pre>

<p>The right side is evaluated independently for <i>every</i> value published
by the left side:</p>

<pre class="orc-prelude">
def David(x) = Rtimer(1000) >>
	println("(David says 'Pan's Labyrinth')") >>
	"Pan's Labyrinth"
def Adrian(x) = Rtimer(1500) >>
	println("(Adrian says 'The Princess Bride')") >>
	"The Princess Bride"
</pre>
<pre class="orc">
(   David("Pick a movie you like:")
  | Adrian("Pick a movie you like:") )

  >movie>
 
-- Will print for every response received
cat("I heard that ", movie, " is a good movie.")
</pre>

<p>The final combinator, <tt>&lt;&lt;</tt> (asymmetric, pull, or where),
combines the concepts of selection, blocking, and termination. It is used to
select the first value published by an expression and then terminate that
expression.</p>

<pre class="orc-prelude">
def David(x) = Rtimer(1000) >>
	println("(David says 'azure')") >>
	"azure"
def Adrian(x) = null
</pre>
<pre class="orc">
-- Only one response will be printed.
cat(color, " wins.")

  &lt;color&lt;

        David("Choose a color.")
      | Adrian("Choose a color.")  
</pre>

<p>Both sides of a pull begin evaluating immediately. When the left-hand side
needs the value produced by the right-hand side, it blocks until that value is
available.</p>

<pre class="orc-prelude">
def David(x) = 
	println("(Talking to David ...)") >>
	Rtimer(3000) >>
	println("(David says 'purple')") >>
	"purple"
def Adrian(x) = null
</pre>
<pre class="orc">
-- "red" and "blue" are printed immediately
"red" | cat("light ", color) | "blue"

  &lt;color&lt;

    David("Choose a color.")  
</pre>

<h2>Fundamental Sites</h2>

<p>Orc provides some fundamental sites which are necessary for writing
useful expressions:</p>

<pre class="orc-prelude">
def David(x) = 
	Rtimer(6000) >>
	println("(David says '42')")
</pre>
<pre class="orc">
-- if publishes a value if the condition is true
  if(3 /= 4) >> "three does not equal four"
-- and does not publish if it is false
| if(false) >> "impossible!"

-- Rtimer waits for some number of milliseconds
-- before publishing a value.
| Rtimer(3000) >> "...three seconds later..."

-- null never publishes anything
| David("Favorite number?") >> null
</pre>

<h2>Concurrency Idioms</h2>

<p>A timeout is expressed using a pull together with the built-in site
<tt>Rtimer</tt>:</p>
<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def David(x) = 
	Rtimer(Random(3000,7000)) >>
	"rutabaga"
</pre>
<pre class="orc">
-- If the answer is not received within 5
-- seconds, use the default answer "timed out"
cat("Answer: ", answer)

  &lt;answer&lt;
  
      David("What is your favorite food?")
    | Rtimer(5000) >> "timed out"
</pre>

<p>The above example is randomized, so try running it several times to see
different results.</p>

<p>The opposite of a timeout is a delay: forcing a site to <i>wait</i> before
publishing its response:</p>
<pre class="orc-prelude">
def David(x) = 
	Rtimer(2500) >>
	println("(David says 'grue')") >>
	"grue"
</pre>
<pre class="orc">
-- Print the answer after 5 seconds or
-- when it is received, whichever is later.
Rtimer(5000) >> u

  &lt;u&lt;

    David("Pick a color: ")
</pre>

<p>A delay can be used to give one expression a higher priority:</p>

<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def Adrian(x) = 
	Rtimer(Random(3000,7000)) >>
	println("(Adrian says 'HIGH')") >>
	"HIGH"
def David(x) = 
	Rtimer(3000) >>
	println("(David says 'LOW')") >>
	"LOW"
</pre>
<pre class="orc">
-- If Adrian responds within 5 seconds, use his
-- answer, otherwise use whoever responds first.
z

  &lt;z&lt;

    ( high

      &lt;high&lt;   Adrian("High priority response: ")
             | Rtimer(5000) >> low
            
      &lt;low&lt; David("Low priority response: ") )
</pre>

<p>Fork/join begins two processes in parallel and wait for both to complete:</p>
<pre class="orc-prelude">
def Adrian(x) = 
	Rtimer(1000) >>
	println("(Adrian says 'Hydrogen')") >>
	"Hydrogen"
def David(x) = 
	Rtimer(3000) >>
	println("(David says 'Helium')") >>
	"Helium"
null; -- to force a new expression
</pre>
<pre class="orc">
-- Publish both Adrian and David's responses only
-- when both have been received.
(a,d)

  &lt;a&lt; Adrian("First element: ")
  &lt;d&lt; David("Second element: ")
</pre>

<p>"Parallel Or" is a more complex example. By analogy to a traditional
short-circuiting sequential "or" operation, we want to return <tt>true</tt> as
soon as any expression evaluates to <tt>true</tt>, and <tt>false</tt> if all
expressions evaluate to <tt>false</tt>:</p>
<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def Adrian(x) = 
	Rtimer(Random(1000,5000)) >>
	println("(Adrian says 'true')") >>
	true
def David(x) = 
	Rtimer(3000) >>
	println("(David says 'false')") >>
	false
</pre>
<pre class="orc">
z &lt;z&lt; (   if(x) >> true
        | if(y) >> true
        | (x || y)

            &lt;x&lt; David("True or false?")
            &lt;y&lt; Adrian("True or false?") )
</pre>

<h2>Functions</h2>

<p>To facilitate the construction of large programs, Orc allows users to define
named functions. Functions are called like sites, but unlike sites, they do
not need to block if one of their arguments is not available when they are
called, and they can publish multiple values.</p>

<p>Here is a simple recursive function which publishes a number every second:</p>
<pre class="orc">
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

Metronome(0)
</pre>

<p>Function publications can be interleaved with the parallel combinator:</p>
<pre class="orc">
def Metronome(t, i) =
    i
  | Rtimer(t) >> Metronome(t, i+1)

Metronome(1100, 0) | Metronome(700, 100)
</pre>

<p>A common idiom in Orc is to treat an expression as a stream of values which
may be filtered:</p>

<pre class="orc-prelude">
def isPrime(n) = 
  def primeat(i) = 
      if(b) >> (n % i /= 0) && primeat(i+1)
    | if(~b) >> true
        &lt;b&lt; i * i <= n
  primeat(2)
</pre>
<pre class="orc">
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

-- Publish only prime numbers
Metronome(2) >n> if(isPrime(n)) >> n
</pre>

<p>Like any good functional programming language, Orc supports higher-order
functions (functions which take functions or sites as arguments), lists and
tuples as basic datatypes, and pattern matching. The following example
illustrates both:</p>
<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def Adrian(x) = 
	Rtimer(Random(3000,7000)) >>
	println("(Adrian says '13')") >>
	13
def David(x) = 
	Rtimer(3000) >>
	println("(David says '10')") >>
	10
</pre>
<pre class="orc">
-- Query a site for a number, and default to 0
-- if it does not respond within 5 seconds
def timeout(M) = n
    &lt;n&lt; M("Pick a number:") | Rtimer(5000) >> 0

-- Add up the responses from a list of sites
-- in parallel
def tally([]) = 0
def tally(x:xs) = timeout(x) + tally(xs)

-- Ask David and Adrian for numbers
tally([David, Adrian])
</pre>

<p>Datatype constructors and patterns are just syntactic sugar for sequential
site calls which you could write yourself, but they are still very useful.</p>

<h2>Airline Quotes</h2>

<p>We are now equipped to solve an interesting wide-area computing problem in Orc:</p>

<p>A client contacts two airlines simultaneously for price quotes.  He buys a
ticket from either airline if its quoted price is no more than $300, the
cheapest ticket if both quotes are above $300, and any ticket if the other
airline does not provide a timely quote. The client should receive an
indication if neither airline provides a timely quote.</p>

<p>We will assume that the airlines provide the sites <tt>Delta</tt> and
<tt>United</tt> which return a dollar value quote. Getting quotes from
both airlines is a case of the "fork/join" idiom:</p>
<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def Airline(name) = 
	Rtimer(Random(1000,5000)) >>
	Random(200, 400) >q>
	println(cat("(", name, " quotes ", q, ")")) >>
	q
def Delta() = Airline("Delta")
def United() = Airline("United")

null; -- to force a new expression
</pre>
<pre class="orc">
(u,d)
  &lt;d&lt; Delta()
  &lt;u&lt; United()
</pre>

<p>The "first under $300" rules are a case of the "parallel or" idiom:</p>
<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def Airline(name) = 
	Rtimer(Random(1000,5000)) >>
	Random(200, 400) >q>
	println(cat("(", name, " quotes ", q, ")")) >>
	q
def Delta() = Airline("Delta")
def United() = Airline("United")
</pre>
<pre class="orc">
-- Utility function: return y1 (or y2)
-- if x1 (or x2) is smaller
def min(x1,y1,x2,y2) =
    if(x1&lt;:x2) >> y1
  | if(x2&lt;:x1) >> y2

airline

  &lt;airline&lt; (
  
      if(d&lt;:300) >> "Delta"
    | if(u&lt;:300) >> "United"
    | min(d,"Delta",u,"United")
  
      &lt;d&lt; Delta()
      &lt;u&lt; United()
  )
</pre>

<p>(Run the above example several times to see different results.)</p>

<p>Now all we need to do is introduce timeouts to handle untimely quotes.
We'll represent an untimely quote as an empty list and use pattern matching
to easily distinguish timely and untimely quotes.</p>
<pre class="orc-prelude">
def Random(i,j) = random(j - i) + i + 1
def Airline(name) = 
	Rtimer(Random(1000,5000)) >>
	Random(200, 400) >q>
	println(cat("(", name, " quotes ", q, ")")) >>
	q
def Delta() = Airline("Delta")
def United() = Airline("United")
</pre>
<pre class="orc">
def min(x1,y1,x2,y2) =
    if(x1&lt;:x2) >> y1
  | if(x2&lt;:x1) >> y2

airline

  &lt;airline&lt; (

      dd >[d]> if(d&lt;:300) >> "Delta"
    | uu >[u]> if(u&lt;:300) >> "United"
    | dd >[d]> uu >[u]> min(d,"Delta",u,"United") 
    | dd >[d]> uu >[]> "Delta"
    | dd >[]> uu >[u]> "United"
    | dd >[]> uu >[]> "Timed out!"
  
      &lt;dd&lt; [Delta()] | Rtimer(3000) >> []
      &lt;uu&lt; [United()] | Rtimer(3000) >> []
  )
</pre>

<h2>Further Study</h2>

<p>Now you are ready to <a href="/orchard">play with Orc</a> yourself.</p>
<p>Please refer to the <a href="documentation.shtml">Documentation</a> page for further guidance.</p>

<!--#include virtual="footer.shtml" --> 
