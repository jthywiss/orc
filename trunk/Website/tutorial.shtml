<!--#include virtual="header.shtml" --> 

<link rel="stylesheet" type="text/css" href="/orchard/orc.css" media="screen"/>
<script src="/orchard/jquery-1.2.6.min.js" type="text/javascript"></script>
<script src="/orchard/orc.js" type="text/javascript"></script>

<a name="top"></a><h1>Orc in 15 Minutes</h1>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Sites">Sites</a></li>
<li><a href="#Combinators">Combinators</a>
	<ul>
	<li><a href="#Parallel_Combinator">Parallel Combinator</a></li>
	<li><a href="#Sequential_Combinator">Sequential Combinator</a></li>
	<li><a href="#Asymmetric_Combinator">Asymmetric Combinator</a></li>
	</ul>
<li><a href="#Functions">Functions</a>
<li><a href="#Conclusion">Conclusion</a>
</li>
</ul>

<a name="Introduction"></a><h2>Introduction <small>(<a href="#top">top</a>)</small></h2>

<p>This tutorial is interactive: when you see a code example with a <b>run</b>
button, click it to run the program. The results of the program (the values it
"publishes") will be printed below. For some examples, you may also see extra
trace information printed (in parentheses like this) to help you understand
what the program is doing.</p>

<a name="Sites"></a><h2>Sites <small>(<a href="#top">top</a>)</small></h2>
<p>The fundamental unit of computation in an Orc program is called a
<i>site</i>.  Sites are similar to functions in other languages,
but they may be distributed and are therefore unreliable. A site can implement
a complex distributed operation, like interacting with a user ...</p>
<pre class="orc">
Prompt("What is your favorite food?")
</pre>

<p>... or a very simple local operation, like adding two numbers:</p>
<pre class="orc">
1 + 2
</pre>

<p>Although Orc supports standard infix notation for sites which implement
arithmetic and comparison operators, these are still considered sites like any
other.</p>

<p>This tutorial will make frequent use of the <tt>Prompt</tt> site, which
prompts you to enter something and returns your response. For some examples we
will also use a site called <tt>David</tt>, which you should think of as
prompting David and returning his response.</p>

<a name="Combinators"><h2>Combinators <small>(<a href="#top">top</a>)</small></h2>
<p>Orc has three basic combinators which are used to build concurrent expressions:</p>
<ul>
<li>Parallel, or bar, written <tt>|</tt></li>
<li>Sequential, or push, written <tt>>></tt></li>
<li>Asymmetric, or pull, written <tt>&lt;&lt;</tt></li>
</ul>
<p>We will examine each in turn.</p>

<a name="Parallel_Combinator"><h3>Parallel Combinator <small>(<a href="#top">top</a>)</small></h3>

<p>Two Orc expressions can be evaluated in parallel using <tt>|</tt></p>

<pre class="orc-prelude">
def David(x) = Rtimer(3000) >>
	println("(David says 'Breakfast tacos')") >>
	"Breakfast tacos"
</pre>
<pre class="orc">
  David("What is your favorite food?")
| Prompt("What is your favorite food?")
</pre>

<p>In the above example, <tt>David</tt> and <tt>Prompt</tt> are invoked
simultaneously, and <i>both</i> responses are published. Note that Orc is
unlike most functional programming languages in that an expression may publish
(return) more than one value if it involves more than one concurrent
computation.</p>

<a name="Sequential_Combinator"><h3>Sequential Combinator <small>(<a href="#top">top</a>)</small></h3>

<p>Sites can also be called in sequence. The <tt>>></tt> combinator evaluates
its right side as soon as the left side returns a value:</p>

<pre class="orc">
Prompt("What is your name?")

  >>
 
Prompt("What is your favorite color?")
</pre>

<p>Notice that your first response was not published. <tt>>></tt> only
publishes the value(s) published by the right side.  If you want to use a value
published by the left side, you can bind it to a variable, like this:</p>

<pre class="orc">
Prompt("What is your name?")

  >name>
 
"Hello " + name
</pre>

<p>If the left side publishes more than one value, the right side is evaluated
independently for <i>each</i> value:</p>

<pre class="orc-prelude">
def David(x) = Rtimer(5000) >>
	println("(David says 'Pan's Labyrinth')") >>
	"Pan's Labyrinth"
</pre>
<pre class="orc">
(   David("Pick a movie you like:")
  | Prompt("Pick a movie you like:") )

  >movie>
 
"I heard that " + movie + " is a good movie."
</pre>

<a name="Asymmetric_Combinator"><h3>Asymmetric Combinator <small>(<a href="#top">top</a>)</small></h3>

<p>The final combinator, <tt>&lt;&lt;</tt>, combines the concepts of selection,
blocking, and termination. It is used to select the first value published by an
expression and then terminate that expression. In the next example, both you
and David will be asked to enter your names, and the first name entered will be
published while the other is ignored.</p>

<pre class="orc-prelude">
def David(x) = 
	Rtimer(5000) >>
	"David"
</pre>
<pre class="orc">
name + " wins."

  &lt;name&lt;

	David("What's your name?")
      | Prompt("What's your name?")  
</pre>

<p>Both sides of the asymmetric combinator begin evaluating immediately, but
when the left side needs the value produced by the right side, it blocks until
that value is available. The next example will print "red" and "blue"
immediately but must wait to print your color until you enter it:</p>

<pre class="orc">
"red" | "light " + color | "blue"

  &lt;color&lt;

    Prompt("Choose a color.")  
</pre>

<p>Site calls with expressions as arguments are just syntactic sugar for
asymmetric composition. For example, these two expressions are equivalent:</p>

<pre class="orc">
  "3+4=" + (3 + 4)
| ( "3+4=" + a &lt;a&lt; 3 + 4 )
</pre>

<a name="Fundamental_Sites"><h2>Fundamental Sites <small>(<a href="#top">top</a>)</small></h2>

<p>Orc provides some fundamental sites which are necessary for writing
useful expressions. The following examples illustrate the most basic ones.</p>

<p><tt>if(condition)</tt> publishes only if <tt>condition</tt> is true:</p>
<pre class="orc">
  if(3 /= 4) >> "three does not equal four"
| if(false) >> "impossible!"
</pre>

<p><tt>Rtimer(t)</tt> publishes after <tt>t</tt> milliseconds:</p>
<pre class="orc">
  "immediately"
| Rtimer(3000) >> "...three seconds later..."
| Rtimer(5000) >> "...five seconds later..."
</pre>

<p><tt>null</tt> is a special value which never publishes (similar to "bottom" or <tt>_|_</tt> in functional languages).
It is commonly used with sequential composition to suppress published values:</p>
<pre class="orc">
Prompt("I'm not listening...") >> null
</pre>

<a name="Functions"><h2>Functions <small>(<a href="#top">top</a>)</small></h2>

<p>To facilitate the construction of large programs, Orc allows users to define
functions.  Functions are called like sites, but unlike sites, they do not need
to block if one of their arguments is not available when they are called, and
they can publish multiple values.</p>

<p>Here is a simple recursive function which publishes a number every second:</p>
<pre class="orc">
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

Metronome(0)
</pre>

<p>Function publications can be interleaved with the parallel combinator:</p>
<pre class="orc">
def Metronome(t, i) =
    i
  | Rtimer(t) >> Metronome(t, i+1)

Metronome(1100, 0) | Metronome(700, 100)
</pre>

<p>A common idiom in Orc is to treat an expression as a stream of values which
may be filtered:</p>

<pre class="orc-prelude">
def isPrime(n) = 
  def primeat(i) = 
      if(b) >> (n % i /= 0) && primeat(i+1)
    | if(~b) >> true
        &lt;b&lt; i * i &lt;= n
  primeat(2)
</pre>
<pre class="orc">
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

-- Publish only prime numbers
Metronome(2) >n> if(isPrime(n)) >> n
</pre>

<p>Like any good functional programming language, Orc supports higher-order
functions (functions which take functions or sites as arguments), lists and
tuples as basic datatypes, and pattern matching. Like infix operators, datatype
constructors and patterns are just syntactic sugar for sequential site calls.</p>

<p>The next example illustrates these features in a program that adds up all
the responses received from a list of sites within 5 seconds.</p>
<pre class="orc-prelude">
def David(x) = 
	Rtimer(3000) >>
	println("(David says '10')") >>
	10
def PromptNumber(x) = Prompt(x) >n> parseInt(n)
</pre>
<pre class="orc">
-- Query a site for a number, and default to 0
-- if it does not respond within 5 seconds
def timeout(M) = n
    &lt;n&lt; M("Pick a number:") | Rtimer(5000) >> 0

-- Add up the responses from a list of sites
-- in parallel
def tally([]) = 0
def tally(x:xs) = timeout(x) + tally(xs)

-- Ask two sites for numbers
tally([David, PromptNumber])
</pre>

<p></p>

<a name="Conclusion"><h2>Conclusion <small>(<a href="#top">top</a>)</small></h2>

<p>That concludes this Orc tutorial. Please refer to the <a
href="documentation.shtml">Documentation</a> page for further
guidance.  When you are ready, <a href="/orchard">play with Orc</a>
yourself.</p>

<!--#include virtual="footer.shtml" --> 
