<!--#include virtual="header.shtml" --> 

<h1>Tutorial</h1>

<h2>Sites</h2>
<p>The fundamental unit of computation in an Orc program is called a
<i>site</i>.  Sites are similar to procedures or functions in other languages,
but they may be distributed and are therefore unreliable. A site can implement
a very simple operation, like adding two numbers...</p>
<pre>
1 + 2
</pre>
<p>... or a very complex operation, like conversing with a person via an
instant message or email:</p>
<pre>
David("What is your favorite food?")
</pre>

<p>For the rest of these samples, we will use <tt>David</tt> and
<tt>Adrian</tt> as examples of sites which query a person and return their
response.</p>

<h2>Combinators</h2>
<p>Two Orc expressions can be evaluated in parallel using the <tt>|</tt>
(symmetric, parallel, or bar) combinator:</p>

<pre>
  David("What is your favorite food?")
| Adrian("What is your favorite color?")
</pre>

<p>In the above example, <tt>David</tt> and <tt>Adrian</tt> are invoked
simultaneously, and <i>both</i> responses are returned. Note that Orc is unlike
most functional programming languages in that expressions may return more than
one value if they involve more than one concurrent computation.</p>

<p>Sites can also be called in sequence. The <tt>>></tt> (sequencing, or push)
combinator evaluates its right side as soon as the left side returns a
value:</p>

<pre>
David("I'm about to ask Adrian about the weather.")

  >>
 
-- Will run as soon as David responds
Adrian("How is the weather?")
</pre>

<p>Push allows you to bind a value produced by its left side and use it in the
right side:</p>

<pre>
David("How is the weather?")

  >weather>
 
print("The weather in Austin is ", weather)
</pre>

<p>The right side is evaluated independently for <i>every</i> value published
by the left side:</p>

<pre>
(   David("Pick a movie you like:")
  | Adrian("Pick a movie you like:") )

  >movie>
 
-- Will print for every response received
print("I heard that ", movie, " is a good movie.")
</pre>

<p>The final combinator, <tt>&lt;&lt;</tt> (asymmetric, pull, or where),
combines the concepts of selection, blocking, and termination. It is used to
select the first value published by an expression and then terminate that
expression.</p>

<pre>
-- Only one response will be printed.
print(color, " wins.")

  &lt;color&lt;

        David("Choose a color.")
      | Adrian("Choose a color.")  
</pre>

<p>Both sides of a pull begin evaluating immediately. When the left-hand side
needs the value produced by the right-hand side, it blocks until that value is
available.</p>

<pre>
-- "red" and "blue" are printed immediately
print("red") | print(color) | print("blue")

  &lt;color&lt;

    David("Choose a color.")  
</pre>

<h2>Fundamental Sites</h2>

<p>Orc provides some fundamental sites which are necessary for writing
useful expressions:</p>

<pre>
-- if publishes a value if the condition is true
  if(3 /= 4) >> "three does not equal four"
-- and does not publish if it is false
| if(false) >> "impossible!"

-- Rtimer waits for some number of milliseconds
-- before publishing a value.
| Rtimer(3000) >> "...three seconds later..."

-- null never publishes anything
| David("Favorite number?") >> null
</pre>

<h2>Concurrency Idioms</h2>

<p>A timeout is expressed using a pull together with the built-in site
<tt>Rtimer</tt>:</p>
<pre>
-- If the answer is not received within 8 seconds,
-- use the default answer "timed out"
print("Answer: ", answer)

  &lt;answer&lt;
  
      David("What is your favorite food?")
    | Rtimer(8000) >> "timed out"
</pre>

<p>The opposite of a timeout is a delay: forcing a site to <i>wait</i> before
publishing its response:</p>
<pre>
-- Print the answer after 10 seconds or
-- when it is received, whichever is later.
Rtimer(10000) >> print(u)

  &lt;u&lt;

    David("Pick a color: ")
</pre>

<p>A delay can be used to give one expression a higher priority:</p>

<pre>
-- If Adrian responds within 10 seconds, use his
-- answer, otherwise use whoever responds first.
z

  &lt;z&lt;

    ( high

        &lt;high&lt;   Adrian("High priority response: ")
               | Rtimer(10000) >> low
            
        &lt;low&lt; David("Low priority response: ") )
</pre>

<p>A fork/join begins two processes in parallel and wait for both to complete:</p>
<pre>
-- Publish both Adrian and David's responses only
-- when both have been received.
(a,d)

  &lt;a&lt; Adrian("First element: ")
  &lt;d&lt; David("Second element: ")
</pre>

<p>"Parallel Or" is a more complex example. By analogy to a traditional
short-circuiting sequential "or" operation, we want to return <tt>true</tt> as
soon as any expression evaluates to <tt>true</tt>, and <tt>false</tt> if all
expressions evaluate to <tt>false</tt>:</p>
<pre>
z &lt;z&lt; (   if(x) >> true
	| if(y) >> true
	| (x,y) >> false

            &lt;x&lt; David("True or false?")
            &lt;y&lt; Adrian("True or false?") )
</pre>

<h2>Functions</h2>

<p>To facilitate the construction of large programs, Orc allows users to define
named functions. Functions are called like sites, but unlike sites, they do
not need to block if one of their arguments is not available when they are
called, and they can publish multiple values.</p>

<p>Here is a simple recursive function which publishes a number every second:</p>
<pre>
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

Metronome(0)
</pre>

<p>A common idiom in Orc is to treat an expression as a stream of values which
may be filtered:</p>

<pre>
-- Publish only prime numbers
Metronome(2) >n> if(isPrime(n)) >> n
</pre>

<p>Like any good functional programming language, Orc supports higher-order
functions (functions which take functions or sites as arguments), lists and
tuples as basic datatypes, and pattern matching. The following example
illustrates both:</p>
<pre>
-- Query a site for a number, and default to 0
-- if it does not respond within 10 seconds
def timeout(M) = n
    &lt;n&lt; M("Pick a number:") | Rtimer(10000) >> 0

-- Add up the responses from a list of sites
-- in parallel
def tally([]) = 0
def tally(first:rest) = timeout(first) + tally(rest)

-- Ask David and Adrian for numbers
tally([David, Adrian])
</pre>

<p>Datatype constructors and patterns are just syntactic sugar for sequential
site calls which you could write yourself, but they are still very useful.</p>

<h2>Airline Quotes</h2>

<p>We are now equipped to solve an interesting wide-area computing problem in Orc:</p>

<p>A client contacts two airlines simultaneously for price quotes.  He buys a
ticket from either airline if its quoted price is no more than $300, the
cheapest ticket if both quotes are above $300, and any ticket if the other
airline does not provide a timely quote. The client should receive an
indication if neither airline provides a timely quote.</p>

<p>We will assume that the airlines provide the sites <tt>Delta</tt> and
<tt>United</tt> which return a dollar value quote. Getting quotes from
both airlines is a case of the "fork/join" idiom:</p>
<pre>
(u,d)
  &lt;d&lt; Delta()
  &lt;u&lt; United()
</pre>

<p>The "first under $300" rules are a case of the "parallel or" idiom:</p>
<pre>
-- Utility function: return y1 (or y2)
-- if x1 (or x2) is smaller
def min(x1,y1,x2,y2) =
    if(x1&lt;:x2) >> y1
  | if(x2&lt;:x1) >> y2

airline

  &lt;airline&lt;
  
      if(d&lt;:300) >> "Delta"
    | if(u&lt;:300) >> "United"
    | min(d,"Delta",u,"United")
  
      &lt;d&lt; Delta()
      &lt;u&lt; United()
</pre>

<p>Now all we need to do is introduce timeouts to handle untimely quotes.
We'll represent an untimely quote as an empty list and use pattern matching
to easily distinguish timely and untimely quotes.</p>
<pre>
def min(x1,y1,x2,y2) =
    if(x1&lt;:x2) >> y1
  | if(x2&lt;:x1) >> y2

airline

  &lt;airline&lt;

      dd >[d]> if(u&lt;:300) >> "Delta"
    | uu >[d]> if(u&lt;:300) >> "United"
    | dd >[d]> uu >[u]> min(d,"Delta",u,"United") 
    | dd >[]> uu >[]> "Timed out!"
  
      &lt;dd&lt; [Delta()] | Rtimer(timely) >> []
      &lt;uu&lt; [United()] | Rtimer(timely) >> []
</pre>

<h2>Further Study</h2>

<p>For further help with Orc, please refere to the <a href="documentation.shtml">Documentation</a> page.</p>

<!--#include virtual="footer.shtml" --> 
