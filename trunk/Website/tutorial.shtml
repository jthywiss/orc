<!--#include virtual="header.shtml" --> 

<link rel="stylesheet" type="text/css" href="/orchard/orc.css" media="screen"/>
<script src="/orchard/jquery-1.2.6.min.js" type="text/javascript"></script>
<script src="/orchard/orc.js" type="text/javascript"></script>

<a name="top"></a><h1>Orc in 15 Minutes</h1>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Sites">Sites</a></li>
<li><a href="#Combinators">Combinators</a>
	<ul>
	<li><a href="#Parallel_Combinator">Parallel Combinator</a></li>
	<li><a href="#Sequential_Combinator">Sequential Combinator</a></li>
	<li><a href="#Asymmetric_Combinator">Asymmetric Combinator</a></li>
	</ul>
<li><a href="#Functions">Functions</a>
<li><a href="#Conclusion">Conclusion</a>
</li>
</ul>

<a name="Introduction"></a><h2>Introduction <small>(<a href="#top">top</a>)</small></h2>

<p>This tutorial is interactive: when you see a code example with a <b>run</b>
button, click it to run the program. The results of the program (the values it
"publishes") will be printed below.</p>

<a name="Sites"></a><h2>Sites <small>(<a href="#top">top</a>)</small></h2>
<p>The fundamental unit of computation in an Orc program is called a
<i>site</i>.  Sites are similar to functions in other languages,
but they may be distributed and are therefore unreliable. A site can implement
a complex distributed operation, like interacting with a user ...</p>
<pre class="orc">
Prompt("What is your favorite food?")
</pre>

<p>... or a very simple local operation, like adding two numbers:</p>
<pre class="orc">
1 + 2
</pre>

<p>Although Orc supports standard infix notation for sites which implement
arithmetic and comparison operators, these are still considered sites like any
other.</p>

<p>This tutorial will make frequent use of the <tt>Prompt</tt> site, which
prompts you to enter something and returns your response.</p>

<a name="Combinators"><h2>Combinators <small>(<a href="#top">top</a>)</small></h2>
<p>Orc has three basic combinators which are used to build concurrent expressions:</p>
<ul>
<li>Parallel, or bar, written <tt>|</tt></li>
<li>Sequential, or push, written <tt>>></tt></li>
<li>Asymmetric, or pull, written <tt>&lt;&lt;</tt></li>
</ul>
<p>We will examine each in turn.</p>

<a name="Parallel_Combinator"><h3>Parallel Combinator <small>(<a href="#top">top</a>)</small></h3>

<p>Two Orc expressions can be evaluated in parallel using <tt>|</tt></p>

<pre class="orc">
  Prompt("What is your favorite food?")
| Prompt("What is your favorite color?")
</pre>

<p>In the above example, two <tt>Prompt</tt>s are invoked simultaneously, and
<i>both</i> responses are published. Note that Orc is unlike most functional
programming languages in that an expression may publish (return) more than one
value if it involves more than one concurrent computation.</p>

<a name="Sequential_Combinator"><h3>Sequential Combinator <small>(<a href="#top">top</a>)</small></h3>

<p>Sites can also be called in sequence. The <tt>>></tt> combinator evaluates
its right side as soon as the left side returns a value:</p>

<pre class="orc">
Prompt("What is your name?")

  >>
 
Prompt("What is your favorite color?")
</pre>

<p>Notice that your first response was not published. <tt>>></tt> only
publishes the value(s) published by the right side.  If you want to use a value
published by the left side, you can bind it to a variable, like this:</p>

<pre class="orc">
Prompt("What is your name?")

  >name>
 
"Hello " + name
</pre>

<p>If the left side publishes more than one value, the right side is evaluated
independently for <i>each</i> value:</p>

<pre class="orc">
(   Prompt("Pick a movie you like:")
  | Prompt("Pick a movie you like:") )

  >movie>
 
"I heard that " + movie + " is a good movie."
</pre>

<a name="Asymmetric_Combinator"><h3>Asymmetric Combinator <small>(<a href="#top">top</a>)</small></h3>

<p>The final combinator, <tt>&lt;&lt;</tt>, combines the concepts of selection,
blocking, and termination. It is used to select the first value published by an
expression and then terminate that expression. In the next example, you will be
asked two questions and only your first answer will be published.</p>

<pre class="orc">
name

  &lt;name&lt;

        Prompt("What's your name?")
      | Prompt("What's your favorite color?")  
</pre>

<p>Both sides of the asymmetric combinator begin evaluating immediately, but
when the left side needs the value produced by the right side, it blocks until
that value is available. The next example will print "red" and "blue"
immediately but must wait to print your color until you enter it:</p>

<pre class="orc">
"red" | "light " + color | "blue"

  &lt;color&lt;

    Prompt("Choose a color.")  
</pre>

<p>The &lt;&lt; syntax can sometimes be cumbersome, so Orc supports an
alternative form that allows you to write the previous example like this
instead:</p>

<pre class="orc">
val color = Prompt("Choose a color.")  
"red" | "light " + color | "blue"
</pre>

<p>Furthermore, site calls with expressions as arguments are just syntactic
sugar for asymmetric composition. For example, these two expressions are
equivalent:</p>

<pre class="orc">
  "3+4=" + (3 + 4)
| ( "3+4=" + a ) &lt;a&lt; ( 3 + 4 )
</pre>

<p></p>

<a name="Fundamental_Sites"><h2>Fundamental Sites <small>(<a href="#top">top</a>)</small></h2>

<p>Orc provides some fundamental sites which are necessary for writing
useful expressions. The following examples illustrate the most basic ones.</p>

<p><tt>if(condition)</tt> publishes only if <tt>condition</tt> is true:</p>
<pre class="orc">
  if(3 /= 4) >> "three does not equal four"
| if(false) >> "impossible!"
</pre>

<p><tt>Rtimer(t)</tt> publishes after <tt>t</tt> milliseconds:</p>
<pre class="orc">
  "immediately"
| Rtimer(3000) >> "...three seconds later..."
| Rtimer(5000) >> "...five seconds later..."
</pre>

<p><tt>null</tt> is a special value which never publishes (similar to "bottom" or <tt>_|_</tt> in functional languages).
It is commonly used with sequential composition to suppress published values:</p>
<pre class="orc">
Prompt("I'm not listening...") >> null
</pre>

<a name="Functions"><h2>Functions <small>(<a href="#top">top</a>)</small></h2>

<p>To facilitate the construction of large programs, Orc allows users to define
functions.  Functions are called like sites, but unlike sites, they do not need
to block if one of their arguments is not available when they are called, and
they can publish multiple values.</p>

<p>Here is a simple recursive function which publishes a number every second:</p>
<pre class="orc">
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

Metronome(0)
</pre>

<p>Function publications can be interleaved with the parallel combinator:</p>
<pre class="orc">
def Metronome(t, i) =
    i
  | Rtimer(t) >> Metronome(t, i+1)

Metronome(1100, 0) | Metronome(700, 100)
</pre>

<p>A common idiom in Orc is to treat an expression as a stream of values which
may be filtered:</p>

<pre class="orc-prelude">
def isPrime(n) = 
  def primeat(i) = 
      if(b) >> (n % i /= 0) && primeat(i+1)
    | if(~b) >> true
        &lt;b&lt; i * i &lt;= n
  primeat(2)
</pre>
<pre class="orc">
def Metronome(i) =
    i
  | Rtimer(1000) >> Metronome(i+1)

-- Publish only prime numbers
Metronome(2) >n> if(isPrime(n)) >> n
</pre>

<p>Like any good functional programming language, Orc supports nested
functions, higher-order functions (functions which take functions or sites as
arguments) and pattern matching. Datatype constructors and deconstructors for
patterns are just syntactic sugar for site calls.</p>

<p>The next example makes use of these features to simulate a simple booking
agent: it gets quotes from a list of airlines, and returns the best quote under
$200 received within 5 seconds.</p>
<pre class="orc">
-- Build a simulated airline quote site
def Airline(name) =
    def MakeQuote() =
        Prompt(name + " quote ($)") >n>
        (name, parseInt(n))
    MakeQuote

-- Return the lesser of two quotes
def min((n1,q1), (n2,q2)) =
    if(q1 <: q2) >> (n1, q1)
  | if(q2 <= q1) >> (n2, q2)

-- Return the best quote under 200 dollars
-- within 5 seconds
def bestQuote([]) = ("None of the above", 200)
def bestQuote(airline:rest) =
    val best = bestQuote(rest)
    val current = airline() | Rtimer(5000) >> best
    min(current, best)

bestQuote([Airline("Delta"),
           Airline("United")])
</pre>

<p></p>

<a name="Conclusion"><h2>Conclusion <small>(<a href="#top">top</a>)</small></h2>

<p>That concludes this Orc tutorial. Please refer to the <a
href="documentation.shtml">Documentation</a> page for further
guidance.  When you are ready, <a href="/orchard">play with Orc</a>
yourself.</p>

<!--#include virtual="footer.shtml" --> 
