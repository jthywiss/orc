<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2.3.&nbsp;Larger Examples</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide v"><link rel="up" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Programming Methodology"><link rel="prev" href="ch02s02.html" title="2.2.&nbsp;Programming Idioms"><link rel="next" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">2.3.&nbsp;Larger Examples</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch02s02.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;2.&nbsp;Programming Methodology</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch03.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N110E4"></a>2.3.&nbsp;Larger Examples</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N110E7"></a>2.3.1.&nbsp;Dining Philosophers</h3></div></div></div><p>
The dining philosophers problem is a well known and intensely studied problem in
concurrent programming. For a detailed description, see 
<a class="ulink" href="" target="_top">the Wikipedia entry</a>
on the problem. Here, we present an Orc solution to the dining philosophers problem,
based on a probabilistic solution by Rabin.  
</p><pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">shuffle</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) = <span class="hl-keyword">if</span> (<span class="hl-site">random</span>(<span class="hl-literal">2</span>) = <span class="hl-literal">1</span>) <span class="hl-keyword">then</span> (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-keyword">else</span> (<span class="hl-variable">b</span>,<span class="hl-variable">a</span>)

<span class="hl-keyword">def</span> <span class="hl-site">take</span>((<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)) =    
  <span class="hl-variable">a</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">acquirenb</span>() <span class="hl-combinator">;</span>
  <span class="hl-variable">a</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">take</span>(<span class="hl-site">shuffle</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>))
    
<span class="hl-keyword">def</span> <span class="hl-site">drop</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) = (<span class="hl-variable">a</span>.<span class="hl-site">release</span>(), <span class="hl-variable">b</span>.<span class="hl-site">release</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>

<span class="hl-keyword">def</span> <span class="hl-site">phil</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>,<span class="hl-variable">name</span>) =
  <span class="hl-keyword">def</span> <span class="hl-site">thinking</span>() = 
    <span class="hl-keyword">if</span> (<span class="hl-site">urandom</span>() &lt; <span class="hl-literal">0.9</span>)
      <span class="hl-keyword">then</span> <span class="hl-site">Rtimer</span>(<span class="hl-site">random</span>(<span class="hl-literal">1000</span>))
      <span class="hl-keyword">else</span> <span class="hl-site">println</span>(<span class="hl-variable">name</span> + <span class="hl-literal">" is thinking forever."</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
  <span class="hl-keyword">def</span> <span class="hl-site">hungry</span>() = <span class="hl-site">take</span>((<span class="hl-variable">a</span>,<span class="hl-variable">b</span>))
  <span class="hl-keyword">def</span> <span class="hl-site">eating</span>() = 
    <span class="hl-site">println</span>(<span class="hl-variable">name</span> + <span class="hl-literal">" is eating."</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
    <span class="hl-site">Rtimer</span>(<span class="hl-site">random</span>(<span class="hl-literal">1000</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
    <span class="hl-site">println</span>(<span class="hl-variable">name</span> + <span class="hl-literal">" has finished eating."</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">drop</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)
  <span class="hl-site">thinking</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">hungry</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">eating</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">phil</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>,<span class="hl-variable">name</span>)

<span class="hl-keyword">def</span> <span class="hl-site">dining</span>(<span class="hl-variable">n</span>) =
  <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">2</span>) 
    <span class="hl-keyword">then</span> <span class="hl-site">println</span>(<span class="hl-literal">"Can't simulate fewer than two philosophers."</span>)
    <span class="hl-keyword">else</span> 
    ( 
      <span class="hl-keyword">val</span> <span class="hl-variable">forks</span> = <span class="hl-site">IArray</span>(<span class="hl-variable">n</span>, <span class="hl-keyword">lambda</span>(<span class="hl-variable">_</span>) = <span class="hl-site">Semaphore</span>(<span class="hl-literal">1</span>))
      <span class="hl-keyword">def</span> <span class="hl-site">phils</span>(<span class="hl-literal">0</span>) = <span class="hl-keyword">stop</span>
      <span class="hl-keyword">def</span> <span class="hl-site">phils</span>(<span class="hl-variable">i</span>) = <span class="hl-site">phil</span>(<span class="hl-site">forks</span>(<span class="hl-variable">i</span>%<span class="hl-variable">n</span>), <span class="hl-site">forks</span>(<span class="hl-variable">i</span>-<span class="hl-literal">1</span>), <span class="hl-literal">"Philosopher "</span> + <span class="hl-variable">i</span>) 
                   <span class="hl-combinator">|</span> <span class="hl-site">phils</span>(<span class="hl-variable">i</span>-<span class="hl-literal">1</span>)
      <span class="hl-site">phils</span>(<span class="hl-variable">n</span>) 
    )
<span class="hl-site">dining</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">;</span> <span class="hl-site">println</span>(<span class="hl-literal">"Done."</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
</pre><p>
The program calls <code class="code"><span class="hl-site">dining</span>(<span class="hl-literal">5</span>)</code> to simulate the dining philosophers
problem with size 5. It waits for the simulation to complete, then prints a message
and stops.
</p><p>
The <code class="code"><span class="hl-variable">dining</span></code> function takes the number <code class="code"><span class="hl-variable">n</span></code> of philosophers 
to simulate. It creates an array of <code class="code"><span class="hl-variable">n</span></code> binary semaphores to
represent the forks. Then, it starts <code class="code"><span class="hl-variable">n</span></code> philosopher processes in
parallel using the function <code class="code"><span class="hl-variable">phil</span></code>, giving each philosopher an
identifier, and references to its left and right forks. 
</p><p>
The <code class="code"><span class="hl-variable">phil</span></code> function describes the behavior of an individual philosopher.
It calls the <code class="code"><span class="hl-variable">thinking</span></code>, <code class="code"><span class="hl-variable">hungry</span></code>, and <code class="code"><span class="hl-variable">eating</span></code>
functions in a continuous loop. A <code class="code"><span class="hl-variable">thinking</span></code> philosopher waits for a random
amount of time, and also has a 10% chance of thinking forever. A <code class="code"><span class="hl-variable">hungry</span></code>
philosopher uses the <code class="code"><span class="hl-variable">take</span></code> function to acquire two forks. An <code class="code"><span class="hl-variable">eating</span></code>
philosopher waits for a random time interval and then uses the <code class="code"><span class="hl-variable">drop</span></code> function
to yield ownership of its forks. 
</p><p>
The <code class="code"><span class="hl-variable">take</span></code> and <code class="code"><span class="hl-variable">drop</span></code> functions are the key to the algorithm.
Calling <code class="code"><span class="hl-variable">take</span></code> attempts to acquire a pair of forks in two steps:
wait for one fork to become available, then immediately attempt to acquire the second
fork. If the second fork is acquired, signal success; otherwise, release the first
fork, and then try again, randomly changing the order in which the forks are
acquired using the <code class="code"><span class="hl-variable">shuffle</span></code> helper function. This reordering ensures
that the algorithm will probabilistically avoid livelock. The <code class="code"><span class="hl-variable">drop</span></code> function
simply releases both of the forks. 
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="methodology.examples.hygenic"></a>2.3.2.&nbsp;Hygienic Dining Philosophers</h3></div></div></div><p>
Here we implement a different solution to the Dining Philosophers problem,
described in "The Drinking Philosophers Problem", by K. M. Chandy and J. Misra.
Briefly, this algorithm efficiently and fairly solves the dining philosophers
problem for philosophers connected in an arbitrary graph (as opposed to a
simple ring).  The algorithm works by augmenting each fork with a clean/dirty
state.  Initially, all forks are dirty.  A philosopher is only obliged to
relinquish a fork to its neighbor if the fork is dirty. On receiving a fork,
the philosopher cleans it. On eating, the philosopher dirties all forks.  For
full details of the algorithm, consult the original paper.
</p><pre class="orc">
<span class="hl-comment">{-
Start a philosopher actor; never publishes.
Messages sent between philosophers include:
- ("fork", p): philosopher p relinquishes the fork
- ("request", p): philosopher p requests the fork
- ("rumble", p): sent by a philosopher to itself when it should
  become hungry

name: identify this process in status messages
mbox: our mailbox; the "address" of this philosopher is mbox.put
missing: set of neighboring philosophers holding our forks
-}</span>
<span class="hl-keyword">def</span> <span class="hl-site">philosopher</span>(<span class="hl-variable">name</span>, <span class="hl-variable">mbox</span>, <span class="hl-variable">missing</span>) =
  <span class="hl-comment">{- deferred requests for forks -}</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">deferred</span> = <span class="hl-site">Buffer</span>()
  <span class="hl-comment">{- forks we hold which are clean -}</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">clean</span> = <span class="hl-site">Set</span>()

  <span class="hl-keyword">def</span> <span class="hl-site">sendFork</span>(<span class="hl-variable">p</span>) =
    <span class="hl-comment">{- remember that we no longer hold the fork -}</span>
    <span class="hl-variable">missing</span>.<span class="hl-site">add</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">p</span>((<span class="hl-literal">"fork"</span>, <span class="hl-variable">mbox</span>.<span class="hl-variable">put</span>))
 
  <span class="hl-keyword">def</span> <span class="hl-site">requestFork</span>(<span class="hl-variable">p</span>) =
    <span class="hl-site">p</span>((<span class="hl-literal">"request"</span>, <span class="hl-variable">mbox</span>.<span class="hl-variable">put</span>))
  
  <span class="hl-comment">{- Start a timer which will tell us when we're hungry. -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">digesting</span>() =
      <span class="hl-site">println</span>(<span class="hl-variable">name</span> + <span class="hl-literal">" thinking"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-site">thinking</span>()
    <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-site">random</span>(<span class="hl-literal">1000</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-variable">mbox</span>.<span class="hl-site">put</span>((<span class="hl-literal">"rumble"</span>, <span class="hl-variable">mbox</span>.<span class="hl-variable">put</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-keyword">stop</span>

  <span class="hl-comment">{- Wait to become hungry -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">thinking</span>() =
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"rumble"</span>, <span class="hl-variable">_</span>)) =
      <span class="hl-site">println</span>(<span class="hl-variable">name</span> + <span class="hl-literal">" hungry"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-site">map</span>(<span class="hl-variable">requestFork</span>, <span class="hl-variable">missing</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-site">hungry</span>()
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"request"</span>, <span class="hl-variable">p</span>)) =
      <span class="hl-site">sendFork</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">thinking</span>()
    <span class="hl-site">on</span>(<span class="hl-variable">mbox</span>.<span class="hl-site">get</span>())

  <span class="hl-comment">{- Eat once we receive all forks -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">hungry</span>() =
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"fork"</span>, <span class="hl-variable">p</span>)) =
      <span class="hl-variable">missing</span>.<span class="hl-site">remove</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-variable">clean</span>.<span class="hl-site">add</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-keyword">if</span> <span class="hl-variable">missing</span>.<span class="hl-site">isEmpty</span>()
      <span class="hl-keyword">then</span> <span class="hl-site">println</span>(<span class="hl-variable">name</span> + <span class="hl-literal">" eating"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">eating</span>()
      <span class="hl-keyword">else</span> <span class="hl-site">hungry</span>()
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"request"</span>, <span class="hl-variable">p</span>)) =
      <span class="hl-keyword">if</span> <span class="hl-variable">clean</span>.<span class="hl-site">contains</span>(<span class="hl-variable">p</span>)
      <span class="hl-keyword">then</span> <span class="hl-variable">deferred</span>.<span class="hl-site">put</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">hungry</span>()
      <span class="hl-keyword">else</span> <span class="hl-site">sendFork</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">requestFork</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">hungry</span>()
    <span class="hl-site">on</span>(<span class="hl-variable">mbox</span>.<span class="hl-site">get</span>())

  <span class="hl-comment">{- Dirty forks, process deferred requests, then digest -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">eating</span>() =
    <span class="hl-variable">clean</span>.<span class="hl-site">clear</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">Rtimer</span>(<span class="hl-site">random</span>(<span class="hl-literal">1000</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">map</span>(<span class="hl-variable">sendFork</span>, <span class="hl-variable">deferred</span>.<span class="hl-site">getAll</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">digesting</span>()

  <span class="hl-comment">{- All philosophers start out digesting -}</span>
  <span class="hl-site">digesting</span>()

<span class="hl-comment">{-
Create an NxN 4-connected grid of philosophers.  Each philosopher
holds the fork for the connections below and to the right (so the
top left philosopher holds both its forks).
-}</span>
<span class="hl-keyword">def</span> <span class="hl-site">philosophers</span>(<span class="hl-variable">n</span>) =
  <span class="hl-comment">{- A set with 1 item -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">Set1</span>(<span class="hl-variable">item</span>) = <span class="hl-site">Set</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">add</span>(<span class="hl-variable">item</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>
  <span class="hl-comment">{- A set with 2 items -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">Set2</span>(<span class="hl-variable">i1</span>, <span class="hl-variable">i2</span>) = <span class="hl-site">Set</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">add</span>(<span class="hl-variable">i1</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">add</span>(<span class="hl-variable">i2</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>

  <span class="hl-comment">{- create an NxN matrix of mailboxes -}</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">cs</span> = <span class="hl-site">uncurry</span>(<span class="hl-site">IArray</span>(<span class="hl-variable">n</span>, <span class="hl-keyword">lambda</span> (<span class="hl-variable">_</span>) = <span class="hl-site">IArray</span>(<span class="hl-variable">n</span>, <span class="hl-site">ignore</span>(<span class="hl-variable">Buffer</span>))))

  <span class="hl-comment">{- create the first row of philosophers -}</span>
  <span class="hl-site">philosopher</span>((<span class="hl-literal">0</span>,<span class="hl-literal">0</span>), <span class="hl-site">cs</span>(<span class="hl-literal">0</span>,<span class="hl-literal">0</span>), <span class="hl-site">Set</span>())
  <span class="hl-combinator">|</span> <span class="hl-site">for</span>(<span class="hl-literal">1</span>, <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">j</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">philosopher</span>((<span class="hl-literal">0</span>,<span class="hl-variable">j</span>), <span class="hl-site">cs</span>(<span class="hl-literal">0</span>,<span class="hl-variable">j</span>), <span class="hl-site">Set1</span>(<span class="hl-site">cs</span>(<span class="hl-literal">0</span>,<span class="hl-variable">j</span>-<span class="hl-literal">1</span>).<span class="hl-variable">put</span>))

  <span class="hl-comment">{- create remaining rows -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">for</span>(<span class="hl-literal">1</span>, <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">i</span><span class="hl-combinator">&gt;</span> (
      <span class="hl-site">philosopher</span>((<span class="hl-variable">i</span>,<span class="hl-literal">0</span>), <span class="hl-site">cs</span>(<span class="hl-variable">i</span>,<span class="hl-literal">0</span>), <span class="hl-site">Set1</span>(<span class="hl-site">cs</span>(<span class="hl-variable">i</span>-<span class="hl-literal">1</span>,<span class="hl-literal">0</span>).<span class="hl-variable">put</span>))
      <span class="hl-combinator">|</span> <span class="hl-site">for</span>(<span class="hl-literal">1</span>, <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">j</span><span class="hl-combinator">&gt;</span>
        <span class="hl-site">philosopher</span>((<span class="hl-variable">i</span>,<span class="hl-variable">j</span>), <span class="hl-site">cs</span>(<span class="hl-variable">i</span>,<span class="hl-variable">j</span>), <span class="hl-site">Set2</span>(<span class="hl-site">cs</span>(<span class="hl-variable">i</span>-<span class="hl-literal">1</span>,<span class="hl-variable">j</span>).<span class="hl-variable">put</span>, <span class="hl-site">cs</span>(<span class="hl-variable">i</span>,<span class="hl-variable">j</span>-<span class="hl-literal">1</span>).<span class="hl-variable">put</span>))
    )

<span class="hl-comment">{- Simulate a 3x3 grid of philosophers for 10 seconds -}</span>
<span class="hl-site">let</span>(
  <span class="hl-site">philosophers</span>(<span class="hl-literal">3</span>)
  <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">10000</span>)
) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"HALTED"</span></pre><p>
Our implementation is based on the <a class="ulink" href="" target="_top">actor model</a> of
concurrency.  An actor is a state machine which reacts to messages.  On
receiving a message, an actor can send asynchronous messages to other actors,
change its state, or create new actors.  Each actor is single-threaded and
processes messages sequentially, which makes some concurrent programs easier to
reason about and avoids explicit locking. <a class="ulink" href="" target="_top">Erlang</a> is one popular language based
on the actor model.
</p><p>
Orc emulates the actor model very naturally.  In Orc, an actor is an Orc thread
of execution, together with a <code class="code"><span class="hl-variable">Buffer</span></code> which serves as a mailbox.  To send a
message to an actor, you place it in the actor's mailbox, and to receive a
message, the actor gets the next item from the mailbox.  The internal states of
the actor are represented by functions: while an actor's thread of execution is
evaluating a function, it is considered to be in the corresponding state.
Because Orc implements <a class="ulink" href="" target="_top">tail-call optimization</a>,
state transitions can be encoded as function calls without running out of stack
space.
</p><p>
In this program, a philosopher is implemented by an actor with three primary
states: <code class="code"><span class="hl-variable">eating</span></code>, <code class="code"><span class="hl-variable">thinking</span></code>, and <code class="code"><span class="hl-variable">hungry</span></code>.
An additional transient state, <code class="code"><span class="hl-variable">digesting</span></code>, is used to start a timer
which will trigger the state change from <code class="code"><span class="hl-variable">thinking</span></code> to
<code class="code"><span class="hl-variable">hungry</span></code>.  Each state is implemented by a function which reads a
message from the mailbox, selects the appropriate action using pattern
matching, performs the action, and finally transitions to the next state
(possibly the same as the current state) by calling the corresponding function.
</p><p>
Forks are never represented explicitly.  Instead each philosopher identifies a
fork with the "address" (sending end of a mailbox) of the neighbor who shares
the fork.  Every message sent includes the sender's address.  Therefore when a
philosopher receives a request for a fork, it knows who requested it and
therefore which fork to relinquish.  Likewise when a philosopher receives a
fork, it knows who sent it and therefore which fork was received.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11169"></a>2.3.3.&nbsp;Readers/Writers</h3></div></div></div><p>
Here we present an Orc solution to the <a class="ulink" href="" target="_top">readers-writers
problem</a>.  Briefly, the readers-writers problem involves concurrent
access to a mutable resource.  Multiple readers can access the resource
concurrently, but writers must have exclusive access.  When readers and writers
conflict, different solutions may resolve the conflict in favor of one or the
other, or fairly.  In the following solution, when a writer tries to acquire
the lock, current readers are allowed to finish but new readers are postponed
until after the writer finishes.  Lock requests are granted in the order
received, guaranteeing fairness.  Normally, such a service would be provided to
Orc programs by a site, but it is educational to see how it can be implemented
directly in Orc.
</p><pre class="orc">
<span class="hl-comment">-- Queue of lock requests</span>
<span class="hl-keyword">val</span> <span class="hl-variable">m</span> = <span class="hl-site">Buffer</span>()
<span class="hl-comment">-- Count of active readers/writers</span>
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> = <span class="hl-site">Counter</span>()

<span class="hl-comment">{-- Process requests in sequence --}</span>
<span class="hl-keyword">def</span> <span class="hl-site">process</span>() =
  <span class="hl-comment">-- Grant read request</span>
  <span class="hl-keyword">def</span> <span class="hl-site">grant</span>((<span class="hl-literal">false</span>,<span class="hl-variable">s</span>)) = <span class="hl-variable">c</span>.<span class="hl-site">inc</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">release</span>()
  <span class="hl-comment">-- Grant write request</span>
  <span class="hl-keyword">def</span> <span class="hl-site">grant</span>((<span class="hl-literal">true</span>,<span class="hl-variable">s</span>)) =
    <span class="hl-variable">c</span>.<span class="hl-site">onZero</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">inc</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">onZero</span>()
  <span class="hl-comment">-- Goal expression of process()</span>
  <span class="hl-variable">m</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">r</span><span class="hl-combinator">&gt;</span> <span class="hl-site">grant</span>(<span class="hl-variable">r</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">process</span>()

<span class="hl-comment">{-- Acquire the lock: argument is "true" if writing --}</span>
<span class="hl-keyword">def</span> <span class="hl-site">acquire</span>(<span class="hl-variable">write</span>) =
  <span class="hl-keyword">val</span> <span class="hl-variable">s</span> = <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>)
  <span class="hl-variable">m</span>.<span class="hl-site">put</span>((<span class="hl-variable">write</span>, <span class="hl-variable">s</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">acquire</span>()

<span class="hl-comment">{-- Release the lock --}</span>
<span class="hl-keyword">def</span> <span class="hl-site">release</span>() = <span class="hl-variable">c</span>.<span class="hl-site">dec</span>()

<span class="hl-comment">-------------------------------------------------</span>

<span class="hl-comment">{-- These definitions are for testing only --}</span>
<span class="hl-keyword">def</span> <span class="hl-site">reader</span>(<span class="hl-variable">start</span>) = <span class="hl-site">Rtimer</span>(<span class="hl-variable">start</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">acquire</span>(<span class="hl-literal">false</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"START READ"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"END READ"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-keyword">def</span> <span class="hl-site">writer</span>(<span class="hl-variable">start</span>) = <span class="hl-site">Rtimer</span>(<span class="hl-variable">start</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">acquire</span>(<span class="hl-literal">true</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"START WRITE"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"END WRITE"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-site">let</span>(
    <span class="hl-site">process</span>()  <span class="hl-comment">{- Output:     -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">10</span>) <span class="hl-comment">{- START READ  -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">20</span>) <span class="hl-comment">{- START READ  -}</span>
               <span class="hl-comment">{- END READ    -}</span>
               <span class="hl-comment">{- END READ    -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">writer</span>(<span class="hl-literal">30</span>) <span class="hl-comment">{- START WRITE -}</span>
               <span class="hl-comment">{- END WRITE   -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">40</span>) <span class="hl-comment">{- START READ  -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">50</span>) <span class="hl-comment">{- START READ  -}</span>
               <span class="hl-comment">{- END READ    -}</span>
               <span class="hl-comment">{- END READ    -}</span>
  <span class="hl-comment">-- halt after the last reader finishes</span>
  <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">60</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">acquire</span>(<span class="hl-literal">true</span>)
)</pre><p>
The lock receives requests over the channel <code class="code"><span class="hl-variable">m</span></code> and processes them
sequentially with the function <code class="code"><span class="hl-variable">grant</span></code>. Each request includes a
boolean flag which is true for write requests and false for read requests, and a
<code class="code"><span class="hl-variable">Semaphore</span></code> which the requester blocks on.  The lock grants access
by releasing the semaphore, unblocking the requester.
</p><p>
The counter <code class="code"><span class="hl-variable">c</span></code> tracks the number of readers or writers currently
holding the lock.  Whenever the lock is granted, <code class="code"><span class="hl-variable">grant</span></code> increments
<code class="code"><span class="hl-variable">c</span></code>, and when the lock is released, <code class="code"><span class="hl-variable">c</span></code> is decremented.
To ensure that a writer has exclusive access, <code class="code"><span class="hl-variable">grant</span></code> waits for the
<code class="code"><span class="hl-variable">c</span></code> to become zero before granting the lock to the writer, and then
waits for <code class="code"><span class="hl-variable">c</span></code> to become zero again before granting any more requests.
</p></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch02s02.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch02.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch03.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">2.2.&nbsp;Programming Idioms&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</td></tr></table></div></body></html>