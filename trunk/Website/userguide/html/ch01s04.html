<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>1.4.&nbsp;Advanced Features of Orc</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide v0.9.9"><link rel="up" href="ch01.html" title="Chapter&nbsp;1.&nbsp;The Orc Programming Language"><link rel="prev" href="ch01s03.html" title="1.3.&nbsp;Orc: Orchestrating services"><link rel="next" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Programming Methodology"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">1.4.&nbsp;Advanced Features of Orc</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch01s03.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;1.&nbsp;The Orc Programming Language</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch02.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10A14"></a>1.4.&nbsp;Advanced Features of Orc</h2></div></div></div><p>
In this section we introduce some advanced features of Orc. These include curried
function definitions and curried calls, writing an arbitrary expression as the
target of a call, a special syntax for writing calls in an object-oriented style, 
extensions to pattern matching, and new forms of declarations, and ML-style
datatypes.
</p><p>
<div class="table"><a name="advanced-ebnf-table"></a><p class="title"><b>Table&nbsp;1.4.&nbsp;Advanced Syntax of Orc</b></p><div class="table-contents"><table summary="Advanced Syntax of Orc" border="0" width="80%"><colgroup><col align="right"><col align="center"><col align="left"><col align="left"><col align="left"></colgroup><tbody><tr><td align="right">E</td><td align="center">::=</td><td align="left">...</td><td align="left">
                                    <span class="emphasis"><em>Expression</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E G+</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>generalized call</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">T</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>throw expression</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">TC</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>try/catch block</em></span>
                                </td></tr><tr><td align="right">G</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>Argument group</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left"> <code class="code">(</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">)</code> </td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>curried arguments</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"> <code class="code">.</code>
                                    <span class="emphasis"><em>field</em></span> </td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>field access</em></span>
                                </td></tr><tr><td align="right">P</td><td align="center">::=</td><td align="left">...</td><td align="left">
                                    <span class="emphasis"><em>Pattern</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">P <code class="code"><span class="hl-keyword">as</span></code> X</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>as pattern</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">
                                    <code class="code">=</code>X</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>equality pattern</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X<code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code>
                                </td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>datatype pattern</em></span>
                                </td></tr><tr><td align="right">D</td><td align="center">::=</td><td align="left"> ... </td><td align="left">
                                    <span class="emphasis"><em>Declaration</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">
                                    <code class="code"><span class="hl-keyword">class</span></code> X <code class="code">=</code> <span class="emphasis"><em>classname</em></span>
                                </td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>class declaration</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">
                                    <code class="code"><span class="hl-keyword">type</span></code> X <code class="code">=</code> DT <code class="code"><span class="hl-combinator">|</span></code> ... <code class="code"><span class="hl-combinator">|</span></code> DT</td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>datatype declaration</em></span>
                                </td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">
                                    <code class="code"><span class="hl-keyword">include</span></code> <code class="code"><span class="hl-literal">"</span></code> <span class="emphasis"><em>filename</em></span> <code class="code"><span class="hl-literal">"</span></code>
                                </td><td align="left">&nbsp;</td><td align="left">
                                    <span class="emphasis"><em>inclusion</em></span>
                                </td></tr><tr><td align="right">DT</td><td align="center">::=</td><td align="left"> X<code class="code">(<span class="hl-variable">_</span>,</code> ... <code class="code">,<span class="hl-variable">_</span>)</code> </td><td align="left">
                                    <span class="emphasis"><em>Datatype</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">T</td><td align="center">::=</td><td align="left"> <code class="code"><span class="hl-keyword">throw</span> </code> E</td><td align="left">
                                    <span class="emphasis"><em>Throw</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">TC</td><td align="center">::=</td><td align="left"> <code class="code"><span class="hl-keyword">try</span> ( </code> E <code class="code"> ) </code> C+</td><td align="left">
                                    <span class="emphasis"><em>Try/Catch</em></span>
                                </td><td align="left">&nbsp;</td></tr><tr><td align="right">C</td><td align="center">::=</td><td align="left"> <code class="code"><span class="hl-keyword">catch</span> ( </code> P <code class="code"> ) </code> E</td><td align="left">
                                    <span class="emphasis"><em>Exception Handler</em></span>
                                </td><td align="left">&nbsp;</td></tr></tbody></table></div></div><br class="table-break">
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10B86"></a>1.4.1.&nbsp;Special call forms</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10B89"></a>1.4.1.1.&nbsp;The <code class="code">.</code> notation</h4></div></div></div><p>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code class="code"><span class="hl-variable">obj</span>.<span class="hl-site">m</span>()</code> calls the method
<code class="code"><span class="hl-variable">m</span></code> of the object <code class="code"><span class="hl-variable">obj</span></code>. 
</p><p>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">msg</span></code>, for any identifiers <code class="code"><span class="hl-variable">x</span></code> and <code class="code"><span class="hl-variable">msg</span></code>. This treats
 the value bound to <code class="code"><span class="hl-variable">x</span></code> as a site, and calls it with a special 
<em class="firstterm">message</em> value <code class="code"><span class="hl-variable">msg</span></code>. 
If the site understands the message <code class="code"><span class="hl-variable">msg</span></code> (for example, if <code class="code"><span class="hl-variable">x</span></code> is 
bound to a Java object with a field called <code class="code"><span class="hl-variable">msg</span></code>), the site interprets the message 
and responds with some appropriate value. If the site does not 
understand the message sent to it, it does not respond, and no publication occurs. 
If <code class="code"><span class="hl-variable">x</span></code> cannot be interpreted as a site, no call is made. 
</p><p>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code class="code"><span class="hl-variable">c</span></code> might understand the messages
<code class="code"><span class="hl-variable">get</span></code> and <code class="code"><span class="hl-variable">put</span></code>, to get values from and put values on that channel,
respectively. Such calls would be written <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">get</span>()</code>, or <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-literal">6</span>)</code>.
</p><p>
A call such as <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-literal">6</span>)</code> actually occurs in two steps. First <code class="code"><span class="hl-variable">c</span>.<span class="hl-variable">put</span></code> sends the message
<code class="code"><span class="hl-variable">put</span></code> to the site <code class="code"><span class="hl-variable">c</span></code>; this publishes a site whose only purpose
is to put values on the channel. Next, that site is called on the argument
<code class="code"><span class="hl-literal">6</span></code>, sending 6 on the channel. Readers familiar with functional programming
will recognize this technique as <span class="emphasis"><em>currying</em></span>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10BDF"></a>1.4.1.2.&nbsp;Currying</h4></div></div></div><p>
It is sometimes useful to <span class="emphasis"><em>stage</em></span> the arguments to a function; that is,
rather than writing a function on two arguments, one instead writes a function on one
argument which returns a function taking the second argument and performing the remainder
of the evaluation. 
</p><p>
This technique is known as <span class="emphasis"><em>currying</em></span> and it is common in functional
programming languages. We can write curried functions using <a class="link" href="ch01s02.html#cor.closures" title="1.2.7.2.&nbsp;Closures">closures</a>. Suppose we want to 
define a curried addition function on two arguments, and later apply that function to the 
arguments 3 and 4. We could write such a program in the following way:

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">Sum</span>(<span class="hl-variable">a</span>) = ( <span class="hl-keyword">lambda</span>(<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span> )  
<span class="hl-keyword">val</span> <span class="hl-variable">f</span> = <span class="hl-site">Sum</span>(<span class="hl-literal">3</span>)
<span class="hl-site">f</span>(<span class="hl-literal">4</span>)
</pre>

This defines a function <code class="code"><span class="hl-variable">Sum</span></code> which, given an argument <code class="code"><span class="hl-variable">a</span></code>, creates a function
which will take an argument <code class="code"><span class="hl-variable">b</span></code> and add <code class="code"><span class="hl-variable">a</span></code> to <code class="code"><span class="hl-variable">b</span></code>. It then creates the
function which adds <code class="code"><span class="hl-literal">3</span></code> to its argument, binds that to <code class="code"><span class="hl-variable">f</span></code>, and then invokes
<code class="code"><span class="hl-variable">f</span></code> on <code class="code"><span class="hl-literal">4</span></code> to yield <code class="code"><span class="hl-literal">3</span>+<span class="hl-literal">4</span></code>.

</p><p>
When defining a curried function, we have abstracted it in two steps, and when
applying it we have written two separate calls. However, this is verbose and
not very clear. Orc has a special syntax for curried function definitions and curried 
applications that will simplify both of these steps. Function definitions may have multiple 
argument sequences; they are enclosed in parentheses and concatenated. Curried function calls 
chain together multiple applications in a similar way. Here is the previous program, written 
in this simplified syntax:

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">Sum</span>(<span class="hl-variable">a</span>)(<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span>
<span class="hl-site">Sum</span>(<span class="hl-literal">3</span>)(<span class="hl-literal">4</span>)
</pre>

Naturally, this syntax is backwards compatible; e.g. both of the following programs are also
equivalent:  

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">Sum</span>(<span class="hl-variable">a</span>) = ( <span class="hl-keyword">lambda</span>(<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span> )  
<span class="hl-site">Sum</span>(<span class="hl-literal">3</span>)(<span class="hl-literal">4</span>)
</pre>

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">Sum</span>(<span class="hl-variable">a</span>)(<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span>  
<span class="hl-keyword">val</span> <span class="hl-variable">f</span> = <span class="hl-site">Sum</span>(<span class="hl-literal">3</span>)
<span class="hl-site">f</span>(<span class="hl-literal">4</span>)
</pre>

</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
Clauses of a function may be defined with both curried arguments and patterns in arguments.
However, the combination of these two features can produce unintuitive behavior. Consider
the following clausal, curried function definition:

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">x</span>)(<span class="hl-literal">0</span>) = <span class="hl-variable">x</span>
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">x</span>)(<span class="hl-variable">y</span>) = <span class="hl-variable">x</span> + <span class="hl-variable">y</span>
<span class="hl-site">sum</span>(<span class="hl-literal">2</span>)(<span class="hl-literal">3</span>)
</pre>

One might expect <code class="code"><span class="hl-site">sum</span>(<span class="hl-literal">2</span>)(<span class="hl-literal">3</span>)</code> to evaluate to <code class="code"><span class="hl-literal">5</span></code>. However, this is not
the case; instead <code class="code"><span class="hl-site">sum</span>(<span class="hl-literal">2</span>)(<span class="hl-literal">3</span>)</code> remains silent due to a pattern matching failure.
This is because the compiler always expands curried definitions before considering patterns,
so the above program is in fact equivalent to:

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">x</span>) = ( <span class="hl-keyword">lambda</span>(<span class="hl-literal">0</span>) = <span class="hl-variable">x</span> )
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">x</span>) = ( <span class="hl-keyword">lambda</span>(<span class="hl-variable">y</span>) = <span class="hl-variable">x</span> + <span class="hl-variable">y</span> )
<span class="hl-site">sum</span>(<span class="hl-literal">2</span>)(<span class="hl-literal">3</span>)
</pre>

Now the problem becomes apparent. The first clause will always match when the function is
applied to its first argument, and then only one clause is available when the second
argument is available: the clause with succeeds only on <code class="code"><span class="hl-literal">0</span></code>.
</p><p>
Therefore, use caution when writing function definitions that use both currying and clauses.
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10C39"></a>1.4.2.&nbsp;Extensions to pattern matching</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10C3C"></a>1.4.2.1.&nbsp;As pattern</h4></div></div></div><p>
In taking apart a value with a pattern, it is often useful to capture intermediate results.

<pre class="programlisting">
<span class="hl-keyword">val</span> (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) = ((<span class="hl-literal">1</span>,<span class="hl-literal">2</span>),(<span class="hl-literal">3</span>,<span class="hl-literal">4</span>))
<span class="hl-keyword">val</span> (<span class="hl-variable">ax</span>,<span class="hl-variable">ay</span>) = <span class="hl-variable">a</span>
<span class="hl-keyword">val</span> (<span class="hl-variable">bx</span>,<span class="hl-variable">by</span>) = <span class="hl-variable">b</span>
</pre>

We can use the <code class="code"><span class="hl-keyword">as</span></code> keyword to simplify this program fragment, giving a name to an entire
sub-pattern. Here is an equivalent version of the above code.

<pre class="programlisting">
<span class="hl-keyword">val</span> ((<span class="hl-variable">ax</span>,<span class="hl-variable">ay</span>) <span class="hl-keyword">as</span> <span class="hl-variable">a</span>, (<span class="hl-variable">bx</span>,<span class="hl-variable">by</span>) <span class="hl-keyword">as</span> <span class="hl-variable">b</span>) = ((<span class="hl-literal">1</span>,<span class="hl-literal">2</span>),(<span class="hl-literal">3</span>,<span class="hl-literal">4</span>))
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10C4A"></a>1.4.2.2.&nbsp;Equality pattern</h4></div></div></div><p>
When a variable occurs in a pattern, it is bound to the value being matched against that pattern. What
if instead we would like to use the value of a bound variable as a test pattern, in a way similar to
a literal value like <code class="code"><span class="hl-literal">0</span></code>? 
</p><p>
We can use an equality pattern to do this. An equality pattern is a variable name preceded by <code class="code">=</code>.
Consider the following definition, which compares its argument to the value bound to variable <code class="code"><span class="hl-variable">x</span></code>,
returning <code class="code"><span class="hl-literal">true</span></code> if they are equal and <code class="code"><span class="hl-literal">false</span></code> otherwise.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">isx</span>(=<span class="hl-variable">x</span>) = <span class="hl-literal">true</span>
<span class="hl-keyword">def</span> <span class="hl-site">isx</span>(<span class="hl-variable">_</span>) = <span class="hl-literal">false</span>
</pre>

</p><p>
The equality pattern becomes much more useful when it is embedded within other patterns. For example, consider
this definition <code class="code"><span class="hl-variable">withz</span></code>. If one of the arguments passed to it is equal to <code class="code"><span class="hl-variable">z</span></code>, then the function
returns its other argument. Otherwise it remains silent.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">withz</span>(=<span class="hl-variable">z</span>,<span class="hl-variable">y</span>) = <span class="hl-variable">y</span>
<span class="hl-keyword">def</span> <span class="hl-site">withz</span>(<span class="hl-variable">x</span>,=<span class="hl-variable">z</span>) = <span class="hl-variable">x</span>
</pre>

</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.orc.datatypes"></a>1.4.3.&nbsp;Datatypes</h3></div></div></div><p>
We have seen Orc's predefined data structures: tuples and lists. Orc also provides the capability
for programmers to define their own data structures, using a feature adopted from the ML/Haskell
language family called <em class="firstterm">datatypes</em> (also called variants or tagged sums).
</p><p>
Datatypes are defined using the <code class="code"><span class="hl-keyword">type</span></code> declaration:

<pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-variable">Tree</span> = <span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">_</span>,<span class="hl-variable">_</span>) <span class="hl-combinator">|</span> <span class="hl-site">Empty</span>()
</pre>

</p><p>
This declaration defines two new sites named <code class="code"><span class="hl-variable">Node</span></code> and <code class="code"><span class="hl-variable">Empty</span></code>.
<code class="code"><span class="hl-variable">Node</span></code> takes three arguments, and publishes a <span class="emphasis"><em>tagged value</em></span>
wrapping those arguments. <code class="code"><span class="hl-variable">Empty</span></code> takes no arguments and does the same.
</p><p>
Once we have created these tagged values, we use a new pattern called a datatype pattern
to match them and unwrap the arguments:

<pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-variable">Tree</span> = <span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">_</span>,<span class="hl-variable">_</span>) <span class="hl-combinator">|</span> <span class="hl-site">Empty</span>()
<span class="hl-comment">{- Build up a small binary tree -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">l</span> = <span class="hl-site">Node</span>(<span class="hl-site">Empty</span>(), <span class="hl-literal">0</span>, <span class="hl-site">Empty</span>())
<span class="hl-keyword">val</span> <span class="hl-variable">r</span> = <span class="hl-site">Node</span>(<span class="hl-site">Empty</span>(), <span class="hl-literal">2</span>, <span class="hl-site">Empty</span>())
<span class="hl-keyword">val</span> <span class="hl-variable">t</span> = <span class="hl-site">Node</span>(<span class="hl-variable">l</span>,<span class="hl-literal">1</span>,<span class="hl-variable">r</span>)

<span class="hl-comment">{- And then match it to extract its contents -}</span>
<span class="hl-variable">t</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Node</span>(<span class="hl-variable">l</span>,<span class="hl-variable">j</span>,<span class="hl-variable">r</span>)<span class="hl-combinator">&gt;</span>
<span class="hl-variable">l</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">i</span>,<span class="hl-variable">_</span>)<span class="hl-combinator">&gt;</span>
<span class="hl-variable">r</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">k</span>,<span class="hl-variable">_</span>)<span class="hl-combinator">&gt;</span>
( <span class="hl-variable">i</span> <span class="hl-combinator">|</span> <span class="hl-variable">j</span> <span class="hl-combinator">|</span> <span class="hl-variable">k</span> )
</pre>
</p><p>
One pair of datatypes is so commonly used that it is already predefined in the standard library:
<code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">_</span>)</code> and <code class="code"><span class="hl-site">None</span>()</code>. These are used as return values for calls that
need to distinguish between successfully returning a value (<code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">v</span>)</code>), and successfully
completing but having no meaningful value to return (<code class="code"><span class="hl-site">None</span>()</code>). For example, a lookup
function might return <code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">result</span>)</code> if it found a result, or return <code class="code"><span class="hl-site">None</span>()</code>
if it successfully performed the lookup but found no suitable result.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10CA9"></a>1.4.4.&nbsp;New forms of declarations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="section.orc.class"></a>1.4.4.1.&nbsp;

                        <code class="code"><span class="hl-keyword">class</span></code> declaration</h4></div></div></div><p>
When Orc is run on top of an object-oriented programming language, classes
from that language may be used as sites in Orc itself, via the <code class="code"><span class="hl-keyword">class</span></code>
declaration. 
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- Use the String class from Java's standard library as a site -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">String</span> = <span class="hl-variable">java</span>.<span class="hl-variable">lang</span>.<span class="hl-variable">String</span>
<span class="hl-keyword">val</span> <span class="hl-variable">s</span> = <span class="hl-site">String</span>(<span class="hl-literal">"foo"</span>)
<span class="hl-variable">s</span>.<span class="hl-site">concat</span>(<span class="hl-literal">"bar"</span>)
</pre>
</p><p>
This program binds the variable <code class="code"><span class="hl-variable">String</span></code> to Java's String class.
When it is called as a site, it constructs a new instance of String, passing
the given arguments to the constructor.
</p><p>
This instance of String is a Java object; its methods are called and its fields
are accessed using the dot (<code class="code">.</code>) notation, just as one would expect
in Java.  For complete details of how Orc interacts with Java, see
<a class="link" href="ch03s02.html" title="3.2.&nbsp; class Sites">Java Integration</a>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10CCB"></a>1.4.4.2.&nbsp;
                        <code class="code"><span class="hl-keyword">include</span></code> declaration</h4></div></div></div><p>
It is often convenient to group related declarations into units that can be
shared between programs. The <code class="code"><span class="hl-keyword">include</span></code> declaration offers a simple
way to do this. It names a source file containing a sequence of Orc declarations;
those declarations are incorporated into the program as if they had textually
replaced the include declaration. An included file may itself contain 
<code class="code"><span class="hl-keyword">include</span></code> declarations. 
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- Contents of fold.inc -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,[],<span class="hl-variable">s</span>) = <span class="hl-variable">s</span>
<span class="hl-keyword">def</span> <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,<span class="hl-variable">h</span>:<span class="hl-variable">t</span>,<span class="hl-variable">s</span>) = <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,<span class="hl-variable">t</span>,<span class="hl-site">f</span>(<span class="hl-variable">h</span>,<span class="hl-variable">s</span>))

<span class="hl-keyword">def</span> <span class="hl-site">foldr</span>(<span class="hl-variable">f</span>,<span class="hl-variable">l</span>,<span class="hl-variable">s</span>) = <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,<span class="hl-site">rev</span>(<span class="hl-variable">l</span>),<span class="hl-variable">s</span>)
</pre>
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- This is the same as inserting the contents of fold.inc here -}</span>
<span class="hl-keyword">include</span> <span class="hl-literal">"fold.inc"</span>

<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">L</span>) = <span class="hl-site">foldl</span>(<span class="hl-keyword">lambda</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span>, <span class="hl-variable">L</span>, <span class="hl-literal">0</span>)

<span class="hl-site">sum</span>([<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>])
</pre>
</p><p>
Note that these declarations still obey the rules of lexical scope. Also, Orc 
does not detect shared declarations; if the same file is included twice, its 
declarations occur twice.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10CE5"></a>1.4.5.&nbsp;Exceptions in Orc</h3></div></div></div><p>
We have added an experimental implementation of <span class="emphasis"><em>exceptions</em></span> to the Orc language,
which allows exceptions to be raised, caught, and handled (to be added in release 0.9.9).
We introduce three new keywords to the Orc syntax: 
<code class="code"><span class="hl-keyword">throw</span></code>, <code class="code"><span class="hl-keyword">try</span></code>, and <code class="code"><span class="hl-keyword">catch</span></code>, which are defined as follows:

<p>
<code class="code"><span class="hl-keyword">throw</span></code> E: for each publication x by expression E, raise an exception with value x.
</p>

<p>
<code class="code"><span class="hl-keyword">try</span> </code> E: Defines E to be a block, possibly containing throw expressions.
</p>

<p>
<code class="code"><span class="hl-keyword">catch</span> (</code> P <code class="code">) </code>E: Given pattern P and expression E, any exception
with value x that matches pattern P causes execution of E under the binding of P to x.
For each corresponding try expression, one or more catch statements are defined.  Catch
statements are executed in order, and the first to match is the statement executed.
</p>

<p>
Examples of throw expressions:

<p>
<pre class="programlisting">
<span class="hl-keyword">throw</span> <span class="hl-literal">3</span>
<span class="hl-keyword">throw</span> <span class="hl-literal">"error"</span>
<span class="hl-keyword">throw</span> (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)    <span class="hl-comment">{- throws two exceptions -}</span>
<span class="hl-keyword">throw</span> <span class="hl-keyword">stop</span>       <span class="hl-comment">{- throws no exceptions -}</span>
</pre>
</p>

</p>

Below we combine both exception raising and handling:

<p>
<pre class="programlisting">
<span class="hl-comment">{- simple exception expressions -}</span>
<span class="hl-keyword">try</span>(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-keyword">throw</span> <span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-keyword">throw</span> <span class="hl-literal">2</span>) 
<span class="hl-keyword">catch</span> (<span class="hl-literal">1</span>) <span class="hl-literal">"one"</span>
<span class="hl-keyword">catch</span> (<span class="hl-variable">x</span>) <span class="hl-variable">x</span>               
<span class="hl-keyword">catch</span> (<span class="hl-literal">2</span>) <span class="hl-literal">"two"</span>           

<span class="hl-comment">{- Output: 0, "one", 2 -}</span>
</pre>
</p>

The value <code class="code"><span class="hl-literal">0</span></code> is published by the expression directly, while <code class="code"><span class="hl-literal">"one"</span></code> is
published by <code class="code"><span class="hl-keyword">catch</span> (<span class="hl-literal">1</span>) <span class="hl-literal">"one"</span></code>, and <code class="code"><span class="hl-literal">2</span></code> is published by <code class="code"><span class="hl-keyword">catch</span>(<span class="hl-variable">x</span>) <span class="hl-variable">x</span></code>.
The handler <code class="code"><span class="hl-keyword">catch</span> (<span class="hl-literal">2</span>) <span class="hl-literal">"two"</span></code> is not executed.

</p><p>
Exception handlers can also be nested; if the immediately enclosing
try/catch block has no handler that matches the thrown exception, the
Orc interpreter attempts to match against the next enclosing handler.  If
no handler matches the exception (or no enclosing handler exists) the exception
is dropped (for example, it is treated as a <code class="code"><span class="hl-keyword">stop</span></code>) 
and an error is reported to the interpreter.
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- a contrived nested handler example -}</span>
<span class="hl-keyword">try</span>(
  <span class="hl-keyword">try</span>(<span class="hl-keyword">throw</span> <span class="hl-literal">3</span>)
  <span class="hl-keyword">catch</span> (<span class="hl-literal">1</span>) <span class="hl-literal">"one"</span>
)
<span class="hl-keyword">catch</span> (<span class="hl-variable">x</span>) <span class="hl-variable">x</span>
</pre>
</p><p>
When combining exceptions with the combinators, i.e., the pruning or
otherwise combinators, exceptions are silent, that is, they do not publish any value.
For example, in the following expression, both <code class="code"><span class="hl-literal">0</span></code> and
<code class="code"><span class="hl-literal">1</span></code> are published; <code class="code"><span class="hl-keyword">throw</span> <span class="hl-literal">0</span></code> is silent, not publishing
any value, causing the otherwise combinator to also execute its alternate expression:
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- the throw expression is treated as a silent by the combinators -}</span>
<span class="hl-keyword">try</span> (<span class="hl-keyword">throw</span> <span class="hl-literal">0</span><span class="hl-combinator">;</span> <span class="hl-literal">1</span>) <span class="hl-keyword">catch</span>(<span class="hl-variable">x</span>) <span class="hl-variable">x</span>

<span class="hl-comment">{- output: 
0
1
-}</span>
</pre>
</p><p>
Similarly, exceptions thrown within a pruning combinator do not terminate 
the expression (since the throw is treated as a silent), and throwing a silent expression
(i.e., <code class="code"><span class="hl-keyword">throw</span> <span class="hl-keyword">stop</span></code>) results in no exception being thrown; the entire
expression functions as a stop.  Unlike other languages, an uncaught exception
only kills the process that threw it, and the other processes in the system
will continue running.  In the example below, the entire expression publishes no value
(because the expression inside the pruning combinator does not publish).  Instead,
the exception thrown is uncaught and results in a runtime error:
</p><p>
<pre class="programlisting">
<span class="hl-variable">x</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-keyword">throw</span> <span class="hl-literal">2</span>

<span class="hl-comment">{- output:
Error: uncaught exception:
Backtrace:
OrcJava/examples/uncaught.orc:1:8-15:  x &lt;x&lt; throw 2
-}</span>
</pre>
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10D50"></a>1.4.5.1.&nbsp;Catching Java exceptions</h4></div></div></div><p>
Orc also allows Java exceptions thrown by sites 
to be matched against by Orc exception
handlers.  This is especially useful when calling Java code directly,
which might throw exceptions in cases of failure, seen here in this 
short example.  Attemping to create a <code class="code"><span class="hl-variable">FileInputSteam</span></code> with
a nonexistent file path returns an error by throwing a <code class="code"><span class="hl-variable">FileNotFoundException</span></code>.
By pattern matching for a <code class="code"><span class="hl-variable">FileNotFoundException</span></code>, the
error can be detected and handled by the Orc program.

</p><p>
<pre class="programlisting">
<span class="hl-comment">{- catching exceptions thrown by Java sites via pattern matching -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">FileInputStream</span> = <span class="hl-variable">java</span>.<span class="hl-variable">io</span>.<span class="hl-variable">FileInputStream</span>
<span class="hl-keyword">class</span> <span class="hl-variable">FileNotFoundException</span> = <span class="hl-variable">java</span>.<span class="hl-variable">io</span>.<span class="hl-variable">FileNotFoundException</span>

...

<span class="hl-keyword">try</span>(
<span class="hl-site">FileInputStream</span>(<span class="hl-literal">"non/existent/file/path"</span>)
) <span class="hl-keyword">catch</span> (<span class="hl-site">FileNotFoundException</span>(<span class="hl-variable">e</span>)) <span class="hl-variable">e</span>

...
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10D63"></a>1.4.5.2.&nbsp;Catching Orc Engine Errors</h4></div></div></div><p>
This functionality also allows certain Orc runtime errors to be caught.
Here are a few examples of runtime errors which might occur, and a full
list can be found in the 
<a class="link" href="http://orc.csres.utexas.edu/javadoc/STABLE/orc/error/runtime/TokenException.html" target="_top">Javadoc</a>.
</p><p>
<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-variable">ArgumentTypeMismatchException</span></code></li><li><code class="code"><span class="hl-variable">ArityMismatchException</span></code></li><li><code class="code"><span class="hl-variable">MessageNotUnderstoodException</span></code></li></ul></div>
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- Detecting runtime errors using exceptions -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">ArgumentTypeMismatchException</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">error</span>.<span class="hl-variable">runtime</span>.<span class="hl-variable">ArgumentTypeMismatchException</span>

<span class="hl-keyword">try</span>(
  <span class="hl-keyword">if</span> <span class="hl-literal">3</span> <span class="hl-keyword">then</span> <span class="hl-literal">"foo"</span>
) <span class="hl-keyword">catch</span> (<span class="hl-site">ArgumentTypeMismatchException</span>(<span class="hl-variable">e</span>)) <span class="hl-literal">"error"</span>
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10D7E"></a>1.4.5.3.&nbsp;Exceptions in Practice</h4></div></div></div>
Exceptions add two important capabilities to the Orc language.  First, they allow 
Java exceptions thrown by Java based sites, as well the Orc engine itself, to be
caught, allowing previously undetectable errors to be handled by the programmer.  Additionally,
they simplify error handling significantly, by removing error handling code from the body of
the program.  This is especially helpful when propagating error information across 
function calls or various parts of the program.  In the examples below, let <code class="code"><span class="hl-variable">request</span></code> be
a function that will return a single value eventually:

<p>
<pre class="programlisting">
<span class="hl-comment">{- error handling without exceptions: -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">makeRequest</span>() = 
  <span class="hl-site">let</span>(<span class="hl-site">request</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> (<span class="hl-literal">true</span>, <span class="hl-variable">x</span>) <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> (<span class="hl-literal">false</span>, <span class="hl-literal">"timeout"</span>))

<span class="hl-keyword">def</span> <span class="hl-site">call</span>() =
  <span class="hl-site">makeRequest</span>() <span class="hl-combinator">&gt;</span>(<span class="hl-variable">success</span>, <span class="hl-variable">result</span>)<span class="hl-combinator">&gt;</span> <span class="hl-keyword">if</span> <span class="hl-variable">success</span> <span class="hl-keyword">then</span> <span class="hl-variable">result</span> <span class="hl-keyword">else</span> <span class="hl-literal">"failed"</span>
</pre>
</p>

Compare this to using exceptions, where error handling is made explicit and
the program as a whole is simplified.  (Note the improvement would be more marked if
a deeper layer of function nesting was used.)

<p>
<pre class="programlisting">
<span class="hl-comment">{- error handling with exceptions -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">makeRequest</span>() = 
  <span class="hl-site">request</span>() <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">throw</span>(<span class="hl-literal">"timeout"</span>)

<span class="hl-keyword">def</span> <span class="hl-site">call</span>() =
  <span class="hl-keyword">try</span>( <span class="hl-site">makeRequest</span>() ) <span class="hl-keyword">catch</span> (<span class="hl-variable">_</span>) <span class="hl-literal">"failed"</span>
</pre>
</p></div></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch01s03.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch01.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch02.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">1.3.&nbsp;Orc: Orchestrating services&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;Chapter&nbsp;2.&nbsp;Programming Methodology</td></tr></table></div></body></html>