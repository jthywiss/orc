<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2.2.&nbsp;Programming Idioms</title><link href="style.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide"><link rel="up" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Programming Methodology"><link rel="prev" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Programming Methodology"><link rel="next" href="ch02s03.html" title="2.3.&nbsp;Larger Examples"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">2.2.&nbsp;Programming Idioms</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;2.&nbsp;Programming Methodology</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch02s03.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10C85"></a>2.2.&nbsp;Programming Idioms</h2></div></div></div>

In this section we look at some common idioms used in the design of Orc programs. Many of these idioms will
be familiar to programmers using concurrency, and they are very simple to express in Orc.

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10C89"></a>2.2.1.&nbsp;Fork-join</h3></div></div></div>

One of the most common concurrent idioms is a <em class="firstterm">fork-join</em>: run two processes concurrently,
and wait for a result from each one. This is very easy to express in Orc. Whenever we write a <code class="code"><span class="hl-keyword">val</span></code>
declaration, the process computing that value runs in parallel with the rest of the program. So if we write
two <code class="code"><span class="hl-keyword">val</span></code> declarations, and then form a tuple of their results, this performs a fork-join.


<p>
<pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> = <span class="bold"><strong>F</strong></span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> = <span class="bold"><strong>G</strong></span>
(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)
</pre>
</p>


Fork-joins are a fundamental part of all Orc programs, since they are created by all nested expression
translations. In fact, the fork-join we wrote above could be expressed even more simply as just:

<p>
<pre class="programlisting">
(<span class="bold"><strong>F</strong></span>,<span class="bold"><strong>G</strong></span>)
</pre>
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10CB1"></a>2.2.1.1.&nbsp;Example: Machine initialization</h4></div></div></div><p>
In Orc programs, we often use fork-join and recursion together to dispatch many tasks in parallel and wait
for all of them to complete. Suppose we want to initialize a list of machines; for each machine <code class="code"><span class="hl-variable">m</span></code>,
calling <code class="code"><span class="hl-variable">m</span>.<span class="hl-variable">init</span>()</code> initializes <code class="code"><span class="hl-variable">m</span></code> and then publishes a signal when initialization
is complete. The function <code class="code"><span class="hl-variable">initAll</span></code> does exactly that:
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">initAll</span>([]) = <span class="hl-keyword">signal</span>
<span class="hl-keyword">def</span> <span class="hl-variable">initAll</span>(<span class="hl-variable">m</span>:<span class="hl-variable">ms</span>) = ( <span class="hl-variable">m</span>.<span class="hl-variable">init</span>() , <span class="hl-variable">initAll</span>(<span class="hl-variable">ms</span>) ) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>
</pre><p>
For each machine, we fork-join the initialization of that machine (<code class="code"><span class="hl-variable">m</span>.<span class="hl-variable">init</span>()</code>) with the initialization
of the remaining machines (<code class="code"><span class="hl-variable">initAll</span>(<span class="hl-variable">ms</span>)</code>). Thus, all of the initializations proceed in parallel, and
the function returns a signal only when every machine in the list has completed its initialization. 
</p><p>
Note that if some machine fails to initialize, and does not return a signal, then the initialization procedure
will never complete. We will see later how to better manage such failures, using a timeout or a quorum.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10CCE"></a>2.2.1.2.&nbsp;Example: Simple parallel auction</h4></div></div></div><p>
We can also use a recursive fork-join to obtain a value, rather than just signaling completion. Suppose we
have a list of bidders in a sealed-bid, single-round auction. Calling <code class="code"><span class="hl-variable">b</span>.<span class="hl-variable">ask</span>()</code> requests a bid
from the bidder <code class="code"><span class="hl-variable">b</span></code>. We want to ask for one bid from each bidder, and then return the highest
bid. The function <code class="code"><span class="hl-variable">auction</span></code> performs such an auction (<code class="code"><span class="hl-variable">Max</span></code> finds the maxiumum of
its arguments):
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">auction</span>([]) = <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-variable">auction</span>(<span class="hl-variable">b</span>:<span class="hl-variable">bs</span>) = <span class="hl-variable">Max</span>(<span class="hl-variable">b</span>.<span class="hl-variable">ask</span>(), <span class="hl-variable">auction</span>(<span class="hl-variable">bs</span>))
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10CE2"></a>2.2.1.3.&nbsp;Barrier synchronization</h4></div></div></div><p>
Suppose we have an expression of the following form, where F and G are expressions and M and N are sites:

<pre class="programlisting">
<span class="hl-variable">M</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="hl-variable">N</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> <span class="bold"><strong>G</strong></span>
</pre>

</p><p>
However, we would also like to <span class="emphasis"><em>synchronize</em></span> the completion of M and N, so that
neither F nor G starts executing until both M and N have published. This is a particular example
of a fork-join:

<pre class="programlisting">
( <span class="hl-variable">M</span>() , <span class="hl-variable">N</span>() ) <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)<span class="hl-combinator">&gt;</span> ( <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>G</strong></span> )
</pre>

We assume, naturally, that x does not occur free in G, nor y in F.

</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10D02"></a>2.2.2.&nbsp;Parallel Or</h3></div></div></div><p>
Next we consider a classic example of parallel programming which builds up from fork-join: a parallel-or program. Given two
expressions F and G which may publish boolean values (or might stay silent forever), we want to find the disjunction of their
results as soon as possible. In particular, we know that if one of the expressions publishes <code class="code"><span class="hl-literal">true</span></code>, then
the disjunction must be <code class="code"><span class="hl-literal">true</span></code>; it is not necessary to wait for the other expression to publish a value.
</p><p>
Here is the code:

<pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">r</span> = 
    <span class="hl-keyword">val</span> <span class="hl-variable">a</span> = <span class="bold"><strong>F</strong></span>
    <span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="bold"><strong>G</strong></span>
      <span class="hl-keyword">if</span>(<span class="hl-variable">a</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">true</span> 
    <span class="hl-combinator">|</span> <span class="hl-keyword">if</span>(<span class="hl-variable">b</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">true</span> 
    <span class="hl-combinator">|</span> (<span class="hl-variable">a</span> <span class="hl-site">||</span> <span class="hl-variable">b</span>)
<span class="hl-variable">r</span>
</pre>
</p><p>
Recall that the <code class="code"><span class="hl-site">||</span></code> operator is strict; if one of <code class="code"><span class="hl-variable">a</span></code> or <code class="code"><span class="hl-variable">b</span></code> is not bound, it cannot
compute a result. So, we introduce two extra branches of the form <code class="code"><span class="hl-keyword">if</span>(<span class="hl-keyword">as</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">true</span></code>, which wait
in parallel for each variable to become <code class="code"><span class="hl-literal">true</span></code> and then publish the result <code class="code"><span class="hl-literal">true</span></code>. That way, the
parallel-or can evaluate to <code class="code"><span class="hl-literal">true</span></code> based on only one of the results, even if the other result is not forthcoming.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10D31"></a>2.2.3.&nbsp;Arbitration</h3></div></div></div><p>
Another important concurrent idiom is <span class="emphasis"><em>arbitration</em></span>: choosing between two tasks based on the output
of another task. This is simple to accomplish in Orc using conditionals. This program executes an expression P, which
produces a boolean value, and then uses that value to choose whether to subsequently run F or G.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="bold"><strong>P</strong></span>
<span class="hl-keyword">if</span> <span class="hl-variable">b</span> <span class="hl-keyword">then</span> <span class="bold"><strong>F</strong></span> <span class="hl-keyword">else</span> <span class="bold"><strong>G</strong></span> 
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10D47"></a>2.2.4.&nbsp;Timeout</h3></div></div></div><p>
One of the most powerful idioms available in Orc is a <em class="firstterm">timeout</em>: execute an expression for at
most a specified amount of time. We accomplish this using <code class="code"><span class="hl-keyword">val</span></code> and a timer. The following programs runs
F for at most one second to get a value from it. If it does not publish within one second, the value defaults to 0.
</p><pre class="programlisting">
<span class="hl-variable">let</span>( <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="hl-variable">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">0</span> )
</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10D58"></a>2.2.4.1.&nbsp;Auction with timeout</h4></div></div></div><p>
In the <a class="link" href="ch02s02.html#example.auction">auction example</a> shown earlier, the auction may never complete if 
one of the bidders does not respond. We can add a timeout so that a bidder has at most 8 seconds to provide a bid:
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">auction</span>([]) = <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-variable">auction</span>(<span class="hl-variable">b</span>:<span class="hl-variable">bs</span>) = 
  <span class="hl-keyword">val</span> <span class="hl-variable">bid</span> = <span class="hl-variable">b</span>.<span class="hl-variable">ask</span>() <span class="hl-combinator">|</span> <span class="hl-variable">Rtimer</span>(<span class="hl-literal">8000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">0</span>
  <span class="hl-variable">Max</span>(<span class="hl-variable">bid</span>, <span class="hl-variable">auction</span>(<span class="hl-variable">bs</span>))
</pre><p>
Now, the auction is guaranteed to complete in at most 8 seconds.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10D65"></a>2.2.4.2.&nbsp;Detecting timeout</h4></div></div></div><p>
Sometimes, rather than just yielding a default value, we would like to determine
whether an expression has timed out, and if so, perform some other computation.
To detect the timeout, we pair the expression with <code class="code"><span class="hl-literal">true</span></code> and the timer
with <code class="code"><span class="hl-literal">false</span></code>, so if the expression does time out, then we can detect
it using the truth value. We then test the truth value, performing the usual
computation if no timeout occurred, or some error-correcting computation if 
the expression did time out.
</p><p>
Here, we run the expression F with a time limit t. If it publishes within the time
limit, we execute G (the result of F is bound to r). Otherwise, we execute H.

<pre class="programlisting">
<span class="hl-keyword">val</span> (<span class="hl-variable">r</span>,<span class="hl-variable">b</span>) = (<span class="bold"><strong>F</strong></span>,<span class="hl-literal">true</span>) <span class="hl-combinator">|</span> (<span class="hl-variable">Rtimer</span>(<span class="hl-variable">t</span>),<span class="hl-literal">false</span>)
<span class="hl-keyword">if</span> <span class="hl-variable">b</span> <span class="hl-keyword">then</span> <span class="bold"><strong>G</strong></span> <span class="hl-keyword">else</span> <span class="bold"><strong>H</strong></span>
</pre>

</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10D81"></a>2.2.5.&nbsp;Priority</h3></div></div></div><p>
We can also use a timer to give a window of priority to one computation over another.
In this example, we run expressions F and G concurrently. F has priority for the first
second: if F publishes, its value is used immediately, but if G publishes, that publication 
is suspended for the first second and may be superseded by a publication from F
during that time. If neither F nor G publishes within a second, then whichever publishes
first after that point is the winner. 

<pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> = <span class="bold"><strong>F</strong></span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> = <span class="bold"><strong>G</strong></span>
<span class="hl-variable">let</span>( <span class="hl-variable">y</span> <span class="hl-combinator">|</span> <span class="hl-variable">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span> )
</pre>

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10D91"></a>2.2.6.&nbsp;Repeat</h3></div></div></div><p>
Recall the definition of <code class="code"><span class="hl-variable">metronome</span></code> from the previous chapter:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">metronome</span>() = <span class="hl-keyword">signal</span> <span class="hl-combinator">|</span> <span class="hl-variable">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">metronome</span>()
</pre>
</p><p>
We can use <code class="code"><span class="hl-variable">metronome</span></code> and the sequential combinator to repeat 
an expression, so that copies of that expression will execute at
regular intervals.
</p><p>
<pre class="programlisting">
<span class="hl-comment">{-
   Publish "tick" once every second.
   Publish "tock" once every second, with an initial 500ms delay.
   The publications alternate: tick tock tick tock ...
-}</span>   
  <span class="hl-variable">metronome</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"tick"</span>
<span class="hl-combinator">|</span> <span class="hl-variable">Rtimer</span>(<span class="hl-literal">500</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">metronome</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"tock"</span>
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10DA6"></a>2.2.7.&nbsp;Priority Poll</h3></div></div></div><p>
Suppose we have a list of buffers. We would like to poll these buffers periodically to see if they have
any available data. Furthermore, this list of buffers is ordered by priority; the first buffer in the
list has the highest priority, so it should be polled first, and if it has no data, then the next buffer
should be polled, and so on.
</p><p>
Here is a function which polls a prioritized list of buffers in this way. It publishes the first item 
that it finds, removing it from the originating buffer. If all buffers are empty, it remains silent.
We use the <code class="code"><span class="hl-variable">getnb</span></code> ("get non-blocking") method of the buffer, which retrieves the first
available item if there is one, or else remains silent and completes immediately if the buffer is empty
(it does not wait for an item to become available).
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">PriorityPoll</span>([]) = <span class="hl-keyword">stop</span>
<span class="hl-keyword">def</span> <span class="hl-variable">PriorityPoll</span>(<span class="hl-variable">b</span>:<span class="hl-variable">bs</span>) = <span class="hl-variable">b</span>.<span class="hl-variable">getnb</span>() <span class="hl-combinator">;</span> <span class="hl-variable">PriorityPoll</span>(<span class="hl-variable">bs</span>)
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10DB2"></a>2.2.8.&nbsp;Buffer Transfer</h3></div></div></div><p>
Suppose we have two buffers, and would like to empty one buffer and put its contents 
into the other buffer. We use the following function to do so.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">Transfer</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) = 
    <span class="hl-keyword">def</span> <span class="hl-variable">loop</span>() = <span class="hl-variable">x</span>.<span class="hl-variable">getnb</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">v</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">y</span>.<span class="hl-variable">put</span>(<span class="hl-variable">v</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">loop</span>()
    <span class="hl-variable">loop</span>() <span class="hl-combinator">;</span> <span class="hl-keyword">signal</span>
</pre>

<code class="code"><span class="hl-variable">loop</span></code> takes the elements from <code class="code"><span class="hl-variable">x</span></code> one at a time
(using <code class="code"><span class="hl-variable">getnb</span></code>) and recurses. When <code class="code"><span class="hl-variable">x</span></code> is empty, <code class="code"><span class="hl-variable">getnb</span></code> 
completes and is silent, so the call to <code class="code"><span class="hl-variable">loop</span></code> becomes silent,
allowing the right side of the <code class="code"><span class="hl-combinator">;</span></code> to run, publishing a signal
to indicate that the transfer is finished.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10DCF"></a>2.2.9.&nbsp;Parallel Matching</h3></div></div></div><p>
Matching a value against multiple patterns, as we have seen it so far, is a linear
process, and requires a <code class="code"><span class="hl-keyword">def</span></code> whose clauses have patterns in their
argument lists. Such a match is linear; each pattern is tried in order until
one succeeds.
</p><p>
What if we want to match a value against multiple patterns in parallel, executing
every clause that succeeds? Fortunately, this is very easy to do in Orc. Suppose
we have an expression F which publishes pairs of integers, and we want to publish
a signal for each 3 that occurs. We write:

<pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>
  ( <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>(<span class="hl-literal">3</span>,<span class="hl-variable">_</span>)<span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>
  <span class="hl-combinator">|</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>(<span class="hl-variable">_</span>,<span class="hl-literal">3</span>)<span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span> ) 

</pre>

The interesting case is the pair <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">3</span>)</code>, which is counted twice
because both patterns match it in parallel.
</p><p>
This is a useful idiom even if the patterns are mutually exclusive, to avoid
creating a helper function just to handle the pattern match.
</p></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch02.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch02s03.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Chapter&nbsp;2.&nbsp;Programming Methodology&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;2.3.&nbsp;Larger Examples</td></tr></table></div></body></html>