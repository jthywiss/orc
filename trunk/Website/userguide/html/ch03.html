<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide"><link rel="up" href="index.html" title="Orc User Guide"><link rel="prev" href="ch02s03.html" title="2.3.&nbsp;Larger Examples"><link rel="next" href="apa.html" title="Appendix&nbsp;A.&nbsp;Complete Syntax of Orc"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch02s03.html">Prev</a>&nbsp;</td><th align="center" width="60%">&nbsp;</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="apa.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chapter.services"></a>Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ch03.html#section.services.java">3.1. Java Integration</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#section.services.java.dot">3.1.1. Dot Operator</a></span></dt><dt><span class="section"><a href="ch03.html#N111FD">3.1.2. Direct Calls</a></span></dt><dt><span class="section"><a href="ch03.html#section.services.java.method">3.1.3. Method Resolution</a></span></dt><dt><span class="section"><a href="ch03.html#N11241">3.1.4. Orc Values in Java</a></span></dt><dt><span class="section"><a href="ch03.html#N11279">3.1.5. Java Values in Orc</a></span></dt><dt><span class="section"><a href="ch03.html#N11280">3.1.6. Cooperative Scheduling</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.services.java"></a>3.1.&nbsp;Java Integration</h2></div></div></div><p>
Java classes can be imported into Orc as sites using the <a class="link" href="ch01s04.html#section.orc.class" title="1.4.4.1.&nbsp; class declaration">

                    <code class="code"><span class="hl-keyword">class</span></code>
declaration</a>.  Imported classes must be in the classpath of the JVM running
the Orc interpreter.  The following sections describe in detail how such
imported classes behave in Orc programs.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.java.dot"></a>3.1.1.&nbsp;Dot Operator</h3></div></div></div><p>
<code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">member</span></code>, where <code class="code"><span class="hl-variable">x</span></code> evaluates to a Java class or object, is evaluated as follows:
<div class="itemizedlist"><ul type="disc"><li>If <code class="code"><span class="hl-variable">x</span></code> has one or more methods named <code class="code"><span class="hl-variable">member</span></code>,
a "method handle" site is returned which may be called like any other Orc site.
When a method handle is actually called with arguments, the appropriate Java
method is selected and called depending on the number and type of arguments, as
described in <a class="link" href="ch03.html#section.services.java.method" title="3.1.3.&nbsp;Method Resolution">Method Resolution</a>
below.</li><li>Otherwise, if <code class="code"><span class="hl-variable">x</span></code> has a field named <code class="code"><span class="hl-variable">member</span></code>,
the object's field is returned, encapsulated in a <a class="link" href="apbs03.html#orc.lib.state.Ref">
                                <code class="code"><span class="hl-variable">Ref</span></code> object</a>. The
<code class="code"><span class="hl-variable">Ref</span></code> object has <code class="code"><span class="hl-variable">read</span></code> and <code class="code"><span class="hl-variable">write</span></code> methods
which are used to get and set the value of the field.</li></ul></div>
</p><p>
Note that no distinction is made between static and non-static members; it is
an error to reference a non-static member through a class, but this does not
change how members are resolved.  Note also that if a field shares a name with
one or more methods, there is no way to access the field directly.
</p><p>
The following (rather useless) example illustrates how the dot operator can be
used to access both static and non-static methods and fields:
<pre class="programlisting">
<span class="hl-comment">{- bind Integer to a Java class -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">Integer</span> = <span class="hl-variable">java</span>.<span class="hl-variable">lang</span>.<span class="hl-variable">Integer</span>

<span class="hl-comment">{- call a static method -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">i</span> = <span class="hl-variable">Integer</span>.<span class="hl-site">decode</span>(<span class="hl-literal">"5"</span>)
<span class="hl-comment">{- read a field -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">m</span> = <span class="hl-variable">Integer</span>.<span class="hl-variable">MIN_VALUE</span>.<span class="hl-site">read</span>()
<span class="hl-comment">{- write a field -}</span>
<span class="hl-variable">Integer</span>.<span class="hl-variable">MIN_VALUE</span>.<span class="hl-site">write</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
<span class="hl-comment">{- call a non-static method -}</span>
<span class="hl-variable">i</span>.<span class="hl-site">toString</span>()
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N111FD"></a>3.1.2.&nbsp;Direct Calls</h3></div></div></div><p>
When <code class="code"><span class="hl-variable">x</span></code> evaluates to a Java object (but not a Java class), the syntax
<code class="code"><span class="hl-site">x</span>(...)</code> is equivalent to <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">apply</span>(...)</code>.
</p><p>
When <code class="code"><span class="hl-variable">x</span></code> evaluates to a Java class, the syntax <code class="code"><span class="hl-site">x</span>(...)</code>
calls the class's constructor.  In case of overloaded constructors, the
appropriate constructor is chosen based on the number and types of arguments as
described in <a class="link" href="ch03.html#section.services.java.method" title="3.1.3.&nbsp;Method Resolution">Method Resolution</a>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.java.method"></a>3.1.3.&nbsp;Method Resolution</h3></div></div></div><p>
When a method handle is called, the actual Java method called is chosen based
on the runtime types of the arguments, as follows:
<div class="orderedlist"><ol type="1"><li>If only one method has the appropriate number of arguments, that method is called.</li><li>Otherwise, each method taking the appropriate number of arguments is
	tested for type compatibility as follows, and the first matching method
	is called.
	<div class="orderedlist"><ol type="a"><li>Every argument is compared to the corresponding formal
		parameter type as follows. All arguments must match for the
		method to match.
		<div class="orderedlist"><ol type="i"><li>If the argument is null, then the argument matches</li><li>If the formal parameter type is primitive (int, char,
			float, ...) and the argument is an instance of a
			wrapper class, then the argument is unboxed (unwrapped)
			and coerced to the type of the formal parameter
			according to Java's standard rules for implicit
			widening coercions.</li><li>If the formal parameter type is a primitive numeric type
			and the argument is an instance of <code class="code"><span class="hl-variable">BigDecimal</span></code>,
			the argument is implicitly narrowed to the formal parameter type.</li><li>If the formal parameter type is a primitive integral type
			and the argument is an instance of <code class="code"><span class="hl-variable">BigInteger</span></code>,
			the argument is implicitly narrowed to the formal parameter type.</li><li>Otherwise, the argument must be a subtype of the formal parameter type.</li></ol></div></li></ol></div></li></ol></div>
</p><p>
The reason for the unusual implicit narrowing of <code class="code"><span class="hl-variable">BigDecimal</span></code> and
<code class="code"><span class="hl-variable">BigInteger</span></code> is that Orc numeric literals have these types, and it
would be awkward to have to perform an explicit conversion every time such a
value is passed to a Java method expecting a primitive.
</p><p>
Currently we do not implement specificity rules for choosing the best matching
method; the first matching method (according to some unspecified order) is
chosen.  Note also that we do not support varargs methods explicitly, but
instead varargs may be passed as an array of the appropriate type.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11241"></a>3.1.4.&nbsp;Orc Values in Java</h3></div></div></div><p>
Any value in an Orc program may be treated as a Java object and passed to Java
methods.  Orc literals have the following Java types:
<div class="variablelist"><dl><dt><span class="term">string</span></dt><dd><code class="code">java.lang.String</code></dd><dt><span class="term">boolean</span></dt><dd><code class="code">java.lang.Boolean</code></dd><dt><span class="term">integer</span></dt><dd><code class="code">java.math.BigInteger</code></dd><dt><span class="term">float</span></dt><dd><code class="code">java.math.BigDecimal</code></dd><dt><span class="term">tuple</span></dt><dd><code class="code">orc.runtime.values.TupleValue</code></dd><dt><span class="term">function</span></dt><dd><code class="code">orc.runtime.values.Closure</code></dd><dt><span class="term">list</span></dt><dd><code class="code">orc.runtime.values.ListValue</code></dd></dl></div>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11279"></a>3.1.5.&nbsp;Java Values in Orc</h3></div></div></div><p>
Java objects may be used directly as values anywhere in an Orc program.
Primitive Java values cannot be used directly in an Orc program, but are
automatically boxed (and unboxed) as necessary.
</p><p>
When both arguments of an arithmetic or comparison operator are Java numeric
types, the arguments are implicitly coerced to the widest of the two argument
types.  "Widest" is defined by the following relation, where "&gt;" means "is
wider than": BigDecimal &gt; Double &gt; Float &gt; BigInteger &gt; Long &gt; Integer &gt; Short
&gt; Byte
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11280"></a>3.1.6.&nbsp;Cooperative Scheduling</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N11283"></a>3.1.6.1.&nbsp;Overview</h4></div></div></div><p>
In order to support massive concurrency efficiently in Java, Orc uses
cooperative threading.  Orc programs are broken into discrete steps which
are executed by a fixed-size thread pool.  This approach works for Orc
expressions, but the internals of an Orc site written in Java cannot be easily
broken down.  So Orc has two choices when it needs to call a local Java site:
</p><div class="itemizedlist"><ul type="disc"><li>Run the site call in a new thread.  This means site calls never
unnecessarily block the Orc engine, but it also limits the number of concurrent
site calls an Orc program can make.</li><li>Run the site call in the same thread as the Orc engine, which
conserves thread resources but may block the engine from making further
progress until the site call finishes.</li></ul></div><p>
Fortunately, in practice most Orc site calls take a short, deterministic amount
of time to complete. Of those that don't, it's usually only because they are
blocked waiting for some external event, like another site call.  In this case,
instead of blocking the site can return control to the Orc engine, asking to
be run again when the external event occurs.  In typical Java applications this
kind of non-blocking behavior is implemented using callbacks (or in its most
general form, continuation passing).  Unfortunately this creates convoluted and
verbose code: what if you need to block in the middle of a <code class="code"><span class="hl-keyword">for</span></code> loop, for example?
</p><p>
<a class="ulink" href="http://kilim.malhar.net/" target="_top">Kilim</a> resolves this issue by
allowing programmers to write code in a natural blocking style and then
manipulating the bytecode to perform a form of CPS conversion, so that instead
of blocking the code actually returns control to a scheduler. Orc incorporates
Kilim to allow site authors to write sites with internal concurrency and
blocking behavior which don't use Java threads and cooperate with the Orc
engine.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N11299"></a>3.1.6.2.&nbsp;Kilim Tutorial</h4></div></div></div><p>
For a full introduction to <a class="ulink" href="http://kilim.malhar.net/" target="_top">Kilim</a>, see <a class="ulink" href="http://www.malhar.net/sriram/kilim/thread_of_ones_own.pdf" target="_top">A Thread of
One's Own</a>, by Sriram Srinivasan. In the following, we will cover just
enough to get you started writing Orc sites using Kilim.
</p><p>
Kilim introduces three key primitives:
<div class="variablelist"><dl><dt><span class="term">
<code class="code">Pausable</code>
</span></dt><dd>
This checked exception marks methods which may block
<sup>[<a href="#ftn.N112B2" name="N112B2" class="footnote">1</a>]</sup>. You should never catch
this exception, and you should always declare it even if you have already
declared <code class="code"><span class="hl-keyword">throws</span> Exception</code> or <code class="code"><span class="hl-keyword">throws</span> Throwable</code>.  In all other respects it follows the
normal rules for checked exceptions: an override can only throw it if the
superclass method throws it, and you must throw it if you call any method which
throws it.
</dd><dt><span class="term">
<code class="code">Mailbox</code>
</span></dt><dd>
A multiple-producer, single-consumer queue used to communicate
between tasks. The most important methods are <code class="code">put(Object)</code>, which places an item in the
mailbox, and <code class="code">get()</code>, which blocks until the mailbox
is non-empty and then returns the first item.

</dd><dt><span class="term">
<code class="code">Task</code>
</span></dt><dd>
Cooperative analogue of a Thread. Every pausable method must be run within a
task. To create and run a task:

<pre class="programlisting">
<span class="hl-keyword">new</span> Task() {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute() <span class="hl-keyword">throws</span> Pausable {
        <span class="hl-comment">// do some stuff</span>
    }
}.start();
</pre></dd></dl></div>
</p><p>
When writing Orc sites you rarely need to use tasks explicitly because every Orc
site call is implicitly run inside a Kilim task if necessary. Therefore all you need to do is mark
<code class="code">Pausable</code> methods. Here's a short example of a
buffer site written using Kilim <code class="code">Mailbox</code>es:

<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> KilimBuffer&lt;V&gt; {
	<span class="hl-keyword">private</span> LinkedList&lt;Mailbox&lt;V&gt;&gt; waiters =
		<span class="hl-keyword">new</span> LinkedList&lt;Mailbox&lt;V&gt;&gt;();
	<span class="hl-keyword">private</span> LinkedList&lt;V&gt; buffer = <span class="hl-keyword">new</span> LinkedList&lt;V&gt;();
	<span class="hl-keyword">public</span> <span class="hl-keyword">synchronized</span> <span class="hl-keyword">void</span> put(V o) <span class="hl-keyword">throws</span> Pausable {
		Mailbox&lt;V&gt; waiter = waiters.poll();
		<span class="hl-keyword">if</span> (waiter != null) waiter.put(o);
		<span class="hl-keyword">else</span> buffer.add(o);
	}
	<span class="hl-keyword">public</span> <span class="hl-keyword">synchronized</span> V get() <span class="hl-keyword">throws</span> Pausable {
		V out = buffer.poll();
		<span class="hl-keyword">if</span> (out != null) <span class="hl-keyword">return</span> out;
		<span class="hl-keyword">else</span> {
			Mailbox&lt;V&gt; waiter = <span class="hl-keyword">new</span> Mailbox&lt;V&gt;();
			waiters.add(waiter);
			<span class="hl-keyword">return</span> waiter.get();
		}
	}
}</pre>
</p><p>Classes using Kilim can be imported like other Java classes using the Orc
<code class="code"><span class="hl-keyword">class</span></code> declaration.  For example, we can use the
<code class="code"><span class="hl-variable">KilimBuffer</span></code> class defined above:
<pre class="programlisting">
<span class="hl-keyword">class</span> <span class="hl-variable">Buffer</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">lib</span>.<span class="hl-variable">state</span>.<span class="hl-variable">KilimBuffer</span>
<span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="hl-site">Buffer</span>()
  <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">put</span>(<span class="hl-literal">"1 second later"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">null</span>
<span class="hl-combinator">|</span> <span class="hl-variable">b</span>.<span class="hl-site">get</span>()</pre>
</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
The version of Kilim bundled with Orc does not support calls to pausable
methods in constructor arguments. For example, this does not work:
<pre class="programlisting">
<span class="hl-keyword">new</span> Foo(bar.pausable());
</pre>
The workaround is to use a temporary variable:
<pre class="programlisting">
Object tmp = bar.pausable();
<span class="hl-keyword">new</span> Foo(tmp);
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N11301"></a>3.1.6.3.&nbsp;When you must block</h4></div></div></div><p>
Sometimes blocking is unavoidable, for example if a site must perform blocking
IO.  For such cases, Orc provides a utility method <code class="code">orc.runtime.Kilim#runThreaded(Callable)</code> which farms work
out to a thread pool.  The advantage of doing this over spawning your own
thread is that there is no chance of using too many threads; if no thread is
available, the method pauses until one becomes available.  The disadvantage is
that if you have too many Java methods which must communicate with each other
concurrently and can't use Mailboxes, there won't be enough threads for them
all and execution will deadlock.  This situation is sufficiently rare that
<code class="code">runThreaded</code> is usually the correct approach.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1130E"></a>3.1.6.4.&nbsp;Compiling Kilim Sites</h4></div></div></div><p>
Code which uses Kilim annotations must be processed after compiling and before
running, with the Kilim "weaver".  For example, if your <code class="filename">.class</code> files
are in <code class="filename">./build</code>, you would run the weaver like this:
</p><pre class="programlisting">
java -cp orc-0.9.3.jar:lib/kilimex.jar:./build \
  kilim.tools.Weaver -d ./build ./build</pre><p>
The Orc source distribution includes an ant <span class="command"><strong>kilim</strong></span> task in
<code class="filename">build.xml</code> to do exactly this.
</p></div></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N112B2" name="ftn.N112B2" class="para">1</a>] </sup>Originally Kilim used annotations to mark pausable methods. It turned
out that <span class="command"><strong>javac</strong></span> would sometimes manipulate code in ways which violate the
invariants regarding use of the annotation. Annotations also have the
disadvantage that the invariants on their use are not checked automatically by
tools like Eclipse.</p></div></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch02s03.html">Prev</a>&nbsp;</td><td align="center" width="20%">&nbsp;</td><td align="right" width="40%">&nbsp;<a accesskey="n" href="apa.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">2.3.&nbsp;Larger Examples&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;Appendix&nbsp;A.&nbsp;Complete Syntax of Orc</td></tr></table></div></body></html>