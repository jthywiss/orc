<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4.2.&nbsp;Polymorphism</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide v1.0.0"><link rel="up" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Type Checking"><link rel="prev" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Type Checking"><link rel="next" href="ch04s03.html" title="4.3.&nbsp;Interacting with Java"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">4.2.&nbsp;Polymorphism</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch04.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;4.&nbsp;Type Checking</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch04s03.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1192A"></a>4.2.&nbsp;Polymorphism</h2></div></div></div>

In this section we examine a powerful feature of Orc's typechecker: <span class="emphasis"><em>parametric polymorphism</em></span>.
This allows us to define types that take other types as parameters; the same theory underlies Java's generics.


 
<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11931"></a>4.2.1.&nbsp;Parametric types</h3></div></div></div><p>
What is the type of <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>]</code>? It is a list, containing Integers. What about <code class="code">[<span class="hl-literal">true</span>, <span class="hl-literal">true</span>]</code>?
Again a list, but it contains Booleans instead. It would be very cumbersome to have separate types such
as <code class="code"><span class="hl-variable">IntegerList</span></code> and <code class="code"><span class="hl-variable">BooleanList</span></code> for each of these possibilities, and in fact
infinitely many such types are possible. What we would like instead is one <code class="code"><span class="hl-variable">List</span></code> type, with
a parameter which gives us the types contained in the list.
</p><p>
Such a type is called a parametric, or generic, type. It contains two parts: a type operator, such as
<code class="code"><span class="hl-variable">List</span></code>, followed by a sequence of paramemters enclosed in brackets <code class="code">[...]</code>. 
For example, <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>] :: <span class="hl-site">List</span>[<span class="hl-variable">Integer</span>]</code>, and <code class="code">[<span class="hl-literal">true</span>,<span class="hl-literal">true</span>] :: <span class="hl-site">List</span>[<span class="hl-variable">Boolean</span>]</code>.
</p><p>
Lists are not the only parametric type. The standard library includes other parametric types, such as
<code class="code"><span class="hl-variable">Option</span></code>, <code class="code"><span class="hl-variable">Buffer</span></code>, and <code class="code"><span class="hl-variable">Cell</span></code>. Type operators, such as <code class="code"><span class="hl-variable">List</span></code>,
are declared using the same <code class="code"><span class="hl-keyword">type</span></code> declarations as any other type. For example, the
declaration

<pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-variable">Buffer</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">lib</span>.<span class="hl-variable">state</span>.<span class="hl-variable">types</span>.<span class="hl-variable">BufferType</span>
</pre>

is part of the standard library; it declares the <code class="code"><span class="hl-variable">Buffer</span></code> type operator. 
 
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1196B"></a>4.2.2.&nbsp;Parametric functions</h3></div></div></div><p>
How do we write functions that use parametric types? Consider the following definition
of the <code class="code"><span class="hl-variable">append</span></code> function, which appends two lists:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">append</span>[<span class="hl-variable">T</span>](<span class="hl-site">List</span>[<span class="hl-variable">T</span>], <span class="hl-site">List</span>[<span class="hl-variable">T</span>]) :: <span class="hl-site">List</span>[<span class="hl-variable">T</span>]
<span class="hl-keyword">def</span> <span class="hl-site">append</span>([], <span class="hl-variable">l</span>) = <span class="hl-variable">l</span>
<span class="hl-keyword">def</span> <span class="hl-site">append</span>(<span class="hl-variable">h</span>::<span class="hl-variable">t</span>, <span class="hl-variable">l</span>) = <span class="hl-variable">h</span>::<span class="hl-site">append</span>(<span class="hl-variable">t</span>,<span class="hl-variable">l</span>)
</pre>

The function <code class="code"><span class="hl-variable">append</span></code> has a <span class="emphasis"><em>type argument</em></span>, T, in its
signature. The type T is the type of elements in the lists that we are appending. Notice that both argument
lists must contain the same type of elements. The resulting list contains elements of that same type.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1197D"></a>4.2.3.&nbsp;Generic calls</h3></div></div></div><p>
When calling the <code class="code"><span class="hl-variable">append</span></code> function, in addition to providing its normal arguments, we must
also provide its type argument:

<pre class="programlisting">
<span class="hl-site">append</span>[<span class="hl-variable">Integer</span>]([<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>], [<span class="hl-literal">4</span>,<span class="hl-literal">5</span>])
</pre>

However, it would be very burdensome and verbose to provide type arguments to all such calls. Fortunately,
in most cases, the type checker can infer the correct type arguments, in the same way that it infers
the correct type for many expressions without any additional information. So in this case, we can
simply write:

<pre class="programlisting">
<span class="hl-site">append</span>([<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>], [<span class="hl-literal">4</span>,<span class="hl-literal">5</span>])
</pre>

and the typechecker infers that the parameter T is <code class="code"><span class="hl-variable">Integer</span></code>, since both argument lists are
of type <code class="code"><span class="hl-site">List</span>[<span class="hl-variable">Integer</span>]</code>. For a more thorough explanation of how this inference occurs, please
refer to Pierce and Turner's paper.
</p><p>
Inference of type arguments will always fail on certain kinds of calls, because the typechecker does
not have enough information to infer the correct type. The most common case is a site call which
constructs a parametric type without taking any arguments. For example:

<pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="hl-site">Buffer</span>()
</pre>

will never typecheck, since there is no way for the typechecker to know what type of elements the
buffer should contain. In other languages such as ML, the typechecker might be able to infer this information
from the rest of the program, but Orc's typechecker is based on <span class="emphasis"><em>local</em></span> type inference,
which must find the information locally, such as from the types of the arguments. So, to construct
a buffer that will contain Numbers, a type parameter must be given:

<pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="hl-site">Buffer</span>[<span class="hl-variable">Number</span>]()
</pre>

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N119A0"></a>4.2.4.&nbsp;Polymorphic aliases</h3></div></div></div><p>
A type alias may have type parameters. For example, here is a type alias for triples:

<pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-site">Triple</span>[<span class="hl-variable">T</span>] = (<span class="hl-variable">T</span>,<span class="hl-variable">T</span>,<span class="hl-variable">T</span>)
</pre>

<code class="code"><span class="hl-variable">Triple</span></code> is now a type operator that takes one parameter. Any occurrence of
<code class="code"><span class="hl-site">Triple</span>[<span class="hl-variable">T</span>]</code> is equivalent to <code class="code">(<span class="hl-variable">T</span>,<span class="hl-variable">T</span>,<span class="hl-variable">T</span>)</code>.

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N119B2"></a>4.2.5.&nbsp;Polymorphic datatypes</h3></div></div></div><p>
Datatypes can also have type parameters. This allows a programmer to
define very useful generic data structures. For example, this is necessary
to define a reasonable datatype for trees:

<pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-site">Tree</span>[<span class="hl-variable">T</span>] = <span class="hl-site">Node</span>(<span class="hl-site">Tree</span>[<span class="hl-variable">T</span>], <span class="hl-site">Tree</span>[<span class="hl-variable">T</span>], <span class="hl-variable">T</span>) <span class="hl-combinator">|</span> <span class="hl-site">Leaf</span>()
</pre>

Notice that the datatype is recursive, and the type parameter <code class="code"><span class="hl-variable">T</span></code> is
passed recursively to <code class="code"><span class="hl-variable">Tree</span></code> to define the type of the subtrees. 

</p></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch04.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch04.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch04s03.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Chapter&nbsp;4.&nbsp;Type Checking&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;4.3.&nbsp;Interacting with Java</td></tr></table></div></body></html>