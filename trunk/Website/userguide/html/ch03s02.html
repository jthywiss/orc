<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3.2.&nbsp;Cooperative Scheduling</title><link href="style.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link rel="prev" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link rel="next" href="apa.html" title="Appendix&nbsp;A.&nbsp;Complete Syntax of Orc"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">3.2.&nbsp;Cooperative Scheduling</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="apa.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10FCE"></a>3.2.&nbsp;Cooperative Scheduling</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10FD1"></a>3.2.1.&nbsp;Overview</h3></div></div></div><p>
Because Orc makes concurrency so easy, Orc programs often involve thousands of
concurrent processes. In order to support this much concurrency efficiently in
Java, Orc uses cooperative threading, where each Orc program is broken into
small steps which are executed by a fixed-size thread pool.  This works fine
for Orc expressions, but the internals of an Orc site written in Java cannot be
easily broken down. So Orc has two choices when it needs to call a local Java
site:
</p><div class="itemizedlist"><ul type="disc"><li>Run the site call in a new thread.  This means site calls never
unnecessarily block the Orc engine, but it also limits the number of concurrent
site calls an Orc program can make.</li><li>Run the site call in the same thread as the Orc engine, which
conserves thread resources but may block the engine from making further
progress until the site call finishes.</li></ul></div><p>
Fortunately, in practice most Orc site calls take a short, deterministic amount
of time to complete. Of those that don't, it's usually only because they are
blocked waiting for some external event, like another site call.  In this case,
instead of blocking the site could return control to the Orc engine, asking to
be run again when the external event occurs.
</p><p>
Often this kind of non-blocking behavior is implemented using callbacks (or
in its most general form, continuation passing). Unfortunately this creates
convoluted (and in Java, verbose) code: what if you need to block in the middle
of a <code class="code"><span class="hl-keyword">for</span></code> loop, for example?
</p><p>
<a class="ulink" href="http://kilim.malhar.net/" target="_top">Kilim</a> resolves this issue by
allowing programmers to write code in a natural blocking style and then
manipulating the bytecode to perform a kind of CPS conversion, so that instead
of blocking the code actually returns control to a scheduler. Orc incorporates
Kilim to allow site authors to write sites with internal concurrency and
blocking behavior which don't use Java threads and play nicely with the Orc
engine.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10FE9"></a>3.2.2.&nbsp;Kilim Tutorial</h3></div></div></div><p>
For a full introduction to Kilim, see <a class="ulink" href="http://www.malhar.net/sriram/kilim/thread_of_ones_own.pdf" target="_top">A Thread of
One's Own</a>, by Sriram Srinivasan. In the following, we will cover just
enough to get you started writing Orc sites using Kilim.
</p><p>
Kilim introduces three key primitives:
<div class="variablelist"><dl><dt><span class="term">
<code class="code">Pausable</code>
</span></dt><dd>
This checked exception marks methods which may block
<sup>[<a href="#ftn.N10FFE" name="N10FFE" class="footnote">1</a>]</sup>. You should never catch
this exception, and you should always declare it even if you have already
declared <code class="code"><span class="hl-keyword">throws</span> Exception</code> or <code class="code"><span class="hl-keyword">throws</span> Throwable</code>. Otherwise it follows the normal rules
for checked exceptions: an override can only throw it if the superclass method
throws it, and you must throw it if you call any method which throws it.
</dd><dt><span class="term">
<code class="code">Mailbox</code>
</span></dt><dd>
A multiple-producer, single-consumer blocking queue used to communicate with tasks.
</dd><dt><span class="term">
<code class="code">Task</code>
</span></dt><dd>
Cooperative analogue of a Thread. A task looks like this:

<pre class="programlisting">
<span class="hl-keyword">new</span> Task() {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute() <span class="hl-keyword">throws</span> Pausable {
        <span class="hl-comment">// do some stuff</span>
    }
}.start();
</pre></dd></dl></div>
</p><p>
When writing Orc sites you rarely need to use tasks explicitly because each Orc
site call is implicitly run inside a Kilim task. So all you need to do is mark
<code class="code">Pausable</code> methods. Here's a short example of a
buffer site written using Kilim <code class="code">Mailbox</code>es:

<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> KilimBuffer&lt;V&gt; {
	<span class="hl-keyword">private</span> LinkedList&lt;Mailbox&lt;V&gt;&gt; waiters =
		<span class="hl-keyword">new</span> LinkedList&lt;Mailbox&lt;V&gt;&gt;();
	<span class="hl-keyword">private</span> LinkedList&lt;V&gt; buffer = <span class="hl-keyword">new</span> LinkedList&lt;V&gt;();
	<span class="hl-keyword">public</span> <span class="hl-keyword">synchronized</span> <span class="hl-keyword">void</span> put(V o) <span class="hl-keyword">throws</span> Pausable {
		Mailbox&lt;V&gt; waiter = waiters.poll();
		<span class="hl-keyword">if</span> (waiter != null) waiter.put(o);
		<span class="hl-keyword">else</span> buffer.add(o);
	}
	<span class="hl-keyword">public</span> <span class="hl-keyword">synchronized</span> V get() <span class="hl-keyword">throws</span> Pausable {
		V out = buffer.poll();
		<span class="hl-keyword">if</span> (out != null) <span class="hl-keyword">return</span> out;
		<span class="hl-keyword">else</span> {
			Mailbox&lt;V&gt; waiter = <span class="hl-keyword">new</span> Mailbox&lt;V&gt;();
			waiters.add(waiter);
			<span class="hl-keyword">return</span> waiter.get();
		}
	}
}</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11030"></a>3.2.3.&nbsp;Using Kilim in Orc</h3></div></div></div><p>
There are two ways to use Kilim-using sites from Orc. The simplest is to use
the <code class="code"><span class="hl-keyword">class</span></code> declaration. We can use the <code class="code"><span class="hl-variable">KilimBuffer</span></code>
class defined above as simply as:
<pre class="programlisting">
<span class="hl-keyword">class</span> <span class="hl-variable">Buffer</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">lib</span>.<span class="hl-variable">state</span>.<span class="hl-variable">KilimBuffer</span>
<span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="hl-site">Buffer</span>()
  <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">put</span>(<span class="hl-literal">"1 second later"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">null</span>
<span class="hl-combinator">|</span> <span class="hl-variable">b</span>.<span class="hl-site">get</span>()</pre>
</p><p>
For closer integration with Orc, you can extend <code class="code">KilimSite</code> like this:
<pre class="programlisting">
<span class="hl-comment">/** Publish a value after a delay of 1 second. */</span>
<span class="hl-keyword">class</span> MySite <span class="hl-keyword">extends</span> KilimSite {
    <span class="hl-keyword">public</span> Value evaluate(Args args) <span class="hl-keyword">throws</span> TokenException, Pausable {
        Task.sleep(<span class="hl-number">1000</span>);
        <span class="hl-keyword">return</span> args.valArg(<span class="hl-number">0</span>);
    }
}</pre>
</p><p>
Finally, any Orc site can run <code class="code">Task</code>s directly or
use the utility method <code class="code">orc.runtime.Kilim#runPausable(Token, Pausable)</code> to run a
task which produces a value for a token.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11052"></a>3.2.4.&nbsp;When you must block</h3></div></div></div><p>
Sometimes blocking is unavoidable, for example you have to do some blocking IO.  In this case there really is no alternative to spawning a thread.
</p><p>
Orc provides a utility method <code class="code">orc.runtime.Kilim#runThreaded(Callable)</code> which farms work
out to a thread pool. The advantage of doing this over spawning your own thread
is that there is no chance of using too many threads; if no thread is
available, the method pauses until one becomes available.  The disadvantage is
that if you have dozens of Java methods which must communicate with each other
concurrently and can't use Mailboxes, there won't be enough threads for them
all and you'll get deadlock. Fortunately this situation is probably quite rare and relatively easy to avoid,
so <code class="code">Kilim#runThreaded</code> is the way to go.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11061"></a>3.2.5.&nbsp;Compiling Kilim Sites</h3></div></div></div><p>
Code which uses Kilim annotations must be processed after compiling and before
running, with the Kilim "Weaver". E.g. if your <code class="filename">.class</code>
files are in <code class="filename">./build</code>:
</p><pre class="programlisting">
java -cp orc-0.9.3.jar:lib/kilimex.jar:./build kilim.tools.Weaver -d ./build ./build</pre><p>
The Orc source distribution includes an ant <span class="command"><strong>kilim</strong></span> task in
<code class="filename">build.xml</code> to do exactly this.
</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote">Originally Kilim used annotations to mark pausable methods. It turned
out that <span class="command"><strong>javac</strong></span> would sometimes manipulate code in ways which
violate the invariants regarding use of the annotation. Annotations also have
the disadvantage that the invariants on their use are not checked automatically
by tools like Eclipse.</div></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch03.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="apa.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;Appendix&nbsp;A.&nbsp;Complete Syntax of Orc</td></tr></table></div></body></html>