<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter&nbsp;4.&nbsp;Type Checking</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide v1.0.0"><link rel="up" href="index.html" title="Orc User Guide v1.0.0"><link rel="prev" href="ch03s04.html" title="3.4.&nbsp;Web Services"><link rel="next" href="ch04s02.html" title="4.2.&nbsp;Polymorphism"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter&nbsp;4.&nbsp;Type Checking</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch03s04.html">Prev</a>&nbsp;</td><th align="center" width="60%">&nbsp;</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch04s02.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chapter.typechecker"></a>Chapter&nbsp;4.&nbsp;Type Checking</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ch04.html#N1175F">4.1. Simple Typing</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#N11763">4.1.1. Values and Operators</a></span></dt><dt><span class="section"><a href="ch04.html#N1179A">4.1.2. 
                    signal and stop
                </a></span></dt><dt><span class="section"><a href="ch04.html#N117DA">4.1.3. Tuples</a></span></dt><dt><span class="section"><a href="ch04.html#N117E7">4.1.4. Combinators</a></span></dt><dt><span class="section"><a href="ch04.html#N11852">4.1.5. Conditionals</a></span></dt><dt><span class="section"><a href="ch04.html#N11863">4.1.6. Defined Functions</a></span></dt><dt><span class="section"><a href="ch04.html#N118BF">4.1.7. Ascriptions</a></span></dt><dt><span class="section"><a href="ch04.html#N118D1">4.1.8. Aliasing</a></span></dt><dt><span class="section"><a href="ch04.html#N118DF">4.1.9. Datatypes</a></span></dt><dt><span class="section"><a href="ch04.html#N118F0">4.1.10. Interacting with External Services</a></span></dt><dt><span class="section"><a href="ch04.html#N11919">4.1.11. Assertions</a></span></dt></dl></dd><dt><span class="section"><a href="ch04s02.html">4.2. Polymorphism</a></span></dt><dd><dl><dt><span class="section"><a href="ch04s02.html#N11931">4.2.1. Parametric types</a></span></dt><dt><span class="section"><a href="ch04s02.html#N1196B">4.2.2. Parametric functions</a></span></dt><dt><span class="section"><a href="ch04s02.html#N1197D">4.2.3. Generic calls</a></span></dt><dt><span class="section"><a href="ch04s02.html#N119A0">4.2.4. Polymorphic aliases</a></span></dt><dt><span class="section"><a href="ch04s02.html#N119B2">4.2.5. Polymorphic datatypes</a></span></dt></dl></dd><dt><span class="section"><a href="ch04s03.html">4.3. Interacting with Java</a></span></dt><dt><span class="section"><a href="ch04s04.html">4.4. Syntax of Typed Orc</a></span></dt></dl></div><p>
The Orc language, as it is described in <a class="link" href="ch01.html" title="Chapter&nbsp;1.&nbsp;The Orc Programming Language">Chapter 1</a>, is
dynamically typed. If an operation occurs at runtime which is not type-correct, the call
which attempted that operation becomes silent, and produces a type error that is reported
on the console. 
</p><p>
Orc also has an optional static typechecker, which will guarantee that a program is
free of type errors before the program is run. For every expression in the program,
the typechecker tries to find the types of values that it could publish, 
and checks that all such types are consistent. It performs a limited form of
<span class="emphasis"><em>type inference</em></span>, so it can discover many types automatically;
however, the programmer must provide additional type information for defined functions,
and in a few other specific cases.
</p><p>
The typechecker uses the local type inference algorithm described by Pierce and Turner in their paper, 
<a class="link" href="http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf" target="_top">Local Type Inference</a>.
It extends this algorithm with polymorphic type constructors (e.g. <code class="code"><span class="hl-variable">List</span></code> and
<code class="code"><span class="hl-variable">Buffer</span></code>), user-defined datatypes (which may also be polymorphic),
and a typing strategy for external services. The typechecker supports both 
<span class="emphasis"><em>parametric polymorphism</em></span> (generics) and 
<span class="emphasis"><em>inclusion polymorphism</em></span> (subtyping), 
though it does not currently implement the extended version 
of the algorithm which allows both of them simultaneously (bounded polymorphism).
</p><p>
The typechecker is disabled by default, though typed syntax is still permitted (and types are still
checked for syntax errors) even when the typechecker is not used. It may be enabled as a project
property in the Eclipse plugin, or by using the <code class="code">-<span class="hl-variable">typecheck</span></code> switch on the command line. 
</p><p>
If the typechecker can verify that a program is correctly typed, it will display the message
</p><p>
<code class="code">... :: </code>T
</p><p>
on the console. The symbol <code class="code">::</code> means "has type", and T is the type of any value that
the program might publish.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1175F"></a>4.1.&nbsp;Simple Typing</h2></div></div></div>

In this section we will see how Orc programs are typechecked, starting with
simple expressions like constants and arithmetic operations, and working up to more interesting
cases such as defined functions, the concurrency combinators, and calls to external services.

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11763"></a>4.1.1.&nbsp;Values and Operators</h3></div></div></div><p>
Each of the Orc constants has the expected type:

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-literal">true</span> , <span class="hl-literal">false</span></code><code class="code"> :: </code><code class="code"><span class="hl-variable">Boolean</span></code></li><li> ... <code class="code"> -<span class="hl-literal">1</span>, <span class="hl-literal">0</span>, <span class="hl-literal">1</span> </code> ... <code class="code"> :: </code><code class="code"><span class="hl-variable">Integer</span></code></li><li> ... <code class="code"> <span class="hl-literal">"orc"</span> , <span class="hl-literal">"ceci n'est pas une |"</span></code> ... <code class="code"> :: </code><code class="code"><span class="hl-variable">String</span></code></li><li> ... <code class="code"> <span class="hl-literal">0.001</span>, -<span class="hl-literal">1.5</span>, <span class="hl-literal">2.71828</span> </code> ... <code class="code"> :: </code><code class="code"><span class="hl-variable">Number</span></code></li></ul></div>

Orc allows <span class="emphasis"><em>subtyping</em></span>: some types are included in other types. For example,
Integer is a subtype of Number, because all Integers are also Numbers. 
</p><p>
Each of the primitive operators typechecks in the obvious way; for example <code class="code">&amp;&amp;</code> requires
two Boolean operands and returns a Boolean result. Some of the arithmetic operators also support
<span class="emphasis"><em>ad-hoc polymorphism</em></span>; for example, a <code class="code">+</code> expression with two Integer 
operands has type Integer, but with one or more Number operands it instead has type Number. 


</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1179A"></a>4.1.2.&nbsp;
                    <code class="code"><span class="hl-keyword">signal</span></code> and <code class="code"><span class="hl-keyword">stop</span></code>
                </h3></div></div></div><p>
There are two other important types:

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-keyword">signal</span> :: <span class="hl-variable">Top</span></code></li><li><code class="code"><span class="hl-keyword">stop</span> :: <span class="hl-variable">Bot</span></code></li></ul></div>

</p><p>
<code class="code"><span class="hl-variable">Top</span></code> is the universal type; it is the type of any value, and all other types are subtypes 
of it. In particular, signals only have type <code class="code"><span class="hl-variable">Top</span></code>, since they carry no information.
</p><p>
<code class="code"><span class="hl-variable">Bot</span></code> is the empty type; no value has type <code class="code"><span class="hl-variable">Bot</span></code>. It is a subtype of all other
types. Expressions with type <code class="code"><span class="hl-variable">Bot</span></code> are expressions that the typechecker can verify will
never publish any values. In particular, <code class="code"><span class="hl-keyword">stop</span></code> will never publish, so it has type <code class="code"><span class="hl-variable">Bot</span></code>.
</p><p>
<code class="code"><span class="hl-variable">Bot</span></code> has an interesting status in Orc. In other typed languages, if an expression
has type <code class="code"><span class="hl-variable">Bot</span></code>, this usually indicates a guaranteed error, infinite loop, or other failure
to return a value. Since sequential programming rarely involves subexpressions that are guaranteed
never to return, <code class="code"><span class="hl-variable">Bot</span></code> is usually just a curiosity or a formal artifact of the type system,
and indeed many static type systems do not have a <code class="code"><span class="hl-variable">Bot</span></code> type at all. 
In Orc, however, <code class="code"><span class="hl-variable">Bot</span></code> is very useful, since it is frequently the case that Orc expressions 
are written to carry out ongoing concurrent activities but never publish any values, and the type system 
can use the type <code class="code"><span class="hl-variable">Bot</span></code> to indicate that no publications will ever be seen from such
expressions.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N117DA"></a>4.1.3.&nbsp;Tuples</h3></div></div></div><p>
The type of a tuple is a tuple of the types of each of its elements.

<div class="itemizedlist"><ul type="disc"><li><code class="code">(<span class="hl-literal">3</span>+<span class="hl-literal">3</span>, <span class="hl-literal">true</span>) :: (<span class="hl-variable">Integer</span>, <span class="hl-variable">Boolean</span>)</code></li><li><code class="code">(<span class="hl-literal">"orc"</span>, (<span class="hl-literal">2</span>, <span class="hl-literal">"orc"</span>)) :: (<span class="hl-variable">String</span>, (<span class="hl-variable">Integer</span>, <span class="hl-variable">String</span>))</code></li></ul></div>

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N117E7"></a>4.1.4.&nbsp;Combinators</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N117EA"></a>4.1.4.1.&nbsp;Parallel</h4></div></div></div><p>
The type of F <code class="code"><span class="hl-combinator">|</span></code> G is the <span class="emphasis"><em>join</em></span> of the types of F and G.
</p><p>
A <span class="emphasis"><em>common supertype</em></span> of two types S and T is any type U such that 
S and T are both subtypes of U. The join J is the <span class="emphasis"><em>least</em></span> common 
supertype of S and T, that is, J is a common supertype, and J is also a subtype of every other 
common supertype.
</p><p>
The most common case is the join of a type T with itself. Then the join is just T.
This happens when both parallel branches publish the same type of values.

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-literal">3</span>+<span class="hl-literal">4</span> <span class="hl-combinator">|</span> <span class="hl-literal">5</span>  ::  <span class="hl-variable">Integer</span></code></li></ul></div>
</p><p>
If S is a subtype of T, the join of S and T is T. This happens when one branch
is publishing a less specific type of value. To be safe, the whole expression
then has that less specific type.

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">3.1</span>  ::  <span class="hl-variable">Number</span></code></li></ul></div>

</p><p>
As a special case, the join of any type T with <code class="code"><span class="hl-variable">Bot</span></code> is T. This occurs
when one branch publishes values and the other one never publishes. Thus, it is
safe to use the type of values from the first branch, since the second branch
contributes no values at all.

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-literal">"all quiet on the western front"</span> <span class="hl-combinator">|</span> <span class="hl-site">EasternFront</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>  ::  <span class="hl-variable">String</span></code></li></ul></div>
 
</p><p>
In any other case, the typechecker will try to infer the join. However, it
may not always find the least supertype, and in some cases there may not
even be a useful common supertype. In these cases it will default to
the <code class="code"><span class="hl-variable">Top</span></code> type, which is a supertype of all other types, and is
therefore always a safe join, if not a very useful one.

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">"three"</span>  ::  <span class="hl-variable">Top</span></code></li></ul></div>

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1181F"></a>4.1.4.2.&nbsp;Sequential</h4></div></div></div><p>
The type of F <code class="code">&gt;<span class="hl-variable">x</span>&gt;</code> G is the type of G using the assumption x :: T, where T is the type of F.
</p><p>
If a pattern is used instead of a variable, the structure of the pattern must match the structure
of the type of F, and the types for each variable bound in G are taken from the corresponding
pieces of the type of F. For example, in the expression F <code class="code">&gt;(<span class="hl-variable">x</span>,<span class="hl-variable">b</span>)&gt;</code> G,
where F <code class="code">:: (<span class="hl-variable">Integer</span>, <span class="hl-variable">Boolean</span>)</code>, G is typechecked with the assumptions <code class="code"><span class="hl-variable">x</span> :: <span class="hl-variable">Integer</span></code>
and <code class="code"><span class="hl-variable">b</span> :: <span class="hl-variable">Boolean</span></code>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N11835"></a>4.1.4.3.&nbsp;Pruning</h4></div></div></div><p>
The type of F <code class="code">&lt;<span class="hl-variable">x</span>&lt;</code> G is the type of F using the assumption x :: T, where T is the type of G.
</p><p>
When a declaration <code class="code"><span class="hl-keyword">val</span> <span class="hl-variable">x</span> = </code> F occurs, the expression in scope for the declaration
is typechecked using the assumption x :: T, where T is the type of F.
</p><p>
Patterns in the pruning combinator and in <code class="code"><span class="hl-keyword">val</span></code> declarations are typechecked in the same way as in the sequential combinator.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N11847"></a>4.1.4.4.&nbsp;Otherwise</h4></div></div></div><p>
The type of F <code class="code"><span class="hl-combinator">;</span></code> G is the <span class="emphasis"><em>join</em></span> of the types of F and G, as described for the parallel combinator.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11852"></a>4.1.5.&nbsp;Conditionals</h3></div></div></div><p>
In the conditional expression <code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G, the expression E must have type
<code class="code"><span class="hl-variable">Boolean</span></code>, and the type of the whole expression is the join of the types of F and G, as described for the
parallel combinator.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11863"></a>4.1.6.&nbsp;Defined Functions</h3></div></div></div><p>
Though the typechecker can infer the types of many expressions without additional information from the programmer, there are some
cases where the algorithm does need assistance. In particular, whenever a function is defined (using the <code class="code"><span class="hl-keyword">def</span></code> keyword),
the programmer must also include a <span class="emphasis"><em>signature</em></span> for that function, supplying its argument types and return type.
</p><p>
A signature immediately precedes a function definition, and is written as follows:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">magsq</span>(<span class="hl-variable">Number</span>, <span class="hl-variable">Number</span>) :: <span class="hl-variable">Number</span>
<span class="hl-keyword">def</span> <span class="hl-site">magsq</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) = <span class="hl-variable">x</span>*<span class="hl-variable">x</span> + <span class="hl-variable">y</span>*<span class="hl-variable">y</span>
</pre>

Argument types replace the arguments, <code class="code">::</code> replaces <code class="code">=</code>, and the return type (the type of the body expression)
replaces the body expression. If the function is not recursive, then the return type is optional, because the typechecker can infer it from
the body expression without additional information. So, in this case, we could have just written:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">magsq</span>(<span class="hl-variable">Number</span>, <span class="hl-variable">Number</span>)
<span class="hl-keyword">def</span> <span class="hl-site">magsq</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) = <span class="hl-variable">x</span>*<span class="hl-variable">x</span> + <span class="hl-variable">y</span>*<span class="hl-variable">y</span>
</pre>
</p><p>
It is also possible to include the argument types and return type directly in a definition, rather than as a separate signature. 
The signature and definition above could be written together as:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">magsq</span>(<span class="hl-variable">x</span> :: <span class="hl-variable">Number</span>, <span class="hl-variable">y</span> :: <span class="hl-variable">Number</span>) :: <span class="hl-variable">Number</span> = <span class="hl-variable">x</span>*<span class="hl-variable">x</span> + <span class="hl-variable">y</span>*<span class="hl-variable">y</span>
</pre>

An argument <code class="code"><span class="hl-variable">x</span></code> with type <code class="code"><span class="hl-variable">T</span></code> is replaced by <code class="code"><span class="hl-variable">x</span> :: <span class="hl-variable">T</span></code> in the argument list. The return type is inserted
between the argument list and the <code class="code">=</code> sign. This form is not typically used for functions with multiple clauses or pattern
matches, though it is allowed in those cases so long as only one clause has the type information.
</p><p>
<code class="code"><span class="hl-keyword">lambda</span></code> expressions are a special case: the type information must be included directly in this way,
since there is no way to declare the signature separately. Specifying the return type of a lambda is always optional,
since it is not possible for an anonymous function to make a recursive call. Written as a typed lambda function, the <code class="code"><span class="hl-variable">magsq</span></code>
definition looks like:

<pre class="programlisting">
<span class="hl-keyword">lambda</span> (<span class="hl-variable">x</span> :: <span class="hl-variable">Number</span>, <span class="hl-variable">y</span> :: <span class="hl-variable">Number</span>) = <span class="hl-variable">x</span>*<span class="hl-variable">x</span> + <span class="hl-variable">y</span>*<span class="hl-variable">y</span>
</pre>

When the typechecker has enough information to check the type of a lambda against a given function type, rather than needing to infer it, 
the argument types of the lambda are also optional. This occurs, for example, when a lambda is given as an argument to a defined higher-order function.
</p><p>
Once defined, functions are values, and thus have a special type of their own. The type of a function is written
very much like a signature, but using the <code class="code"><span class="hl-keyword">lambda</span></code> keyword instead of <code class="code"><span class="hl-keyword">def</span></code> and the function
name.

<div class="itemizedlist"><ul type="disc"><li><code class="code"><span class="hl-variable">magsq</span></code>, defined earlier, has type <code class="code"><span class="hl-keyword">lambda</span> (<span class="hl-variable">Number</span>, <span class="hl-variable">Number</span>) :: <span class="hl-variable">Number</span></code></li><li><code class="code"><span class="hl-keyword">lambda</span> (<span class="hl-variable">x</span> :: <span class="hl-variable">Integer</span>) = <span class="hl-variable">x</span>+<span class="hl-literal">1</span></code>  has type  <code class="code"><span class="hl-keyword">lambda</span> (<span class="hl-variable">Integer</span>) :: <span class="hl-variable">Integer</span></code></li><li><code class="code"><span class="hl-keyword">lambda</span> () = <span class="hl-keyword">signal</span></code> has type <code class="code"><span class="hl-keyword">lambda</span> () :: <span class="hl-variable">Top</span></code></li><li><code class="code"><span class="hl-keyword">lambda</span> (<span class="hl-variable">a</span> :: <span class="hl-variable">Boolean</span>, <span class="hl-variable">b</span> :: <span class="hl-variable">Boolean</span>) = (<span class="hl-variable">b</span>,<span class="hl-variable">a</span>)</code> has type <code class="code"><span class="hl-keyword">lambda</span> (<span class="hl-variable">Boolean</span>,<span class="hl-variable">Boolean</span>) :: (<span class="hl-variable">Boolean</span>,<span class="hl-variable">Boolean</span>)</code></li></ul></div>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N118BF"></a>4.1.7.&nbsp;Ascriptions</h3></div></div></div><p>
In addition to annotation defined functions with a signature, the typechecker can also accept programmer-supplied type
information for any expression. An <span class="emphasis"><em>ascription</em></span>, written E <code class="code">::</code> T, asks the typechecker 
to verify that expression E has type T.
</p><p>
Normally, the typechecker would simply find the type of E by inference, but in certain situations it is easier to check
a given type. For example, the typechecker may not be able to infer the correct join type for a parallel combinator,
but it is always able to check that both branches are subtypes of an already provided type. Furthermore, adding extra
type information makes it easier to pinpoint the source of a typechecking failure.
</p><p>
Ascriptions are also allowed in patterns; P <code class="code">::</code> T is a valid pattern, instructing the typechecker to verify
that the value fragment bound by the pattern P will always be of type T.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N118D1"></a>4.1.8.&nbsp;Aliasing</h3></div></div></div>

When adding function signatures and ascriptions, it is often helpful to have simpler names for
complex types that frequently occur. In the same way that variable binding can be used to give
a name to a complex value, there is a type declaration that binds a complex type to a type variable.
This is called <span class="emphasis"><em>aliasing</em></span>, and it is accomplished using the <code class="code"><span class="hl-keyword">type</span></code>
definition. 

<pre class="programlisting">
<span class="hl-comment">-- A rectangle is defined by its lower left and upper right coordinates.</span>
<span class="hl-keyword">type</span> <span class="hl-variable">Rect</span> = ((<span class="hl-variable">Number</span>, <span class="hl-variable">Number</span>), (<span class="hl-variable">Number</span>, <span class="hl-variable">Number</span>))

<span class="hl-comment">-- Transpose such a rectangle, rotating it around an x=y axis</span>
<span class="hl-keyword">def</span> <span class="hl-site">flip</span>(<span class="hl-variable">Rect</span>) :: <span class="hl-variable">Rect</span>
<span class="hl-keyword">def</span> <span class="hl-site">flip</span>( ((<span class="hl-variable">a</span>, <span class="hl-variable">b</span>), (<span class="hl-variable">c</span>, <span class="hl-variable">d</span>)) ) = ((<span class="hl-variable">a</span>, <span class="hl-variable">b</span>), (<span class="hl-variable">d</span>, <span class="hl-variable">c</span>))
</pre>

While it does not change the behavior of the typing algorithm, aliasing can substantially improve
readability and make the intention of one's code much clearer.

</div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N118DF"></a>4.1.9.&nbsp;Datatypes</h3></div></div></div>

We have already seen user-defined datatypes in the untyped Orc language. In the typed language, they are
declared in the same way, except that the slots in the datatype, which previously were always <code class="code"><span class="hl-variable">_</span></code>,
now contain the actual types that go in those slots. As an example, here is a datatype for geometric
shapes.

<pre class="programlisting">
<span class="hl-comment">{- 
  Rect(w,h): A rectangle with width w and height h. 
  Circle(r): A circle with radius r.
  RegularPolygon(n,l): A regular polygon with n sides, each of length l.
-}</span>
<span class="hl-keyword">type</span> <span class="hl-variable">Shape</span> = <span class="hl-site">Rect</span>(<span class="hl-variable">Number</span>, <span class="hl-variable">Number</span>) <span class="hl-combinator">|</span> <span class="hl-site">Circle</span>(<span class="hl-variable">Number</span>) <span class="hl-combinator">|</span> <span class="hl-site">RegularPolygon</span>(<span class="hl-variable">Integer</span>, <span class="hl-variable">Number</span>)
</pre>

We will see how to declare generic datatypes, like <code class="code"><span class="hl-variable">Tree</span></code> or <code class="code"><span class="hl-variable">Option</span></code>, in the next section.

</div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N118F0"></a>4.1.10.&nbsp;Interacting with External Services</h3></div></div></div>

In addition to verifying the correctness of code written within Orc itself, the typechecker must also ensure that
external services are used correctly in the context of the Orc program. 

<p>
When an external site is made available to Orc with the <code class="code"><span class="hl-keyword">site</span></code> declaration, its type is also
made available to the Orc typechecker. The type of a site is itself treated like a service; it is passed
the types of its arguments, and responds with a return type for those arguments. Thus, a site call can typecheck
in ways not possible for function calls or other expressions. For example, sites can support ad-hoc polymorphism.
Also, sites can respond to messages sent using the dot operator. In fact, Orc has no native record type, because
the dot operator only applies to sites, so the type of the site can interpret the message internally
and determine the correct type to return, if any. 
</p><p>
Additionally, a site can introduce new types into Orc. For example, the <code class="code"><span class="hl-variable">Semaphore</span></code> site responds with
new instances of semaphores. And just as sites can be declared using <code class="code"><span class="hl-keyword">site</span></code>, these types can be
declared using <code class="code"><span class="hl-keyword">type</span></code>. Typically they are represented as Java classes, just as sites are. As an example,
here is a program which declares the <code class="code"><span class="hl-variable">Semaphore</span></code> type, and then defines a function which "toggles" a pair 
of semaphores by acquiring the first and releasing the second.

<pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-variable">Semaphore</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">lib</span>.<span class="hl-variable">state</span>.<span class="hl-variable">types</span>.<span class="hl-variable">SemaphoreType</span>

<span class="hl-keyword">def</span> <span class="hl-site">toggle</span>(<span class="hl-variable">Semaphore</span>, <span class="hl-variable">Semaphore</span>) :: <span class="hl-variable">Top</span>
<span class="hl-keyword">def</span> <span class="hl-site">toggle</span>(<span class="hl-variable">s</span>, <span class="hl-variable">t</span>) = <span class="hl-variable">s</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">t</span>.<span class="hl-site">release</span>()
</pre>

Notice that it is not possible to typecheck <code class="code"><span class="hl-variable">toggle</span></code> without first giving a name to the Semaphore type,
because it is used in the signature of <code class="code"><span class="hl-variable">toggle</span></code>.
</p><p>
<code class="code"><span class="hl-keyword">type</span></code> definitions occur alongside <code class="code"><span class="hl-keyword">site</span></code> definitions in the standard library, so the
types returned by many of the library functions are already available.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11919"></a>4.1.11.&nbsp;Assertions</h3></div></div></div><p>
While the typechecker can be helpful, it will not accept programs that are not safe according to
its algorithm, which can be burdensome when the programmer knows that an expression will have a
certain type but the typechecker cannot verify it.
</p><p>
Since the typechecker is optional, it can always be turned off in these cases. But this is often
too drastic a solution: typechecking difficulties often arise from small segments of a much larger
program, and the rest of the program still benefits from typechecking. 
</p><p>
Fortunately, the typechecker can be selectively disabled for parts of a program. For this purpose,
the typechecker supports a special operation called an <span class="emphasis"><em>assertion</em></span>, written 
E <code class="code"> :!: </code> T, where E is an expression and T is its asserted type. An assertion 
is used like an ascription, but rather than verifying that E has type T, the typechecker instead
assumes that E has type T, without inspecting E at all. Thus, the programmer can supply the correct
type T without being restricted by the typechecking algorithm.
</p><p>
This feature should be used sparingly, with the knowledge that it does compromise the integrity
of the typechecking algorithm. If the supplied type is wrong, runtime type errors could propagate to any
part of the program that depends on that type. Assertions are useful for rapid prototyping, but
they are not recommended for production code.
</p></div></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch03s04.html">Prev</a>&nbsp;</td><td align="center" width="20%">&nbsp;</td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch04s02.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">3.4.&nbsp;Web Services&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;4.2.&nbsp;Polymorphism</td></tr></table></div></body></html>