<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title></title><link href="style.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#N10004">1. The Orc Programming Language</a></span></dt><dd><dl><dt><span class="section"><a href="#N10007">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#N10017">1.2. Cor: A Functional Subset</a></span></dt><dd><dl><dt><span class="section"><a href="#N1017C">1.2.1. Constants</a></span></dt><dt><span class="section"><a href="#language.base.oeprators">1.2.2. Operators</a></span></dt><dt><span class="section"><a href="#N102B6">1.2.3. Conditionals</a></span></dt><dt><span class="section"><a href="#N10352">1.2.4. Variables</a></span></dt><dt><span class="section"><a href="#N1038A">1.2.5. Data Structures</a></span></dt><dt><span class="section"><a href="#N10404">1.2.6. Patterns</a></span></dt><dt><span class="section"><a href="#N1046D">1.2.7. Functions</a></span></dt><dt><span class="section"><a href="#N10534">1.2.8. Comments</a></span></dt></dl></dd><dt><span class="section"><a href="#N10549">1.3. Orc: Orchestrating services</a></span></dt><dd><dl><dt><span class="section"><a href="#N10603">1.3.1. Communicating with external services</a></span></dt><dt><span class="section"><a href="#N10643">1.3.2. The concurrency combinators of Orc</a></span></dt><dt><span class="section"><a href="#N106F8">1.3.3. Revising Cor expressions</a></span></dt><dt><span class="section"><a href="#N107D2">1.3.4. Time</a></span></dt></dl></dd><dt><span class="section"><a href="#N107FE">1.4. Advanced Features of Orc</a></span></dt><dd><dl><dt><span class="section"><a href="#N108E5">1.4.1. Special call forms</a></span></dt><dt><span class="section"><a href="#N1094D">1.4.2. Extensions to pattern matching</a></span></dt><dt><span class="section"><a href="#N109B4">1.4.3. New forms of declarations</a></span></dt><dt><span class="section"><a href="#N109E2">1.4.4. The after combinator</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chapter.methodology">2. Programming Methodology</a></span></dt><dt><span class="chapter"><a href="#chapter.services">3. Accessing and Creating External Services</a></span></dt><dt><span class="appendix"><a href="#N10A2B">A. Complete Syntax of Orc</a></span></dt><dt><span class="appendix"><a href="#appendix.library">B. Standard Library</a></span></dt><dt><span class="appendix"><a href="#N10C4D">C. FAQ</a></span></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="#cor-ebnf-table">Syntax of the Functional Subset of Orc (Cor)</a></dt><dt>1.2. <a href="#ops-table">Operators</a></dt><dt>1.3. <a href="#orc-ebnf-table">Basic Syntax of Orc</a></dt><dt>1.4. <a href="#advanced-ebnf-table">Advanced Syntax of Orc</a></dt><dt>A.1. <a href="#full-ebnf-grammar">Complete Syntax of Orc</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="N10004"></a>Chapter&nbsp;1.&nbsp;The Orc Programming Language</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#N10007">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#N10017">1.2. Cor: A Functional Subset</a></span></dt><dd><dl><dt><span class="section"><a href="#N1017C">1.2.1. Constants</a></span></dt><dt><span class="section"><a href="#language.base.oeprators">1.2.2. Operators</a></span></dt><dt><span class="section"><a href="#N102B6">1.2.3. Conditionals</a></span></dt><dt><span class="section"><a href="#N10352">1.2.4. Variables</a></span></dt><dt><span class="section"><a href="#N1038A">1.2.5. Data Structures</a></span></dt><dt><span class="section"><a href="#N10404">1.2.6. Patterns</a></span></dt><dt><span class="section"><a href="#N1046D">1.2.7. Functions</a></span></dt><dt><span class="section"><a href="#N10534">1.2.8. Comments</a></span></dt></dl></dd><dt><span class="section"><a href="#N10549">1.3. Orc: Orchestrating services</a></span></dt><dd><dl><dt><span class="section"><a href="#N10603">1.3.1. Communicating with external services</a></span></dt><dt><span class="section"><a href="#N10643">1.3.2. The concurrency combinators of Orc</a></span></dt><dt><span class="section"><a href="#N106F8">1.3.3. Revising Cor expressions</a></span></dt><dt><span class="section"><a href="#N107D2">1.3.4. Time</a></span></dt></dl></dd><dt><span class="section"><a href="#N107FE">1.4. Advanced Features of Orc</a></span></dt><dd><dl><dt><span class="section"><a href="#N108E5">1.4.1. Special call forms</a></span></dt><dt><span class="section"><a href="#N1094D">1.4.2. Extensions to pattern matching</a></span></dt><dt><span class="section"><a href="#N109B4">1.4.3. New forms of declarations</a></span></dt><dt><span class="section"><a href="#N109E2">1.4.4. The after combinator</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10007"></a>1.1.&nbsp;Introduction</h2></div></div></div><p>
Orc is a programming language designed to make distributed and
concurrent programs simple and intuitive to write. Orc expresses
orchestration, a type of structured concurrency. It emphasizes the
flow of control and gives a global view of a concurrent system. Orc
is well-suited for task orchestration, a form of
concurrent programming with applications in workflow, business process
management, and web service orchestration. Orc provides constructs to
orchestrate the concurrent invocation of services while managing
time-outs, priorities, and failures of services or communication.  To
learn more about Orc and run your own Orc programs, visit the website:
<a class="ulink" href="http://orc.csres.utexas.edu/" target="_top"><code class="code"><span class="hl-variable">http</span>://<span class="hl-variable">orc</span>.<span class="hl-variable">csres</span>.<span class="hl-variable">utexas</span>.<span class="hl-variable">edu</span>/</code></a>.
</p><p>
This chapter describes the Orc programming language in three steps. In Section 1.2, we
discuss a small subset of Orc called Cor. Cor is a pure functional language,
which has no features for concurrency, has no state, and does not communicate 
with external services. Cor introduces us to the parts of Orc that are most familiar 
from existing programming languages, such as arithmetic operations, variables,
conditionals, and functions.
</p><p>
Next, in Section 1.3, we consider Orc itself, which in addition to Cor, comprises 
external services and combinators for concurrent orchestration of those services. 
We show how Orc interacts with these external services, how the combinators can be
used to build up complex orchestrations from simple base expressions, and how the 
functional constructs of Cor take on new, subtler behaviors in the concurrent 
context of Orc.
</p><p>
Finally, in Section 1.4, we discuss some additional features of Orc that extend 
the basic syntax. These are useful for creating large-scale Orc programs, but 
they are not essential to the understanding of the language.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10017"></a>1.2.&nbsp;Cor: A Functional Subset</h2></div></div></div><p>
In this section we introduce Cor, a pure functional subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</p><p>
A Cor program is called an <em class="firstterm">expression</em>. Cor expressions are built
up recursively from smaller expressions. Cor <em class="firstterm">evaluates</em> an expression
to reduce it to some simple <em class="firstterm">value</em> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <em class="firstterm">
result</em> of the expression.
</p><p>
In the following subsections we introduce the concepts of Cor. First, we talk about
simple constants, such as numbers and truth values, and the operations that we can perform
on those values. Then we introduce conditionals (<code class="code"><span class="hl-keyword">if</span> <span class="hl-keyword">then</span> <span class="hl-keyword">else</span></code>). Then we 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we talk about constructing data structures, and examining those structures
using patterns. Lastly, we introduce functions.
</p><p>
The following figure describes the syntax of Cor. Each part of the syntax is explained 
in a subsequent section.
</p><p>
<div class="table"><a name="cor-ebnf-table"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Syntax of the Functional Subset of Orc (Cor)</b></p><div class="table-contents"><table summary="Syntax of the Functional Subset of Orc (Cor)" border="0" width="80%"><colgroup><col align="right"><col align="center"><col align="left"><col align="left"><col align="left"></colgroup><tbody><tr><td align="right">E</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Expression</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left">C</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>constant value</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E <span class="emphasis"><em>operator</em></span> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>operator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>variable</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> E <code class="code"><span class="hl-keyword">else</span></code> E </td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>conditional</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X<code class="code">(</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>function call</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">(</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>tuple</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">[</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">]</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>list</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">D E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>scoped declaration</em></span></td></tr><tr><td align="right">C</td><td align="center">::=</td><td align="left"><code class="code"><span class="hl-literal">true</span></code> | <code class="code"><span class="hl-literal">false</span></code> | <span class="emphasis"><em>integer</em></span> | <span class="emphasis"><em>string</em></span></td><td align="left"><span class="emphasis"><em>Constant</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">X</td><td align="center">::=</td><td align="left"><span class="emphasis"><em>identifier</em></span></td><td align="left"><span class="emphasis"><em>Variable</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">D</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Declaration</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left"><code class="code"><span class="hl-keyword">val</span></code> P <code class="code">=</code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>value declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">def</span></code> X<code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code> <code class="code">=</code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>function declaration</em></span></td></tr><tr><td align="right">P</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Pattern</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left">X</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>variable</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">C</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>constant</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-variable">_</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>wildcard</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>tuple</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">[</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">]</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>list</em></span></td></tr></tbody></table></div></div><br class="table-break">
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1017C"></a>1.2.1.&nbsp;Constants</h3></div></div></div><p>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</p><p>

Cor has three types of constants, and thus for the moment three types of values:

<div class="itemizedlist"><ul type="disc"><li>
Integers: <code class="code"> ... -<span class="hl-literal">1</span>, <span class="hl-literal">0</span>, <span class="hl-literal">1</span> ... </code></li><li>
Booleans: <code class="code"><span class="hl-literal">true</span></code> and <code class="code"><span class="hl-literal">false</span></code></li><li>
Strings: <code class="code"><span class="hl-literal">"orc"</span></code>, <code class="code"><span class="hl-literal">"ceci n'est pas une |"</span></code></li></ul></div>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.base.oeprators"></a>1.2.2.&nbsp;Operators</h3></div></div></div><p>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-literal">1</span>+<span class="hl-literal">2</span></code> evaluates to <code class="code"><span class="hl-literal">3</span></code>.</li><li><code class="code">(<span class="hl-literal">98</span>+<span class="hl-literal">2</span>)*<span class="hl-literal">17</span></code> evaluates to <code class="code"><span class="hl-literal">1700</span></code>.</li><li><code class="code"><span class="hl-literal">4</span> = <span class="hl-literal">20</span> / <span class="hl-literal">5</span></code> evaluates to <code class="code"><span class="hl-literal">true</span></code>.</li><li><code class="code"><span class="hl-literal">3</span>-<span class="hl-literal">5</span> <span class="hl-site">&gt;=</span> <span class="hl-literal">5</span>-<span class="hl-literal">3</span> </code> evaluates to <code class="code"><span class="hl-literal">false</span></code>.</li><li><code class="code"><span class="hl-literal">true</span> &amp;&amp; (<span class="hl-literal">false</span> <span class="hl-site">||</span> <span class="hl-literal">true</span>)</code> evaluates to <code class="code"><span class="hl-literal">true</span></code>.</li><li><code class="code"><span class="hl-literal">"leap"</span> + <span class="hl-literal">"frog"</span></code> evaluates to <code class="code"><span class="hl-literal">"leapfrog"</span></code>.</li></ul></div>
</p><p>
Here is the full set of operators that Cor supports:

<div class="table"><a name="ops-table"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;Operators</b></p><div class="table-contents"><table summary="Operators" border="0" width="80%"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th colspan="2" align="left">Arithmetic</th><th colspan="2" align="left">Comparison</th><th colspan="2" align="left">Logical</th><th colspan="2" align="left">String</th></tr></thead><tbody><tr><td align="left"><code class="code">+</code></td><td align="left">addition</td><td align="left"><code class="code">=</code></td><td align="left">equality</td><td align="left"><code class="code">&amp;&amp;</code></td><td align="left">logical and</td><td align="left"><code class="code">+</code></td><td align="left">concatenation</td></tr><tr><td align="left"><code class="code">-</code></td><td align="left">subtraction</td><td align="left"><code class="code">/=</code></td><td align="left">inequality</td><td align="left"><code class="code"><span class="hl-site">||</span></code></td><td align="left">logical or</td><td colspan="2" align="left">&nbsp;</td></tr><tr><td align="left"><code class="code">*</code></td><td align="left">multiplication</td><td align="left"><code class="code">&lt;</code></td><td align="left">less than</td><td align="left"><code class="code">~</code></td><td align="left">logical not</td><td colspan="2" align="left">&nbsp;</td></tr><tr><td align="left"><code class="code">/</code></td><td align="left">division</td><td align="left"><code class="code">&gt;</code></td><td align="left">greater than</td><td colspan="2" align="left">&nbsp;</td><td colspan="2" align="left">&nbsp;</td></tr><tr><td align="left"><code class="code">%</code></td><td align="left">modulus</td><td align="left"><code class="code"><span class="hl-site">&lt;=</span></code></td><td align="left">less than or equal</td><td colspan="2" align="left">&nbsp;</td><td colspan="2" align="left">&nbsp;</td></tr><tr><td colspan="2" align="left">&nbsp;</td><td align="left"><code class="code"><span class="hl-site">&gt;=</span></code></td><td align="left">greater than or equal</td><td colspan="2" align="left">&nbsp;</td><td colspan="2" align="left">&nbsp;</td></tr></tbody></table></div></div><br class="table-break">

</p><p>
The <code class="code">=</code> operator can compare values of any type.
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-literal">10</span> = <span class="hl-literal">true</span></code> evaluates to <code class="code"><span class="hl-literal">false</span></code>.</li></ul></div>
</p><p>
Sometimes, there are situations where an expression is stuck, because it is attempting to perform 
some impossible operation and cannot reach a value. If this is the case, we say that the expression
is <em class="firstterm">silent</em>. An expression is also silent if it depends on the result of a silent 
subexpression.
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-literal">10</span> / <span class="hl-literal">0</span></code> is silent.</li><li><code class="code"><span class="hl-literal">6</span> + <span class="hl-literal">false</span></code> is silent.</li><li><code class="code"><span class="hl-literal">3</span> + <span class="hl-literal">1</span>/<span class="hl-literal">0</span></code> is silent.</li><li><code class="code"><span class="hl-literal">4</span> + <span class="hl-literal">true</span> = <span class="hl-literal">5</span></code> is silent.</li></ul></div>
</p><p>
Note that Cor is a dynamically typed language. It does not statically check the type correctness
of an expression; instead, an expression with a type error is simply silent when evaluated.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N102B6"></a>1.2.3.&nbsp;Conditionals</h3></div></div></div><p>
A conditional expression in Cor is of the form 
<code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G. 
Its meaning is similar to that in other languages: the value
of the expression is the value of F if and only if E evaluates to true, 
or the value of G if and only if E evaluates to false. Note that G is not
evaluated at all if E evaluates to true, and similarly F is not evaluated
at all of E evaluates to false. Thus, for example, evaluation of 
<code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">3</span> = <span class="hl-literal">3</span> <span class="hl-keyword">then</span> <span class="hl-literal">5</span> <span class="hl-keyword">else</span> <span class="hl-literal">1</span>/<span class="hl-literal">0</span></code> does not cause any error. 
</p><p>
Unlike other languages, expressions in Cor may be silent. If E is
silent, then the entire expression is silent. And if E evaluates to true 
but F is silent (or if E evaluates to false and G is silent) then the 
expression is silent.
</p><p>
The behavior of conditionals is summarized by the following table
(<span class="emphasis"><em>v</em></span> denotes a value).

<div class="informaltable"><a name="cond-table"></a><table border="0" width="60%"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">E</th><th align="center">F</th><th align="center">G</th><th align="center"><code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G</th></tr></thead><tbody><tr><td align="center"><code class="code"><span class="hl-literal">true</span></code></td><td align="center"><span class="emphasis"><em>v</em></span></td><td align="center">-</td><td align="center"><span class="emphasis"><em>v</em></span></td></tr><tr><td align="center"><code class="code"><span class="hl-literal">true</span></code></td><td align="center">silent</td><td align="center">-</td><td align="center">silent</td></tr><tr><td align="center"><code class="code"><span class="hl-literal">false</span></code></td><td align="center">-</td><td align="center"><span class="emphasis"><em>v</em></span></td><td align="center"><span class="emphasis"><em>v</em></span></td></tr><tr><td align="center"><code class="code"><span class="hl-literal">false</span></code></td><td align="center">-</td><td align="center">silent</td><td align="center">silent</td></tr><tr><td align="center">silent</td><td align="center">-</td><td align="center">-</td><td align="center">silent</td></tr></tbody></table></div>

</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">true</span> <span class="hl-keyword">then</span> <span class="hl-literal">4</span> <span class="hl-keyword">else</span> <span class="hl-literal">5</span></code> evaluates to <code class="code"><span class="hl-literal">4</span></code>.</li><li><code class="code"><span class="hl-keyword">if</span>  <span class="hl-literal">2</span> &lt; <span class="hl-literal">3</span> &amp;&amp; <span class="hl-literal">5</span> &lt; <span class="hl-literal">4</span>  <span class="hl-keyword">then</span> <span class="hl-literal">"blue"</span> <span class="hl-keyword">else</span> <span class="hl-literal">"green"</span></code> evaluates to "green".</li><li><code class="code"><span class="hl-keyword">if</span>  <span class="hl-literal">true</span> <span class="hl-site">||</span> <span class="hl-literal">"fish"</span>  <span class="hl-keyword">then</span> <span class="hl-literal">"yes"</span> <span class="hl-keyword">else</span> <span class="hl-literal">"no"</span></code> is silent.</li><li><code class="code"><span class="hl-keyword">if</span>  <span class="hl-literal">false</span> <span class="hl-site">||</span> <span class="hl-literal">false</span>  <span class="hl-keyword">then</span> <span class="hl-literal">4</span>+<span class="hl-literal">5</span> <span class="hl-keyword">else</span> <span class="hl-literal">4</span>+<span class="hl-literal">true</span></code> is silent.</li><li><code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">0</span> &lt; <span class="hl-literal">5</span> <span class="hl-keyword">then</span> <span class="hl-literal">0</span>/<span class="hl-literal">5</span> <span class="hl-keyword">else</span> <span class="hl-literal">5</span>/<span class="hl-literal">0</span></code> evaluates to 0.</li></ul></div>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10352"></a>1.2.4.&nbsp;Variables</h3></div></div></div><p>
A <em class="firstterm">variable</em> names the value of some expression so that we can use it later.
Expression <code class="code"><span class="hl-variable">x</span></code>, where x is some variable name, evaluates to the result <em class="firstterm">bound</em>
to the variable x.
</p><p>
Variables are bound using a <em class="firstterm">declaration</em>. A declaration is a statement that has no value 
of its own but instead binds one or more variables. The simplest form of declaration is <code class="code"><span class="hl-keyword">val</span></code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<a class="ulink" href="http://en.wikipedia.org/wiki/Lexical_scope" target="_top">lexical scoping</a>.
</p><p>
<pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> = <span class="hl-literal">1</span> + <span class="hl-literal">2</span> + <span class="hl-literal">3</span> + <span class="hl-literal">4</span> + <span class="hl-literal">5</span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> = <span class="hl-variable">x</span> + <span class="hl-variable">x</span>
</pre>

These declarations bind variable <code class="code"><span class="hl-variable">x</span></code> to 15 and variable <code class="code"><span class="hl-variable">y</span></code> to 30.
</p><p>
If the expression on the right side of a <code class="code"><span class="hl-keyword">val</span></code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions can continue. If an evaluated expression depends on that
variable, that expression is silent.

<pre class="orc">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> = <span class="hl-literal">1</span>/<span class="hl-literal">0</span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> = <span class="hl-literal">4</span>+<span class="hl-literal">5</span>
<span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-variable">x</span> <span class="hl-keyword">else</span> <span class="hl-variable">y</span></pre>

Evaluation of the declaration <code class="code"><span class="hl-keyword">val</span> <span class="hl-variable">y</span> = <span class="hl-literal">4</span>+<span class="hl-literal">5</span></code> and the expression <code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-variable">x</span> <span class="hl-keyword">else</span> <span class="hl-variable">y</span></code>
may continue even though <code class="code"><span class="hl-variable">x</span></code> is not bound. The expression evaluates to 9.

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1038A"></a>1.2.5.&nbsp;Data Structures</h3></div></div></div><p>
Cor supports two basic data structures, <em class="firstterm">tuples</em> and <em class="firstterm">lists</em>.
</p><p>
A <em class="firstterm">tuple expression</em> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code">(<span class="hl-literal">1</span>+<span class="hl-literal">2</span>, <span class="hl-literal">7</span>)</code> evaluates to <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">7</span>)</code>.</li><li><code class="code"> (<span class="hl-literal">"true"</span> + <span class="hl-literal">"false"</span>, <span class="hl-literal">true</span> <span class="hl-site">||</span> <span class="hl-literal">false</span>, <span class="hl-literal">true</span> &amp;&amp; <span class="hl-literal">false</span>) </code> evaluates to <code class="code">(<span class="hl-literal">"truefalse"</span>, <span class="hl-literal">true</span>, <span class="hl-literal">false</span>)</code>.</li><li><code class="code">(<span class="hl-literal">2</span>/<span class="hl-literal">2</span>, <span class="hl-literal">2</span>/<span class="hl-literal">1</span>, <span class="hl-literal">2</span>/<span class="hl-literal">0</span>)</code> is silent.</li></ul></div>
</p><p>
A <em class="firstterm">list expression</em> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">2</span>+<span class="hl-literal">3</span>] </code> evaluates to <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">5</span>]</code>.</li><li><code class="code"> [<span class="hl-literal">true</span> &amp;&amp; <span class="hl-literal">true</span>]  </code> evaluates to <code class="code">[<span class="hl-literal">true</span>]</code>.</li><li><code class="code">[]</code> evaluates trivially to <code class="code">[]</code>, the empty list.</li><li><code class="code">[<span class="hl-literal">5</span>, <span class="hl-literal">5</span> + <span class="hl-literal">true</span>, <span class="hl-literal">5</span>]</code> is silent.</li></ul></div>
</p><p>
There is also a concatenation (<em class="firstterm">cons</em>) operation on lists,
written F<code class="code">:</code>G, where F and G are expressions. Its result is a new list whose first element is the 
value of F and whose remaining elements are the list value of G.
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code">(<span class="hl-literal">1</span>+<span class="hl-literal">3</span>):[<span class="hl-literal">2</span>+<span class="hl-literal">5</span>,<span class="hl-literal">6</span>]</code> evaluates to <code class="code">[<span class="hl-literal">4</span>,<span class="hl-literal">7</span>,<span class="hl-literal">6</span>]</code>.</li><li><code class="code"><span class="hl-literal">2</span>:<span class="hl-literal">2</span>:<span class="hl-literal">5</span>:[] </code> evaluates to <code class="code">[<span class="hl-literal">2</span>,<span class="hl-literal">2</span>,<span class="hl-literal">5</span>]</code>.</li><li>Suppose <code class="code"><span class="hl-variable">t</span></code> is bound to [3,5]. Then <code class="code"><span class="hl-literal">1</span>:<span class="hl-variable">t</span></code> evaluates to <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">3</span>,<span class="hl-literal">5</span>]</code>.</li><li><code class="code"><span class="hl-literal">2</span>:<span class="hl-literal">3</span></code> is silent, because <code class="code"><span class="hl-literal">3</span></code> is not a list.</li></ul></div>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10404"></a>1.2.6.&nbsp;Patterns</h3></div></div></div><p>
We have seen how to construct data structures. But how do we examine them, and use them? We use <em class="firstterm">patterns</em>.
</p><p>
A pattern is a powerful way to bind variables. When writing <code class="code"><span class="hl-keyword">val</span></code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <em class="firstterm">shape</em>; a
pattern may take the shape of any structured value. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-keyword">val</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) = (<span class="hl-literal">2</span>+<span class="hl-literal">3</span>,<span class="hl-literal">2</span>*<span class="hl-literal">3</span>)</code> binds <code class="code"><span class="hl-variable">x</span></code> to 5 and <code class="code"><span class="hl-variable">y</span></code> to 6.</li><li><code class="code"><span class="hl-keyword">val</span> [<span class="hl-variable">a</span>,<span class="hl-variable">b</span>,<span class="hl-variable">c</span>] = [<span class="hl-literal">"one"</span>, <span class="hl-literal">"two"</span>, <span class="hl-literal">"three"</span>]</code> binds <code class="code"><span class="hl-variable">a</span></code> to "one", 
<code class="code"><span class="hl-variable">b</span></code> to "two", and <code class="code"><span class="hl-variable">c</span></code> to "three".
</li><li><code class="code"><span class="hl-keyword">val</span> ((<span class="hl-variable">a</span>,<span class="hl-variable">b</span>),<span class="hl-variable">c</span>) = ((<span class="hl-literal">1</span>, <span class="hl-literal">true</span>), (<span class="hl-literal">2</span>, <span class="hl-literal">false</span>))</code> binds <code class="code"><span class="hl-variable">a</span></code> to 1, <code class="code"><span class="hl-variable">b</span></code> to <code class="code"><span class="hl-literal">true</span></code>,
and <code class="code"><span class="hl-variable">c</span></code> to <code class="code">(<span class="hl-literal">2</span>,<span class="hl-literal">false</span>)</code>.
</li></ul></div>
</p><p>
Patterns are <em class="firstterm">linear</em>; that is, a pattern may mention a variable name at most once. 
For example, <code class="code">(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>,<span class="hl-variable">x</span>)</code> is not a valid pattern.
</p><p>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code class="code"><span class="hl-keyword">val</span></code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evaluated, it is silent.
</p><p>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code class="code"><span class="hl-variable">_</span></code>, to do this; it matches any shape and binds no
variables.
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-keyword">val</span> (<span class="hl-variable">x</span>,<span class="hl-variable">_</span>,<span class="hl-variable">_</span>) = (<span class="hl-literal">1</span>,(<span class="hl-literal">2</span>,<span class="hl-literal">2</span>),[<span class="hl-literal">3</span>,<span class="hl-literal">3</span>,<span class="hl-literal">3</span>])</code> binds <code class="code"><span class="hl-variable">x</span></code> to 1.</li><li><code class="code"><span class="hl-keyword">val</span> [[<span class="hl-variable">_</span>,<span class="hl-variable">x</span>],[<span class="hl-variable">_</span>,<span class="hl-variable">y</span>]] = [[<span class="hl-literal">1</span>,<span class="hl-literal">3</span>],[<span class="hl-literal">2</span>,<span class="hl-literal">4</span>]]</code> binds <code class="code"><span class="hl-variable">x</span></code> to 3 and <code class="code"><span class="hl-variable">y</span></code> to 4.</li></ul></div>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1046D"></a>1.2.7.&nbsp;Functions</h3></div></div></div><p>
Like most other programming languages, Cor has the capability to define <em class="firstterm">functions</em>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code class="code"><span class="hl-keyword">def</span></code>, in the following way.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">add</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) = <span class="hl-variable">x</span>+<span class="hl-variable">y</span>
</pre>

The expression on the right of the <code class="code">=</code> is called the <em class="firstterm">body</em> of the function.
</p><p>
After defining the function, we can <em class="firstterm">call</em> it. A call looks just like the left side of
the declaration except that the variable names (the <em class="firstterm">formal parameters</em>) have been 
replaced by expressions (the <em class="firstterm">actual parameters</em>). 
</p><p>
To evaluate a call, we treat it as a sequence of <code class="code"><span class="hl-keyword">val</span></code> declarations associating the formal
parameters with the actual parameters, followed by the body of the function. 

<pre class="programlisting">
<span class="hl-comment">{- Evaluation of add(1+2,3+4) -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> = <span class="hl-literal">1</span>+<span class="hl-literal">2</span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> = <span class="hl-literal">3</span>+<span class="hl-literal">4</span>
<span class="hl-variable">x</span>+<span class="hl-variable">y</span>
</pre>
</p><p>
<div class="itemizedlist"><p class="title"><b>Examples</b></p><ul type="disc"><li><code class="code"><span class="hl-site">add</span>(<span class="hl-literal">10</span>,<span class="hl-literal">10</span>*<span class="hl-literal">10</span>)</code> evaluates to <code class="code"><span class="hl-literal">110</span></code>.</li><li><code class="code"><span class="hl-site">add</span>(<span class="hl-site">add</span>(<span class="hl-literal">5</span>,<span class="hl-literal">3</span>),<span class="hl-literal">5</span>)</code> evaluates to <code class="code"><span class="hl-literal">13</span></code>.</li></ul></div>
</p><p>
Notice that the evaluation strategy of functions allows to call to proceed even if some of the actual
parameters to be silent, so long as the values of those actual parameters are not used in the evaluation
of the body.

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">cond</span>(<span class="hl-variable">b</span>,<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) = <span class="hl-keyword">if</span> <span class="hl-variable">b</span> <span class="hl-keyword">then</span> <span class="hl-variable">x</span> <span class="hl-keyword">else</span> <span class="hl-variable">y</span>
<span class="hl-site">cond</span>(<span class="hl-literal">true</span>, <span class="hl-literal">3</span>, <span class="hl-literal">5</span>/<span class="hl-literal">0</span>)
</pre>

This evaluates to <code class="code"><span class="hl-literal">3</span></code> even though <code class="code"><span class="hl-literal">5</span>/<span class="hl-literal">0</span></code> is silent, because <code class="code"><span class="hl-variable">y</span></code> is not
needed.

</p><p>
A definition or a call may have zero arguments, in which case we write <code class="code">()</code> for the arguments.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">zero</span>() = <span class="hl-literal">0</span>
</pre>
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N104BF"></a>1.2.7.1.&nbsp;Recursion</h4></div></div></div><p>
Definitions can be recursive; that is, the name of a definition may be used in its own body.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">sumto</span>(<span class="hl-variable">n</span>) = <span class="hl-keyword">if</span> <span class="hl-variable">n</span> &lt; <span class="hl-literal">1</span> <span class="hl-keyword">then</span> <span class="hl-literal">0</span> <span class="hl-keyword">else</span> <span class="hl-variable">n</span> + <span class="hl-site">sumto</span>(<span class="hl-variable">n</span>-<span class="hl-literal">1</span>)
</pre>

Then, <code class="code"><span class="hl-site">sumto</span>(<span class="hl-literal">5</span>)</code> evaluates to 15.
</p><p>
Mutual recursion is also supported.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span>) = 
  <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span>-<span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span>+<span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-literal">true</span>
<span class="hl-keyword">def</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span>) = 
  <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span>-<span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span>+<span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-literal">false</span>
</pre>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N104CF"></a>1.2.7.2.&nbsp;Closure</h4></div></div></div><p>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<em class="firstterm">closure</em>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">a</span>(<span class="hl-variable">x</span>) = <span class="hl-variable">x</span>-<span class="hl-literal">3</span>
<span class="hl-keyword">def</span> <span class="hl-site">b</span>(<span class="hl-variable">y</span>) = <span class="hl-variable">y</span>*<span class="hl-literal">4</span>
<span class="hl-keyword">val</span> <span class="hl-variable">funs</span> = (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)
</pre>
</p><p>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
supports <span class="emphasis"><em>higher-order</em></span> functions.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">onetwosum</span>(<span class="hl-variable">f</span>) = <span class="hl-site">f</span>(<span class="hl-literal">1</span>) + <span class="hl-site">f</span>(<span class="hl-literal">2</span>)
<span class="hl-keyword">def</span> <span class="hl-site">triple</span>(<span class="hl-variable">x</span>) = <span class="hl-variable">x</span> * <span class="hl-literal">3</span>
</pre>

Then, <code class="code"><span class="hl-site">onetwosum</span>(<span class="hl-variable">triple</span>)</code> is <code class="code"><span class="hl-site">triple</span>(<span class="hl-literal">1</span>) + <span class="hl-site">triple</span>(<span class="hl-literal">2</span>)</code>, which is <code class="code"><span class="hl-literal">1</span> * <span class="hl-literal">3</span> + <span class="hl-literal">2</span> * <span class="hl-literal">3</span></code>, which evaluates to <code class="code"><span class="hl-literal">9</span></code>.

</p><p>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<span class="emphasis"><em>lexical closures</em></span>. This means that when a closure is created, if the body of the
function contains any variables other than the formal parameters, the bindings for those variables are
stored in the closure. Then, when the closure is called, the evaluation of the function body uses those 
stored variable bindings.  
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N104F3"></a>1.2.7.3.&nbsp;Lambda</h4></div></div></div><p>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code class="code"><span class="hl-keyword">lambda</span></code> for this purpose. By writing a function
definition with the keyword <code class="code"><span class="hl-keyword">lambda</span></code> instead of a function name, that definition
becomes an expression which evaluates to a closure. 

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">onetwosum</span>(<span class="hl-variable">f</span>) = <span class="hl-site">f</span>(<span class="hl-literal">1</span>) + <span class="hl-site">f</span>(<span class="hl-literal">2</span>)

<span class="hl-site">onetwosum</span>( <span class="hl-keyword">lambda</span>(<span class="hl-variable">x</span>) = <span class="hl-variable">x</span> * <span class="hl-literal">3</span> )
<span class="hl-comment">{- 
  identical to:
  def triple(x) = x * 3
  onetwosum(triple)
-}</span></pre>

Then, <code class="code"><span class="hl-site">onetwosum</span>( <span class="hl-keyword">lambda</span>(<span class="hl-variable">x</span>) = <span class="hl-variable">x</span> * <span class="hl-literal">3</span> )</code> evaluates to 9. 

</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10505"></a>1.2.7.4.&nbsp;Clauses</h4></div></div></div><p>
The combination of functions and pattern matching offers a powerful capability: 
<em class="firstterm">clausal</em> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</p><p>
Here's an example.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>([]) = <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">h</span>:<span class="hl-variable">t</span>) = <span class="hl-variable">h</span> + <span class="hl-site">sum</span>(<span class="hl-variable">t</span>)
</pre>

<code class="code"><span class="hl-site">sum</span>(<span class="hl-variable">L</span>)</code> publishes the sum of the numbers in the list <code class="code"><span class="hl-variable">L</span></code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</p><p>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</p><p>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</p><p>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

<pre class="programlisting">
<span class="hl-comment">{- Fibonacci numbers -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-literal">0</span>) = <span class="hl-literal">1</span>
<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-literal">1</span>) = <span class="hl-literal">1</span>
<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-variable">n</span>) = <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-literal">0</span> <span class="hl-keyword">else</span> <span class="hl-site">fib</span>(<span class="hl-variable">n</span>-<span class="hl-literal">1</span>) + <span class="hl-site">fib</span>(<span class="hl-variable">n</span>-<span class="hl-literal">2</span>)
</pre>

<pre class="programlisting">
<span class="hl-comment">{- Take up to the first n elements from a list -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">take</span>(<span class="hl-literal">0</span>,<span class="hl-variable">_</span>) = []
<span class="hl-keyword">def</span> <span class="hl-site">take</span>(<span class="hl-variable">_</span>,[]) = []
<span class="hl-keyword">def</span> <span class="hl-site">take</span>(<span class="hl-variable">n</span>,<span class="hl-variable">h</span>:<span class="hl-variable">t</span>) = <span class="hl-variable">h</span>:(<span class="hl-site">take</span>(<span class="hl-variable">n</span>-<span class="hl-literal">1</span>,<span class="hl-variable">t</span>))
</pre>
</p><p>
Mutual recursion and clausal definitions are allowed to occur together.
For example, this function takes a list and evaluates to a new list with every other element repeated:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">stutter</span>([]) = []
<span class="hl-keyword">def</span> <span class="hl-site">stutter</span>(<span class="hl-variable">h</span>:<span class="hl-variable">t</span>) = <span class="hl-variable">h</span>:<span class="hl-variable">h</span>:<span class="hl-site">mutter</span>(<span class="hl-variable">t</span>)
<span class="hl-keyword">def</span> <span class="hl-site">mutter</span>([]) = []
<span class="hl-keyword">def</span> <span class="hl-site">mutter</span>(<span class="hl-variable">h</span>:<span class="hl-variable">t</span>) = <span class="hl-variable">h</span>:<span class="hl-site">stutter</span>(<span class="hl-variable">t</span>)
</pre>

<code class="code"><span class="hl-site">stutter</span>([<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>])</code> evaluates to <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>,<span class="hl-literal">3</span>]</code>.
</p><p>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">even</span>(<span class="hl-literal">0</span>) = <span class="hl-literal">true</span>
<span class="hl-keyword">def</span> <span class="hl-site">odd</span>(<span class="hl-literal">0</span>) = <span class="hl-literal">false</span>
<span class="hl-keyword">def</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span>) = <span class="hl-site">odd</span>(<span class="hl-keyword">if</span> <span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span> <span class="hl-keyword">then</span> <span class="hl-variable">n</span>-<span class="hl-literal">1</span> <span class="hl-keyword">else</span> <span class="hl-variable">n</span>+<span class="hl-literal">1</span>)
<span class="hl-keyword">def</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span>) = <span class="hl-site">even</span>(<span class="hl-keyword">if</span> <span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span> <span class="hl-keyword">then</span> <span class="hl-variable">n</span>-<span class="hl-literal">1</span> <span class="hl-keyword">else</span> <span class="hl-variable">n</span>+<span class="hl-literal">1</span>)
</pre>

</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10534"></a>1.2.8.&nbsp;Comments</h3></div></div></div><p>
Cor has two kinds of comments.   

</p><p>
A line which begins with two dashes (<code class="code"><span class="hl-comment">--</span></code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<pre class="programlisting">
<span class="hl-comment">-- This is a single line comment.</span>
	 <span class="hl-comment">-- This is also a single line comment.</span>
</pre>
</p><p>
Multiline comments are enclosed by matching braces of the form <code class="code"><span class="hl-comment">{- -}</span></code>. 
Multiline comments may be nested. They may appear anywhere, even in the middle of an expression.

<pre class="programlisting">
<span class="hl-comment">{- 
   This is a
   multiline comment.
-}</span>
   
<span class="hl-comment">{- Multiline comments {- can be nested -}</span> -}

<span class="hl-comment">{- They may appear anywhere, -}</span> 
<span class="hl-literal">1</span> + <span class="hl-comment">{- even in the middle of an expression. -}</span> <span class="hl-literal">2</span> + <span class="hl-literal">3</span>
</pre>

</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10549"></a>1.3.&nbsp;Orc: Orchestrating services</h2></div></div></div><p>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. Clearly, the full 
Orc language must transcend these limitations, because the orchestration of external services 
is critical to Orc's purpose.
</p><p>
As in Cor, an Orc program is an  <em class="firstterm">expression</em>; Orc expressions are built 
up recursively from smaller expressions. Orc is a superset of Cor, i.e., all Cor expressions are 
also Orc expressions. Orc expressions are <em class="firstterm">executed</em>, rather than evaluated; 
an execution may call external services and <em class="firstterm">publish</em> some number of 
values (possibly zero). Different executions of the same expression may have completely different
behaviors; they may call different services, may receive different responses from the same site,
and may publish different values. Expressions in the functional subset, though, will display
the same behavior in all executions.
</p><p>
If an execution of an expression publishes no value, it is called <em class="firstterm">silent</em>.
If no execution of an expression can possibly publish a value, then that expression is slient.
However, unlike silent expressions in Cor, a silent expression in Orc might perform some meaningful 
computation or communication; silence does not necessarily indicate an error.
</p><p>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <em class="firstterm">combinators</em>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</p><p>
The following figure summarizes the syntax of Orc as an extension of the syntax of Cor. 
The original Cor grammar rules are abbreviated by ellipses (...). 
</p><p>
<div class="table"><a name="orc-ebnf-table"></a><p class="title"><b>Table&nbsp;1.3.&nbsp;Basic Syntax of Orc</b></p><div class="table-contents"><table summary="Basic Syntax of Orc" border="0" width="80%"><colgroup><col align="right"><col align="center"><col align="left"><col align="left"><col align="left"></colgroup><tbody><tr><td align="right">D</td><td align="center">::=</td><td align="left"> ... </td><td align="left"><span class="emphasis"><em>Declaration</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">site</span></code> X <code class="code">=</code> <span class="emphasis"><em>address</em></span></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>site declaration</em></span></td></tr><tr><td align="right">C</td><td align="center">::=</td><td align="left"> ... </td><td align="left"><span class="emphasis"><em>Constant</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">signal</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>signal value</em></span></td></tr><tr><td align="right">E</td><td align="center">::=</td><td align="left">...</td><td align="left"><span class="emphasis"><em>Expression</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E <code class="code"><span class="hl-combinator">|</span></code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>parallel combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E<code class="code"> <span class="hl-combinator">&gt;</span></code>P<code class="code"><span class="hl-combinator">&gt;</span> </code>E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>sequential combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E<code class="code"> <span class="hl-combinator">&lt;</span></code>P<code class="code"><span class="hl-combinator">&lt;</span> </code>E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>asymmetric combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">stop</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>silent expression</em></span></td></tr></tbody></table></div></div><br class="table-break">
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10603"></a>1.3.1.&nbsp;Communicating with external services</h3></div></div></div><p>
We introduce the term <em class="firstterm">site</em> to denote an external service which
Orc may call. Sites are called using the same syntax as a function call, but with a 
slightly different meaning. Sites are introduced and bound to variables by a special 
declaration.  
</p><p>
A site is a value, just like an integer or a list. It may be bound to a variable, passed 
as an argument, or published by an execution, just like any other value.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1060D"></a>1.3.1.1.&nbsp;Calling a site</h4></div></div></div><p>
Suppose that the variable <code class="code"><span class="hl-variable">Google</span></code> is bound to a site which sends a 
string to the Google search engine and returns the URL of the top result. A call to
<code class="code"><span class="hl-variable">Google</span></code> looks just like a function call.

<pre class="programlisting">
<span class="hl-comment">{- Get the top search result for "computation orchestration" -}</span>
<span class="hl-site">Google</span>(<span class="hl-literal">"computation orchestration"</span>)
</pre>

When the Google search engine determines the top result for this search, it responds with
some URL. The site call then publishes that response. Note that the service might
never respond: Google's servers might be down, the network might be down, or the search 
might yield no result URL. If the service fails to respond, the site call remains
silent.
</p><p>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</p><p>
A site is sometimes called purely for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <em class="firstterm">signal</em>: a special value which carries no 
information (analogous to the unit value <code class="code">()</code> in ML). The signal value
can be written as <code class="code"><span class="hl-keyword">signal</span></code> within Orc programs.


<pre class="orc">
<span class="hl-comment">{- 
  Use the 'println' site to print a string, followed by
  a newline, to an output console.
  The return value of this site call is a signal.
-}</span>
<span class="hl-site">println</span>(<span class="hl-literal">"Hello, World!"</span>)
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1062C"></a>1.3.1.2.&nbsp;Declaring a site</h4></div></div></div><p>
A <code class="code"><span class="hl-keyword">site</span></code> declaration makes some service available as a site and
binds it to a variable. The service might be an object in the host language,
e.g. a class instance in Java, or an external service on the web accessed 
through some protocol like SOAP or REST, or even a primitive operation like addition. 
We will discuss the particulars of these declarations, and the guidelines for accessing 
web-based services or creating one's own services, in <a class="link" href="#chapter.services" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services">Chapter 3</a>. 
Also, many useful sites are already defined in the Orc standard library, documented
in <a class="link" href="#appendix.library" title="Appendix&nbsp;B.&nbsp;Standard Library">Appendix B</a>. For now, we present a simple 
type of site declaration: using an object in the host language as a site.  
</p><p>
The following example instantiates a Java object to be used as a site in an Orc program, specifically
a Java object which provides an asynchronous buffer service. The declaration uses a
fully qualified Java class name to find and load a class, and creates an instance of that
class to provide the service. 

<pre class="programlisting">
<span class="hl-comment">{-  Define the Buffer site  -}</span>
<span class="hl-keyword">site</span> <span class="hl-variable">Buffer</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">lib</span>.<span class="hl-variable">state</span>.<span class="hl-variable">Buffer</span>
</pre>  
</p><p>

</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N10643"></a>1.3.2.&nbsp;The concurrency combinators of Orc</h3></div></div></div><p>
Orc has three concurrency <em class="firstterm">combinators</em>: parallel, sequential, and asymmetric.
The combinators connect expressions together.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1064B"></a>1.3.2.1.&nbsp;The parallel combinator</h4></div></div></div><p>
Orc's simplest combinator is <code class="code"><span class="hl-combinator">|</span></code>, the parallel combinator. Orc executes
the expression F <code class="code"><span class="hl-combinator">|</span></code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
the whole execution does so as well.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish 1, 2, and 3 in parallel  </span>
<span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-literal">2</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span>+<span class="hl-literal">2</span>
</pre>
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- 
  Access two search sites, Google and Yahoo, in parallel.

  Publish any results they return.
  
  Since each call may publish a value, the expression
  may publish up to two values.
-}</span>  
<span class="hl-site">Google</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Yahoo</span>(<span class="hl-literal">"cupcake"</span>)
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10661"></a>1.3.2.2.&nbsp;The sequential combinator</h4></div></div></div><p>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F<code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> </code>G, 
combines the expression F, which publishes some values, with another expression G 
which will use those values as they are published, using <code class="code"><span class="hl-variable">x</span></code> to transmit
the values from from F to G.
</p><p>
The execution of F<code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> </code>G starts by executing F. Whenever F publishes a value, 
a new copy of G is executed in parallel with F (and with any previous copies of G); in that
copy of G, variable <code class="code"><span class="hl-variable">x</span></code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish 1 and 2 in parallel  </span>
(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">n</span>+<span class="hl-literal">1</span>
</pre>
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish 3 and 4 in parallel  </span>
<span class="hl-literal">2</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">n</span>+<span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-variable">n</span>+<span class="hl-literal">2</span>)
</pre>
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish 0, 1, 2 and 3 in parallel  </span>
(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">2</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">n</span> <span class="hl-combinator">|</span> <span class="hl-variable">n</span>+<span class="hl-literal">1</span>)
</pre>
</p><p>
<pre class="programlisting">
<span class="hl-comment">-- Prepend the string "Result: " to each published search result</span>
<span class="hl-comment">-- The cat site concatenates any number of arguments into one string  </span>
  <span class="hl-site">Google</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-site">cat</span>(<span class="hl-literal">"Result: "</span>, <span class="hl-variable">s</span>)
<span class="hl-combinator">|</span> <span class="hl-site">Yahoo</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-site">cat</span>(<span class="hl-literal">"Result: "</span>, <span class="hl-variable">s</span>)
</pre>
</p><p>
The sequential combinator may be written as F<code class="code"> <span class="hl-combinator">&gt;</span></code>P<code class="code"><span class="hl-combinator">&gt;</span> </code>G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new copy of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new copy of G is executed.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish 3, 6, and 9 in arbitrary order.</span>
(<span class="hl-literal">3</span>,<span class="hl-literal">6</span>,<span class="hl-literal">9</span>)  <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>,<span class="hl-variable">z</span>)<span class="hl-combinator">&gt;</span>  ( <span class="hl-variable">x</span> <span class="hl-combinator">|</span> <span class="hl-variable">y</span> <span class="hl-combinator">|</span> <span class="hl-variable">z</span> )
</pre>
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish x from any tuple of the form (1,x)</span>
<span class="hl-comment">-- Publishes 4 and 6  </span>
( (<span class="hl-literal">1</span>,<span class="hl-literal">4</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">2</span>,<span class="hl-literal">5</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">1</span>,<span class="hl-literal">6</span>) )  <span class="hl-combinator">&gt;</span>(<span class="hl-literal">1</span>,<span class="hl-variable">x</span>)<span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>
</pre>
</p><p>
We may also omit the variable entirely, writing <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>. This
is equivalent to using a wildcard pattern: <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">_</span><span class="hl-combinator">&gt;</span> </code>
</p><p>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code> together with the special expression 
<code class="code"><span class="hl-keyword">stop</span></code>, which is always silent.  
</p><p>
<pre class="orc">
<span class="hl-comment">{- 
  Print two strings to the console,
  but don't publish the return values of the calls.
-}</span>
( <span class="hl-site">println</span>(<span class="hl-literal">"goodbye"</span>) <span class="hl-combinator">|</span> <span class="hl-site">println</span>(<span class="hl-literal">"world"</span>) ) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N106B5"></a>1.3.2.3.&nbsp;The asymmetric combinator</h4></div></div></div><p>
The asymmetric combinator, written F<code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code>G, allows us to block 
a computation waiting for a result, or terminate a computation. The execution of 
F<code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code>G starts by executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then the execuion of G is immediately 
<em class="firstterm">terminated</em>. A terminated expression cannot call any sites or 
publish any values.
</p><p>
During the execution of F, any execution that depends on <code class="code"><span class="hl-variable">x</span></code> will be
suspended until <code class="code"><span class="hl-variable">x</span></code> is bound (to the first value published by G). If G
never publishes a value, those executions are suspended forever. 
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish either 5 or 6, but not both</span>
<span class="hl-variable">x</span>+<span class="hl-literal">2</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)
</pre>
</p><p>
<pre class="programlisting">
<span class="hl-comment">-- Query Google and Yahoo for a search result</span>
<span class="hl-comment">-- Print out the result that arrives first; ignore the other result</span>
<span class="hl-site">println</span>(<span class="hl-variable">result</span>) <span class="hl-combinator">&lt;</span><span class="hl-variable">result</span><span class="hl-combinator">&lt;</span> ( <span class="hl-site">Google</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Yahoo</span>(<span class="hl-literal">"cupcake"</span>) )
</pre>
</p><p>
Though a terminated execution may not make any new calls, the calls
that it has already made will continue as normal; their responses are simply
ignored. This may have surprising consequences when a call has side effects,
as in the following example.
</p><p>
<pre class="orc">
<span class="hl-comment">{- 
  This example actually prints both "true" and "false" to the
  console, regardless of which call responds first.
-}</span>
<span class="hl-keyword">stop</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"true"</span>) <span class="hl-combinator">|</span> <span class="hl-site">println</span>(<span class="hl-literal">"false"</span>)
</pre>
</p><p>
The asymmetric combinator may include a full pattern P instead of just a variable name. Any
value published by G is matched against the pattern P. If this match is successful, then G
terminates and all of the bindings of the pattern P are made in F. Otherwise, the published 
value is simply ignored and G continues to execute.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish either 9 or 25, but not 16.</span>
<span class="hl-variable">x</span>*<span class="hl-variable">x</span> <span class="hl-combinator">&lt;</span>(<span class="hl-variable">x</span>,<span class="hl-literal">true</span>)<span class="hl-combinator">&lt;</span> ( (<span class="hl-literal">3</span>,<span class="hl-literal">true</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">4</span>,<span class="hl-literal">false</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">5</span>,<span class="hl-literal">true</span>) )
</pre>
</p><p>
Note that even if <code class="code">(<span class="hl-literal">4</span>,<span class="hl-literal">false</span>)</code> is published before <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">true</span>)</code> or <code class="code">(<span class="hl-literal">5</span>,<span class="hl-literal">true</span>)</code>, 
it is ignored. The right side continues to execute and will publish one of <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">true</span>)</code> or 
<code class="code">(<span class="hl-literal">5</span>,<span class="hl-literal">true</span>)</code>.
</p> 3



</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N106F8"></a>1.3.3.&nbsp;Revising Cor expressions</h3></div></div></div><p>
Now that we have introduced concurrency and state, some of the assumptions we
made when describing the behavior of functional expressions in Cor no longer hold.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N106FD"></a>1.3.3.1.&nbsp;<code class="code"><span class="hl-keyword">val</span></code></h4></div></div></div><p>
It turns out that <code class="code"><span class="hl-keyword">val</span> <span class="hl-variable">x</span> = <span class="hl-variable">g</span></code> followed by expression <code class="code"><span class="hl-variable">f</span></code> is 
actually just a prefix form of the asymmetric combinator <code class="code"><span class="hl-variable">f</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-variable">g</span></code>.
Thus, <code class="code"><span class="hl-keyword">val</span></code> shares all of the behavior of the asymmetric combinator,
which we have already described. This is also true when a pattern is used instead
of a variable name.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1070F"></a>1.3.3.2.&nbsp;<code class="code"><span class="hl-keyword">if</span></code></h4></div></div></div><p>
The conditional expression <code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G
is actually a derived form based on a site named <code class="code"><span class="hl-keyword">if</span></code>. The <code class="code"><span class="hl-keyword">if</span></code>
site takes a boolean argument; it returns a signal if that argument is <code class="code"><span class="hl-literal">true</span></code>,
or remains silent if the argument is <code class="code"><span class="hl-literal">false</span></code>. When the <code class="code"><span class="hl-keyword">else</span></code>
branch of a conditional is unnecessary,we can use the <code class="code"><span class="hl-keyword">if</span></code> site and the 
sequential combinator to write the simpler expression <code class="code"><span class="hl-keyword">if</span>(</code>E<code class="code">) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>F.
</p><p>
<code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G is equivalent to
to <code class="code">( <span class="hl-keyword">if</span>(<span class="hl-variable">b</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>F<code class="code"> <span class="hl-combinator">|</span> <span class="hl-keyword">if</span>(~<span class="hl-variable">b</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>G<code class="code"> ) <span class="hl-combinator">&lt;</span><span class="hl-variable">b</span><span class="hl-combinator">&lt;</span> </code>E.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1074A"></a>1.3.3.3.&nbsp;Treating Orc expressions functionally</h4></div></div></div><p>
An Orc expression with concurrency combinators may occur as a subexpression of a Cor expression,
for example as an operand to an arithmetic operation, or as an argument to a function call. The
execution of an Orc expression may publish many values and perform many site calls. What does
such an expression mean in a purely functional context, where only one value is expected? For 
example, what does <code class="code"><span class="hl-literal">2</span> + (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)</code> publish? 
</p><p>
The specific syntactic contexts we are interested in are as follows (E is any Orc expression):

<div class="informaltable"><a name="value-context-table"></a><table border="0" width="40%"><colgroup><col align="left"><col align="right"></colgroup><tbody><tr><td align="left">E <span class="emphasis"><em>op</em></span> E</td><td align="right"><span class="emphasis"><em>operators</em></span></td></tr><tr><td align="left"><code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> ...</td><td align="right"><span class="emphasis"><em>conditionals</em></span></td></tr><tr><td align="left">X<code class="code">(</code> ... <code class="code">,</code> E <code class="code">,</code> ... <code class="code">)</code></td><td align="right"><span class="emphasis"><em>calls</em></span></td></tr><tr><td align="left"><code class="code">(</code> ... <code class="code">,</code> E <code class="code">,</code> ... <code class="code">)</code></td><td align="right"><span class="emphasis"><em>tuples</em></span></td></tr><tr><td align="left"><code class="code">[</code> ... <code class="code">,</code> E <code class="code">,</code> ... <code class="code">]</code></td><td align="right"><span class="emphasis"><em>lists</em></span></td></tr></tbody></table></div>
</p><p>
These are the contexts where only one value is expected from E. Whenever an Orc expression
appears in such a context, it executes until it publishes its first value, and then it is 
terminated. The published value is used in the context as if it were the result of evaluating
the expression.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish either 5 or 6</span>
<span class="hl-literal">2</span> + (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)
</pre>
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish exactly one of 0, 1, 2 or 3</span>
(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">2</span>) + (<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span>)
</pre>
</p><p>
To be precise, whenever an Orc expression appears in a Cor context, it is treated as if it was 
on the right side of an asymmetric combinator, using a fresh variable name to fill in the hole. 
Thus, C[E] (where E is an Orc expression and C is a Cor context) translates to the Orc expression 
C[<code class="code"><span class="hl-variable">x</span></code>] <code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code> E. This translation repeats until no Orc
expression appears within a Cor context. 
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N107C3"></a>1.3.3.4.&nbsp;Functions</h4></div></div></div><p>
The body of a function in Orc may be any Orc expression; thus, function
bodies in Orc are executed rather than evaluated, and may engage in communication
and publish multiple values.
</p><p>
A function call in Orc, as in Cor, binds the values of its actual parameters
to its formal parameters, and then executes the function body with those bindings.
Whenever the function body publishes a value, the function call publishes that
value. Thus, unlike a site call, or a pure functional Cor call, an Orc function
call may publish many values.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Publish all integers in the interval [0,n], in arbitrary order. </span>
<span class="hl-site">Range</span>(<span class="hl-variable">n</span>) = <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) 
             <span class="hl-keyword">then</span> <span class="hl-keyword">stop</span> 
             <span class="hl-keyword">else</span> (<span class="hl-variable">n</span> <span class="hl-combinator">|</span> <span class="hl-site">Range</span>(<span class="hl-variable">n</span>-<span class="hl-literal">1</span>)) 

<span class="hl-comment">-- Publishes 0, 1, 2, and 3 in arbitrary order.</span>
<span class="hl-site">Range</span>(<span class="hl-literal">3</span>)
</pre>
</p><p>
In the context of Orc, function calls are not strict. When a function
is called, the function body and the arguments are actually evaluated
in parallel. Whenever an execution in the function body reaches one of 
the argument variables, it blocks until the corresponding argument 
expression publishes a value. 
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N107D2"></a>1.3.4.&nbsp;Time</h3></div></div></div><p>
Orc is designed to communicate with the external world, and one of the
most important characteristics of the external world is the passage of
time. Orc implicitly interacts with the passage of time by calling external
services which take time to respond. However, Orc can also explicitly
wait for some amount of time, using the special site <code class="code"><span class="hl-variable">Rtimer</span></code>. 
</p><p>
The site <code class="code"><span class="hl-variable">Rtimer</span></code> is a relative timer. It takes as an argument
an amount of time to wait. It waits for exactly that amount of time,
and then responds with a signal. By default, this argument is in
milliseconds.
</p><p>
<pre class="orc">
<span class="hl-comment">-- Print "red", wait for 3 seconds (3000 ms), and then print "green" </span>
<span class="hl-site">println</span>(<span class="hl-literal">"red"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">3000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"green"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
</pre>
</p><p>
The timer can be used together with recursion to create a <em class="firstterm">metronome</em>:
an expression which publishes values at fixed time intervals. The following example
defines a metronome which publishes a signal once per second, indefinitely.
</p><p>
<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">Metronome</span>() = <span class="hl-keyword">signal</span> <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Metronome</span>()
</pre>
</p><p>
We can also use <code class="code"><span class="hl-variable">Rtimer</span></code> together with the asymmetric combinator 
to enforce a timeout.
</p><p>
<pre class="programlisting">
<span class="hl-comment">-- Publish the result of a Google search</span>
<span class="hl-comment">-- If it takes more than 5 seconds, time  </span>
<span class="hl-variable">result</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">result</span><span class="hl-combinator">&lt;</span> <span class="hl-site">Google</span>(<span class="hl-literal">"impatience"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Rtimer</span>(<span class="hl-literal">5000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"Search timed out (wait &gt; 5 sec)."</span>
</pre>
</p>



We present many more examples of programming techniques using time in <a class="link" href="#chapter.methodology" title="Chapter&nbsp;2.&nbsp;Programming Methodology">Chapter 2</a>.

</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N107FE"></a>1.4.&nbsp;Advanced Features of Orc</h2></div></div></div><p>
In this section we introduce some advanced features of Orc. These include curried
function definitions and curried calls, a special syntax for writing calls in
an object-oriented style, extensions to pattern matching, new forms of declarations,
and a new concurrency combinator.
</p><p>
<div class="table"><a name="advanced-ebnf-table"></a><p class="title"><b>Table&nbsp;1.4.&nbsp;Advanced Syntax of Orc</b></p><div class="table-contents"><table summary="Advanced Syntax of Orc" border="0" width="80%"><colgroup><col align="right"><col align="center"><col align="left"><col align="left"><col align="left"></colgroup><tbody><tr><td align="right">E</td><td align="center">::=</td><td align="left">...</td><td align="left"><span class="emphasis"><em>Expression</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X G+</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>generalized call</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E <code class="code"><span class="hl-combinator">;</span></code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>after combinator</em></span></td></tr><tr><td align="right">G</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Argument group</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left"> <code class="code">(</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">)</code> </td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>curried arguments</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"> <code class="code">.</code><span class="emphasis"><em>field</em></span> </td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>field access</em></span></td></tr><tr><td align="right">P</td><td align="center">::=</td><td align="left">...</td><td align="left"><span class="emphasis"><em>Pattern</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">!</code>P</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>bang pattern</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">P <code class="code"><span class="hl-keyword">as</span></code> X</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>as pattern</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X<code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>call pattern</em></span></td></tr><tr><td align="right">D</td><td align="center">::=</td><td align="left"> ... </td><td align="left"><span class="emphasis"><em>Declaration</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">class</span></code> X <code class="code">=</code> <span class="emphasis"><em>classname</em></span></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>class declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">include</span></code> <code class="code"><span class="hl-literal">"</span></code> <span class="emphasis"><em>filename</em></span> <code class="code"><span class="hl-literal">"</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>inclusion</em></span></td></tr></tbody></table></div></div><br class="table-break">
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N108E5"></a>1.4.1.&nbsp;Special call forms</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N108E8"></a>1.4.1.1.&nbsp;The <code class="code">.</code> notation</h4></div></div></div><p>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code class="code"><span class="hl-variable">obj</span>.<span class="hl-site">m</span>()</code> calls the method
<code class="code"><span class="hl-variable">m</span></code> of the object <code class="code"><span class="hl-variable">obj</span></code>. 
</p><p>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">msg</span></code>, for any identifiers <code class="code"><span class="hl-variable">x</span></code> and <code class="code"><span class="hl-variable">msg</span></code>. This attempts
to treat the value bound to <code class="code"><span class="hl-variable">x</span></code> as a site, and call it with a special 
<em class="firstterm">message</em> value. If the value cannot be interpreted as a site, no call is made. 
If that site understands the message <code class="code"><span class="hl-variable">msg</span></code> (for example, if <code class="code"><span class="hl-variable">x</span></code> is 
bound to a Java object with a field called <code class="code"><span class="hl-variable">msg</span></code>), the site interprets the message 
and responds with some appropriate value. If the value is a site, but it does not 
understand the message sent to it, it does not respond, and no publication occurs. 
</p><p>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code class="code"><span class="hl-variable">c</span></code> might understand the messages
<code class="code"><span class="hl-variable">get</span></code> and <code class="code"><span class="hl-variable">put</span></code>, to get values from and put values on that channel,
respectively. Such calls would be written <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">get</span>()</code>, or <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-literal">6</span>)</code>.
</p><p>
Such calls actually occur in two steps: first <code class="code"><span class="hl-variable">c</span>.<span class="hl-variable">put</span></code> sends the message
<code class="code"><span class="hl-variable">put</span></code> to the value <code class="code"><span class="hl-variable">c</span></code>; this publishes a site whose only purpose
is to put values to that channel. Then, that 'put site' is called on the argument
<code class="code"><span class="hl-literal">6</span></code>, sending 6 on that channel. Readers familiar with functional programming
will recognize this technique as <span class="emphasis"><em>currying</em></span>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10935"></a>1.4.1.2.&nbsp;Currying</h4></div></div></div><p>
It is sometimes useful to <span class="emphasis"><em>stage</em></span> the arguments to a function; that is,
rather than writing a function on two arguments, one instead writes a function on one
argument which returns a function taking the second argument and performing the remainder
of the evaluation. 
</p><p>
This technique is known as <span class="emphasis"><em>currying</em></span> and it is common in functional
programming languages. It is obviously supported in Orc since it is possible to define
closures. However, there is additional support for making curried function calls, and
for defining functions directly in a curried way.
</p><p>
Suppose we want to define a curried addition function on two arguments, and later 
apply that function to the arguments 3 and 4. The verbose way to write such 
a program is as follows:

<pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">add</span>(<span class="hl-variable">a</span>) = ( <span class="hl-keyword">lambda</span>(<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span> )  
<span class="hl-keyword">val</span> <span class="hl-variable">f</span> = <span class="hl-site">add</span>(<span class="hl-literal">3</span>)
<span class="hl-site">f</span>(<span class="hl-literal">4</span>)
</pre>

</p><p>
When defining a curried function, we have abstracted it in two steps, and when
applying it we have written two separate calls. However, Orc has a special syntax
for curried definitions and curried applications that will simplify both of
these steps.

<pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">add</span>(<span class="hl-variable">a</span>)(<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span>
<span class="hl-site">add</span>(<span class="hl-literal">3</span>)(<span class="hl-literal">4</span>)
</pre>

Definitions may have multiple argument sequences; they are enclosed in parentheses
and concatenated. Curried function calls chain together multiple applications in
a similar way.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1094D"></a>1.4.2.&nbsp;Extensions to pattern matching</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N10950"></a>1.4.2.1.&nbsp;Bang pattern</h4></div></div></div><p>
A bang pattern, written <code class="code">!<span class="hl-variable">p</span></code>, will publish the value that matches the pattern 
<code class="code"><span class="hl-variable">p</span></code> if the match is successful.

<pre class="orc">
(<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>)  <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>,!<span class="hl-variable">y</span>,!<span class="hl-variable">z</span>)<span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
</pre>

This publishes <code class="code"><span class="hl-literal">2</span></code> and <code class="code"><span class="hl-literal">3</span></code>. 
</p><p>
Note that a bang pattern will not publish if the overall match fails, even if its particular match succeeds:

<pre class="orc">
( (<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">4</span>,<span class="hl-literal">5</span>,<span class="hl-literal">6</span>) )  <span class="hl-combinator">&gt;</span>(<span class="hl-literal">1</span>,!<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)<span class="hl-combinator">&gt;</span>  <span class="hl-keyword">stop</span>
</pre>

This publishes only <code class="code"><span class="hl-literal">2</span></code>. Even though the pattern <code class="code"><span class="hl-variable">x</span></code> matches the value <code class="code"><span class="hl-literal">5</span></code>, 
the overall pattern <code class="code">(<span class="hl-literal">1</span>,!<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)</code> does not match the value <code class="code">(<span class="hl-literal">4</span>,<span class="hl-literal">5</span>,<span class="hl-literal">6</span>)</code>, so <code class="code"><span class="hl-literal">5</span></code> 
is not published.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1097D"></a>1.4.2.2.&nbsp;As pattern</h4></div></div></div><p>
In taking apart a value with a pattern, it is often useful to capture intermediate results.

<pre class="programlisting">
<span class="hl-keyword">val</span> (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) = ((<span class="hl-literal">1</span>,<span class="hl-literal">2</span>),(<span class="hl-literal">3</span>,<span class="hl-literal">4</span>))
<span class="hl-keyword">val</span> (<span class="hl-variable">ax</span>,<span class="hl-variable">ay</span>) = <span class="hl-variable">a</span>
<span class="hl-keyword">val</span> (<span class="hl-variable">bx</span>,<span class="hl-variable">by</span>) = <span class="hl-variable">b</span>
</pre>

We can use the <code class="code"><span class="hl-keyword">as</span></code> keyword to simplify this process, giving a name to an entire
subpattern. Here is an equivalent version of the above code.

<pre class="programlisting">
<span class="hl-keyword">val</span> ((<span class="hl-variable">ax</span>,<span class="hl-variable">ay</span>) <span class="hl-keyword">as</span> <span class="hl-variable">a</span>, (<span class="hl-variable">bx</span>,<span class="hl-variable">by</span>) <span class="hl-keyword">as</span> <span class="hl-variable">b</span>) = ((<span class="hl-literal">1</span>,<span class="hl-literal">2</span>),(<span class="hl-literal">3</span>,<span class="hl-literal">4</span>))
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1098B"></a>1.4.2.3.&nbsp;Site patterns</h4></div></div></div><p>
A site pattern, written <code class="code"><span class="hl-site">M</span>(<span class="hl-variable">p</span>,...,<span class="hl-variable">p</span>)</code>, matches any value which was published by a call to the
site <code class="code"><span class="hl-variable">M</span></code> with arguments that match the tuple <code class="code">(<span class="hl-variable">p</span>,...,<span class="hl-variable">p</span>)</code>. 
</p><p>
Site patterns provide a generalized version of datatype matching, as seen in the <code class="code"><span class="hl-variable">case</span> .. <span class="hl-variable">of</span></code>
 or <code class="code"><span class="hl-variable">match</span> .. <span class="hl-variable">with</span> </code> constructs provided by Haskell and ML.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N109A1"></a>1.4.2.4.&nbsp;Patterns as views</h4></div></div></div><p>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <em class="firstterm">view</em> of that data.
</p><p>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</p><p>
The concept of views and view patterns is not new in programming languages; it has been demonstrated
in other languages, most notably <a class="ulink" href="http://www.scala-lang.org/" target="_top">Scala</a>. In fact, the 
underlying implementation strategy for using sites as view patterns is very similar to the use of
extractor objects and the <code class="code"><span class="hl-variable">unapply</span></code> method in Scala.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N109B4"></a>1.4.3.&nbsp;New forms of declarations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N109B7"></a>1.4.3.1.&nbsp;Class declarations</h4></div></div></div><p>
When Orc is run on top of an object-oriented programming language, classes
from that language may be used as sites in Orc itself, via the <code class="code"><span class="hl-keyword">class</span></code>
declaration. 
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- Use the String class from Java's standard library as a site -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">String</span> = <span class="hl-variable">java</span>.<span class="hl-variable">lang</span>.<span class="hl-variable">String</span>
<span class="hl-keyword">val</span> <span class="hl-variable">s</span> = <span class="hl-site">String</span>(<span class="hl-literal">"foo"</span>)
<span class="hl-variable">s</span>.<span class="hl-site">concat</span>(<span class="hl-literal">"bar"</span>)
</pre>
</p><p>
This program binds the variable <code class="code"><span class="hl-variable">String</span></code> to the constructor of Java's
String class. When it is called, it constructs a new instance of String, passing
the given arguments to the constructor.
</p><p>
This instance of String is a Java object; its methods are called and its fields
are accessed using the <code class="code">.</code> notation, just as one would expect in Java.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N109CE"></a>1.4.3.2.&nbsp;Included declarations</h4></div></div></div><p>
It is often convenient to group related declarations into units that can be
shared between programs. The <code class="code"><span class="hl-keyword">include</span></code> declaration offers a simple
way to do this. It names a source file containing a sequence of Orc declarations;
those declarations are incorporated into the program as if they had textually
replaced the include declaration.
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- Contents of fold.inc -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,[],<span class="hl-variable">s</span>) = <span class="hl-variable">s</span>
<span class="hl-keyword">def</span> <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,<span class="hl-variable">h</span>:<span class="hl-variable">t</span>,<span class="hl-variable">s</span>) = <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,<span class="hl-variable">t</span>,<span class="hl-site">f</span>(<span class="hl-variable">h</span>,<span class="hl-variable">s</span>))

<span class="hl-keyword">def</span> <span class="hl-site">foldr</span>(<span class="hl-variable">f</span>,<span class="hl-variable">l</span>,<span class="hl-variable">s</span>) = <span class="hl-site">foldl</span>(<span class="hl-variable">f</span>,<span class="hl-site">rev</span>(<span class="hl-variable">l</span>),<span class="hl-variable">s</span>)
</pre>
</p><p>
<pre class="programlisting">
<span class="hl-comment">{- This is the same as inserting the contents of fold.inc here -}</span>
<span class="hl-keyword">include</span> <span class="hl-literal">"fold.inc"</span>

<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">L</span>) = <span class="hl-site">foldl</span>(<span class="hl-keyword">lambda</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) = <span class="hl-variable">a</span>+<span class="hl-variable">b</span>, <span class="hl-variable">L</span>, <span class="hl-literal">0</span>)

<span class="hl-site">sum</span>([<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>])
</pre>
</p><p>
Note that these declarations still obey the rules of lexical scope. Also,
Orc does not detect shared declarations; if the same file is included twice,
its declarations occur twice.
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N109E2"></a>1.4.4.&nbsp;The after combinator</h3></div></div></div><p>
Orc has a fourth concurrency combinator: the <em class="firstterm">after</em> combinator,
written <code class="code"><span class="hl-variable">f</span> <span class="hl-combinator">;</span> <span class="hl-variable">g</span></code>. The after combinator executes its left side, publishing 
each of its publications as they occur. When the left side is done executing, then 
the right side executes.
</p><p>
We determine when an expression is done executing using the following rules.

<div class="itemizedlist"><ul type="disc"><li>Any Cor expression is done when it is fully evaluated.</li><li>A site call is done when it has published a value. A site may
also <em class="firstterm">refuse</em> a call, in which case the call is silent and
done.</li><li>F <code class="code"><span class="hl-combinator">|</span></code> G is done when its subexpressions F and G are done.</li><li>F<code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> </code>G is done when F is done and all copies of G are done.</li><li>F<code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code>G is done when F is done, and G is either 
done or has been terminated after publishing a value.</li><li>F <code class="code"><span class="hl-combinator">;</span></code> G is done when its subexpressions F and G are done.</li><li><code class="code"><span class="hl-keyword">stop</span></code> is done.</li></ul></div>

</p><p>
The after combinator is intended to capture as closely as possible the notion of sequential
processing, as denoted by <code class="code"><span class="hl-combinator">;</span></code> in other languages. It was not present in the
original formulation of the Orc concurrency calculus; it has been added to support computation
and iteration over strictly finite data. Sequential programs conflate the concept of
producing a value with the concept of completion. Orc separates these two concepts; variable
binding combinators like <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> </code> and <code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code> handle
values, whereas <code class="code"><span class="hl-combinator">;</span></code> detects the completion of an execution.
</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chapter.methodology"></a>Chapter&nbsp;2.&nbsp;Programming Methodology</h2></div></div></div>

Under construction.

</div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chapter.services"></a>Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</h2></div></div></div>

Under construction.

</div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="N10A2B"></a>Appendix&nbsp;A.&nbsp;Complete Syntax of Orc</h2></div></div></div><p>

<div class="table"><a name="full-ebnf-grammar"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;Complete Syntax of Orc</b></p><div class="table-contents"><table summary="Complete Syntax of Orc" border="0" width="80%"><colgroup><col align="right"><col align="center"><col align="left"><col align="left"><col align="left"></colgroup><tbody><tr><td align="right">E</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Expression</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left">C</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>constant value</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E <span class="emphasis"><em>op</em></span> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>operator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>variable</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> E <code class="code"><span class="hl-keyword">else</span></code> E </td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>conditional</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X G+</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>call</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">(</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>tuple</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">[</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">]</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>list</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">D E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>scoped declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E <code class="code"><span class="hl-combinator">|</span></code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>parallel combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E<code class="code"> <span class="hl-combinator">&gt;</span></code>P<code class="code"><span class="hl-combinator">&gt;</span> </code>E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>sequential combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E<code class="code"> <span class="hl-combinator">&lt;</span></code>P<code class="code"><span class="hl-combinator">&lt;</span> </code>E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>asymmetric combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">E <code class="code"><span class="hl-combinator">;</span></code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>after combinator</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">stop</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>silent expression</em></span></td></tr><tr><td align="right">G</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Argument group</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left"> <code class="code">(</code> E <code class="code">,</code> ... <code class="code">,</code> E <code class="code">)</code> </td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>arguments</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"> <code class="code">.</code><span class="emphasis"><em>field</em></span> </td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>field access</em></span></td></tr><tr><td align="right">C</td><td align="center">::=</td><td align="left"><code class="code"><span class="hl-literal">true</span></code> | <code class="code"><span class="hl-literal">false</span></code> | <span class="emphasis"><em>integer</em></span> | <span class="emphasis"><em>string</em></span> | <code class="code"><span class="hl-keyword">signal</span></code></td><td align="left"><span class="emphasis"><em>Constant</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">X</td><td align="center">::=</td><td align="left"><span class="emphasis"><em>identifier</em></span></td><td align="left"><span class="emphasis"><em>Variable</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">D</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Declaration</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left"><code class="code"><span class="hl-keyword">val</span></code> P <code class="code">=</code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>value declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">def</span></code> X<code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code> <code class="code">=</code> E</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>function declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">site</span></code> X <code class="code">=</code> <span class="emphasis"><em>URL</em></span></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>site declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">class</span></code> X <code class="code">=</code> <span class="emphasis"><em>classname</em></span></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>class declaration</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-keyword">include</span></code> <code class="code"><span class="hl-literal">"</span></code> <span class="emphasis"><em>filename</em></span> <code class="code"><span class="hl-literal">"</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>inclusion</em></span></td></tr><tr><td align="right">P</td><td align="center">::=</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>Pattern</em></span></td><td align="left">&nbsp;</td></tr><tr><td align="right">&nbsp;</td><td align="center">&nbsp;</td><td align="left">X</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>variable</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">C</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>constant</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code"><span class="hl-variable">_</span></code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>wildcard</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>tuple</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">[</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">]</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>list</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left"><code class="code">!</code>P</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>bang pattern</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">P <code class="code"><span class="hl-keyword">as</span></code> X</td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>as pattern</em></span></td></tr><tr><td align="right">&nbsp;</td><td align="center">|</td><td align="left">X<code class="code">(</code> P <code class="code">,</code> ... <code class="code">,</code> P <code class="code">)</code></td><td align="left">&nbsp;</td><td align="left"><span class="emphasis"><em>call pattern</em></span></td></tr></tbody></table></div></div><br class="table-break">
</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix.library"></a>Appendix&nbsp;B.&nbsp;Standard Library</h2></div></div></div>
Under construction.
</div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="N10C4D"></a>Appendix&nbsp;C.&nbsp;FAQ</h2></div></div></div>

Under construction.

</div></div><script type="text/javascript" src="/orchard/orc.js"></script></body></html>