# vim: set et ts=2 sw=2: #

Orc service brainstorming:

- Responsibilities
  - Compile Orc programs to TIL
  - Report on compilation errors
  - Submit TIL for execution as job
  - Check status of job
    - Receive notification of status changes?
  - Manage jobs
    - List
    - Abort
    - Pause/resume (with checkpointing?)
  - Receive published values from job
  - Debugging: add this on later?

- RPC or document-oriented?
  - Concept seems better suited to RPC

- Synchronous, semi-synchronous, or asynchronous?
  - Synchronous (pull)
    - simpler client code, no hassle with firewalls
    - requires polling for inherently asynchronous operations like receiving published values
  - Semi-synchronous (push/pull)
    - use long-running connections to wait for data
    - e.g. "Comet" (long-running HTTP AJAX connections)
    - requires special server support to handle long-lived connections
      - Apache won't cut it
      - Some Java Servlet containers might
  - Asynchronous (push)
    - requires an open port on the client side
    - probably not good to require
    - but maybe good to support for clients that can do it

- Underlying protocol
  - TCP/IP assumed for transport layer
  - Should our API try to be protocol-neutral? With bindings to different protocols?
  - Possibilities:
    - HTTP: best for text-based data, widely understood, easy to fit through firewalls
      - SOAP(-RPC): possibly too heavyweight
      - REST: unstructured, not RPC-oriented
      - JSON: ditto
      - Make up our own (sexprs?)
    - Erlang wire protocol
      - Libraries for Java and C
      - Binary protocol
      - Somewhat Erlang-centric (especially in terms of datatypes)
      - Asynchronous
    - Java RMI
      - Easy to implement!
      - Very Java-centric
      - Fully synchronous

- Representations for data types?
  - Use XML for everything?
  - Basic types
    - String, List, Tuple, Int, Float (issues with base-10 text encoding!)
    - Sites: URIs the natural choice
  - Our type system needs to subsume those used by common services:
    - XML (XML Schema)
    - JSON

- Typing
  - Typing issue: If service types are treated as existentials, or use nominal
    typing, how does the user make new instances of those types?
  - Can we have a combination nominal/structural typing where you can cast
    between named types but the named types must have the same structure?
  - Is XML Schema rich enough to be our core type language?

- Security
  - Developer keys or Username and password
  - Use time-limited sessions?
  - Use SSL for protocol security

API sketch:
  - compile :: String -> (TIL | [CompilationError])
    - Compilation errors should include line and extent information to allow for editor highlighting
  - submit :: TIL -> (Job | [SubmitError])
    - Job should be scoped to the specific developer account
    - Submit errors may include
      - Resource limits reached
      - Improper TIL
      - TIL violates sandbox constraints for account
  - current_status :: Job -> (New | Running | Waiting | Paused | Dead | JobError)
  - changed_status :: Job -> (New | Running | Waiting | Paused | Dead | JobError)
    - semi-synchronous version, does not return until status changes
  - list :: [Job]
  - abort :: Job -> (OK | JobError)
  - pause :: Job -> (OK | JobError)
  - resume :: Job -> (OK | JobError)
  - receive :: Job -> ([OrcValue] | JobError)
    - returns all available published values
    - semi-synchronous version, does not return until a value is published, and then returns immediately
    - value could include a timestamp and other meta-data to aid in debugging (source code origin?)
    - server must queue values

Job state machine:
  - New
    - begin execution -> Running
  - Running
    - no active tokens -> Waiting
    - no live tokens -> Dead
    - abort -> Dead
    - pause -> Paused
  - Waiting
    - site call returns -> Running
    - abort -> Dead
    - pause -> Paused
  - Pause
    - abort -> Dead
    - resume -> Running
  - Dead
    - garbage collected -> FINISH
