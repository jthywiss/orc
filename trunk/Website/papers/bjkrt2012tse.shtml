<!--#include virtual="../template/header.shtml" --> 

<script src="/orchard/orc.js" type="text/javascript"></script>

<a id="top"></a><h2>Supplemental material to:</h2>
<h1>QoS-Aware Management of Monotonic Service Orchestrations</h1>

<p>This page is supplemental material to:
A. Benveniste, C. Jard, A. Kattepur, S. Rosario, and J.A. Thywissen, 
"QoS-Aware Management of Monotonic Service Orchestrations,"
Submitted to <cite>IEEE Transactions in Software Engineering</cite>, 2012.</p>

<ul>
<li><a href="#SLADeclaration">SLADeclaration.orc&mdash;Declaration of the SLA for the TravelAgent2 orchestration.</a></li>
<li><a href="#TravelAgent">TravelAgent.orc&mdash;The Orc specification of the TravelAgent2 orchestration</a></li>
<li><a href="#TravelAgentWeaved">TravelAgentWeaved&mdash;The QoS-weaved description of the TravelAgent2 orchestration</a></li>
</ul>

<a id="SLADeclaration"></a><h2>SLADeclaration.orc <small>(<a href="#top">top</a>)</small></h2>

<p>Declaration of the SLA for the TravelAgent2 orchestration. We make use of
the <code>def class</code> declaration to implement new sites to track QoS
metrics. Data structures and operations on records <code>{. .}</code>, lists
<code>[f,g]</code> and tuples <code>(f,g)</code> are used. Other general sites
available in Orc such as real time (<code>Rtime</code>) rewritable storage
locations (<code>Ref</code> and FIFO channels (<code>Channel</code>) are also
invoked.</p>

<pre class="orc">
def bestQoS(comparer, publisher) = head(sortBy(comparer, publisher))

def class InterQueryTime()=
   def QoS(sitex) =
      val s = {. r = Ref(0), c = Channel() .}		
      val curTime = Rtime()
      s.r? &gt;p&gt; (s.c.put(curTime-p) | s.r:=(curTime)) &gt;&gt; Dictionary() &gt;sitex&gt; 
      sitex.InterQueryTime := s &gt;&gt; stop
   def QoSCompare(it1,it2) = it1 &gt;= it2
   def QoSCompete(it1,it2) = bestQoS(QoSCompare,[it1,it2])
   stop

def class ResponseTime() =
   def QoS(sitex,d) = Rtime()-d &gt;q&gt; q
   def QoSOplus(rt1,rt2) = rt1+rt2
   def QoSCompare(rt1,rt2) = rt1 &lt;= rt2
   def QoSCompete(rt1,rt2) = bestQoS(QoSCompare,[rt1,rt2])
   def QoSVee(rt1,rt2) = max(rt1,rt2)
   stop

def class Cost() =
   def QoS(sitex,c)=
      val s = Ref([]) 
      s? &gt;x&gt; QoSOplus(x,[]) &gt;q&gt; s:= q &gt;&gt; Dictionary() &gt;sitex&gt; sitex.Cost := s
   def QoSOplus(c1,c2) =
      def Oplus([],[]) = []
      def Oplus(x:xs,y:ys) = (x+y):Oplus(xs,ys)
      Oplus(c1,c2)
   def QoSCompare(c1,c2) =
      def Compare([],[]) = true
      def Compare(x:xs,y:ys) = (x &lt;= y) && Compare(xs,ys)
      Compare(c1,c2)
   def QoSCompete(c1,c2) = bestQoS(QoSCompare,[c1,c2])	                                   	
   def QoSVee(c1,c2) =
      def Vee([],[]) = []
      def Vee(x:xs,y:ys) = max(x,y):Vee(xs,ys)
      Vee(c1,c2)
   stop
</pre>

<a id="TravelAgent"></a><h2>TravelAgent.orc <small>(<a href="#top">top</a>)</small></h2>

<p>The Orc specification of the TravelAgent2 orchestration. The general purpose
<code>Dictionary</code> site is used as a mutable map from field names to
values, references to which are accessed using <code>.</code> access. Values
held by references are obtained using <code>x?</code> (equivalent to
<code>x.read()</code>) and set using <code>x:=y</code> (equivalent to
<code>x.write(y)</code>.</p>

<pre class="orc">
val AirlineList = ["Airline 1", "Airline 2"]
val HotelList = ["Hotel A", "Hotel B"]

--BestQoS and simulation utilities

def bestQ(comparer,publisher) =  head(sortBy(comparer,collect(publisher)))
def cat() = if (Random(1)=1) then "Economy" else "Premium"
val simElapsedTime = Rclock()

--Sites declared

def TravelAgent(SalesOrder,Budget) =

  def inquireCost(List) = each(List) &gt;sup&gt; Dictionary() &gt;ProductDetails&gt; ProductDetails.Company := sup&gt;&gt;
  ProductDetails.cost := Random(100) &gt;&gt; ProductDetails
  def inquireCategory(List) = each(List) &gt;sup&gt; Dictionary() &gt;ProductDetails&gt; ProductDetails.Company
  := sup &gt;&gt; ProductDetails.cost := Random(100) &gt;&gt; ProductDetails.category := cat() &gt;&gt; ProductDetails

  def compareCost(x, y) = x.cost? &lt;= y.cost?
  def compareCategory(x, y) = if x.category?="Economy" then false else if y.category?="Economy" then
  true else compareCost(x, y)

  def GenerateOrder(SalesOrder,Budget) = Dictionary() &gt;GenerateInvoice&gt; GenerateInvoice.TravelAgent :=
  SalesOrder.ordernumber? &gt;&gt; GenerateInvoice.acceptedTime := simElapsedTime.time() &gt;&gt; Println("Order
  "+GenerateInvoice.TravelAgent?+" accepted at time "+GenerateInvoice.acceptedTime?) &gt;&gt;
  (GenerateInvoice,Budget)

  def AirlineCompany(GenerateInvoice) = bestQ(compareCost, defer(inquireCost,AirlineList)) &gt;q&gt;
  GenerateInvoice.AirQuote := q
  def HotelBooking(GenerateInvoice) = bestQ(compareCategory, defer(inquireCategory,HotelList)) &gt;q&gt;
  GenerateInvoice.HotelQuote := q

  def CheckBudget(GenerateInvoice,Budget) = if (GenerateInvoice.AirQuote?.cost? +
  GenerateInvoice.HotelQuote?.cost? &lt;: Budget) then GenerateInvoice else (Println("Resubmit Order "
  +GenerateInvoice.TravelAgent?)&gt;&gt; Dictionary() &gt;SalesOrder&gt; SalesOrder.ordernumber:=
  GenerateInvoice.TravelAgent? &gt;&gt; (SalesOrder,GenerateOrder(SalesOrder,Budget)))

  def timeout(x, t, SalesOrder) = Let(Some(x) | (Rwait(t) &gt;&gt; notifyFail(SalesOrder, "Timeout") &gt;&gt; None()))
  def notifyFail(SalesOrder, reason) = Println("Order "+SalesOrder.id?+" failed: "+reason)
  &gt;&gt; stop

timeout((GenerateOrder(SalesOrder,Budget) &gt;(GenerateInvoice,Budget)&gt; AirlineCompany(GenerateInvoice) &gt;&gt;
HotelBooking(GenerateInvoice) &gt;&gt; CheckBudget(GenerateInvoice,Budget)) , 2000, SalesOrder)
&gt;Some(GenerateInvoice)&gt; GenerateInvoice

--Simulation

def simulateOrders(n) = Dictionary() &gt;SalesOrder&gt; SalesOrder.ordernumber:= n &gt;&gt;
Println("Order "+n+" created") &gt;&gt; SalesOrder | Rwait(Random(100)) &gt;&gt; simulateOrders(n+1)

simulateOrders(1) &gt;SalesOrder&gt; TravelAgent(SalesOrder,50) &gt;GenerateInvoice&gt;
Println("Invoice for order "+SalesOrder.ordernumber?+" presented at time "+simElapsedTime.time()) &gt;&gt;stop
</pre&gt;

<a id="TravelAgentWeaved"></a><h2>TravelAgentWeaved.orc <small>(<a href="#top">top</a>)</small></h2>

<p>The QoS-weaved description of the TravelAgent2 orchestration. Pattern
matching is used extensively to assign and propagate QoS values.</p>

<pre class="orc">
{- TravelAgentWeaved.orc -- Orc program TravelAgentWeaved
 -
 - This file is supplemental material to:
 - A. Benveniste, C. Jard, A. Kattepur, S. Rosario, and J.A. Thywissen, "QoS-Aware
 - Management of Monotonic  Service Orchestrations," IEEE Trans. Softw. Eng. 2012.
 -
 - The Orc language is available at URL: http://orc.csres.utexas.edu/
 -}

--include the SLA Declaration sites

include "SLADeclaration.orc"

val AirlineList = ["Airline 1", "Airline 2"]
val HotelList = ["Hotel A", "Hotel B"]

--BestQoS and simulation utilities
def bestQ(comparer,publisher) =  head(sortBy(comparer,collect(publisher)))
def cat() = if (Random(1)=1) then "Economy" else "Premium"
val simElaspedTime = Rclock()
val RTimer = Ref(0)

--Sites declared
def TravelAgent(SalesOrder,Budget,ResponseTime,Cost) =

  def inquireCost(List) = each(List) &gt;sup&gt; Dictionary() &gt;ProductDetails&gt; ProductDetails.Company := sup&gt;&gt; 
  ProductDetails.cost := Random(100) &gt;&gt; ProductDetails
  def inquireCategory(List) = each(List) &gt;sup&gt; Dictionary() &gt;ProductDetails&gt; ProductDetails.Company := sup 
  &gt;&gt; ProductDetails.cost := Random(100) &gt;&gt; ProductDetails.category := cat() &gt;&gt; ProductDetails

  def compareCost(x, y) = x.cost? &lt;= y.cost?
  def compareCategory(x, y) = if x.category?="Economy" then false else if y.category?="Economy" then 
  true else compareCost(x, y)
  

  def GenerateOrder(SalesOrder,Budget) = (Dictionary() &gt;GenerateInvoice&gt; GenerateInvoice.TravelAgent :=
  SalesOrder.ordernumber? &gt;&gt; GenerateInvoice.acceptedTime := simElaspedTime.time() &gt;&gt; Println("Order
  "+GenerateInvoice.TravelAgent?+" accepted at time "+GenerateInvoice.acceptedTime?) &gt;&gt;
  (GenerateInvoice,Budget), Rclock().time()) &gt;((GenerateInvoice,Budget),d)&gt;
  ((GenerateInvoice,Budget),ResponseTime().QoS(GenerateOrder,d))
  
  def AirlineCompany(GenerateInvoice,Cost) = (bestQ(compareCost, defer(inquireCost,AirlineList)) &gt;q&gt;
  GenerateInvoice.AirQuote := q &gt;&gt; Cost().QoS(AirlineCompany,[q]), Rclock().time()) &gt;(q,d)&gt;
  (q,ResponseTime().QoS(AirlineCompany,d))
  def HotelBooking(GenerateInvoice,Cost) = (bestQ(compareCategory, defer(inquireCategory,HotelList)) 
  &gt;q&gt; GenerateInvoice.HotelQuote := q &gt;&gt; Cost().QoS(AirlineCompany,[q]), Rclock().time()) &gt;(q,d)&gt;
  (q,ResponseTime().QoS(HotelBooking,d))
  
  def CheckBudget(GenerateInvoice,Budget,Cost) = (if (GenerateInvoice.AirQuote?.cost? +
  GenerateInvoice.HotelQuote?.cost? &lt;: Budget) then GenerateInvoice else (Println("Resubmit Order "
  +GenerateInvoice.TravelAgent?+ " with bigger budget")&gt;&gt; Dictionary() &gt;SalesOrder&gt; 
  SalesOrder.ordernumber:= GenerateInvoice.TravelAgent? &gt;&gt; (SalesOrder,GenerateOrder(SalesOrder,Budget)))
  &gt;r&gt; Cost().QoSOplus(GenerateInvoice.AirQuote?, GenerateInvoice.HotelQuote?) &gt;v&gt; 
  Cost().QoSCompete(v, Budget) &gt;&gt; r, Rclock().time()) &gt;(r,d)&gt; (r,ResponseTime().QoS(CheckBudget,d))
  
  def timeout(x, t, SalesOrder) = Let(Some(x) | (Rwait(t) &gt;&gt; notifyFail(SalesOrder, "Timeout") &gt;&gt; None()))
  def notifyFail(SalesOrder, reason) = Println("Order "+SalesOrder.id?+" failed: "+reason)
  &gt;&gt; stop

GenerateOrder(SalesOrder,Budget) &gt;((GenerateInvoice,Budget),RT)&gt; 
timeout((AirlineCompany(GenerateInvoice,Cost) &gt;(q,RT1)&gt; (q,ResponseTime().QoSOplus(RT,RT1)) &gt;(q,RT)&gt;
HotelBooking(GenerateInvoice,Cost) &gt;(q,RT2)&gt; (q,ResponseTime().QoSOplus(RT,RT2)) &gt;(q,RT)&gt;
CheckBudget(GenerateInvoice,Budget,Cost)) &gt;(r,RT3)&gt; (r,ResponseTime().QoSOplus(RT,RT3)) &gt;(r,RT)&gt; 
RTimer:=RT &gt;&gt; r, 2000, SalesOrder) &gt;Some(r)&gt; (GenerateInvoice,ResponseTime().QoSCompete(RTimer?,2000))
&gt;(GenerateInvoice,RT)&gt; (GenerateInvoice,RT) 
|  InterQueryTime().QoS(TravelAgent)


--Simulation
  
def simulateOrders(n) = Dictionary() &gt;SalesOrder&gt; SalesOrder.ordernumber:= n &gt;&gt; 
Println("Order "+n+" created") &gt;&gt; SalesOrder | Rwait(Random(100)) &gt;&gt; simulateOrders(n+1)  
   
simulateOrders(1) &gt;SalesOrder&gt; TravelAgent(SalesOrder,50,ResponseTime,Cost) &gt;GenerateInvoice&gt;
Println("Invoice for order "+SalesOrder.ordernumber?+" presented at time "+simElaspedTime.time()) &gt;&gt;stop
</pre>

<!--#include virtual="../template/footer.shtml" --> 
