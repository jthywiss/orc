<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Orc User Guide v2.0.0</title><meta content="DocBook XSL-NS Stylesheets V1.76.1" name="generator"><link xmlns:od="http://orc.csres.utexas.edu/OrcDocBook.xsd" xmlns:db="http://docbook.org/ns/docbook" type="text/css" rel="stylesheet" href="/orchard/orc.css"><link href="style.css" type="text/css" rel="stylesheet"><script type="text/javascript">
// Expandable content script from flooble.com.
// For more information please visit:
// http://www.flooble.com/scripts/expand.php
// Copyright 2002 Animus Pactum Consulting Inc.
//----------------------------------------------
function toggle(link, divId) {
	var lText = link.innerHTML;
	var d = document.getElementById(divId);
	if (lText == '+') {
		link.innerHTML = '&#8722;';
		d.style.display = 'block';
	} else {
		link.innerHTML = '+';
		d.style.display = 'none';
	}
}
</script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="Orc User Guide v2.0.0"><div><div><div><h1 class="title"><a name="userguide"></a>
	Orc User Guide v2.0.0

</h1></div><div><div class="author"><h3 class="author"><span class="orgname">The University of Texas at Austin</span><div class="address"><p></p></div><code class="uri">http://orc.csres.utexas.edu/</code></h3></div></div><div><p class="pubdate">2011-04-14</p></div><div><p class="copyright">Copyright &copy; 2011 The University of Texas at Austin</p></div><div><div class="legalnotice" title="License and Grant Information"><a name="legalnotice"></a><p class="legalnotice-title"><b>License and Grant Information</b></p><p>
			Use and redistribution of this file is governed by the license terms in
			the LICENSE file found in the project's top-level directory and also
			found at
			URL: http://orc.csres.utexas.edu/license.shtml .
		</p><p>
			This material is based upon work supported by the National Science
			Foundation under Grant No. CCF-0811536.
			Any opinions, findings, and conclusions or
			recommendations expressed in this document are those of the authors
			and do not necessarily reflect the views of the National Science
			Foundation.
		</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#ug.introduction">Introduction</a></span></dt><dt><span class="chapter"><a href="#ug.language">1. The Orc Programming Language</a></span></dt><dd><dl><dt><span class="section"><a href="#ug.language.cor">1.1. Cor: A Functional Subset</a></span></dt><dd><dl><dt><span class="section"><a href="#orc.constants">1.1.1. Constants</a></span></dt><dt><span class="section"><a href="#language.base.operators">1.1.2. Operators</a></span></dt><dt><span class="section"><a href="#N100EE">1.1.3. Conditionals</a></span></dt><dt><span class="section"><a href="#cor.variables">1.1.4. Variables</a></span></dt><dt><span class="section"><a href="#cor.data">1.1.5. Data Structures</a></span></dt><dt><span class="section"><a href="#orc.language.patterns">1.1.6. Patterns</a></span></dt><dt><span class="section"><a href="#cor.functions">1.1.7. Functions</a></span></dt><dt><span class="section"><a href="#N103CA">1.1.8. Comments</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.language.orc">1.2. Orc: Orchestrating services</a></span></dt><dd><dl><dt><span class="section"><a href="#orc.sites">1.2.1. Communicating with external services</a></span></dt><dt><span class="section"><a href="#combinators">1.2.2. The concurrency combinators of Orc</a></span></dt><dt><span class="section"><a href="#N10535">1.2.3. Revisiting Cor expressions</a></span></dt><dt><span class="section"><a href="#orc.language.time">1.2.4. Time</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.language.advanced">1.3. Advanced Features of Orc</a></span></dt><dd><dl><dt><span class="section"><a href="#special.dot">1.3.1. The <code class="code">.</code> notation</a></span></dt><dt><span class="section"><a href="#section.orc.datatypes">1.3.2. Datatypes</a></span></dt><dt><span class="section"><a href="#section.language.class">1.3.3. Classes</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ug.methodology">2. Programming Methodology</a></span></dt><dd><dl><dt><span class="section"><a href="#ug.methodology.convention">2.1. Syntactic and Stylistic Conventions</a></span></dt><dd><dl><dt><span class="section"><a href="#N10823">2.1.1. Parallel combinator</a></span></dt><dt><span class="section"><a href="#N1085C">2.1.2. Sequential combinator</a></span></dt><dt><span class="section"><a href="#style.pruning">2.1.3. Pruning combinator</a></span></dt><dt><span class="section"><a href="#N10907">2.1.4. Declarations</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.methodology.idiom">2.2. Programming Idioms</a></span></dt><dd><dl><dt><span class="section"><a href="#methodology.channels">2.2.1. Channels</a></span></dt><dt><span class="section"><a href="#N109C6">2.2.2. Lists</a></span></dt><dt><span class="section"><a href="#methodology.streams">2.2.3. Streams</a></span></dt><dt><span class="section"><a href="#methodology.mutable">2.2.4. Mutable References</a></span></dt><dt><span class="section"><a href="#N10ADE">2.2.5. Tables</a></span></dt><dt><span class="section"><a href="#N10B29">2.2.6. Loops</a></span></dt><dt><span class="section"><a href="#N10B42">2.2.7. Parallel Matching</a></span></dt><dt><span class="section"><a href="#methodology.forkjoin">2.2.8. Fork-join</a></span></dt><dt><span class="section"><a href="#N10C0D">2.2.9. Sequential Fork-Join</a></span></dt><dt><span class="section"><a href="#N10C28">2.2.10. Priority Poll</a></span></dt><dt><span class="section"><a href="#N10C4B">2.2.11. Parallel Or</a></span></dt><dt><span class="section"><a href="#N10C88">2.2.12. Timeout</a></span></dt><dt><span class="section"><a href="#N10D32">2.2.13. Priority</a></span></dt><dt><span class="section"><a href="#N10D42">2.2.14. Metronome</a></span></dt><dt><span class="section"><a href="#N10D58">2.2.15. Routing</a></span></dt><dt><span class="section"><a href="#N10E04">2.2.16. Interruption</a></span></dt><dt><span class="section"><a href="#N10E36">2.2.17. Fold</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.methodology.example">2.3. Larger Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#N10E9D">2.3.1. Dining Philosophers</a></span></dt><dt><span class="section"><a href="#methodology.examples.hygenic">2.3.2. Hygienic Dining Philosophers</a></span></dt><dt><span class="section"><a href="#N10F34">2.3.3. Readers-Writers</a></span></dt><dt><span class="section"><a href="#N10F62">2.3.4. Quicksort</a></span></dt><dt><span class="section"><a href="#N10FC2">2.3.5. Meeting Scheduler</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" title="Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="ug.introduction"></a>Introduction</h2></div></div></div><p>
Orc is a programming language designed to make distributed and
concurrent programs simple and intuitive to write. Orc expresses
orchestration, a type of structured concurrency. It emphasizes the
flow of control and gives a global view of a concurrent system. Orc
is well-suited for task orchestration, a form of
concurrent programming with applications in workflow, business process
management, and web service orchestration. Orc provides constructs to
orchestrate the concurrent invocation of services while managing
time-outs, priorities, and failures of services or communication.  To
learn more about Orc and run your own Orc programs, visit the website:
<a class="link" href="http://orc.csres.utexas.edu/" target="_top"><code class="code"><span class="hl-variable">http</span><span class="hl-operator">:</span><span class="hl-operator">/</span><span class="hl-operator">/</span><span class="hl-variable">orc</span>.<span class="hl-variable">csres</span>.<span class="hl-variable">utexas</span>.<span class="hl-variable">edu</span><span class="hl-operator">/</span></code></a>.
</p><p>
Unless otherwise noted, all material in this document pertains to the
Orc language implementation version
2.0.0
.
</p></div><div lang="" class="chapter" title="Chapter&nbsp;1.&nbsp;The Orc Programming Language"><div class="titlepage"><div><div><h2 class="title"><a name="ug.language"></a>Chapter&nbsp;1.&nbsp;The Orc Programming Language</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#ug.language.cor">1.1. Cor: A Functional Subset</a></span></dt><dd><dl><dt><span class="section"><a href="#orc.constants">1.1.1. Constants</a></span></dt><dt><span class="section"><a href="#language.base.operators">1.1.2. Operators</a></span></dt><dt><span class="section"><a href="#N100EE">1.1.3. Conditionals</a></span></dt><dt><span class="section"><a href="#cor.variables">1.1.4. Variables</a></span></dt><dt><span class="section"><a href="#cor.data">1.1.5. Data Structures</a></span></dt><dt><span class="section"><a href="#orc.language.patterns">1.1.6. Patterns</a></span></dt><dt><span class="section"><a href="#cor.functions">1.1.7. Functions</a></span></dt><dt><span class="section"><a href="#N103CA">1.1.8. Comments</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.language.orc">1.2. Orc: Orchestrating services</a></span></dt><dd><dl><dt><span class="section"><a href="#orc.sites">1.2.1. Communicating with external services</a></span></dt><dt><span class="section"><a href="#combinators">1.2.2. The concurrency combinators of Orc</a></span></dt><dt><span class="section"><a href="#N10535">1.2.3. Revisiting Cor expressions</a></span></dt><dt><span class="section"><a href="#orc.language.time">1.2.4. Time</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.language.advanced">1.3. Advanced Features of Orc</a></span></dt><dd><dl><dt><span class="section"><a href="#special.dot">1.3.1. The <code class="code">.</code> notation</a></span></dt><dt><span class="section"><a href="#section.orc.datatypes">1.3.2. Datatypes</a></span></dt><dt><span class="section"><a href="#section.language.class">1.3.3. Classes</a></span></dt></dl></dd></dl></div><p>
	This chapter describes the Orc programming language in three steps. In Section 1.2, we
	discuss a small subset of Orc called Cor. Cor is a pure functional language,
	which has no features for concurrency, has no state, and does not communicate 
	with external services. Cor introduces us to the parts of Orc that are most familiar 
	from existing programming languages, such as arithmetic operations, variables,
	conditionals, and functions.
	</p><p>
	In Section 1.3, we consider Orc itself, which in addition to Cor, comprises 
	external services and combinators for concurrent orchestration of those services. 
	We show how Orc interacts with these external services, how the combinators can be
	used to build up complex orchestrations from simple base expressions, and how the 
	functional constructs of Cor take on new, subtler behaviors in the concurrent 
	context of Orc.
	</p><p>
	In Section 1.4, we discuss some additional features of Orc that extend 
	the basic syntax. These are useful for creating large-scale Orc programs, but 
	they are not essential to the understanding of the language.
	</p><div class="section" title="1.1.&nbsp;Cor: A Functional Subset"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.language.cor"></a>1.1.&nbsp;Cor: A Functional Subset</h2></div></div></div><p>
In this section we introduce Cor, a pure functional subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</p><p>
A Cor program is an <em class="firstterm"><a name="terms.expression"></a>expression</em>. Cor expressions are built
up recursively from smaller expressions. Cor <em class="firstterm">evaluates</em> an expression
to reduce it to some simple <em class="firstterm">value</em> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <em class="firstterm">
result</em> of the expression.
</p><p>
In the following subsections we introduce the concepts of Cor. First, we talk about
simple <em class="firstterm"><a name="terms.constant"></a>constants</em>, such as numbers and truth values, and the operations that we can perform
on those values. Then we introduce conditionals (<code class="code"><span class="hl-keyword">if</span> <span class="hl-keyword">then</span> <span class="hl-keyword">else</span></code>). Then we 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we talk about constructing data structures, and examining those structures
using patterns. Lastly, we introduce functions.
</p><div class="section" title="1.1.1.&nbsp;Constants"><div class="titlepage"><div><div><h3 class="title"><a name="orc.constants"></a>1.1.1.&nbsp;Constants</h3></div></div></div><p>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</p><p>

Cor has three types of constants, and thus for the moment three types of values:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Boolean: <code class="code"><span class="hl-literal">true</span></code> and <code class="code"><span class="hl-literal">false</span></code></li><li class="listitem">
Number: <code class="code"> <span class="hl-literal">5</span>, <span class="hl-operator">-</span><span class="hl-literal">1</span>, <span class="hl-literal">2.71828</span>, ... </code></li><li class="listitem">
String: <code class="code"><span class="hl-literal">"orc"</span></code>, <code class="code"><span class="hl-literal">"ceci n'est pas une |"</span></code></li></ul></div><p>
</p></div><div class="section" title="1.1.2.&nbsp;Operators"><div class="titlepage"><div><div><h3 class="title"><a name="language.base.operators"></a>1.1.2.&nbsp;Operators</h3></div></div></div><p>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">2</span></code> evaluates to <code class="code"><span class="hl-literal">3</span></code>.</li><li class="listitem"><code class="code">(<span class="hl-literal">98</span><span class="hl-operator">+</span><span class="hl-literal">2</span>)<span class="hl-operator">*</span><span class="hl-literal">17</span></code> evaluates to <code class="code"><span class="hl-literal">1700</span></code>.</li><li class="listitem"><code class="code"><span class="hl-literal">4</span> <span class="hl-operator">=</span> <span class="hl-literal">20</span> <span class="hl-operator">/</span> <span class="hl-literal">5</span></code> evaluates to <code class="code"><span class="hl-literal">true</span></code>.</li><li class="listitem"><code class="code"><span class="hl-literal">3</span><span class="hl-operator">-</span><span class="hl-literal">5</span> <span class="hl-operator">&gt;=</span> <span class="hl-literal">5</span><span class="hl-operator">-</span><span class="hl-literal">3</span> </code> evaluates to <code class="code"><span class="hl-literal">false</span></code>.</li><li class="listitem"><code class="code"><span class="hl-literal">true</span> <span class="hl-operator">&amp;&amp;</span> (<span class="hl-literal">false</span> <span class="hl-operator">||</span> <span class="hl-literal">true</span>)</code> evaluates to <code class="code"><span class="hl-literal">true</span></code>.</li><li class="listitem"><code class="code"><span class="hl-literal">"leap"</span> <span class="hl-operator">+</span> <span class="hl-literal">"frog"</span></code> evaluates to <code class="code"><span class="hl-literal">"leapfrog"</span></code>.</li></ul></div><p>
</p><p>
Numbers with no decimal part, such as <code class="code"><span class="hl-literal">3</span></code>, are treated as integers. Arithmetic operators with two integer arguments will perform
an integer operation and return an integer result; for example, <code class="code"><span class="hl-literal">5</span> <span class="hl-operator">/</span> <span class="hl-literal">2</span></code> performs integer division and evaluates to <code class="code"><span class="hl-literal">2</span></code>.
However, if either argument to an operator has a decimal part (even if it is trivial, as in <code class="code"><span class="hl-literal">3.0</span></code>), the other argument will
be promoted, and a decimal operation will be peformed. For example, <code class="code"><span class="hl-literal">5</span> <span class="hl-operator">/</span> <span class="hl-literal">2.0</span></code> and <code class="code"><span class="hl-literal">5.0</span> <span class="hl-operator">/</span> <span class="hl-literal">2</span></code> both perform decimal
division and evaluate to <code class="code"><span class="hl-literal">2.5</span></code>.
</p><div class="section" title="1.1.2.1.&nbsp;Silent Expression"><div class="titlepage"><div><div><h4 class="title"><a name="N100D6"></a>1.1.2.1.&nbsp;Silent Expression</h4></div></div></div><p>
There are situations where an expression evaluation is stuck, because it is attempting to perform 
some impossible operation and cannot compute a value. In that case, the expression is <em class="firstterm">silent</em>. 
An expression is also silent if it depends on the result of a silent subexpression. For example, the following
expressions are silent: <code class="code"><span class="hl-literal">10</span><span class="hl-operator">/</span><span class="hl-literal">0</span></code>, <code class="code"><span class="hl-literal">6</span> <span class="hl-operator">+</span> <span class="hl-literal">false</span></code>, <code class="code"><span class="hl-literal">3</span> <span class="hl-operator">+</span> <span class="hl-literal">1</span><span class="hl-operator">/</span><span class="hl-literal">0</span></code>, <code class="code"><span class="hl-literal">4</span> <span class="hl-operator">+</span> <span class="hl-literal">true</span> <span class="hl-operator">=</span> <span class="hl-literal">5</span></code>.
</p><p>
Cor is a dynamically typed language. A Cor implementation does not statically
check the type correctness of an expression; instead, an expression with a type
error is simply silent when it is evaluated.
</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
Silent expressions can produce side effects.  For example, on encountering a
type error, Orc will print an error message to the console.  However the
expression containing the type error will not publish a value, and in this
respect it is silent.
</div></div></div><div class="section" title="1.1.3.&nbsp;Conditionals"><div class="titlepage"><div><div><h3 class="title"><a name="N100EE"></a>1.1.3.&nbsp;Conditionals</h3></div></div></div><p>
A conditional expression in Cor is of the form 
<code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G. 
Its meaning is similar to that in other languages: the value
of the expression is the value of F if and only if E evaluates to true, 
or the value of G if and only if E evaluates to false. Note that G is not
evaluated at all if E evaluates to true, and similarly F is not evaluated
at all if E evaluates to false. Thus, for example, evaluation of 
<code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">true</span> <span class="hl-keyword">then</span> <span class="hl-literal">2</span><span class="hl-operator">+</span><span class="hl-literal">3</span> <span class="hl-keyword">else</span> <span class="hl-literal">1</span><span class="hl-operator">/</span><span class="hl-literal">0</span></code> does not evaluate <code class="code"><span class="hl-literal">1</span><span class="hl-operator">/</span><span class="hl-literal">0</span></code>;
it only evaluates <code class="code"><span class="hl-literal">2</span><span class="hl-operator">+</span><span class="hl-literal">3</span></code>.
</p><p>
Unlike other languages, expressions in Cor may be silent. If E is
silent, then the entire expression is silent. And if E evaluates to true 
but F is silent (or if E evaluates to false and G is silent) then the 
expression is silent.
</p><p>
Note that conditionals have lower precedence than any of the operators.
For example, <code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-literal">1</span> <span class="hl-keyword">else</span> <span class="hl-literal">2</span> <span class="hl-operator">+</span> <span class="hl-literal">3</span></code> is equivalent to
<code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-literal">1</span> <span class="hl-keyword">else</span> (<span class="hl-literal">2</span> <span class="hl-operator">+</span> <span class="hl-literal">3</span>)</code>, not <code class="code">(<span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-literal">1</span> <span class="hl-keyword">else</span> <span class="hl-literal">2</span>) <span class="hl-operator">+</span> <span class="hl-literal">3</span></code>.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">true</span> <span class="hl-keyword">then</span> <span class="hl-literal">4</span> <span class="hl-keyword">else</span> <span class="hl-literal">5</span></code> evaluates to <code class="code"><span class="hl-literal">4</span></code>.</li><li class="listitem"><code class="code"><span class="hl-keyword">if</span>  <span class="hl-literal">2</span> &lt; <span class="hl-literal">3</span> <span class="hl-operator">&amp;&amp;</span> <span class="hl-literal">5</span> &lt; <span class="hl-literal">4</span>  <span class="hl-keyword">then</span> <span class="hl-literal">"blue"</span> <span class="hl-keyword">else</span> <span class="hl-literal">"green"</span></code> evaluates to "green".</li><li class="listitem"><code class="code"><span class="hl-keyword">if</span>  <span class="hl-literal">true</span> <span class="hl-operator">||</span> <span class="hl-literal">"fish"</span>  <span class="hl-keyword">then</span> <span class="hl-literal">"yes"</span> <span class="hl-keyword">else</span> <span class="hl-literal">"no"</span></code> is silent.</li><li class="listitem"><code class="code"><span class="hl-keyword">if</span>  <span class="hl-literal">false</span> <span class="hl-operator">||</span> <span class="hl-literal">false</span>  <span class="hl-keyword">then</span> <span class="hl-literal">4</span><span class="hl-operator">+</span><span class="hl-literal">5</span> <span class="hl-keyword">else</span> <span class="hl-literal">4</span><span class="hl-operator">+</span><span class="hl-literal">true</span></code> is silent.</li><li class="listitem"><code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">0</span> &lt; <span class="hl-literal">5</span> <span class="hl-keyword">then</span> <span class="hl-literal">0</span><span class="hl-operator">/</span><span class="hl-literal">5</span> <span class="hl-keyword">else</span> <span class="hl-literal">5</span><span class="hl-operator">/</span><span class="hl-literal">0</span></code> evaluates to 0.</li></ul></div><p>
</p></div><div class="section" title="1.1.4.&nbsp;Variables"><div class="titlepage"><div><div><h3 class="title"><a name="cor.variables"></a>1.1.4.&nbsp;Variables</h3></div></div></div><p>
A <em class="firstterm">variable</em> can be bound to a value. A <em class="firstterm">declaration</em> binds one or
more variables to values. The simplest form of declaration is <code class="code"><span class="hl-keyword">val</span></code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<a class="link" href="http://en.wikipedia.org/wiki/Lexical_scope" target="_top">lexical scoping</a>.
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span> <span class="hl-operator">+</span> <span class="hl-literal">2</span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-variable">x</span> <span class="hl-operator">+</span> <span class="hl-variable">x</span>
</pre><p>

These declarations bind variable <code class="code"><span class="hl-variable">x</span></code> to 3 and variable <code class="code"><span class="hl-variable">y</span></code> to 6.
</p><p>
If the expression on the right side of a <code class="code"><span class="hl-keyword">val</span></code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions continues. If an evaluated expression depends on that
variable, that expression is silent.

</p><pre class="orc">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span><span class="hl-operator">/</span><span class="hl-literal">0</span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">4</span><span class="hl-operator">+</span><span class="hl-literal">5</span>
<span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-variable">x</span> <span class="hl-keyword">else</span> <span class="hl-variable">y</span></pre><p>

Evaluation of the declaration <code class="code"><span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">4</span><span class="hl-operator">+</span><span class="hl-literal">5</span></code> and the expression <code class="code"><span class="hl-keyword">if</span> <span class="hl-literal">false</span> <span class="hl-keyword">then</span> <span class="hl-variable">x</span> <span class="hl-keyword">else</span> <span class="hl-variable">y</span></code>
may continue even though <code class="code"><span class="hl-variable">x</span></code> is not bound. The expression evaluates to 9.

</p></div><div class="section" title="1.1.5.&nbsp;Data Structures"><div class="titlepage"><div><div><h3 class="title"><a name="cor.data"></a>1.1.5.&nbsp;Data Structures</h3></div></div></div><p>
Cor supports three basic data structures, <em class="firstterm">tuples</em>, <em class="firstterm">lists</em>, and <em class="firstterm">records</em>.
</p><div class="section" title="1.1.5.1.&nbsp;Tuples"><div class="titlepage"><div><div><h4 class="title"><a name="N1016E"></a>1.1.5.1.&nbsp;Tuples</h4></div></div></div><p>
A <em class="firstterm">tuple expression</em> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">(<span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">2</span>, <span class="hl-literal">7</span>)</code> evaluates to <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">7</span>)</code>.</li><li class="listitem"><code class="code"> (<span class="hl-literal">"true"</span> <span class="hl-operator">+</span> <span class="hl-literal">"false"</span>, <span class="hl-literal">true</span> <span class="hl-operator">||</span> <span class="hl-literal">false</span>, <span class="hl-literal">true</span> <span class="hl-operator">&amp;&amp;</span> <span class="hl-literal">false</span>) </code> evaluates to <code class="code">(<span class="hl-literal">"truefalse"</span>, <span class="hl-literal">true</span>, <span class="hl-literal">false</span>)</code>.</li><li class="listitem"><code class="code">(<span class="hl-literal">2</span><span class="hl-operator">/</span><span class="hl-literal">2</span>, <span class="hl-literal">2</span><span class="hl-operator">/</span><span class="hl-literal">1</span>, <span class="hl-literal">2</span><span class="hl-operator">/</span><span class="hl-literal">0</span>)</code> is silent.</li></ul></div><p>
</p></div><div class="section" title="1.1.5.2.&nbsp;Lists"><div class="titlepage"><div><div><h4 class="title"><a name="N1018E"></a>1.1.5.2.&nbsp;Lists</h4></div></div></div><p>
A <em class="firstterm">list expression</em> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">2</span><span class="hl-operator">+</span><span class="hl-literal">3</span>] </code> evaluates to <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">5</span>]</code>.</li><li class="listitem"><code class="code"> [<span class="hl-literal">true</span> <span class="hl-operator">&amp;&amp;</span> <span class="hl-literal">true</span>]  </code> evaluates to <code class="code">[<span class="hl-literal">true</span>]</code>.</li><li class="listitem"><code class="code">[]</code> evaluates vacuously to <code class="code">[]</code>, the empty list.</li><li class="listitem"><code class="code">[<span class="hl-literal">5</span>, <span class="hl-literal">5</span> <span class="hl-operator">+</span> <span class="hl-literal">true</span>, <span class="hl-literal">5</span>]</code> is silent.</li></ul></div><p>
</p><p>
There is also a concatenation (<em class="firstterm">cons</em>) operation on lists,
written F<code class="code"><span class="hl-operator">:</span></code>G, where F and G are expressions. Its result is a new list whose first element is the 
value of F and whose remaining elements are the list value of G. The <code class="code"><span class="hl-operator">:</span></code> operator is right associative,
so F<code class="code"><span class="hl-operator">:</span></code>G<code class="code"><span class="hl-operator">:</span></code>H is F<code class="code"><span class="hl-operator">:</span>(</code>G<code class="code"><span class="hl-operator">:</span></code>H<code class="code">)</code>.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">(<span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">3</span>)<span class="hl-operator">:</span>[<span class="hl-literal">2</span><span class="hl-operator">+</span><span class="hl-literal">5</span>,<span class="hl-literal">6</span>]</code> evaluates to <code class="code">[<span class="hl-literal">4</span>,<span class="hl-literal">7</span>,<span class="hl-literal">6</span>]</code>.</li><li class="listitem"><code class="code"><span class="hl-literal">2</span><span class="hl-operator">:</span><span class="hl-literal">2</span><span class="hl-operator">:</span><span class="hl-literal">5</span><span class="hl-operator">:</span>[] </code> evaluates to <code class="code">[<span class="hl-literal">2</span>,<span class="hl-literal">2</span>,<span class="hl-literal">5</span>]</code>.</li><li class="listitem">Suppose <code class="code"><span class="hl-variable">t</span></code> is bound to [3,5]. Then <code class="code"><span class="hl-literal">1</span><span class="hl-operator">:</span><span class="hl-variable">t</span></code> evaluates to <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">3</span>,<span class="hl-literal">5</span>]</code>.</li><li class="listitem"><code class="code"><span class="hl-literal">2</span><span class="hl-operator">:</span><span class="hl-literal">3</span></code> is silent, because <code class="code"><span class="hl-literal">3</span></code> is not a list.</li></ul></div><p>
</p></div><div class="section" title="1.1.5.3.&nbsp;Records"><div class="titlepage"><div><div><h4 class="title"><a name="N101F5"></a>1.1.5.3.&nbsp;Records</h4></div></div></div><p>
A <em class="firstterm">record expression</em> is a comma-separated sequence of elements of the form 
<span class="emphasis"><em>f</em></span><code class="code"> <span class="hl-operator">=</span> </code> E, enclosed by
record braces <code class="code">{.</code> and <code class="code">.}</code>, where each f is a field name and each E is an expression. 
Records may have any number of fields, including zero. Each expression is evaluated; the value 
of the whole record expression is a record containing an element for each field with its associated value. 
Order is irrelevant. If any of the expressions is silent, then the whole record expression is silent.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">{. <span class="hl-variable">zero</span> <span class="hl-operator">=</span> <span class="hl-literal">3</span> <span class="hl-operator">-</span> <span class="hl-literal">3</span>, <span class="hl-variable">one</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span> <span class="hl-operator">+</span> <span class="hl-literal">1</span> .}</code> evaluates to <code class="code">{. <span class="hl-variable">zero</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span>, <span class="hl-variable">one</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span> .}</code>.</li><li class="listitem"><code class="code">{. .}</code> evaluates to <code class="code">{. .}</code>, the empty record.</li></ul></div><p>
</p>

Elements of records are accessed using a dot (<code class="code">.</code>) syntax, as in most object oriented languages.
The expression <code class="code"><span class="hl-variable">r</span>.<span class="hl-variable">f</span></code> evaluates to the value associated with field <code class="code"><span class="hl-variable">f</span></code> in record <code class="code"><span class="hl-variable">r</span></code>.
If <code class="code"><span class="hl-variable">f</span></code> is not present in <code class="code"><span class="hl-variable">r</span></code>, the expression is silent.

<p>
Suppose <code class="code"><span class="hl-variable">r</span> <span class="hl-operator">=</span> {. <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span>, <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span> .}</code>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-variable">r</span>.<span class="hl-variable">x</span></code> evaluates to <code class="code"><span class="hl-literal">0</span></code>.</li><li class="listitem"><code class="code"><span class="hl-variable">r</span>.<span class="hl-variable">y</span></code> evaluates to <code class="code"><span class="hl-literal">1</span></code>.</li><li class="listitem"><code class="code"><span class="hl-variable">r</span>.<span class="hl-variable">z</span></code> is silent.</li></ul></div><p>
</p><p>
Records can also be extended using the + operator. An expression <code class="code"><span class="hl-variable">r</span> <span class="hl-operator">+</span> <span class="hl-variable">s</span></code>, where r and s are records, 
creates a new record which has all of the elements of <code class="code"><span class="hl-variable">r</span></code> whose field names do not appear in <code class="code"><span class="hl-variable">s</span></code>, and all
of the elements of <code class="code"><span class="hl-variable">s</span></code>. In other words, <code class="code"><span class="hl-variable">s</span></code> overrides <code class="code"><span class="hl-variable">r</span></code>.
This use of <code class="code"><span class="hl-operator">+</span></code> is left-associative and does not commute.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">{. <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span> .} <span class="hl-operator">+</span> {. <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span> .}</code> evaluates to <code class="code">{. <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span>, <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span> .}</code></li><li class="listitem"><code class="code">{. <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span>, <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span> .} <span class="hl-operator">+</span> {. <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">2</span>, <span class="hl-variable">z</span> <span class="hl-operator">=</span> <span class="hl-literal">3</span> .}</code> evaluates to <code class="code">{. <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">0</span>, <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">2</span>, <span class="hl-variable">z</span> <span class="hl-operator">=</span> <span class="hl-literal">3</span> .}</code></li></ul></div><p>
</p></div></div><div class="section" title="1.1.6.&nbsp;Patterns"><div class="titlepage"><div><div><h3 class="title"><a name="orc.language.patterns"></a>1.1.6.&nbsp;Patterns</h3></div></div></div><p>
We have seen how to construct data structures. But how do we examine them, and use them? We use <em class="firstterm">patterns</em>.
</p><p>
A pattern is a powerful way to bind variables. When writing <code class="code"><span class="hl-keyword">val</span></code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <em class="firstterm">shape</em>; a
pattern may take the shape of any structured value except a record. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-keyword">val</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) <span class="hl-operator">=</span> (<span class="hl-literal">2</span><span class="hl-operator">+</span><span class="hl-literal">3</span>,<span class="hl-literal">2</span><span class="hl-operator">*</span><span class="hl-literal">3</span>)</code> binds <code class="code"><span class="hl-variable">x</span></code> to 5 and <code class="code"><span class="hl-variable">y</span></code> to 6.</li><li class="listitem"><code class="code"><span class="hl-keyword">val</span> [<span class="hl-variable">a</span>,<span class="hl-variable">b</span>,<span class="hl-variable">c</span>] <span class="hl-operator">=</span> [<span class="hl-literal">"one"</span>, <span class="hl-literal">"two"</span>, <span class="hl-literal">"three"</span>]</code> binds <code class="code"><span class="hl-variable">a</span></code> to "one", 
<code class="code"><span class="hl-variable">b</span></code> to "two", and <code class="code"><span class="hl-variable">c</span></code> to "three".
</li><li class="listitem"><code class="code"><span class="hl-keyword">val</span> ((<span class="hl-variable">a</span>,<span class="hl-variable">b</span>),<span class="hl-variable">c</span>) <span class="hl-operator">=</span> ((<span class="hl-literal">1</span>, <span class="hl-literal">true</span>), (<span class="hl-literal">2</span>, <span class="hl-literal">false</span>))</code> binds <code class="code"><span class="hl-variable">a</span></code> to 1, <code class="code"><span class="hl-variable">b</span></code> to <code class="code"><span class="hl-literal">true</span></code>,
and <code class="code"><span class="hl-variable">c</span></code> to <code class="code">(<span class="hl-literal">2</span>,<span class="hl-literal">false</span>)</code>.
</li></ul></div><p>
</p><p>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code class="code"><span class="hl-keyword">val</span></code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evaluated, it is silent.
</p><p>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code class="code"><span class="hl-variable">_</span></code>, to do this; it matches any shape and binds no
variables.
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-keyword">val</span> (<span class="hl-variable">x</span>,<span class="hl-variable">_</span>,<span class="hl-variable">_</span>) <span class="hl-operator">=</span> (<span class="hl-literal">1</span>,(<span class="hl-literal">2</span>,<span class="hl-literal">2</span>),[<span class="hl-literal">3</span>,<span class="hl-literal">3</span>,<span class="hl-literal">3</span>])</code> binds <code class="code"><span class="hl-variable">x</span></code> to 1.</li><li class="listitem"><code class="code"><span class="hl-keyword">val</span> [[<span class="hl-variable">_</span>,<span class="hl-variable">x</span>],[<span class="hl-variable">_</span>,<span class="hl-variable">y</span>]] <span class="hl-operator">=</span> [[<span class="hl-literal">1</span>,<span class="hl-literal">3</span>],[<span class="hl-literal">2</span>,<span class="hl-literal">4</span>]]</code> binds <code class="code"><span class="hl-variable">x</span></code> to 3 and <code class="code"><span class="hl-variable">y</span></code> to 4.</li></ul></div><p>
</p></div><div class="section" title="1.1.7.&nbsp;Functions"><div class="titlepage"><div><div><h3 class="title"><a name="cor.functions"></a>1.1.7.&nbsp;Functions</h3></div></div></div><p>
Like most other programming languages, Cor provides the capability to define <em class="firstterm">functions</em>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code class="code"><span class="hl-keyword">def</span></code>, in the following way.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">add</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) <span class="hl-operator">=</span> <span class="hl-variable">x</span><span class="hl-operator">+</span><span class="hl-variable">y</span>
</pre><p>

The expression on the right of the <code class="code"><span class="hl-operator">=</span></code> is called the <em class="firstterm">body</em> of the function.
</p><p>
After defining the function, we can <em class="firstterm">call</em> it. A call looks just like the left side of
the declaration except that the variable names (the <em class="firstterm">formal parameters</em>) have been 
replaced by expressions (the <em class="firstterm">actual parameters</em>). 
</p><p>
To evaluate a call, we treat it as a sequence of <code class="code"><span class="hl-keyword">val</span></code> declarations associating the formal
parameters with the actual parameters, followed by the body of the function. 

</p><pre class="programlisting">
<span class="hl-comment">{- Evaluation of add(1+2,3+4) -}</span>

<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">2</span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">3</span><span class="hl-operator">+</span><span class="hl-literal">4</span>
<span class="hl-variable">x</span><span class="hl-operator">+</span><span class="hl-variable">y</span>

<span class="hl-comment">{-
OUTPUT:
10
-}</span>
</pre><p>
</p><p>
</p><div class="itemizedlist" title="Examples"><p class="title"><b>Examples</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-site">add</span>(<span class="hl-literal">10</span>,<span class="hl-literal">10</span><span class="hl-operator">*</span><span class="hl-literal">10</span>)</code> evaluates to <code class="code"><span class="hl-literal">110</span></code>.</li><li class="listitem"><code class="code"><span class="hl-site">add</span>(<span class="hl-site">add</span>(<span class="hl-literal">5</span>,<span class="hl-literal">3</span>),<span class="hl-literal">5</span>)</code> evaluates to <code class="code"><span class="hl-literal">13</span></code>.</li></ul></div><p>
</p><p>
Notice that the evaluation strategy of functions allows a call to proceed even if some of the actual
parameters are silent, so long as the values of those actual parameters are not used in the evaluation
of the body.

</p><pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">cond</span>(<span class="hl-variable">b</span>,<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> <span class="hl-variable">b</span> <span class="hl-keyword">then</span> <span class="hl-variable">x</span> <span class="hl-keyword">else</span> <span class="hl-variable">y</span>
<span class="hl-site">cond</span>(<span class="hl-literal">true</span>, <span class="hl-literal">3</span>, <span class="hl-literal">5</span><span class="hl-operator">/</span><span class="hl-literal">0</span>)
</pre><p>

This evaluates to <code class="code"><span class="hl-literal">3</span></code> even though <code class="code"><span class="hl-literal">5</span><span class="hl-operator">/</span><span class="hl-literal">0</span></code> is silent, because <code class="code"><span class="hl-variable">y</span></code> is not
needed.

</p><p>
A function definition or call may have zero arguments, in which case we write <code class="code">()</code> for the arguments.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">Zero</span>() <span class="hl-operator">=</span> <span class="hl-literal">0</span>
</pre><p>
</p><div class="section" title="1.1.7.1.&nbsp;Recursion"><div class="titlepage"><div><div><h4 class="title"><a name="N1032A"></a>1.1.7.1.&nbsp;Recursion</h4></div></div></div><p>
Functions can be recursive; that is, the name of a function may be used in its own body.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">sumto</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> <span class="hl-variable">n</span> &lt; <span class="hl-literal">1</span> <span class="hl-keyword">then</span> <span class="hl-literal">0</span> <span class="hl-keyword">else</span> <span class="hl-variable">n</span> <span class="hl-operator">+</span> <span class="hl-site">sumto</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)
</pre><p>

Then, <code class="code"><span class="hl-site">sumto</span>(<span class="hl-literal">5</span>)</code> evaluates to 15.
</p><p>
Mutual recursion is also supported.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> 
  <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-literal">true</span>
<span class="hl-keyword">def</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> 
  <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span>)
  <span class="hl-keyword">else</span> <span class="hl-literal">false</span>
</pre><p>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.
</p></div><div class="section" title="1.1.7.2.&nbsp;Closures"><div class="titlepage"><div><div><h4 class="title"><a name="cor.closures"></a>1.1.7.2.&nbsp;Closures</h4></div></div></div><p>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<em class="firstterm">closure</em>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">a</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">x</span><span class="hl-operator">-</span><span class="hl-literal">3</span>
<span class="hl-keyword">def</span> <span class="hl-site">b</span>(<span class="hl-variable">y</span>) <span class="hl-operator">=</span> <span class="hl-variable">y</span><span class="hl-operator">*</span><span class="hl-literal">4</span>
<span class="hl-keyword">val</span> <span class="hl-variable">funs</span> <span class="hl-operator">=</span> (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)
</pre><p>
</p><p>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
supports <span class="emphasis"><em>higher-order</em></span> functions.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">onetwosum</span>(<span class="hl-variable">f</span>) <span class="hl-operator">=</span> <span class="hl-site">f</span>(<span class="hl-literal">1</span>) <span class="hl-operator">+</span> <span class="hl-site">f</span>(<span class="hl-literal">2</span>)
<span class="hl-keyword">def</span> <span class="hl-site">triple</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">x</span> <span class="hl-operator">*</span> <span class="hl-literal">3</span>
</pre><p>

Then, <code class="code"><span class="hl-site">onetwosum</span>(<span class="hl-variable">triple</span>)</code> is <code class="code"><span class="hl-site">triple</span>(<span class="hl-literal">1</span>) <span class="hl-operator">+</span> <span class="hl-site">triple</span>(<span class="hl-literal">2</span>)</code>, which is <code class="code"><span class="hl-literal">1</span> <span class="hl-operator">*</span> <span class="hl-literal">3</span> <span class="hl-operator">+</span> <span class="hl-literal">2</span> <span class="hl-operator">*</span> <span class="hl-literal">3</span></code> which evaluates to <code class="code"><span class="hl-literal">9</span></code>.

</p><p>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<span class="emphasis"><em>lexical closures</em></span>. This means that when a closure is created, if the body of the
function contains any variables other than the formal parameters, the bindings for those variables are
stored in the closure. Then, when the closure is called, the evaluation of the function body uses those 
stored variable bindings.  
</p></div><div class="section" title="1.1.7.3.&nbsp;Lambda"><div class="titlepage"><div><div><h4 class="title"><a name="orc.language.lambda"></a>1.1.7.3.&nbsp;Lambda</h4></div></div></div><p>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code class="code"><span class="hl-keyword">lambda</span></code> for this purpose. By writing a function
definition without the keyword <code class="code"><span class="hl-keyword">def</span></code> and replacing the function name with
the keyword <code class="code"><span class="hl-keyword">lambda</span></code>, that definition becomes an expression which evaluates to a closure. 

</p><pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">onetwosum</span>(<span class="hl-variable">f</span>) <span class="hl-operator">=</span> <span class="hl-site">f</span>(<span class="hl-literal">1</span>) <span class="hl-operator">+</span> <span class="hl-site">f</span>(<span class="hl-literal">2</span>)

<span class="hl-site">onetwosum</span>( <span class="hl-keyword">lambda</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">x</span> <span class="hl-operator">*</span> <span class="hl-literal">3</span> )
<span class="hl-comment">{- 
  identical to:
  def triple(x) = x * 3
  onetwosum(triple)
-}</span></pre><p>

Then, <code class="code"><span class="hl-site">onetwosum</span>( <span class="hl-keyword">lambda</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">x</span> <span class="hl-operator">*</span> <span class="hl-literal">3</span> )</code> evaluates to 9. 

</p><p>
Since a function defined using <code class="code"><span class="hl-keyword">lambda</span></code> has no name, it is not possible to define 
a recursive function in this way. Only <code class="code"><span class="hl-keyword">def</span></code> can create a recursive function.
</p></div><div class="section" title="1.1.7.4.&nbsp;Clauses"><div class="titlepage"><div><div><h4 class="title"><a name="orc.language.clauses"></a>1.1.7.4.&nbsp;Clauses</h4></div></div></div><p>
The combination of functions and pattern matching offers a powerful capability: 
<em class="firstterm">clausal</em> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</p><p>
Here's an example.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>([]) <span class="hl-operator">=</span> <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-site">sum</span>(<span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-variable">h</span> <span class="hl-operator">+</span> <span class="hl-site">sum</span>(<span class="hl-variable">t</span>)
</pre><p>

<code class="code"><span class="hl-site">sum</span>(<span class="hl-variable">l</span>)</code> publishes the sum of the numbers in the list <code class="code"><span class="hl-variable">l</span></code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</p><p>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</p><p>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</p><p>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

</p><pre class="programlisting">
<span class="hl-comment">{- Fibonacci numbers -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-literal">0</span>) <span class="hl-operator">=</span> <span class="hl-literal">1</span>
<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-literal">1</span>) <span class="hl-operator">=</span> <span class="hl-literal">1</span>
<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-literal">0</span> <span class="hl-keyword">else</span> <span class="hl-site">fib</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>) <span class="hl-operator">+</span> <span class="hl-site">fib</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">2</span>)
</pre><p>

This definition of the Fibonacci function is straightforward, but slow, due to the repeated work in recursive
calls to <code class="code"><span class="hl-variable">fib</span></code>. We can define a linear-time version, again with the help of pattern matching:

</p><pre class="programlisting">
<span class="hl-comment">{- Alternate definition of the Fibonacci function -}</span>

<span class="hl-comment">{- A helper function: find the pair (Fibonacci(n-1), Fibonacci(n)) -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">H</span>(<span class="hl-literal">0</span>) <span class="hl-operator">=</span> (<span class="hl-literal">1</span>,<span class="hl-literal">1</span>)
<span class="hl-keyword">def</span> <span class="hl-site">H</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> 
  <span class="hl-keyword">val</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) <span class="hl-operator">=</span> <span class="hl-site">H</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)
  (<span class="hl-variable">y</span>,<span class="hl-variable">x</span><span class="hl-operator">+</span><span class="hl-variable">y</span>)

<span class="hl-keyword">def</span> <span class="hl-site">fib</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> 
  <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &lt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-literal">0</span> 
  <span class="hl-keyword">else</span> (
    <span class="hl-keyword">val</span> (<span class="hl-variable">x</span>,<span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-site">H</span>(<span class="hl-variable">n</span>) 
    <span class="hl-variable">x</span>
  )
</pre><p>
</p><p>
As a more complex example of matching, consider the following function which takes
a list argument and returns a new list containing only the first <code class="code"><span class="hl-variable">n</span></code> 
elements of the argument list. 

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">take</span>(<span class="hl-literal">0</span>,<span class="hl-variable">_</span>) <span class="hl-operator">=</span> []
<span class="hl-keyword">def</span> <span class="hl-site">take</span>(<span class="hl-variable">n</span>,<span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> <span class="hl-variable">h</span><span class="hl-operator">:</span>(<span class="hl-site">take</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>,<span class="hl-variable">t</span>)) <span class="hl-keyword">else</span> []
</pre><p>
</p><p>
Mutual recursion and clausal definitions are allowed to occur together. Here are two functions,
<code class="code"><span class="hl-variable">stutter</span></code> and <code class="code"><span class="hl-variable">mutter</span></code>, which are each mutually recursive, and each have
multiple clauses. <code class="code"><span class="hl-site">stutter</span>(<span class="hl-variable">l</span>)</code> returns <code class="code"><span class="hl-variable">l</span></code> with every odd element repeated.
<code class="code"><span class="hl-site">mutter</span>(<span class="hl-variable">l</span>)</code> returns <code class="code"><span class="hl-variable">l</span></code> with every even element repeated.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">stutter</span>([]) <span class="hl-operator">=</span> []
<span class="hl-keyword">def</span> <span class="hl-site">stutter</span>(<span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-site">mutter</span>(<span class="hl-variable">t</span>)
<span class="hl-keyword">def</span> <span class="hl-site">mutter</span>([]) <span class="hl-operator">=</span> []
<span class="hl-keyword">def</span> <span class="hl-site">mutter</span>(<span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-variable">h</span><span class="hl-operator">:</span><span class="hl-site">stutter</span>(<span class="hl-variable">t</span>)
</pre><p>

<code class="code"><span class="hl-site">stutter</span>([<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>])</code> evaluates to <code class="code">[<span class="hl-literal">1</span>,<span class="hl-literal">1</span>,<span class="hl-literal">2</span>,<span class="hl-literal">3</span>,<span class="hl-literal">3</span>]</code>.
</p><p>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">even</span>(<span class="hl-literal">0</span>) <span class="hl-operator">=</span> <span class="hl-literal">true</span>
<span class="hl-keyword">def</span> <span class="hl-site">odd</span>(<span class="hl-literal">0</span>) <span class="hl-operator">=</span> <span class="hl-literal">false</span>
<span class="hl-keyword">def</span> <span class="hl-site">even</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-site">odd</span>(<span class="hl-keyword">if</span> <span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span> <span class="hl-keyword">then</span> <span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span> <span class="hl-keyword">else</span> <span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span>)
<span class="hl-keyword">def</span> <span class="hl-site">odd</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-site">even</span>(<span class="hl-keyword">if</span> <span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span> <span class="hl-keyword">then</span> <span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span> <span class="hl-keyword">else</span> <span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span>)
</pre><p>

</p></div></div><div class="section" title="1.1.8.&nbsp;Comments"><div class="titlepage"><div><div><h3 class="title"><a name="N103CA"></a>1.1.8.&nbsp;Comments</h3></div></div></div><p>
Cor has two kinds of comments.   

</p><p>
A line which begins with two dashes (<code class="code"><span class="hl-comment">--</span></code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
</p><pre class="programlisting">
<span class="hl-comment">-- This is a single line comment.</span>
	 <span class="hl-comment">-- This is also a single line comment.</span>
</pre><p>
</p><p>
Multi-line comments are enclosed by matching braces of the form <code class="code"><span class="hl-comment">{- -}</span></code>. 
Multi-line comments may be nested. They may appear anywhere, even in the middle of an expression.

</p><pre class="programlisting">
<span class="hl-comment">{- 
   This is a
   multiline comment.
-}</span>
   
<span class="hl-comment">{- Multiline comments {- can be nested -}</span> <span class="hl-operator">-</span>}

<span class="hl-comment">{- They may appear anywhere, -}</span> 
<span class="hl-literal">1</span> <span class="hl-operator">+</span> <span class="hl-comment">{- even in the middle of an expression. -}</span> <span class="hl-literal">2</span> <span class="hl-operator">+</span> <span class="hl-literal">3</span>
</pre><p>

</p></div></div><div class="section" title="1.2.&nbsp;Orc: Orchestrating services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.language.orc"></a>1.2.&nbsp;Orc: Orchestrating services</h2></div></div></div><p>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. The full 
Orc language transcends these limitations by incorporating the orchestration of external services.
We introduce the term <em class="firstterm">site</em> to denote an external service which can be
called from an Orc program.
</p><p>
As in Cor, an Orc program is an  <em class="firstterm">expression</em>; Orc expressions are built 
up recursively from smaller expressions. Orc is a superset of Cor, i.e., all Cor expressions are 
also Orc expressions. Orc expressions are <em class="firstterm">executed</em>, rather than evaluated; 
an execution may call external services and <em class="firstterm"><a name="terms.publish"></a>publish</em> some number of 
values (possibly zero). Different executions of the same expression may have completely different
behaviors; they may call different services, may receive different responses from the same site,
and may publish different values. Expressions in the functional subset, though, will display
the same behavior in all executions.
</p><p>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <em class="firstterm">combinators</em>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</p><div class="section" title="1.2.1.&nbsp;Communicating with external services"><div class="titlepage"><div><div><h3 class="title"><a name="orc.sites"></a>1.2.1.&nbsp;Communicating with external services</h3></div></div></div><p>
An Orc expression may be a site call. Sites are called using the same syntax as a 
function call, but with a slightly different meaning. Sites are introduced and bound 
to variables by a special declaration.  
</p><div class="section" title="1.2.1.1.&nbsp;Calling a site"><div class="titlepage"><div><div><h4 class="title"><a name="orc.sites.calling"></a>1.2.1.1.&nbsp;Calling a site</h4></div></div></div><p>
Suppose that the variable <code class="code"><span class="hl-variable">Google</span></code> is bound to a site which invokes the
Google search engine service in "I'm Feeling Lucky" mode. A call to <code class="code"><span class="hl-variable">Google</span></code> 
looks just like a function call. Calling <code class="code"><span class="hl-variable">Google</span></code> requests the URL of the top 
result for the given search term.

</p><pre class="programlisting">
<span class="hl-comment">{- Get the top search result for "computation orchestration" -}</span>
<span class="hl-site">Google</span>(<span class="hl-literal">"computation orchestration"</span>)
</pre><p>

Once the Google search service determines the top result, it sends a response. The site 
call then publishes that response. Note that the service might not respond: Google's 
servers might be down, the network might be down, or the search might yield no result URL.  
</p><p>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</p><p>
A call to a site has exactly one of the following effects: 

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">The site returns a value, called its <em class="firstterm">response</em>.</li><li class="listitem">The site communicates that it will never respond to the call; we say that the call has <em class="firstterm">halted</em></li><li class="listitem">The site neither returns a value nor indicates that the call has halted; we say that the call is <em class="firstterm">pending</em>.</li></ol></div><p>
</p><p>
In the last two cases, the site call is said to be silent. However, unlike a silent expression in Cor, 
a silent site call in Orc might perform some meaningful computation or communication; silence does 
not necessarily indicate an error. Since halted site calls and pending site calls are both silent,
they cannot usually be distinguished from each other; only the <a class="link" href="#combinators.otherwise" title="1.2.2.4.&nbsp;The otherwise combinator">
otherwise combinator</a> can tell the difference. 
</p><p>
A site is a value, just like an integer or a list. It may be bound to a variable, passed 
as an argument, or published by an execution, just like any other value.
</p><p>
</p><pre class="programlisting">
<span class="hl-comment">{- Create a search site from a search engine URL,
   bind the variable Search to that site,
   then use that site to search for a term.
-}</span>

<span class="hl-keyword">val</span> <span class="hl-variable">Search</span> <span class="hl-operator">=</span> <span class="hl-site">SearchEngine</span>(<span class="hl-literal">"http://www.google.com/"</span>)
<span class="hl-site">Search</span>(<span class="hl-literal">"first class value"</span>)
</pre><p>
</p><p>
A site is sometimes called only for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <em class="firstterm">signal</em>: a special value which carries no 
information (analogous to the unit value <code class="code">()</code> in ML). The signal value
can be written as <code class="code"><span class="hl-keyword">signal</span></code> within Orc programs.


</p><pre class="orc">
<span class="hl-comment">{- Use the 'println' site to print a string, followed by
   a newline, to an output console.
   The return value of this site call is a signal.
-}</span>

<span class="hl-site">Println</span>(<span class="hl-literal">"Hello, World!"</span>)
</pre><p>
</p></div></div><div class="section" title="1.2.2.&nbsp;The concurrency combinators of Orc"><div class="titlepage"><div><div><h3 class="title"><a name="combinators"></a>1.2.2.&nbsp;The concurrency combinators of Orc</h3></div></div></div><p>
Orc has four <em class="firstterm">combinators</em>: parallel, sequential, pruning, and otherwise. 
A combinator forms an expression from two component expressions. Each combinator captures a 
different aspect of concurrency. Syntactically, the combinators are written infix, and have
lower precedence than operators, but higher precedence than conditionals or declarations.
</p><div class="section" title="1.2.2.1.&nbsp;The parallel combinator"><div class="titlepage"><div><div><h4 class="title"><a name="combinators.parallel"></a>1.2.2.1.&nbsp;The parallel combinator</h4></div></div></div><p>
Orc's simplest combinator is <code class="code"><span class="hl-combinator">|</span></code>, the parallel combinator. Orc executes
the expression F <code class="code"><span class="hl-combinator">|</span></code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
F <code class="code"><span class="hl-combinator">|</span></code> G does so as well.  The resulting publications of F <code class="code"><span class="hl-combinator">|</span></code> G
may be published in arbitrary order.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish 1 and 2 in parallel -}</span>  

<span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">1</span>

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
1
2
-}</span>
</pre><p>
</p><p>
</p><pre class="programlisting">
<span class="hl-comment">{- Access two search sites, Google and Yahoo, in parallel.

   Publish any results they return.
  
   Since each call may publish a value, the expression
   may publish up to two values.
-}</span>  
<span class="hl-site">Google</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Yahoo</span>(<span class="hl-literal">"cupcake"</span>)
</pre><p>
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish 1, 2, and 3 in parallel -}</span>
  
<span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">2</span>

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
1
2
3
-}</span>
</pre><p>
</p><p>For more information, see the 
	<span class="olink">
	Reference Manual (Parallel Combinator)	
	</span>.
</p></div><div class="section" title="1.2.2.2.&nbsp;The sequential combinator"><div class="titlepage"><div><div><h4 class="title"><a name="combinators.sequential"></a>1.2.2.2.&nbsp;The sequential combinator</h4></div></div></div><p>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F<code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> </code>G, 
combines the expression F, which may publish some values, with another expression G, 
which will use the values as they are published; <code class="code"><span class="hl-variable">x</span></code> transmits the values
from F to G.
</p><p>
The execution of F<code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> </code>G starts by executing F. Whenever F publishes a value, 
a new instance of G is executed in parallel with F (and with any previous copies of G); in that
instance of G, variable <code class="code"><span class="hl-variable">x</span></code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish 1 and 2 in parallel -}</span>
  
(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span>

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
1
2
-}</span>
</pre><p>
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish 3 and 4 in parallel -}</span>
  
<span class="hl-literal">2</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">2</span>)

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
3
4
-}</span>
</pre><p>
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish 0, 1, 2 and 3 in parallel -}</span>
  
(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">2</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">n</span> <span class="hl-combinator">|</span> <span class="hl-variable">n</span><span class="hl-operator">+</span><span class="hl-literal">1</span>)

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
0
1
2
3
-}</span>
</pre><p>
</p><p>
</p><pre class="programlisting">
<span class="hl-comment">{- Prepend the site name to each published search result
   The cat site concatenates any number of arguments into one string
-}</span>  
  <span class="hl-site">Google</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-site">cat</span>(<span class="hl-literal">"Google: "</span>, <span class="hl-variable">s</span>)
<span class="hl-combinator">|</span> <span class="hl-site">Yahoo</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-site">cat</span>(<span class="hl-literal">"Yahoo: "</span>, <span class="hl-variable">s</span>)
</pre><p>
</p><p>
The sequential combinator may be written as F<code class="code"> <span class="hl-combinator">&gt;</span></code>P<code class="code"><span class="hl-combinator">&gt;</span> </code>G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new instance of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new instance of G is executed.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish 3, 6, and 9 in arbitrary order. -}</span>

(<span class="hl-literal">3</span>,<span class="hl-literal">6</span>,<span class="hl-literal">9</span>)  <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>,<span class="hl-variable">z</span>)<span class="hl-combinator">&gt;</span>  ( <span class="hl-variable">x</span> <span class="hl-combinator">|</span> <span class="hl-variable">y</span> <span class="hl-combinator">|</span> <span class="hl-variable">z</span> )

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
3
6
9
-}</span>
</pre><p>
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Filter out values of the form (_,false) -}</span>

( (<span class="hl-literal">4</span>,<span class="hl-literal">true</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">5</span>,<span class="hl-literal">false</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">6</span>,<span class="hl-literal">true</span>) )  <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>,<span class="hl-literal">true</span>)<span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
4
6
-}</span> 
</pre><p>
</p><p>
We may also omit the variable entirely, writing <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>. This
is equivalent to using a wildcard pattern: <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-variable">_</span><span class="hl-combinator">&gt;</span> </code>
</p><p>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code class="code"> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code> together with the special expression 
<code class="code"><span class="hl-keyword">stop</span></code>, which is always silent.  
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Print two strings to the console,
   but don't publish the return values of the calls.
-}</span>

( <span class="hl-site">Println</span>(<span class="hl-literal">"goodbye"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Println</span>(<span class="hl-literal">"world"</span>) ) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-comment">{-
OUTPUT:
goodbye
world
-}</span>
</pre><p>
</p><p>
The sequential combinator makes it easy to bind variables in sequence and use
them together.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish the cross product of {1,2} and {3,4} -}</span>

(<span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-literal">2</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
(1,3)
(1,4)
(2,3)
(2,4)
-}</span>
</pre><p>
</p></div><div class="section" title="1.2.2.3.&nbsp;The pruning combinator"><div class="titlepage"><div><div><h4 class="title"><a name="combinators.pruning"></a>1.2.2.3.&nbsp;The pruning combinator</h4></div></div></div><p>
The pruning combinator, written F<code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code>G, allows us to block 
a computation waiting for a result, or terminate a computation. The execution of 
F<code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code>G starts by executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then the execution of G is immediately 
<em class="firstterm">killed</em>. A killed expression cannot call any sites or 
publish any values.
</p><p>
During the execution of F, any part of the execution that depends on <code class="code"><span class="hl-variable">x</span></code> 
will be suspended until <code class="code"><span class="hl-variable">x</span></code> is bound (to the first value published by G). If G
never publishes a value, that part of the execution is suspended forever. 
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish either 5 or 6, but not both -}</span>

<span class="hl-variable">x</span><span class="hl-operator">+</span><span class="hl-literal">2</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)

<span class="hl-comment">{-
OUTPUT:
5
-}</span>
<span class="hl-comment">{-
OUTPUT:
6
-}</span>
</pre><p>
</p><p>
</p><pre class="programlisting">
<span class="hl-comment">{- Query Google and Yahoo for a search result
   Print out the result that arrives first; ignore the other result
-}</span>

<span class="hl-site">Println</span>(<span class="hl-variable">result</span>) <span class="hl-combinator">&lt;</span><span class="hl-variable">result</span><span class="hl-combinator">&lt;</span> ( <span class="hl-site">Google</span>(<span class="hl-literal">"cupcake"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Yahoo</span>(<span class="hl-literal">"cupcake"</span>) )
</pre><p>
</p><p>
Though a terminated execution may not make any new calls, the calls
that it has already made will continue normally; their responses are simply
ignored. This may have surprising consequences when a call has side effects,
as in the following example.

</p><pre class="orc">
<span class="hl-comment">{- This example actually prints both "true" and "false" to the
   console, regardless of which call responds first.
-}</span>

<span class="hl-keyword">stop</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"true"</span>) <span class="hl-combinator">|</span> <span class="hl-site">Println</span>(<span class="hl-literal">"false"</span>)

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
true
false
-}</span>
</pre><p>

Both of the <code class="code"><span class="hl-variable">println</span></code> calls are initiated before either one of
them publishes a value and terminates the expression. Once the expression
is terminated, no new calls occur, but the other <code class="code"><span class="hl-variable">println</span></code> call
still proceeds and still has the effect of printing its message to the
console.
</p><p>
The pruning combinator may include a full pattern P instead of just a variable name. Any
value published by G is matched against the pattern P. If this match is successful, then G
terminates and all of the bindings of the pattern P are made in F. Otherwise, the published 
value is simply ignored and G continues to execute.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish either 9 or 25, but not 16. -}</span>

<span class="hl-variable">x</span><span class="hl-operator">*</span><span class="hl-variable">x</span> <span class="hl-combinator">&lt;</span>(<span class="hl-variable">x</span>,<span class="hl-literal">true</span>)<span class="hl-combinator">&lt;</span> ( (<span class="hl-literal">3</span>,<span class="hl-literal">true</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">4</span>,<span class="hl-literal">false</span>) <span class="hl-combinator">|</span> (<span class="hl-literal">5</span>,<span class="hl-literal">true</span>) )

<span class="hl-comment">{-
OUTPUT:
9
-}</span>
<span class="hl-comment">{-
OUTPUT:
25
-}</span>
</pre><p>
</p><p>
Note that even if <code class="code">(<span class="hl-literal">4</span>,<span class="hl-literal">false</span>)</code> is published before <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">true</span>)</code> or <code class="code">(<span class="hl-literal">5</span>,<span class="hl-literal">true</span>)</code>, 
it is ignored. The right side continues to execute and will publish one of <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">true</span>)</code> or 
<code class="code">(<span class="hl-literal">5</span>,<span class="hl-literal">true</span>)</code>.
</p></div><div class="section" title="1.2.2.4.&nbsp;The otherwise combinator"><div class="titlepage"><div><div><h4 class="title"><a name="combinators.otherwise"></a>1.2.2.4.&nbsp;The otherwise combinator</h4></div></div></div><p>
Orc has a fourth concurrency combinator: the <em class="firstterm">otherwise</em> combinator,
written F<code class="code"> <span class="hl-combinator">;</span> </code>G. The execution of F<code class="code"> <span class="hl-combinator">;</span> </code> G proceeds as follows.
First, F is executed. If F <em class="firstterm">halts</em>, and has not published any values, 
then G executes. If F did publish one or more values, then G is ignored. The publications of 
F <code class="code"><span class="hl-combinator">;</span></code> G are those of F if F publishes, or those of G otherwise.
</p></div></div><div class="section" title="1.2.3.&nbsp;Revisiting Cor expressions"><div class="titlepage"><div><div><h3 class="title"><a name="N10535"></a>1.2.3.&nbsp;Revisiting Cor expressions</h3></div></div></div><p>
Some Cor expressions have new behaviors in the context of Orc, due to the introduction
of concurrency and of sites.
</p><div class="section" title="1.2.3.1.&nbsp;Operators"><div class="titlepage"><div><div><h4 class="title"><a name="N1053B"></a>1.2.3.1.&nbsp;Operators</h4></div></div></div><p>
The arithmetic, logical, and comparison operators are actually calls to sites, simply
written in infix style with the expected operator symbols. For example, <code class="code"><span class="hl-literal">2</span><span class="hl-operator">+</span><span class="hl-literal">3</span></code>
is actually <code class="code">(<span class="hl-operator">+</span>)(<span class="hl-literal">2</span>,<span class="hl-literal">3</span>)</code>, where <code class="code">(<span class="hl-operator">+</span>)</code> is a primitive site provided
by the language itself. All of the operators can be used directly as sites in this way;
the name of the site is the operator enclosed by parentheses, e.g. <code class="code">(<span class="hl-operator">**</span>)</code>,
<code class="code">(<span class="hl-operator">&gt;=</span>)</code>, etc. Negation (unary minus) is named <code class="code">(<span class="hl-literal">0</span><span class="hl-operator">-</span>)</code>.
</p></div><div class="section" title="1.2.3.2.&nbsp;Conditionals"><div class="titlepage"><div><div><h4 class="title"><a name="orc.conditionals"></a>1.2.3.2.&nbsp;Conditionals</h4></div></div></div><p>
The conditional expression <code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G
is actually a derived form based on two different sites named <code class="code"><span class="hl-variable">If</span></code> and <code class="code"><span class="hl-variable">Iff</span></code>. 
The sites take a boolean argument.  <code class="code"><span class="hl-variable">If</span></code> returns a signal if that argument is <code class="code"><span class="hl-literal">true</span></code>,
or remains silent if the argument is <code class="code"><span class="hl-literal">false</span></code>.  <code class="code"><span class="hl-variable">Iff</span></code> returns a signal if that argument
is <code class="code"><span class="hl-literal">false</span></code> or remains silent if the argument is <code class="code"><span class="hl-literal">true</span></code>.
</p><p>
<code class="code"><span class="hl-keyword">if</span></code> E <code class="code"><span class="hl-keyword">then</span></code> F <code class="code"><span class="hl-keyword">else</span></code> G is equivalent 
to <code class="code">( <span class="hl-site">Ift</span>(<span class="hl-variable">b</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>F<code class="code"> <span class="hl-combinator">|</span> <span class="hl-site">Iff</span>(<span class="hl-variable">b</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> </code>G<code class="code">) <span class="hl-combinator">&lt;</span><span class="hl-variable">b</span><span class="hl-combinator">&lt;</span> </code>E.
</p></div><div class="section" title="1.2.3.3.&nbsp;val"><div class="titlepage"><div><div><h4 class="title"><a name="N1058F"></a>1.2.3.3.&nbsp;<code class="code"><span class="hl-keyword">val</span></code></h4></div></div></div><p>
The declaration <code class="code"><span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> </code>G, followed by expression F, is 
actually just a different way of writing the expression F<code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code>G.
Thus, <code class="code"><span class="hl-keyword">val</span></code> shares all of the behavior of the pruning combinator,
which we have already described. (This is also true when a pattern is used instead
of variable name <code class="code"><span class="hl-variable">x</span></code>).
</p></div><div class="section" title="1.2.3.4.&nbsp;Nesting Orc expressions"><div class="titlepage"><div><div><h4 class="title"><a name="expression.nesting"></a>1.2.3.4.&nbsp;Nesting Orc expressions</h4></div></div></div><p>
The execution of an Orc expression may publish many values. What does such an expression 
mean in a context where only one value is expected? For example, what does <code class="code"><span class="hl-literal">2</span> <span class="hl-operator">+</span> (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)</code> 
publish? 
</p><p>
Whenever an Orc expression appears in such a context, it executes until it publishes its first value, 
and then it is terminated. The published value is used in the context as if it were the result of evaluating
the expression.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish either 5 or 6 -}</span>

<span class="hl-literal">2</span> <span class="hl-operator">+</span> (<span class="hl-literal">3</span> <span class="hl-combinator">|</span> <span class="hl-literal">4</span>)

<span class="hl-comment">{-
OUTPUT:
5
-}</span>
<span class="hl-comment">{-
OUTPUT:
6
-}</span>
</pre><p>
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish exactly one of 0, 1, 2 or 3 -}</span>

(<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">2</span>) <span class="hl-operator">+</span> (<span class="hl-literal">0</span> <span class="hl-combinator">|</span> <span class="hl-literal">1</span>)

<span class="hl-comment">{-
OUTPUT:
0
-}</span>
<span class="hl-comment">{-
OUTPUT:
1
-}</span>
<span class="hl-comment">{-
OUTPUT:
2
-}</span>
<span class="hl-comment">{-
OUTPUT:
3
-}</span>
</pre><p>
</p><p>
To be precise, whenever an Orc expression appears in such a context, it is treated as if it was 
on the right side of a pruning combinator, using a fresh variable name to fill in the hole. 
Thus, C[E] (where E is the Orc expression and C is the context) is equivalent to the expression 
C[<code class="code"><span class="hl-variable">x</span></code>] <code class="code"> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> </code> E. 
</p></div><div class="section" title="1.2.3.5.&nbsp;Functions"><div class="titlepage"><div><div><h4 class="title"><a name="N105C1"></a>1.2.3.5.&nbsp;Functions</h4></div></div></div><p>
The body of a function in Orc may be any Orc expression; thus, function
bodies in Orc are executed rather than evaluated, and may engage in communication
and publish multiple values.
</p><p>
A function call in Orc binds the values of its arguments
to the function's parameters, and then executes the function body in parallel with the
computation of the bindings. Whenever the function body publishes a value, the function call publishes that
value. Thus, unlike a site call, a function call may publish many values.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Publish all integers in the interval 1..n, in arbitrary order. -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">range</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> (<span class="hl-variable">n</span> &gt; <span class="hl-literal">0</span>) <span class="hl-keyword">then</span> (<span class="hl-variable">n</span> <span class="hl-combinator">|</span> <span class="hl-site">range</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)) <span class="hl-keyword">else</span> <span class="hl-keyword">stop</span> 

<span class="hl-comment">{- Publish 1, 2, and 3 in arbitrary order. -}</span>
<span class="hl-site">range</span>(<span class="hl-literal">3</span>)

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
1
2
3
-}</span>
</pre><p>
</p><p>
In the context of Orc, function calls are not strict. When a function call executes,
it begins to execute the function body immediately, and also executes the argument
expressions in parallel. When an argument expression publishes a value, it is killed,
and the corresponding parameter is bound to that value in the execution of
the function body. Any part of the function body which uses a parameter
that has not yet been bound blocks until that parameter is bound to a value.
</p></div></div><div class="section" title="1.2.4.&nbsp;Time"><div class="titlepage"><div><div><h3 class="title"><a name="orc.language.time"></a>1.2.4.&nbsp;Time</h3></div></div></div><p>
Orc is designed to communicate with the external world, and one of the
most important characteristics of the external world is the passage of
time. Orc implicitly interacts with the passage of time by calling external
services which take time to respond. However, Orc can also explicitly
wait for some amount of time, using the special site <code class="code"><span class="hl-variable">Rwait</span></code>. 
</p><p>
The site <code class="code"><span class="hl-variable">Rwait</span></code> is a relative timer. It takes as an argument
a number of milliseconds to wait. It waits for approximately that amount of time,
and then responds with a signal.
</p><p>
</p><pre class="orc">
<span class="hl-comment">{- Print "red", wait for 3 seconds (3000 ms), and then print "green" -}</span>
 
<span class="hl-site">Println</span>(<span class="hl-literal">"red"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">3000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"green"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-comment">{-
OUTPUT:
red
green
-}</span>
</pre><p>
</p><p>
The following example defines a metronome, which publishes a signal once 
every <code class="code"><span class="hl-variable">t</span></code> milliseconds, indefinitely.
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">metronome</span>(<span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-keyword">signal</span> <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-variable">t</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">metronome</span>(<span class="hl-variable">t</span>)
</pre><p>
</p><p>
We can also use <code class="code"><span class="hl-variable">Rwait</span></code> together with the pruning combinator 
to enforce a timeout.
</p><p>
</p><pre class="programlisting">
<span class="hl-comment">{- Publish the result of a Google search.
   If it takes more than 5 seconds, time out.
-}</span>
<span class="hl-variable">result</span> 
  <span class="hl-combinator">&lt;</span><span class="hl-variable">result</span><span class="hl-combinator">&lt;</span> ( <span class="hl-site">Google</span>(<span class="hl-literal">"impatience"</span>) 
           <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">5000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"Search timed out."</span>)
</pre><p>
</p>
We present many more examples of programming techniques using real time in <a class="link" href="#">Chapter 2</a>.

</div></div><div class="section" title="1.3.&nbsp;Advanced Features of Orc"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.language.advanced"></a>1.3.&nbsp;Advanced Features of Orc</h2></div></div></div><div class="section" title="1.3.1.&nbsp;The . notation"><div class="titlepage"><div><div><h3 class="title"><a name="special.dot"></a>1.3.1.&nbsp;The <code class="code">.</code> notation</h3></div></div></div><p>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code class="code"><span class="hl-variable">obj</span>.<span class="hl-site">m</span>()</code> calls the method
<code class="code"><span class="hl-variable">m</span></code> of the object <code class="code"><span class="hl-variable">obj</span></code>. 
</p><p>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">msg</span></code>, for any identifiers <code class="code"><span class="hl-variable">x</span></code> and <code class="code"><span class="hl-variable">msg</span></code>. This treats
 the value bound to <code class="code"><span class="hl-variable">x</span></code> as a site, and calls it with a special 
<em class="firstterm">message</em> value <code class="code"><span class="hl-variable">msg</span></code>. 
If the site understands the message <code class="code"><span class="hl-variable">msg</span></code> (for example, if <code class="code"><span class="hl-variable">x</span></code> is 
bound to a Java object with a field called <code class="code"><span class="hl-variable">msg</span></code>), the site interprets the message 
and responds with some appropriate value. If the site does not 
understand the message sent to it, it does not respond, and no publication occurs. 
If <code class="code"><span class="hl-variable">x</span></code> cannot be interpreted as a site, no call is made. 
</p><p>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code class="code"><span class="hl-variable">c</span></code> might understand the messages
<code class="code"><span class="hl-variable">get</span></code> and <code class="code"><span class="hl-variable">put</span></code>, to get values from and put values on that channel,
respectively. Such calls would be written <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">get</span>()</code>, or <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-literal">6</span>)</code>.
</p><p>
A call such as <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-literal">6</span>)</code> actually occurs in two steps. First <code class="code"><span class="hl-variable">c</span>.<span class="hl-variable">put</span></code> sends the message
<code class="code"><span class="hl-variable">put</span></code> to the site <code class="code"><span class="hl-variable">c</span></code>; this publishes a site whose only purpose
is to put values on the channel. Next, that site is called on the argument
<code class="code"><span class="hl-literal">6</span></code>, sending 6 on the channel. Readers familiar with functional programming
will recognize this technique as <span class="emphasis"><em>currying</em></span>. 
</p></div><div class="section" title="1.3.2.&nbsp;Datatypes"><div class="titlepage"><div><div><h3 class="title"><a name="section.orc.datatypes"></a>1.3.2.&nbsp;Datatypes</h3></div></div></div><p>
We have seen Orc's predefined data structures: tuples and lists. Orc also provides the capability
for programmers to define their own data structures, using a feature adopted from the ML/Haskell
language family called <em class="firstterm">datatypes</em> (also called variants or tagged sums).
</p><p>
Datatypes are defined using the <code class="code"><span class="hl-keyword">type</span></code> declaration:

</p><pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-variable">Tree</span> <span class="hl-operator">=</span> <span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">_</span>,<span class="hl-variable">_</span>) <span class="hl-combinator">|</span> <span class="hl-site">Empty</span>()
</pre><p>

</p><p>
This declaration defines two new sites named <code class="code"><span class="hl-variable">Node</span></code> and <code class="code"><span class="hl-variable">Empty</span></code>.
<code class="code"><span class="hl-variable">Node</span></code> takes three arguments, and publishes a <span class="emphasis"><em>tagged value</em></span>
wrapping those arguments. <code class="code"><span class="hl-variable">Empty</span></code> takes no arguments and does the same.
</p><p>
Once we have created these tagged values, we use a new pattern called a datatype pattern
to match them and unwrap the arguments:

</p><pre class="programlisting">
<span class="hl-keyword">type</span> <span class="hl-variable">Tree</span> <span class="hl-operator">=</span> <span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">_</span>,<span class="hl-variable">_</span>) <span class="hl-combinator">|</span> <span class="hl-site">Empty</span>()
<span class="hl-comment">{- Build up a small binary tree -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">l</span> <span class="hl-operator">=</span> <span class="hl-site">Node</span>(<span class="hl-site">Empty</span>(), <span class="hl-literal">0</span>, <span class="hl-site">Empty</span>())
<span class="hl-keyword">val</span> <span class="hl-variable">r</span> <span class="hl-operator">=</span> <span class="hl-site">Node</span>(<span class="hl-site">Empty</span>(), <span class="hl-literal">2</span>, <span class="hl-site">Empty</span>())
<span class="hl-keyword">val</span> <span class="hl-variable">t</span> <span class="hl-operator">=</span> <span class="hl-site">Node</span>(<span class="hl-variable">l</span>,<span class="hl-literal">1</span>,<span class="hl-variable">r</span>)

<span class="hl-comment">{- And then match it to extract its contents -}</span>
<span class="hl-variable">t</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Node</span>(<span class="hl-variable">l</span>,<span class="hl-variable">j</span>,<span class="hl-variable">r</span>)<span class="hl-combinator">&gt;</span>
<span class="hl-variable">l</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">i</span>,<span class="hl-variable">_</span>)<span class="hl-combinator">&gt;</span>
<span class="hl-variable">r</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Node</span>(<span class="hl-variable">_</span>,<span class="hl-variable">k</span>,<span class="hl-variable">_</span>)<span class="hl-combinator">&gt;</span>
( <span class="hl-variable">i</span> <span class="hl-combinator">|</span> <span class="hl-variable">j</span> <span class="hl-combinator">|</span> <span class="hl-variable">k</span> )
</pre><p>
</p><p>
One pair of datatypes is so commonly used that it is already predefined in the standard library:
<code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">_</span>)</code> and <code class="code"><span class="hl-site">None</span>()</code>. These are used as return values for calls that
need to distinguish between successfully returning a value (<code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">v</span>)</code>), and successfully
completing but having no meaningful value to return (<code class="code"><span class="hl-site">None</span>()</code>). For example, a lookup
function might return <code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">result</span>)</code> if it found a result, or return <code class="code"><span class="hl-site">None</span>()</code>
if it successfully performed the lookup but found no suitable result.
</p></div><div class="section" title="1.3.3.&nbsp;Classes"><div class="titlepage"><div><div><h3 class="title"><a name="section.language.class"></a>1.3.3.&nbsp;Classes</h3></div></div></div><p>
A class is an abstraction mechanism in Orc, much like the
<code class="code"><span class="hl-keyword">def</span></code> construct. It extends the <code class="code"><span class="hl-keyword">def</span></code> construct, by allowing
us to convert an Orc program fragment into a site. Specifically, a
class can be used to: (1) Define object classes with methods,
(2) Create new sites and extend behaviors of existing sites, (3) Allow
concurrent method invocation on objects, and (4) Create active
objects, whose executions may be based on time or other external
stimulus, not necessarily explicitly called methods. 
</p><p>
A class has the following properties:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Encapsulation: Just like objects in an object-oriented language, classes 
	also provide the encapsulation facility for the programmer. The data defined inside 
	the class can only be accessed and modified through methods defined in class. Therefore, 
	it hides the representation of the data and implementation of functions and methods 
	which work on the data and manage the state. </li><li class="listitem">Methods instead of functions: These are the gateways to access and manipulate the 
	data represented by class. They also enable the user of the class to access the service 
	provided by that. Unlike functions in Orc, methods defined in a class can only publish 
	one value. </li><li class="listitem">Termination protection: The execution of a class and its methods are protected from 
	termination of the rest of the program. In other words, the execution of class cannot be 
	interrupted. In the pruning combinator as soon as the right hand side expression publishes a 
	value, all the on going executions in the right hand side will be terminated. However, if there 
	is any call to a class in the right hand side, that call will proceed until completion. For 
	example, in the following Orc expression, suppose that c is a class.
	<pre class="programlisting">
	 <span class="hl-variable">y</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">y</span><span class="hl-combinator">&lt;</span> <span class="hl-site">g</span>() <span class="hl-combinator">|</span> <span class="hl-site">c</span>() 
</pre>
	If g() publishes a value before c() does, the execution of c() will continue. Although, the published 
	value of c() (if any) will never be used. On the other hand, if c() publishes a value first, then the 
	execution of g() will be interrupted since its execution is not protected. This property of classes is 
	very important to prevent the data corruption and invalid state of an object. We will see using an 
	example the significance of this property later on in the guide. 
</li><li class="listitem">Strict calls: unlike calls to ordinary function definitions in Orc, calls to class methods 
		are strict. This means that the call will not happen unless all the parameters are bound. </li></ol></div><p>
</p><p>
A class definition can be translated to pure Orc calculus, making
use of the site <code class="code"><span class="hl-variable">makesite</span></code>. (See <a class="xref" href="#">???</a> for details of <code class="code"><span class="hl-variable">makesite</span></code>.)
</p><div class="section" title="1.3.3.1.&nbsp;Object Definition"><div class="titlepage"><div><div><h4 class="title"><a name="N106C7"></a>1.3.3.1.&nbsp;Object Definition</h4></div></div></div><p>
To motivate the notion of class, we start with a simple example, 
defining a stack with methods <code class="code"><span class="hl-variable">push</span></code> and <code class="code"><span class="hl-variable">pop</span></code>. Below, parameter <code class="code"><span class="hl-variable">n</span></code>
defines the maximum length of each instance of stack. We store the
stack elements in an array. Our implementation blocks an illegal
operation (a <code class="code"><span class="hl-variable">push</span></code> on a full stack or a <code class="code"><span class="hl-variable">pop</span></code> on an empty stack).  
</p><pre class="programlisting">
<span class="hl-comment">{- Define a simple stack in Orc -}</span>

<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">Stack</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">store</span> <span class="hl-operator">=</span> <span class="hl-site">Table</span>(<span class="hl-variable">n</span>, <span class="hl-variable">Ref</span>)
  <span class="hl-keyword">val</span> <span class="hl-variable">len</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span> (<span class="hl-literal">0</span>) <span class="hl-comment">-- len is the current stack length</span>

  <span class="hl-keyword">def</span> <span class="hl-site">push</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-site">Ift</span>(<span class="hl-variable">len</span><span class="hl-operator">?</span> <span class="hl-operator">&lt;:</span> <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">store</span>(<span class="hl-variable">len</span><span class="hl-operator">?</span>) <span class="hl-operator">:=</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">len</span> <span class="hl-operator">:=</span> <span class="hl-variable">len</span><span class="hl-operator">?</span> <span class="hl-operator">+</span> <span class="hl-literal">1</span>

  <span class="hl-keyword">def</span> <span class="hl-site">pop</span>() <span class="hl-operator">=</span> <span class="hl-site">Ift</span>(<span class="hl-variable">len</span><span class="hl-operator">?</span> <span class="hl-operator">:&gt;</span> <span class="hl-literal">0</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">len</span> <span class="hl-operator">:=</span> <span class="hl-variable">len</span><span class="hl-operator">?</span> <span class="hl-operator">-</span> <span class="hl-literal">1</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">store</span>(<span class="hl-variable">len</span><span class="hl-operator">?</span>)<span class="hl-operator">?</span>

  <span class="hl-comment">{- class goal -}</span> <span class="hl-keyword">stop</span>

<span class="hl-comment">{- Test the stack -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">st</span> <span class="hl-operator">=</span> <span class="hl-site">Stack</span>(<span class="hl-literal">5</span>)
<span class="hl-variable">st</span>.<span class="hl-site">push</span>(<span class="hl-literal">3</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">st</span>.<span class="hl-site">push</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">st</span>.<span class="hl-site">pop</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">st</span>.<span class="hl-site">pop</span>()

<span class="hl-comment">{-
OUTPUT:
3
-}</span>
</pre></div><div class="section" title="1.3.3.2.&nbsp;Class Syntax and Semantics"><div class="titlepage"><div><div><h4 class="title"><a name="N106DD"></a>1.3.3.2.&nbsp;Class Syntax and Semantics</h4></div></div></div><p>
A class is defined much like a a function. The keyword <code class="code"><span class="hl-variable">class</span></code>
is used after <code class="code"><span class="hl-keyword">def</span></code>. A class may have parameters (including
other classes), as in a function definition. The body of a class
may include function and class definitions. The name of every definition
in the body of a class is exported. 

</p><p>
A class definition obeys all the rules of function definition
except:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">A class definition must include at least one
definition (which could be a class definition),</li><li class="listitem">A class's goal expression must not publish,</li><li class="listitem">Each function defined within a class publishes at most once.</li></ol></div><p>
</p><p>
A class call creates and publishes a site (recall that the goal
expression of a class must not publish). Thus, 

</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">st</span> <span class="hl-operator">=</span> <span class="hl-site">Stack</span>(<span class="hl-literal">5</span>)
</pre><p>

instantiates site <code class="code"><span class="hl-variable">st</span></code>. Multiple instances of a
class may be created by calling the class multiple times. The
functions (and classes) defined in the body of the class are
externally accessed as dot methods.
</p></div><div class="section" title="1.3.3.3.&nbsp;Notes"><div class="titlepage"><div><div><h4 class="title"><a name="N106FC"></a>1.3.3.3.&nbsp;Notes</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Clausal definition: A class may be defined as a set of
  clauses, exactly as a function definition. In this case all clauses
  must define the same names to be exported.
</p></li><li class="listitem"><p>
Concurrent calls to methods: Methods of a class instance may
  be invoked concurrently, as in functions. It is the obligation of
  the programmer to ensure that concurrent calls do not
  interfere. Calling the methods of stack <code class="code"><span class="hl-variable">st</span></code> concurrently may
  result in unintended outcomes. For example, in  
</p><pre class="programlisting">
  <span class="hl-variable">st</span>.<span class="hl-site">push</span>(<span class="hl-literal">3</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">st</span>.<span class="hl-site">pop</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">st</span>.<span class="hl-site">pop</span>()
<span class="hl-combinator">|</span> <span class="hl-variable">st</span>.<span class="hl-site">push</span>(<span class="hl-literal">4</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
</pre><p>
  the last <code class="code"><span class="hl-variable">st</span>.<span class="hl-site">pop</span>()</code> (in the first line) often does not succeed,
  because just one value was stored in the stack though there
  were two concurrent <code class="code"><span class="hl-variable">st</span>.<span class="hl-site">push</span>()</code> operations. 
</p></li><li class="listitem"><p>
Prune on class call: Like site calls, running class method invocations 
  are not terminated by the pruning combinator. In the following program,
  <code class="code"><span class="hl-variable">x</span></code> is assigned value 3 because execution of <code class="code"><span class="hl-site">testprune</span>().<span class="hl-site">run</span>()</code> never
  publishes. However,
  <code class="code"><span class="hl-site">testprune</span>().<span class="hl-site">run</span>()</code> is treated as a site call which continues
  execution even after x is assigned a value. Eventually, the line
  <code class="computeroutput">done</code> is printed.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">testprune</span>() <span class="hl-operator">=</span>
  <span class="hl-keyword">def</span> <span class="hl-site">run</span>() <span class="hl-operator">=</span>  <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"done"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
  <span class="hl-keyword">stop</span>

  <span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span>  <span class="hl-site">Rwait</span>(<span class="hl-literal">50</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">3</span> <span class="hl-combinator">|</span>  <span class="hl-site">testprune</span>().<span class="hl-site">run</span>()
  <span class="hl-variable">x</span>
</pre><p>
</p></li></ul></div></div><div class="section" title="1.3.3.4.&nbsp;Class Example"><div class="titlepage"><div><div><h4 class="title"><a name="N10724"></a>1.3.3.4.&nbsp;Class Example</h4></div></div></div><p>
		The following shows the code for this sequence number generator in Orc: 
	</p><pre class="programlisting">
<span class="hl-comment">{- Create a sequence number generator -}</span>

<span class="hl-comment">{- mutable integer defined with seed zero -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">seq_num</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>(<span class="hl-literal">0</span>) 

<span class="hl-comment">{- gen_seq will increase the seq_num and return the new value -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">gen_seq</span>() <span class="hl-operator">=</span>
  <span class="hl-variable">seq_num</span> <span class="hl-operator">:=</span> <span class="hl-variable">seq_num</span><span class="hl-operator">?</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">seq_num</span><span class="hl-operator">?</span>
  
<span class="hl-site">gen_seq</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-variable">s</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">gen_seq</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-variable">s</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-comment">{-
OUTPUT:
1
2
-}</span>
</pre><p>
		What is the problem with the above code? The first problem is that the seq_num is 
		exposed to all the expressions which come after it. This means that all those 
		expressions can possibly read and write the value of seq_num. This is not always 
		desirable and makes the reasoning about the program more difficult. The second issue 
		with this code is that it is not flexible enough. What if we want to have different 
		sequence number generator with a different initial seed? For example, we may want a 
		sequence number starting at 0 and another one starting at 1000.
	</p><p>
		There is another issue associated with the above code from a concurrent programming 
		viewpoint. It is not thread safe. This means that if we make two parallel calls to 
		gen_seq(), we may get the same result. For example, the following piece of code: 
	</p><pre class="programlisting">
<span class="hl-site">gen_seq</span>() <span class="hl-combinator">|</span> <span class="hl-site">gen_seq</span>()
</pre><p> The above code can generate "1" as the publication for both expressions, and in most of the runs
		it will.  This is a famous phenomenon in parallel programming known as a race condition. 
		In fact, access to the shared variable seq_num is subject to race condition between 
		the two threads running the two calls to gen_seq(). To solve the race issue we need 
		to add a semaphore to the above code in order to regulate the access to the shared 
		variable, seq_num. Therefore, every call to gen_seq needs to acquire the semaphore in 
		order to update the variable and release the semaphore at the end. The new safe code 
		is as follows:  </p><pre class="programlisting">
<span class="hl-comment">{- Create a sequence number generator with a semaphore -}</span>

<span class="hl-comment">{- the mutable integer defined with seed zero -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">seq_num</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>(<span class="hl-literal">0</span>)

<span class="hl-comment">{- a semaphore to regulate access to shared variable seq_num -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">seq_num_sem</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">1</span>)

<span class="hl-comment">{- gen_seq will increase the seq_num and return the new value -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">gen_seq</span>() <span class="hl-operator">=</span>
  <span class="hl-variable">seq_num_sem</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">seq_num</span> <span class="hl-operator">:=</span> <span class="hl-variable">seq_num</span><span class="hl-operator">?</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
  <span class="hl-variable">seq_num</span><span class="hl-operator">?</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">seq_num_sem</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>
  
<span class="hl-site">gen_seq</span>() <span class="hl-combinator">|</span> <span class="hl-site">gen_seq</span>()

<span class="hl-comment">{-
OUTPUT:
1
2
-}</span>
</pre><p>
		The above code, besides the issue of encapsulation and the complexity of having more than 
		one sequence number generator, looks fine. However, there is a subtle problem with this code. 
		The problem is data corruption and invalid state which can be caused by abrupt termination 
		of the call to gen_seq(). Consider the following piece of code and corresponding execution order: 
	</p><pre class="programlisting">
<span class="hl-variable">y</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">y</span><span class="hl-combinator">&lt;</span> <span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">|</span> <span class="hl-site">gen_seq</span>()
		</pre><pre class="programlisting">
<span class="hl-literal">1</span><span class="hl-operator">-</span> <span class="hl-literal">1</span><span class="hl-operator">+</span><span class="hl-literal">1</span>
<span class="hl-literal">2</span><span class="hl-operator">-</span> <span class="hl-variable">seq_num_sem</span>.<span class="hl-site">acquire</span>()
<span class="hl-literal">3</span><span class="hl-operator">-</span> <span class="hl-variable">y</span> <span class="hl-variable">is</span> <span class="hl-variable">bound</span> <span class="hl-variable">to</span> <span class="hl-literal">2</span>
<span class="hl-literal">4</span><span class="hl-operator">-</span> <span class="hl-variable">terminate</span> <span class="hl-site">gen_seq</span>()
		</pre><p>
		As illustrated in the above execution sequence, the semaphore seq_num_sem got acquired but never 
		released because of abrupt termination. Therefore consecutive calls to gen_seq will never proceed 
		because they cannot acquire the semaphore. So, we need to somehow protect the execution of gen_seq. 
		Classes address all the above issues in a succinct way.
	</p><p>
		The class solution to the sequence number generator is the following code:
	</p><pre class="programlisting">
<span class="hl-comment">{- Create a sequence number generator as a class -}</span>

<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">gen_seq</span>(<span class="hl-variable">init</span>) <span class="hl-operator">=</span>
	<span class="hl-comment">{- the mutable integer defined with seed init -}</span>
	<span class="hl-keyword">val</span> <span class="hl-variable">seq_num</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>(<span class="hl-variable">init</span>)
	
	<span class="hl-comment">{- the next function will increase the seq_num and return the new value -}</span>
	<span class="hl-keyword">def</span> <span class="hl-site">next</span>() <span class="hl-operator">=</span>
		<span class="hl-variable">seq_num</span> <span class="hl-operator">:=</span> <span class="hl-variable">seq_num</span><span class="hl-operator">?</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">seq_num</span><span class="hl-operator">?</span>
	<span class="hl-keyword">signal</span>

	<span class="hl-keyword">val</span> <span class="hl-variable">g</span> <span class="hl-operator">=</span> <span class="hl-site">gen_seq</span>(<span class="hl-literal">1000</span>)

	<span class="hl-variable">g</span>.<span class="hl-site">next</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-variable">y</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">g</span>.<span class="hl-site">next</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-variable">y</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-comment">{-
OUTPUT:
1001
1002
-}</span>
		</pre><p>
		It is very easy to instantiate a new sequence number that starts with a different seed. We just need 
		to create a new instance of gen_seq with a different seed. The following code shows an example of creating 
		two sequence number generator with two different seeds. 
	</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">g0</span> <span class="hl-operator">=</span> <span class="hl-site">gen_seq</span>(<span class="hl-literal">0</span>)
<span class="hl-keyword">val</span> <span class="hl-variable">g1</span> <span class="hl-operator">=</span> <span class="hl-site">gen_seq</span>(<span class="hl-literal">1000</span>)

<span class="hl-variable">g0</span>.<span class="hl-site">next</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-variable">y</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">g1</span>.<span class="hl-site">next</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-variable">y</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
		</pre><p>
		Notice how easy it is to have a new sequence number generator. Comparatively, in a pure functional language where 
		we just have functions, we need to declare new declarations of seq_num to accomplish the job.
	</p><p>
		Now, in order to solve the issue of thread safety, we want to add a semaphore to the class. Note that since 
		the execution of the class is protected we will not run into the problem of invalid state or data corruption 
		caused by abrupt termination. The following code shows the thread safe version of the sequence number generator. 
	</p><pre class="programlisting">
<span class="hl-comment">{- Create a sequence number generator as a class with semaphore -}</span>

<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">gen_seq</span>(<span class="hl-variable">init</span>) <span class="hl-operator">=</span>
	<span class="hl-comment">{- the mutable integer defined with seed init -}</span>
	<span class="hl-keyword">val</span> <span class="hl-variable">seq_num</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>(<span class="hl-variable">init</span>)
	
	<span class="hl-comment">{- a semaphore to regulate access to shared variable seq_num -}</span>
	<span class="hl-keyword">val</span> <span class="hl-variable">seq_num_sem</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">1</span>)
	
	<span class="hl-comment">{- gen_seq will increase the seq_num and return the new value -}</span>
	<span class="hl-keyword">def</span> <span class="hl-site">next</span>() <span class="hl-operator">=</span>
		<span class="hl-variable">seq_num_sem</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">seq_num</span> <span class="hl-operator">:=</span> <span class="hl-variable">seq_num</span><span class="hl-operator">?</span><span class="hl-operator">+</span><span class="hl-literal">1</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
		<span class="hl-variable">seq_num</span><span class="hl-operator">?</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">seq_num_sem</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>
	<span class="hl-keyword">signal</span>
	
<span class="hl-comment">{-
OUTPUT:
-}</span>
		</pre></div><div class="section" title="1.3.3.5.&nbsp;More Class Examples"><div class="titlepage"><div><div><h4 class="title"><a name="N1074B"></a>1.3.3.5.&nbsp;More Class Examples</h4></div></div></div><p>
Here we show a few more examples of class usage.
</p><div class="section" title="1.3.3.5.1.&nbsp;Active Classes"><div class="titlepage"><div><div><h5 class="title"><a name="N10750"></a>1.3.3.5.1.&nbsp;Active Classes</h5></div></div></div></div><p>
		Class is an active entity. Active objects, unlike passive ones, have 
		their own thread of control. They can initiate a computation without receiving 
		a method call (in procedural languages) or a message (in languages with message 
		passing model). Note that this definition of active objects subsumes reactive 
		objects and actors. We said that the execution of class is protected from the 
		rest of the program. Here we want to clarify what do we mean by creation of the 
		class and when the class actually exists.
	</p><p>
		A class exists as soon as all the parameters and free variables in the class 
		are bound to their values. Thereafter, any method on the class can be called. This 
		means that the creation process would not wait for goal expression of the class to 
		finish. Therefore, the creation of the class would return immediately. But the goal 
		expression continues to execute. The goal expression will not publish anything. However, 
		it can have side effects. For example, it could print something on the screen or it 
		can initiate some other processes and send and receive data to and/or from channels. 
	</p><p>
		The following example explains the notion of activeness of classes. We want to design a 
		clock that ticks every n (user specified) milliseconds. We want to be able to get the 
		number of ticks passed since the process started. The following example shows a class 
		implementation of this clock.
	</p><pre class="programlisting">
<span class="hl-comment">{- Define a class to track passage of time -}</span>

<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">nclock</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-comment">-- tick every n milliseconds</span>
	<span class="hl-comment">{- tick_cnt counts the number of ticks -}</span>
	<span class="hl-keyword">val</span> <span class="hl-variable">tick_cnt</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>(<span class="hl-literal">0</span>)
	
	<span class="hl-comment">{- getTick returns the number of ticks passed so far -}</span>
	<span class="hl-keyword">def</span> <span class="hl-site">getTick</span>() <span class="hl-operator">=</span> <span class="hl-variable">tick_cnt</span><span class="hl-operator">?</span>
	<span class="hl-site">metronome</span>(<span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">tick_cnt</span><span class="hl-operator">:=</span><span class="hl-variable">tick_cnt</span><span class="hl-operator">?</span><span class="hl-operator">+</span><span class="hl-literal">1</span>

	<span class="hl-keyword">val</span> <span class="hl-variable">ticker</span> <span class="hl-operator">=</span> <span class="hl-site">nclock</span>(<span class="hl-literal">250</span>)
	<span class="hl-comment">{- prints a mutiple of 4 every one second -}</span>
	<span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">metronome</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">ticker</span>.<span class="hl-site">getTick</span>()
	
<span class="hl-comment">{-
OUTPUT:
-}</span>
		</pre><p>
		In this example, the class nclock has a tick counter tick_cnt that records the number of 
		ticks passed so far. The method getTick returns the number of ticks. The interesting point 
		about this class is its goal expression. The goal expression is a metronome that publish 
		a signal every n milliseconds. Each time a signal is issued it causes the tick_cnt to increase 
		by one. As can be seen, the goal expression would never stop. It keeps increasing the tick 
		counter for ever and a thread is always active in the nclock class instance. This program 
		keeps publishing the multiples of 4 starting from 4 upward. 
	</p><div class="section" title="1.3.3.5.2.&nbsp;Multi-dimensional Matrix"><div class="titlepage"><div><div><h5 class="title"><a name="N1075D"></a>1.3.3.5.2.&nbsp;Multi-dimensional Matrix</h5></div></div></div><p>
We declare a two dimensional matrix whose index ranges may span any
finite interval of integers. The same technique can be used to declare
any multi-dimensional matrix.
</p><pre class="programlisting">
<span class="hl-comment">{- Define a multi-dimensional matrix -}</span>

<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">Matrix</span>((<span class="hl-variable">lo1</span>, <span class="hl-variable">up1</span>), (<span class="hl-variable">lo2</span>, <span class="hl-variable">up2</span>)) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">mat</span> <span class="hl-operator">=</span> <span class="hl-site">Array</span>((<span class="hl-variable">up1</span> <span class="hl-operator">-</span> <span class="hl-variable">lo1</span> <span class="hl-operator">+</span> <span class="hl-literal">1</span>) <span class="hl-operator">*</span> (<span class="hl-variable">up2</span> <span class="hl-operator">-</span> <span class="hl-variable">lo2</span> <span class="hl-operator">+</span> <span class="hl-literal">1</span>))
  <span class="hl-keyword">def</span> <span class="hl-site">access</span>(<span class="hl-variable">i</span>, <span class="hl-variable">j</span>) <span class="hl-operator">=</span> <span class="hl-site">mat</span>((<span class="hl-variable">i</span> <span class="hl-operator">-</span> <span class="hl-variable">lo1</span>) <span class="hl-operator">*</span> (<span class="hl-variable">up2</span> <span class="hl-operator">-</span> <span class="hl-variable">lo2</span> <span class="hl-operator">+</span> <span class="hl-literal">1</span>) <span class="hl-operator">+</span> <span class="hl-variable">j</span>)
  <span class="hl-keyword">stop</span>

<span class="hl-keyword">val</span> <span class="hl-variable">A</span> <span class="hl-operator">=</span> <span class="hl-site">Matrix</span>((<span class="hl-operator">-</span><span class="hl-literal">2</span>, <span class="hl-literal">0</span>), (<span class="hl-operator">-</span><span class="hl-literal">1</span>, <span class="hl-literal">3</span>)).<span class="hl-variable">access</span>
<span class="hl-site">A</span>(<span class="hl-operator">-</span><span class="hl-literal">1</span>,<span class="hl-literal">2</span>) <span class="hl-operator">:=</span> <span class="hl-literal">5</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">A</span>(<span class="hl-operator">-</span><span class="hl-literal">1</span>, <span class="hl-literal">2</span>) <span class="hl-operator">:=</span> <span class="hl-literal">3</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">A</span>(<span class="hl-operator">-</span><span class="hl-literal">1</span>, <span class="hl-literal">2</span>)<span class="hl-operator">?</span>

<span class="hl-comment">{-
OUTPUT:
3
-}</span>
</pre><p>
Note that we define matrix <code class="code"><span class="hl-variable">A</span></code> to be the sole method, <code class="code"><span class="hl-variable">access</span></code>, of the
class; this enables us to refer to matrix elements in the
traditional style.
</p></div><div class="section" title="1.3.3.5.3.&nbsp;Create a new site"><div class="titlepage"><div><div><h5 class="title"><a name="N1076C"></a>1.3.3.5.3.&nbsp;Create a new site</h5></div></div></div><p>
We create a new site, a bounded channel, using <code class="code"><span class="hl-variable">Channel</span></code> and
<code class="code"><span class="hl-variable">Semaphore</span></code> sites. The channel stores the data items and the
semaphores are used to ensure proper blocking. Below, <code class="code"><span class="hl-variable">n</span></code> is the
maximum channel size, and <code class="code"><span class="hl-variable">p</span></code> and <code class="code"><span class="hl-variable">g</span></code> are semaphores whose values are the
number of empty and full positions, respectively. A <code class="code"><span class="hl-variable">put</span></code> operation is
allowed only if <code class="code"><span class="hl-variable">p</span> &gt; <span class="hl-literal">0</span></code> and a <code class="code"><span class="hl-variable">get</span></code> if <code class="code"><span class="hl-variable">g</span> &gt; <span class="hl-literal">0</span></code>.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">BChannel</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">b</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
  <span class="hl-keyword">val</span> (<span class="hl-variable">p</span>, <span class="hl-variable">g</span>) <span class="hl-operator">=</span> (<span class="hl-site">Semaphore</span>(<span class="hl-variable">n</span>), <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>))
  <span class="hl-keyword">def</span> <span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">p</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">g</span>.<span class="hl-site">release</span>()
  <span class="hl-keyword">def</span> <span class="hl-site">get</span>() <span class="hl-operator">=</span> <span class="hl-variable">g</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">p</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>
  <span class="hl-keyword">stop</span>
</pre><p>
Note that setting <code class="code"><span class="hl-variable">n</span> <span class="hl-operator">=</span> <span class="hl-literal">1</span></code> lets us define a 1-place channel in which the
executions of 
<code class="code"><span class="hl-variable">put</span></code> and <code class="code"><span class="hl-variable">get</span></code> operations have to alternate.
</p></div><div class="section" title="1.3.3.5.4.&nbsp;Extend functionality of existing site"><div class="titlepage"><div><div><h5 class="title"><a name="N10799"></a>1.3.3.5.4.&nbsp;Extend functionality of existing site</h5></div></div></div><p>
We add a <code class="code"><span class="hl-variable">length</span></code> function to the <code class="code"><span class="hl-variable">Channel</span></code> site, that returns
its current length. 
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">Channel</span>() <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">ch</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
  <span class="hl-keyword">val</span> <span class="hl-variable">chlen</span> <span class="hl-operator">=</span> <span class="hl-site">Counter</span>(<span class="hl-literal">0</span>)

  <span class="hl-keyword">def</span> <span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">ch</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">chlen</span>.<span class="hl-site">inc</span>()
  <span class="hl-keyword">def</span> <span class="hl-site">get</span>() <span class="hl-operator">=</span> <span class="hl-variable">ch</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">chlen</span>.<span class="hl-site">dec</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>
  <span class="hl-keyword">def</span> <span class="hl-site">length</span>() <span class="hl-operator">=</span> <span class="hl-variable">chlen</span>.<span class="hl-site">value</span>()
  <span class="hl-keyword">stop</span>
</pre></div><div class="section" title="1.3.3.5.5.&nbsp;A Communication protocol; Rendezvous"><div class="titlepage"><div><div><h5 class="title"><a name="N107A6"></a>1.3.3.5.5.&nbsp;A Communication protocol; Rendezvous</h5></div></div></div><p>
A set of senders and receivers communicate in the following manner. A
sender executes <code class="code"><span class="hl-site">send</span>(<span class="hl-variable">v</span>)</code> and a receiver <code class="code"><span class="hl-site">recv</span>()</code>. The <code class="code"><span class="hl-site">send</span>(<span class="hl-variable">v</span>)</code> remains
blocked until some <code class="code"><span class="hl-site">recv</span>()</code> operation is executed; similarly a
<code class="code"><span class="hl-site">recv</span>()</code> is blocked until there is a corresponding <code class="code"><span class="hl-site">send</span>(<span class="hl-variable">v</span>)</code>. When both
<code class="code"><span class="hl-site">send</span>(<span class="hl-variable">v</span>)</code> and <code class="code"><span class="hl-site">recv</span>()</code> operations are ready for execution,
the <code class="code"><span class="hl-site">recv</span>()</code> operation receives data <code class="code"><span class="hl-variable">v</span></code>, <code class="code"><span class="hl-variable">send</span></code> receives a signal,
and both can then proceed.
</p><p>
We employ semaphore <code class="code"><span class="hl-variable">s</span></code> on which the send operation blocks; <code class="code"><span class="hl-variable">s</span></code> is released by
the receive operation. The sender then puts its data in a channel and
the receiver reads from the channel. 
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">Rendezvous</span>() <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> (<span class="hl-variable">s</span>,<span class="hl-variable">data</span>) <span class="hl-operator">=</span> (<span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>), <span class="hl-site">Channel</span>())
  <span class="hl-keyword">def</span> <span class="hl-site">send</span>(<span class="hl-variable">x</span>) <span class="hl-operator">=</span> <span class="hl-variable">s</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">data</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>)
  <span class="hl-keyword">def</span> <span class="hl-site">recv</span>() <span class="hl-operator">=</span> <span class="hl-variable">s</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">data</span>.<span class="hl-site">get</span>()
  <span class="hl-keyword">stop</span>
</pre><p>
The following code fragment shows three threads that are forced to
execute their codes in a nearly sequential manner due to the restrictions
imposed by rendezvous.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">group1</span> <span class="hl-operator">=</span> <span class="hl-site">Rendezvous</span>()
<span class="hl-keyword">val</span> <span class="hl-variable">group2</span> <span class="hl-operator">=</span> <span class="hl-site">Rendezvous</span>()

  <span class="hl-variable">group1</span>.<span class="hl-site">send</span>(<span class="hl-literal">3</span>)
<span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">group2</span>.<span class="hl-site">recv</span>()
<span class="hl-combinator">|</span> <span class="hl-variable">group2</span>.<span class="hl-site">send</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">group1</span>.<span class="hl-site">recv</span>()
</pre></div><div class="section" title="1.3.3.5.6.&nbsp;A class operating in real time"><div class="titlepage"><div><div><h5 class="title"><a name="N107DA"></a>1.3.3.5.6.&nbsp;A class operating in real time</h5></div></div></div><p>
We create a class to mimic a stopwatch. A stopwatch allows the
following operations: 
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-site">start</span>()</code>: (re)starts the stopwatch and publishes a signal</li><li class="listitem"><code class="code"><span class="hl-site">halt</span>()</code>: stops and publishes current value on the stopwatch</li></ul></div><p>
</p><p>
We implement an instance of a stopwatch by assigning a new clock to it
(created by calling site <code class="code"><span class="hl-site">Clock</span>()</code> that returns a new clock
with value 0). Additionally, two mutable variables are used with
the following meaning.
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-variable">timeshown</span></code>: clock value when the stopwatch was last stopped,</li><li class="listitem"><code class="code"><span class="hl-variable">laststart</span></code>: clock value when the stopwatch was last started.</li></ul></div><p>
Initially, both variable values are 0.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">class</span> <span class="hl-site">Stopwatch</span>() <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">clk</span> <span class="hl-operator">=</span> <span class="hl-site">Clock</span>()
  <span class="hl-keyword">val</span> (<span class="hl-variable">timeshown</span>, <span class="hl-variable">laststart</span>) <span class="hl-operator">=</span> (<span class="hl-site">Ref</span>(<span class="hl-literal">0</span>), <span class="hl-site">Ref</span>(<span class="hl-literal">0</span>))

  <span class="hl-keyword">def</span> <span class="hl-site">start</span>() <span class="hl-operator">=</span> <span class="hl-variable">laststart</span> <span class="hl-operator">:=</span> <span class="hl-site">clk</span>()

  <span class="hl-keyword">def</span> <span class="hl-site">halt</span>() <span class="hl-operator">=</span> <span class="hl-variable">timeshown</span> <span class="hl-operator">:=</span> <span class="hl-variable">timeshown</span><span class="hl-operator">?</span> <span class="hl-operator">+</span> (<span class="hl-site">clk</span>() <span class="hl-operator">-</span> <span class="hl-variable">laststart</span><span class="hl-operator">?</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">timeshown</span><span class="hl-operator">?</span>
  <span class="hl-keyword">stop</span>
</pre><p>
A useable implementation of stopwatch requires a more general
interface. It should allow <code class="code"><span class="hl-variable">start</span></code> operation in the state where
the stopwatch is already running, and <code class="code"><span class="hl-variable">halt</span></code> in a state where the
stopwatch is already halted. Additionally, an operation to determine
the staus of the stopwatch (running or not) should be provided. Such
an implementation is given for the library site, <code class="code"><span class="hl-variable">Stopwatch</span></code>; see
 the <code class="code"><span class="hl-variable">Stopwatch</span></code> site in <a class="xref" href="#">???</a>.  
</p></div></div></div></div></div><div lang="" class="chapter" title="Chapter&nbsp;2.&nbsp;Programming Methodology"><div class="titlepage"><div><div><h2 class="title"><a name="ug.methodology"></a>Chapter&nbsp;2.&nbsp;Programming Methodology</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#ug.methodology.convention">2.1. Syntactic and Stylistic Conventions</a></span></dt><dd><dl><dt><span class="section"><a href="#N10823">2.1.1. Parallel combinator</a></span></dt><dt><span class="section"><a href="#N1085C">2.1.2. Sequential combinator</a></span></dt><dt><span class="section"><a href="#style.pruning">2.1.3. Pruning combinator</a></span></dt><dt><span class="section"><a href="#N10907">2.1.4. Declarations</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.methodology.idiom">2.2. Programming Idioms</a></span></dt><dd><dl><dt><span class="section"><a href="#methodology.channels">2.2.1. Channels</a></span></dt><dt><span class="section"><a href="#N109C6">2.2.2. Lists</a></span></dt><dt><span class="section"><a href="#methodology.streams">2.2.3. Streams</a></span></dt><dt><span class="section"><a href="#methodology.mutable">2.2.4. Mutable References</a></span></dt><dt><span class="section"><a href="#N10ADE">2.2.5. Tables</a></span></dt><dt><span class="section"><a href="#N10B29">2.2.6. Loops</a></span></dt><dt><span class="section"><a href="#N10B42">2.2.7. Parallel Matching</a></span></dt><dt><span class="section"><a href="#methodology.forkjoin">2.2.8. Fork-join</a></span></dt><dt><span class="section"><a href="#N10C0D">2.2.9. Sequential Fork-Join</a></span></dt><dt><span class="section"><a href="#N10C28">2.2.10. Priority Poll</a></span></dt><dt><span class="section"><a href="#N10C4B">2.2.11. Parallel Or</a></span></dt><dt><span class="section"><a href="#N10C88">2.2.12. Timeout</a></span></dt><dt><span class="section"><a href="#N10D32">2.2.13. Priority</a></span></dt><dt><span class="section"><a href="#N10D42">2.2.14. Metronome</a></span></dt><dt><span class="section"><a href="#N10D58">2.2.15. Routing</a></span></dt><dt><span class="section"><a href="#N10E04">2.2.16. Interruption</a></span></dt><dt><span class="section"><a href="#N10E36">2.2.17. Fold</a></span></dt></dl></dd><dt><span class="section"><a href="#ug.methodology.example">2.3. Larger Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#N10E9D">2.3.1. Dining Philosophers</a></span></dt><dt><span class="section"><a href="#methodology.examples.hygenic">2.3.2. Hygienic Dining Philosophers</a></span></dt><dt><span class="section"><a href="#N10F34">2.3.3. Readers-Writers</a></span></dt><dt><span class="section"><a href="#N10F62">2.3.4. Quicksort</a></span></dt><dt><span class="section"><a href="#N10FC2">2.3.5. Meeting Scheduler</a></span></dt></dl></dd></dl></div><p>
In Chapter 1, we described the syntax and semantics of the Orc language. 
Now, we turn our attention to how the language is used in practice, with guidelines on style and programming 
methodology, including a number of common concurrency patterns.
</p><div class="section" title="2.1.&nbsp;Syntactic and Stylistic Conventions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.methodology.convention"></a>2.1.&nbsp;Syntactic and Stylistic Conventions</h2></div></div></div><p>
In this section we suggest some syntactic conventions for writing Orc programs. None of these 
conventions are required by the parser; newlines are used only to disambiguate certain corner
cases in parsing, and other whitespace is ignored. However, following programming convention 
helps to improve the readability of programs, so that the programmer's intent is more readily apparent.
</p><div class="section" title="2.1.1.&nbsp;Parallel combinator"><div class="titlepage"><div><div><h3 class="title"><a name="N10823"></a>2.1.1.&nbsp;Parallel combinator</h3></div></div></div><p>
When the expressions to be combined are small, write them all on one line.

</p><pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>G</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>H</strong></span>
</pre><p>

</p><p>
When the combined expressions are large enough to take up a full line, write one expression
per line, with each subsequent expression aligned with the first and preceded by <code class="code"><span class="hl-combinator">|</span></code>. 
Indent the first expression to improve readability.

</p><pre class="programlisting">
  <span class="bold"><strong>long expression</strong></span> 
<span class="hl-combinator">|</span> <span class="bold"><strong>long expression</strong></span>
<span class="hl-combinator">|</span> <span class="bold"><strong>long expression</strong></span>
</pre><p>
 
</p><p>
A sequence of parallel expressions often form the left hand side of a sequential combinator. 
Since the sequential combinator has higher precedence, use parentheses to group the
combined parallel expressions together. 


</p><pre class="programlisting">
( <span class="bold"><strong>expression</strong></span> 
<span class="hl-combinator">|</span> <span class="bold"><strong>expression</strong></span>
) <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> 
<span class="bold"><strong>another expression</strong></span>
</pre><p>
</p></div><div class="section" title="2.1.2.&nbsp;Sequential combinator"><div class="titlepage"><div><div><h3 class="title"><a name="N1085C"></a>2.1.2.&nbsp;Sequential combinator</h3></div></div></div><p>
When the expressions to be combined are small, write a cascade of sequential combinators
all on the same line.
</p><pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="bold"><strong>G</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> <span class="bold"><strong>H</strong></span>
</pre><p>
When the expressions to be combined are individually long enough to take up a full line, write one expression
per line; each line ends with the combinator which binds the publications
produced by that line.

</p><pre class="programlisting">
<span class="bold"><strong>long expression</strong></span>  <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>  
<span class="bold"><strong>long expression</strong></span>  <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> 
<span class="bold"><strong>long expression</strong></span>
</pre><p>
 
</p><p>
For very long expressions, or expressions that span multiple lines, write
the combinators on separate lines, indented, between each expression. 

</p><pre class="programlisting">
<span class="bold"><strong>very long expression</strong></span> 
  <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>  
<span class="bold"><strong>very long expression</strong></span> 
  <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> 
<span class="bold"><strong>very long expression</strong></span>
</pre><p>
 
</p></div><div class="section" title="2.1.3.&nbsp;Pruning combinator"><div class="titlepage"><div><div><h3 class="title"><a name="style.pruning"></a>2.1.3.&nbsp;Pruning combinator</h3></div></div></div><p>
When the expressions to be combined are small, write them on the same line:

</p><pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="bold"><strong>G</strong></span>
</pre><p>

When multiple pruning combinators are used to bind multiple variables
(especially when the scoped expression is long), start each line with a 
combinator, aligned and indented, and continue with the expression.

</p><pre class="programlisting">
<span class="bold"><strong>long expression</strong></span> 
  <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="bold"><strong>G</strong></span>
  <span class="hl-combinator">&lt;</span><span class="hl-variable">y</span><span class="hl-combinator">&lt;</span> <span class="bold"><strong>H</strong></span>
</pre><p>

</p><p>
The pruning combinator is not often written in its explicit form
in Orc programs. Instead, the <code class="code"><span class="hl-keyword">val</span></code> declaration is often more
convenient, since it is semantically equivalent and mentions the variable
<code class="code"><span class="hl-variable">x</span></code> before its use in scope, rather than after.

</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="bold"><strong>G</strong></span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="bold"><strong>H</strong></span>
<span class="bold"><strong>long expression</strong></span> 
</pre><p>

</p><p>
Additionally, when the variable is used in only one place, and the
expression is small, it is often easier to use a nested expression.
For example,

</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="bold"><strong>G</strong></span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="bold"><strong>H</strong></span>
<span class="hl-site">M</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)
</pre><p>

is equivalent to

</p><pre class="programlisting">
<span class="hl-site">M</span>(<span class="bold"><strong>G</strong></span>,<span class="bold"><strong>H</strong></span>)
</pre><p>

</p><p>
Sometimes, we use the pruning combinator simply for its capability to terminate
expressions and get a single publication; binding a variable is irrelevant. This
is a special case of nested expressions. We use the identity site <code class="code"><span class="hl-variable">Let</span></code>
to put the expression in the context of a function call.
</p><p>
For example,

</p><pre class="programlisting">
<span class="hl-variable">x</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>G</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>H</strong></span>
</pre><p>

is equivalent to

</p><pre class="programlisting">
<span class="hl-site">Let</span>(<span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>G</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>H</strong></span>)
</pre><p>
</p><p>
The translation uses a pruning combinator, but we don't need to write the combinator, 
name an irrelevant variable, or worry about precedence (since the expression is enclosed
in parentheses as part of the call).
</p></div><div class="section" title="2.1.4.&nbsp;Declarations"><div class="titlepage"><div><div><h3 class="title"><a name="N10907"></a>2.1.4.&nbsp;Declarations</h3></div></div></div><p>
When the body of a declaration spans multiple lines, start the body on a new line
after the <code class="code"><span class="hl-operator">=</span></code> symbol, and indent the entire body.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">f</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) <span class="hl-operator">=</span>
    <span class="bold"><strong>declaration</strong></span>
    <span class="bold"><strong>declaration</strong></span>
    <span class="bold"><strong>body expression</strong></span>
</pre><p>

</p><p>
Apply this style recursively; if a def appears within a def, indent its contents even further.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">f</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>) <span class="hl-operator">=</span>
    <span class="bold"><strong>declaration</strong></span>
    <span class="hl-keyword">def</span> <span class="hl-site">helper</span>(<span class="hl-variable">z</span>) <span class="hl-operator">=</span>
    	<span class="bold"><strong>declaration in helper</strong></span>
    	<span class="bold"><strong>declaration in helper</strong></span>
    	<span class="bold"><strong>body of helper</strong></span>
    <span class="bold"><strong>declaration</strong></span>
    <span class="bold"><strong>body expression</strong></span>
</pre><p>


</p><div class="section" title="2.1.4.1.&nbsp;Ambiguous Declarations"><div class="titlepage"><div><div><h4 class="title"><a name="N1093B"></a>2.1.4.1.&nbsp;Ambiguous Declarations</h4></div></div></div><p> The following situation could introduce syntactic ambiguity: the end
of a declaration (def or val) is followed by an expression that starts with a
non-alphanumeric symbol. Consider these example programs:
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">f</span>() <span class="hl-operator">=</span>       
  <span class="hl-keyword">def</span> <span class="hl-site">g</span>() <span class="hl-operator">=</span> <span class="hl-site">h</span>
  (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)
</pre><p>
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">f</span>() <span class="hl-operator">=</span>      
  <span class="hl-keyword">val</span> <span class="hl-variable">t</span> <span class="hl-operator">=</span> <span class="hl-site">h</span>
  (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)
</pre><p>
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">f</span>() <span class="hl-operator">=</span>       
  <span class="hl-keyword">val</span> <span class="hl-variable">t</span> <span class="hl-operator">=</span> <span class="hl-variable">u</span>
  <span class="hl-operator">-</span><span class="hl-literal">3</span>
</pre><p>
</p><p>  <code class="code">(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)</code> may be interpreted as the parameter list of <code class="code"><span class="hl-variable">h</span></code>, and <code class="code"><span class="hl-operator">-</span><span class="hl-literal">3</span></code> as
continuation of <code class="code"><span class="hl-variable">u</span></code>, or they may be regarded as completely
separate expressions (in this case, the goal expression of <code class="code"><span class="hl-keyword">def</span> <span class="hl-variable">f</span></code>). To avoid this ambiguity, 
Orc imposes the following syntactic constraint:
</p><p><span class="emphasis"><em>An expression that follows a declaration begins with an alphanumeric symbol</em></span></p><p>To circumvent this restriction, if (x,y) is an expression that follows a declaration, 
write it as <code class="code"><span class="hl-keyword">signal</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)</code>. Similarly, write <code class="code"><span class="hl-keyword">signal</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-operator">-</span><span class="hl-literal">3</span></code>, in case <code class="code"><span class="hl-operator">-</span><span class="hl-literal">3</span></code> is
the goal expression in the above example.  Note that there are many solutions to this problem; for example
using <code class="code"><span class="hl-keyword">stop</span> <span class="hl-combinator">|</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)</code> is also valid.</p></div></div></div><div class="section" title="2.2.&nbsp;Programming Idioms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.methodology.idiom"></a>2.2.&nbsp;Programming Idioms</h2></div></div></div><p>
In this section we give Orc implementations of some standard idioms from
concurrent and functional programming. 

Despite the austerity of Orc's four combinators, we are able to encode a variety of idioms straightforwardly.
</p><div class="section" title="2.2.1.&nbsp;Channels"><div class="titlepage"><div><div><h3 class="title"><a name="methodology.channels"></a>2.2.1.&nbsp;Channels</h3></div></div></div><p>
Orc has no communication primitives like pi-calculus
channels<sup>[<a href="#ftn.N10984" name="N10984" class="footnote">1</a>]</sup> or Erlang mailboxes<sup>[<a href="#ftn.N1098B" name="N1098B" class="footnote">2</a>]</sup>. Instead, it makes use of sites
to create channels of communication. 
</p><p>
The most frequently used of these sites is <code class="code"><span class="hl-variable">Channel</span></code>. When called, it
publishes a new asynchronous FIFO channel. That channel is a site with two
methods: <code class="code"><span class="hl-variable">get</span></code> and <code class="code"><span class="hl-variable">put</span></code>.  The call <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">get</span>()</code>
takes the first value from channel <code class="code"><span class="hl-variable">c</span></code> and publishes it, or blocks
waiting for a value if none is available. The call <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">v</span>)</code> puts
<code class="code"><span class="hl-variable">v</span></code> as the last item of <code class="code"><span class="hl-variable">c</span></code> and publishes a signal.
</p><p>
A channel may be closed to indicate that it will not be sent any more values.
If the channel <code class="code"><span class="hl-variable">c</span></code> is closed, <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">v</span>)</code> always halts
(without modifying the state of the channel), and <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">get</span>()</code> halts
once <code class="code"><span class="hl-variable">c</span></code> becomes empty. The channel <code class="code"><span class="hl-variable">c</span></code> may be closed by
calling either <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">close</span>()</code>, which returns a signal once
<code class="code"><span class="hl-variable">c</span></code> becomes empty, or <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()</code>, which returns a
signal immediately.
</p></div><div class="section" title="2.2.2.&nbsp;Lists"><div class="titlepage"><div><div><h3 class="title"><a name="N109C6"></a>2.2.2.&nbsp;Lists</h3></div></div></div><p>
In the section on Cor, we were introduced to lists: how to construct them,
and how to match them against patterns. While it is certainly feasible to
write a specific function with an appropriate pattern match every time we
want to access a list, it is helpful to have a handful of common operations
on lists and reuse them.
</p><p>
One of the most common uses for a list is to send each of its elements through
a sequential combinator. Since the list itself is a single value, we want
to walk through the list and publish each one of its elements in parallel
as a value. The library function <code class="code"><span class="hl-variable">each</span></code> does exactly that.
</p><p>
Suppose we want to send the message <code class="code"><span class="hl-variable">invite</span></code> to each email
address in the list <code class="code"><span class="hl-variable">inviteList</span></code>:

</p><pre class="programlisting">
<span class="hl-site">each</span>(<span class="hl-variable">inviteList</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">address</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Email</span>(<span class="hl-variable">address</span>, <span class="hl-variable">invite</span>)
</pre><p>

</p><p>
Orc also adopts many of the list idioms of functional programming. The Orc library contains definitions
for most of the standard list functions, such as <code class="code"><span class="hl-variable">map</span></code> and <code class="code"><span class="hl-variable">fold</span></code>. Many of the
list functions internally take advantage of concurrency to make use of any available parallelism; for
example, the <code class="code"><span class="hl-variable">map</span></code> function dispatches all of the mapped calls concurrently, and assembles
the result list once they all return using a fork-join.
</p></div><div class="section" title="2.2.3.&nbsp;Streams"><div class="titlepage"><div><div><h3 class="title"><a name="methodology.streams"></a>2.2.3.&nbsp;Streams</h3></div></div></div><p>
Sometimes a source of data is not explicitly represented by a list or other data structure. Instead,
it is made available through a site, which returns the values one at a time, each time it is called.
We call such a site a <em class="firstterm">stream</em>. It is analogous to an iterator in a language 
like Java. Functions can also be used as streams, though typically they will not be pure functions,
and should only return one value. A call to a stream may halt, to indicate that the end of the data
has been reached, and no more values will become available. It is often useful to detect the
end of a stream using the otherwise combinator. 
</p><p>
Streams are common enough in Orc programming that there is a library function to take all of the
available publications from a stream; it is called <code class="code"><span class="hl-variable">repeat</span></code>, and it is analogous to
<code class="code"><span class="hl-variable">each</span></code> for lists.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">repeat</span>(<span class="hl-variable">f</span>) <span class="hl-operator">=</span> <span class="hl-site">f</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">x</span> <span class="hl-combinator">|</span> <span class="hl-site">repeat</span>(<span class="hl-variable">f</span>))
</pre><p>
The <code class="code"><span class="hl-variable">repeat</span></code> function calls the site or function <code class="code"><span class="hl-variable">f</span></code> with no arguments,
publishes its return value, and recurses to query for more values. <code class="code"><span class="hl-variable">repeat</span></code> should
be used with sites or functions that block until a value is available. Notice that if any
call to <code class="code"><span class="hl-variable">f</span></code> halts, then <code class="code"><span class="hl-site">repeat</span>(<span class="hl-variable">f</span>)</code> consequently halts. 
</p><p>
For example, it is very easy to treat a channel <code class="code"><span class="hl-variable">c</span></code> as a stream, reading any 
values put on the channel as they become available:

</p><pre class="programlisting">
<span class="hl-site">repeat</span>(<span class="hl-variable">c</span>.<span class="hl-variable">get</span>)
</pre><p>

</p></div><div class="section" title="2.2.4.&nbsp;Mutable References"><div class="titlepage"><div><div><h3 class="title"><a name="methodology.mutable"></a>2.2.4.&nbsp;Mutable References</h3></div></div></div><p>
Variables in Orc are immutable. There is no assignment operator, and there is no way to
change the value of a bound variable. However, it is often useful to have mutable state
when writing certain algorithms. The Orc library contains two sites that offer simple 
mutable storage: <code class="code"><span class="hl-variable">Ref</span></code> and <code class="code"><span class="hl-variable">Cell</span></code>. It also provides the site <code class="code"><span class="hl-variable">Array</span></code>
to create mutable arrays.
</p><p>
A word of caution: References, cells, and other mutable objects may be accessed concurrently
by many different parts of an Orc program, so race conditions may arise. 
</p><div class="section" title="2.2.4.1.&nbsp;Rewritable references"><div class="titlepage"><div><div><h4 class="title"><a name="N10A24"></a>2.2.4.1.&nbsp;Rewritable references</h4></div></div></div><p>
The <code class="code"><span class="hl-variable">Ref</span></code> site creates rewritable reference cells.

</p><pre class="orc">
<span class="hl-keyword">val</span> <span class="hl-variable">r</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>(<span class="hl-literal">0</span>)
<span class="hl-site">println</span>(<span class="hl-variable">r</span>.<span class="hl-site">read</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
<span class="hl-variable">r</span>.<span class="hl-site">write</span>(<span class="hl-literal">2</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
<span class="hl-site">println</span>(<span class="hl-variable">r</span>.<span class="hl-site">read</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
<span class="hl-keyword">stop</span>
</pre><p>

</p><p>
These are very similar to ML's <code class="code"><span class="hl-variable">ref</span></code> cells. <code class="code"><span class="hl-variable">r</span>.<span class="hl-site">write</span>(<span class="hl-variable">v</span>)</code> stores
the value <code class="code"><span class="hl-variable">v</span></code> in the reference <code class="code"><span class="hl-variable">r</span></code>, overwriting any previous
value, and publishes a signal. <code class="code"><span class="hl-variable">r</span>.<span class="hl-site">read</span>()</code> publishes the current value stored
in <code class="code"><span class="hl-variable">r</span></code>.
</p><p>
However, unlike in ML, a reference cell can be left initially empty by calling <code class="code"><span class="hl-variable">Ref</span></code>
with no arguments. A read operation on an empty cell blocks until the cell is written.

</p><pre class="orc">
<span class="hl-comment">{- Create a cell, and wait 1 second before initializing it.
   The read operation blocks until the write occurs. 
-}</span>

<span class="hl-keyword">val</span> <span class="hl-variable">r</span> <span class="hl-operator">=</span> <span class="hl-site">Ref</span>()
<span class="hl-variable">r</span>.<span class="hl-site">read</span>() <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">r</span>.<span class="hl-site">write</span>(<span class="hl-literal">1</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-comment">{-
OUTPUT:
1
-}</span>
</pre><p>

</p></div><div class="section" title="2.2.4.2.&nbsp;Write-once references"><div class="titlepage"><div><div><h4 class="title"><a name="N10A4D"></a>2.2.4.2.&nbsp;Write-once references</h4></div></div></div><p>
The Orc library also offers write-once reference cells, using the <code class="code"><span class="hl-variable">Cell</span></code> site.
A write-once cell has no initial value. Read operations block until the cell has been
written. A write operation succeeds only if the cell is empty; subsequent write operations
simply halt.

</p><pre class="orc">
<span class="hl-comment">{- Create a cell, try to write to it twice, and read it.
   The read will block until a write occurs
   and only one write will succeed. 
-}</span>

<span class="hl-keyword">val</span> <span class="hl-variable">r</span> <span class="hl-operator">=</span> <span class="hl-site">Cell</span>()
  <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">r</span>.<span class="hl-site">write</span>(<span class="hl-literal">2</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"Wrote 2"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">r</span>.<span class="hl-site">write</span>(<span class="hl-literal">3</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"Wrote 3"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-combinator">|</span> <span class="hl-variable">r</span>.<span class="hl-site">read</span>()

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
2
Wrote 2
-}</span>
</pre><p>

Write-once cells are very useful for concurrent programming, and they are often safer
than rewritable reference cells, since the value cannot be changed once it has been
written. The use of write-once cells for concurrent programming is not a new idea;
they have been studied extensively in the context of the 
<a class="link" href="http://en.wikipedia.org/wiki/Oz_programming_language" target="_top">Oz programming language</a>.
</p></div><div class="section" title="2.2.4.3.&nbsp;Syntax for manipulating references"><div class="titlepage"><div><div><h4 class="title"><a name="N10A5D"></a>2.2.4.3.&nbsp;Syntax for manipulating references</h4></div></div></div><p>Orc provides syntactic sugar for reading and writing mutable storage:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code"><span class="hl-variable">x</span><span class="hl-operator">?</span></code> is equivalent to <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">read</span>()</code>. This operator
is of equal precedence with the dot operator and function application, so
you can write things like <code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">y</span><span class="hl-operator">?</span>.<span class="hl-variable">v</span><span class="hl-operator">?</span></code>. This operator is very similar
to the C languages's <code class="code"><span class="hl-operator">*</span></code> operator, but is postfix instead of prefix.
	</li><li class="listitem"><code class="code"><span class="hl-variable">x</span> <span class="hl-operator">:=</span> <span class="hl-variable">y</span></code> is equivalent to <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">write</span>(<span class="hl-variable">y</span>)</code>.
This operator has higher precedence than the concurrency combinators and if/then/else,
but lower precedence than any of the other operators.</li></ul></div><p>Here is a previous example rewritten using this syntactic sugar:</p><pre class="orc">
<span class="hl-comment">{- Create a cell, try to write to it twice, and read it.
   The read will block until a write occurs
   and only one write will succeed.
-}</span>

<span class="hl-keyword">val</span> <span class="hl-variable">r</span> <span class="hl-operator">=</span> <span class="hl-site">Cell</span>()
  <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">r</span> <span class="hl-operator">:=</span> <span class="hl-literal">2</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"Wrote 2"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">r</span> <span class="hl-operator">:=</span> <span class="hl-literal">3</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-literal">"Wrote 3"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-combinator">|</span> <span class="hl-variable">r</span><span class="hl-operator">?</span>

<span class="hl-comment">{-
OUTPUT:PERMUTABLE
2
Wrote 2
-}</span>
</pre></div><div class="section" title="2.2.4.4.&nbsp;Arrays"><div class="titlepage"><div><div><h4 class="title"><a name="N10A7C"></a>2.2.4.4.&nbsp;Arrays</h4></div></div></div><p>
While lists are a very useful data structure, they are not mutable, and they are not indexed. However, 
these properties are often needed in practice, so the Orc standard library provides a function 
<code class="code"><span class="hl-variable">Array</span></code> to create mutable arrays. 
</p><p>
<code class="code"><span class="hl-site">Array</span>(<span class="hl-variable">n</span>)</code> creates an array of size <code class="code"><span class="hl-variable">n</span></code> whose elements are all initially <code class="code"><span class="hl-literal">null</span></code>. 
The array is used like a function; the call <code class="code"><span class="hl-site">A</span>(<span class="hl-variable">i</span>)</code> returns the <code class="code"><span class="hl-variable">i</span></code>th element of the array 
<code class="code"><span class="hl-variable">A</span></code>, which is then treated as a reference, just like the references created by <code class="code"><span class="hl-variable">Ref</span></code>. A call 
with an out-of-bounds index halts, possibly reporting an error. 
</p><p>

The following program creates an array of size 10, and initializes each index i with the
ith power of 2. It then reads the array values at indices 3, 6, and 10. The read at index 10
halts because it is out of bounds (arrays are indexed from 0).

</p><pre class="orc">
<span class="hl-comment">{- Create and initialize an array, then halt on out of bounds read -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">a</span> <span class="hl-operator">=</span> <span class="hl-site">Array</span>(<span class="hl-literal">10</span>)
<span class="hl-keyword">def</span> <span class="hl-site">initialize</span>(<span class="hl-variable">i</span>) <span class="hl-operator">=</span> 
  <span class="hl-keyword">if</span> (<span class="hl-variable">i</span> <span class="hl-operator">&lt;:</span> <span class="hl-literal">10</span>) 
    <span class="hl-keyword">then</span> <span class="hl-site">a</span>(<span class="hl-variable">i</span>) <span class="hl-operator">:=</span> <span class="hl-literal">2</span> <span class="hl-operator">**</span> <span class="hl-variable">i</span>  <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>  <span class="hl-site">initialize</span>(<span class="hl-variable">i</span><span class="hl-operator">+</span><span class="hl-literal">1</span>)
    <span class="hl-keyword">else</span> <span class="hl-keyword">signal</span>
<span class="hl-site">initialize</span>(<span class="hl-literal">0</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> (<span class="hl-site">a</span>(<span class="hl-literal">3</span>)<span class="hl-operator">?</span> <span class="hl-combinator">|</span> <span class="hl-site">a</span>(<span class="hl-literal">6</span>)<span class="hl-operator">?</span> <span class="hl-combinator">|</span> <span class="hl-site">a</span>(<span class="hl-literal">10</span>)<span class="hl-operator">?</span>)

</pre><p>

</p><p>

The standard library also provides a helper function <code class="code"><span class="hl-variable">fillArray</span></code> which makes array initialization
easier. <code class="code"><span class="hl-site">fillArray</span>(<span class="hl-variable">a</span>, <span class="hl-variable">f</span>)</code> initializes array <code class="code"><span class="hl-variable">a</span></code> using function <code class="code"><span class="hl-variable">f</span></code> by setting
element <code class="code"><span class="hl-site">a</span>(<span class="hl-variable">i</span>)</code> to the first value published by <code class="code"><span class="hl-site">f</span>(<span class="hl-variable">i</span>)</code>. When the array is fully
initialized, <code class="code"><span class="hl-variable">fillArray</span></code> returns the array <code class="code"><span class="hl-variable">a</span></code> that was passed (which makes it easier to
simultaneously create and initialize an array). Here are a few examples:

</p><pre class="orc">
<span class="hl-comment">{- Create an array of 10 elements; element i is the ith power of 2 -}</span>
<span class="hl-site">fillArray</span>(<span class="hl-site">Array</span>(<span class="hl-literal">10</span>), <span class="hl-keyword">lambda</span>(<span class="hl-variable">i</span>) <span class="hl-operator">=</span> <span class="hl-literal">2</span> <span class="hl-operator">**</span> <span class="hl-variable">i</span>)
</pre><p>

</p><pre class="orc">
<span class="hl-comment">{- Create an array of 5 elements; each element is a newly created channel -}</span>
<span class="hl-site">fillArray</span>(<span class="hl-site">Array</span>(<span class="hl-literal">5</span>), <span class="hl-keyword">lambda</span>(<span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-site">Channel</span>())
</pre><p>

</p><pre class="orc">
<span class="hl-comment">{- Create an array of 2 channels -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">A</span> <span class="hl-operator">=</span> <span class="hl-site">fillArray</span>(<span class="hl-site">Array</span>(<span class="hl-literal">2</span>), <span class="hl-keyword">lambda</span>(<span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-site">Channel</span>())

<span class="hl-comment">{- Send true on channel 0,
   listen for a value on channel 0 and forward it to channel 1, 
   and listen for a value on channel 1 and publish it. 
-}</span>

  <span class="hl-site">A</span>(<span class="hl-literal">0</span>)<span class="hl-operator">?</span>.<span class="hl-site">put</span>(<span class="hl-literal">true</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-combinator">|</span> <span class="hl-site">A</span>(<span class="hl-literal">0</span>)<span class="hl-operator">?</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-site">A</span>(<span class="hl-literal">1</span>)<span class="hl-operator">?</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-combinator">|</span> <span class="hl-site">A</span>(<span class="hl-literal">1</span>)<span class="hl-operator">?</span>.<span class="hl-site">get</span>()
</pre><p>
</p><p>
Since arrays are accessed by index, there is a library function specifically
designed to make programming with indices easier. The function <code class="code"><span class="hl-site">upto</span>(<span class="hl-variable">n</span>)</code> 
publishes all of the numbers from <code class="code"><span class="hl-literal">0</span></code> to
<code class="code"><span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span></code> simultaneously; thus, it is very easy to access all of the elements of
an array simultaneously. Suppose we have an array <code class="code"><span class="hl-variable">A</span></code> of <code class="code"><span class="hl-variable">n</span></code> email 
addresses and would like to send the message <code class="code"><span class="hl-variable">m</span></code> to each one.

</p><pre class="programlisting">
<span class="hl-site">upto</span>(<span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">i</span><span class="hl-combinator">&gt;</span> <span class="hl-site">A</span>(<span class="hl-variable">i</span>)<span class="hl-operator">?</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">address</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Email</span>(<span class="hl-variable">address</span>, <span class="hl-variable">m</span>)
</pre><p>

</p></div></div><div class="section" title="2.2.5.&nbsp;Tables"><div class="titlepage"><div><div><h3 class="title"><a name="N10ADE"></a>2.2.5.&nbsp;Tables</h3></div></div></div><p>
Orc programs occasionally require a data structure that supports constant-time indexing but need not also
provide mutable storage. For this purpose, an <code class="code"><span class="hl-variable">Array</span></code> is too powerful. The standard library provides
another structure called a <code class="code"><span class="hl-variable">Table</span></code> to fill this role.
</p><p>
The call <code class="code"><span class="hl-site">Table</span>(<span class="hl-variable">n</span>,<span class="hl-variable">f</span>)</code>, where <code class="code"><span class="hl-variable">n</span></code> is a
natural number and <code class="code"><span class="hl-variable">f</span></code> a total function over natural numbers,
creates and returns an immutable array of size <code class="code"><span class="hl-variable">n</span></code> (indexed from 0), 
whose <code class="code"><span class="hl-variable">i</span></code>th element is initialized to <code class="code"><span class="hl-site">f</span>(<span class="hl-variable">i</span>)</code>.
A table can also be thought of as a partially memoized version of <code class="code"><span class="hl-variable">f</span></code>
restricted to the range [0, <code class="code"><span class="hl-variable">n</span></code>). 
<code class="code"><span class="hl-variable">Table</span></code> does not return a value until all calls to <code class="code"><span class="hl-variable">f</span></code> have completed,
and will halt if any call halts. Given a table <code class="code"><span class="hl-variable">T</span></code>, the call <code class="code"><span class="hl-site">T</span>(<span class="hl-variable">i</span>)</code>
returns the <code class="code"><span class="hl-variable">i</span></code>th element of <code class="code"><span class="hl-variable">T</span></code>. Notice that unlike
array access, the <code class="code"><span class="hl-operator">?</span></code> is not needed to subsequently dereference the return value,
since it is not a mutable reference. 
</p><p>
Tables are useful when writing algorithms which used a fixed mapping of indexes to some resources,
such as a shared table of communication channels. Such a table could be constructed using the
following code:  
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">size</span> <span class="hl-operator">=</span> <span class="hl-literal">10</span>
<span class="hl-keyword">val</span> <span class="hl-variable">channels</span> <span class="hl-operator">=</span> <span class="hl-site">Table</span>(<span class="hl-variable">size</span>, <span class="hl-keyword">lambda</span> (<span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-site">Channel</span>())
</pre><p>
</p><p>
Notice that the <code class="code"><span class="hl-keyword">lambda</span></code> ignores its argument, since each channel is
identical. Here is another example, which memoizes the cubes of the first 30 natural numbers:
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">cubes</span> <span class="hl-operator">=</span> <span class="hl-site">Table</span>(<span class="hl-literal">30</span>, <span class="hl-keyword">lambda</span>(<span class="hl-variable">i</span>) <span class="hl-operator">=</span> <span class="hl-variable">i</span><span class="hl-operator">*</span><span class="hl-variable">i</span><span class="hl-operator">*</span><span class="hl-variable">i</span>)
</pre><p>
</p></div><div class="section" title="2.2.6.&nbsp;Loops"><div class="titlepage"><div><div><h3 class="title"><a name="N10B29"></a>2.2.6.&nbsp;Loops</h3></div></div></div><p>
Orc does not have any explicit looping constructs. Most of the time, where a loop
might be used in other languages, Orc programs use one of two strategies: 
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">When the iterations of the loops can occur in parallel, write an expression
that expands the data into a sequence of publications, and
use a sequential operator to do something for each publication. This is the strategy
that uses functions like <code class="code"><span class="hl-variable">each</span></code>, <code class="code"><span class="hl-variable">repeat</span></code>, and <code class="code"><span class="hl-variable">upto</span></code>.
</li><li class="listitem">When the iterations of the loops must occur in sequence, write a tail
recursive function that iterates over the data. Any loop can be rewritten as a 
tail recursion. Typically the data of interest is in a list, so one of the standard
list functions, such as <code class="code"><span class="hl-variable">foldl</span></code>, applies. The library also defines a
function <code class="code"><span class="hl-variable">while</span></code>, which handles many of the common use cases of
while loops.
</li></ol></div></div><div class="section" title="2.2.7.&nbsp;Parallel Matching"><div class="titlepage"><div><div><h3 class="title"><a name="N10B42"></a>2.2.7.&nbsp;Parallel Matching</h3></div></div></div><p>
Matching a value against multiple patterns, as we have seen it so far, is a linear
process, and requires a <code class="code"><span class="hl-keyword">def</span></code> whose clauses have patterns in their
argument lists. Such a match is linear; each pattern is tried in order until
one succeeds.
</p><p>
What if we want to match a value against multiple patterns in parallel, executing
every clause that succeeds? Fortunately, this is very easy to do in Orc. Suppose
we have an expression F which publishes pairs of integers, and we want to publish
a signal for each 3 that occurs. 
</p><p>
We could write:

</p><pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>, <span class="hl-variable">y</span>)<span class="hl-combinator">&gt;</span>
  ( <span class="hl-site">Ift</span>(<span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="hl-literal">3</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>
  <span class="hl-combinator">|</span> <span class="hl-site">Ift</span>(<span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="hl-literal">3</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span> ) 

</pre><p>

But there is a more general alternative:

</p><pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>
  ( <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>(<span class="hl-literal">3</span>, <span class="hl-variable">_</span>)<span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>
  <span class="hl-combinator">|</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>(<span class="hl-variable">_</span>, <span class="hl-literal">3</span>)<span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span> ) 

</pre><p>

The interesting case is the pair <code class="code">(<span class="hl-literal">3</span>,<span class="hl-literal">3</span>)</code>, which is counted twice
because both patterns match it in parallel.
</p><p>
This parallel matching technique is sometimes used as an alternative to pattern matching using function
clauses, but only when the patterns are mutually exclusive.
</p><p>

For example,

</p><pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">helper</span>([]) <span class="hl-operator">=</span> <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-site">helper</span>([<span class="hl-variable">_</span>]) <span class="hl-operator">=</span> <span class="hl-literal">1</span>
<span class="hl-keyword">def</span> <span class="hl-site">helper</span>(<span class="hl-variable">_</span><span class="hl-operator">:</span><span class="hl-variable">_</span><span class="hl-operator">:</span><span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-literal">2</span>
<span class="hl-site">helper</span>([<span class="hl-literal">4</span>, <span class="hl-literal">6</span>])
</pre><p>

is equivalent to

</p><pre class="orc">
[<span class="hl-literal">4</span>, <span class="hl-literal">6</span>] <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>
  <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>[]<span class="hl-combinator">&gt;</span> <span class="hl-literal">0</span>
<span class="hl-combinator">|</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>[<span class="hl-variable">_</span>]<span class="hl-combinator">&gt;</span> <span class="hl-literal">1</span>
<span class="hl-combinator">|</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">_</span><span class="hl-operator">:</span><span class="hl-variable">_</span><span class="hl-operator">:</span><span class="hl-variable">_</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">2</span>
</pre><p>

whereas

</p><pre class="orc">
<span class="hl-keyword">def</span> <span class="hl-site">helper</span>([]) <span class="hl-operator">=</span> <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-site">helper</span>([<span class="hl-variable">_</span>]) <span class="hl-operator">=</span> <span class="hl-literal">1</span>
<span class="hl-keyword">def</span> <span class="hl-site">helper</span>(<span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-literal">2</span>
<span class="hl-site">helper</span>([<span class="hl-literal">5</span>])
</pre><p>

is <span class="emphasis"><em>not</em></span> equivalent to

</p><pre class="orc">
[<span class="hl-literal">5</span>] <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>
  <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>[]<span class="hl-combinator">&gt;</span> <span class="hl-literal">0</span>
<span class="hl-combinator">|</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span>[<span class="hl-variable">_</span>]<span class="hl-combinator">&gt;</span> <span class="hl-literal">1</span>
<span class="hl-combinator">|</span> <span class="hl-variable">x</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">_</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">2</span>
</pre><p>

because the clauses are not mutually exclusive. Function clauses must attempt to match in linear order, whereas
this expression matches all of the patterns in parallel. Here, it will match <code class="code">[<span class="hl-literal">5</span>]</code> two different ways,
publishing both <code class="code"><span class="hl-literal">1</span></code> and <code class="code"><span class="hl-literal">2</span></code>.
</p></div><div class="section" title="2.2.8.&nbsp;Fork-join"><div class="titlepage"><div><div><h3 class="title"><a name="methodology.forkjoin"></a>2.2.8.&nbsp;Fork-join</h3></div></div></div><p>
One of the most common concurrent idioms is a <em class="firstterm">fork-join</em>: run two processes concurrently,
and wait for a result from each one. This is very easy to express in Orc. Whenever we write a <code class="code"><span class="hl-keyword">val</span></code>
declaration, the process computing that value runs in parallel with the rest of the program. So if we write
two <code class="code"><span class="hl-keyword">val</span></code> declarations, and then form a tuple of their results, this performs a fork-join.
</p><p>
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="bold"><strong>F</strong></span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="bold"><strong>G</strong></span>
   <span class="hl-keyword">signal</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)
</pre><p>
</p><p>
Fork-joins are a fundamental part of all Orc programs, since they are created by all nested expression
translations. In fact, the fork-join we wrote above could be expressed even more simply as just:
</p><p>
</p><pre class="programlisting">
(<span class="bold"><strong>F</strong></span>,<span class="bold"><strong>G</strong></span>)
</pre><p>
</p><div class="section" title="2.2.8.1.&nbsp;Example: Machine initialization"><div class="titlepage"><div><div><h4 class="title"><a name="N10BAA"></a>2.2.8.1.&nbsp;Example: Machine initialization</h4></div></div></div><p>
In Orc programs, we often use fork-join and recursion together to dispatch many tasks in parallel and wait
for all of them to complete. Suppose that given a machine <code class="code"><span class="hl-variable">m</span></code>, calling <code class="code"><span class="hl-variable">m</span>.<span class="hl-site">init</span>()</code> 
initializes <code class="code"><span class="hl-variable">m</span></code> and then publishes a signal when initialization is complete. The function 
<code class="code"><span class="hl-variable">initAll</span></code> initializes a list of machines.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">initAll</span>([]) <span class="hl-operator">=</span> <span class="hl-keyword">signal</span>
<span class="hl-keyword">def</span> <span class="hl-site">initAll</span>(<span class="hl-variable">m</span><span class="hl-operator">:</span><span class="hl-variable">ms</span>) <span class="hl-operator">=</span> ( <span class="hl-variable">m</span>.<span class="hl-site">init</span>() , <span class="hl-site">initAll</span>(<span class="hl-variable">ms</span>) ) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>
</pre><p>
For each machine, we fork-join the initialization of that machine (<code class="code"><span class="hl-variable">m</span>.<span class="hl-site">init</span>()</code>) with the initialization
of the remaining machines (<code class="code"><span class="hl-site">initAll</span>(<span class="hl-variable">ms</span>)</code>). Thus, all of the initializations proceed in parallel, and
the function returns a signal only when every machine in the list has completed its initialization. 
</p><p>
Note that if some machine fails to initialize, and does not return a signal, then the initialization procedure
will never complete. 
</p></div><div class="section" title="2.2.8.2.&nbsp;Example: Simple parallel auction"><div class="titlepage"><div><div><h4 class="title"><a name="example.auction"></a>2.2.8.2.&nbsp;Example: Simple parallel auction</h4></div></div></div><p>
We can also use a recursive fork-join to obtain a value, rather than just signaling completion. Suppose we
have a list of bidders in a sealed-bid, single-round auction. Calling <code class="code"><span class="hl-variable">b</span>.<span class="hl-site">ask</span>()</code> requests a bid
from the bidder <code class="code"><span class="hl-variable">b</span></code>. We want to ask for one bid from each bidder, and then return the highest
bid. The function <code class="code"><span class="hl-variable">auction</span></code> performs such an auction for a list of bidders (<code class="code"><span class="hl-variable">max</span></code> 
finds the maximum of its arguments):
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">auction</span>([]) <span class="hl-operator">=</span> <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-site">auction</span>(<span class="hl-variable">b</span><span class="hl-operator">:</span><span class="hl-variable">bs</span>) <span class="hl-operator">=</span> <span class="hl-site">max</span>(<span class="hl-variable">b</span>.<span class="hl-site">ask</span>(), <span class="hl-site">auction</span>(<span class="hl-variable">bs</span>))
</pre></div><p>
Note that all bidders are called simultaneously. Also note that if some bidder fails 
to return a bid, then the auction will never complete.  Later we will see
a <a class="link" href="#example.auction-with-timeout" title="2.2.12.1.&nbsp;Auction with timeout">different solution</a> that addresses the issue of non-termination.
</p><div class="section" title="2.2.8.3.&nbsp;Example: Barrier synchronization"><div class="titlepage"><div><div><h4 class="title"><a name="N10BE1"></a>2.2.8.3.&nbsp;Example: Barrier synchronization</h4></div></div></div><p>
Consider an expression of the following form, where F and G are expressions and M and N are sites:

</p><pre class="programlisting">
<span class="hl-site">M</span>()  <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span>  <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="hl-site">N</span>()  <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span>  <span class="bold"><strong>G</strong></span>
</pre><p>

</p><p>
Suppose we would like to <span class="emphasis"><em>synchronize</em></span> F and G, so that both start
executing at the same time, after both <code class="code"><span class="hl-site">M</span>()</code> and <code class="code"><span class="hl-site">N</span>()</code> respond.  This is easily done
using the fork-join idiom. In the following, we assume that <code class="code"><span class="hl-variable">x</span></code> does not occur
free in G, nor <code class="code"><span class="hl-variable">y</span></code> in F.

</p><pre class="programlisting">
( <span class="hl-site">M</span>() , <span class="hl-site">N</span>() )  <span class="hl-combinator">&gt;</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)<span class="hl-combinator">&gt;</span>  ( <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="bold"><strong>G</strong></span> )
</pre><p>

</p></div></div><div class="section" title="2.2.9.&nbsp;Sequential Fork-Join"><div class="titlepage"><div><div><h3 class="title"><a name="N10C0D"></a>2.2.9.&nbsp;Sequential Fork-Join</h3></div></div></div><p>
Previous sections illustrate how Orc can use the fork-join idiom to process a
fixed set of expressions or a list of values.  Suppose that instead we wish to
process all the publications of an expression F, and once this processing is
complete, execute some expression G.  For example, F publishes the contents
of a text file, one line at a time, and we wish to print each line to the
console using the site <code class="code"><span class="hl-variable">println</span></code>, then publish a signal after all lines
have been printed.
</p><p>
Sequential composition alone is not sufficient, because we have no way to
detect when all of the lines have been processed.  A recursive fork-join
solution would require that the lines be stored in a traversable data structure
like a list, rather than streamed as publications from F.  A better solution
uses the <code class="code"><span class="hl-combinator">;</span></code> combinator to detect when processing is complete:
</p><pre class="programlisting">
<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-site">println</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> <span class="hl-combinator">;</span> <span class="hl-keyword">signal</span>
</pre><p>
Since <code class="code"><span class="hl-combinator">;</span></code> only evaluates its right side if the left side does not publish,
we suppress the publications on the left side using <code class="code"><span class="hl-keyword">stop</span></code>. Here, we
assume that we can detect when F halts. If, for example,
F is publishing the lines of the file as it receives them over a socket,
and the sending party never closes the socket, then F never halts and no
signal is published.
</p></div><div class="section" title="2.2.10.&nbsp;Priority Poll"><div class="titlepage"><div><div><h3 class="title"><a name="N10C28"></a>2.2.10.&nbsp;Priority Poll</h3></div></div></div><p>
The otherwise combinator is also useful for trying alternatives in sequence. Consider an expression of
the form <code class="code"><span class="hl-variable">F</span><sub>0</sub> <span class="hl-combinator">;</span> <span class="hl-variable">F</span><sub>1</sub> <span class="hl-combinator">;</span> <span class="hl-variable">F</span><sub>2</sub> <span class="hl-combinator">;</span> ...</code>. If F<sub>i</sub> does not publish 
and halts, then F<sub>i+1</sub> is executed. We can think of the F<sub>i</sub>'s as a series of 
alternatives that are explored until a publication occurs.
</p><p>
Suppose that we would like to poll a list of channels for available data.  The
list of channels is ordered by priority. The first channel in the list has the
highest priority, so it is polled first.  If it has no data, then the
next channel is polled, and so on.
</p><p>
Here is a function which polls a prioritized list of channels in this way. It
publishes the first item that it finds, removing it from the originating
channel. If all channels are empty, the function halts.  We use the <code class="code"><span class="hl-variable">getnb</span></code> ("get non-blocking") method of the channel, which retrieves the first
available item if there is one, and halts otherwise.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">priorityPoll</span>([]) <span class="hl-operator">=</span> <span class="hl-keyword">stop</span>
<span class="hl-keyword">def</span> <span class="hl-site">priorityPoll</span>(<span class="hl-variable">b</span><span class="hl-operator">:</span><span class="hl-variable">bs</span>) <span class="hl-operator">=</span> <span class="hl-variable">b</span>.<span class="hl-site">getD</span>() <span class="hl-combinator">;</span> <span class="hl-site">priorityPoll</span>(<span class="hl-variable">bs</span>)
</pre></div><div class="section" title="2.2.11.&nbsp;Parallel Or"><div class="titlepage"><div><div><h3 class="title"><a name="N10C4B"></a>2.2.11.&nbsp;Parallel Or</h3></div></div></div><p>
``Parallel or'' is a classic idiom of parallel programming.  The ``parallel or'' operation executes two
expressions F and G in parallel, each of which may publish a single boolean,
and returns the disjunction of their publications as soon as possible. 
If one of the expressions publishes <code class="code"><span class="hl-literal">true</span></code>, then the disjunction is <code class="code"><span class="hl-literal">true</span></code>, 
so it is not necessary to wait for the other expression to publish a value. 
This holds even if one of the expressions is silent.
</p><p>
The ``parallel or'' of expressions F and G may be expressed in Orc as
follows:
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">result</span> <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">a</span> <span class="hl-operator">=</span> <span class="bold"><strong>F</strong></span>
  <span class="hl-keyword">val</span> <span class="hl-variable">b</span> <span class="hl-operator">=</span> <span class="bold"><strong>G</strong></span>
  <span class="hl-site">Ift</span>(<span class="hl-variable">a</span>)  <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>  <span class="hl-literal">true</span> <span class="hl-combinator">|</span> <span class="hl-site">Ift</span>(<span class="hl-variable">b</span>)  <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>  <span class="hl-literal">true</span> <span class="hl-combinator">|</span> (<span class="hl-variable">a</span> <span class="hl-operator">||</span> <span class="hl-variable">b</span>)

<span class="hl-variable">result</span>
</pre><p>
The expression <code class="code">(<span class="hl-variable">a</span> <span class="hl-operator">||</span> <span class="hl-variable">b</span>)</code> waits for both <code class="code"><span class="hl-variable">a</span></code> and <code class="code"><span class="hl-variable">b</span></code> to become
available and then publishes their disjunction.  However if either <code class="code"><span class="hl-variable">a</span></code> or
<code class="code"><span class="hl-variable">b</span></code> is true we can publish <code class="code"><span class="hl-literal">true</span></code> immediately regardless of whether the
other variable is available.  Therefore we run <code class="code"><span class="hl-site">Ift</span>(<span class="hl-variable">a</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">true</span></code> and <code class="code"><span class="hl-site">Ift</span>(<span class="hl-variable">b</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">true</span></code>
in parallel to wait for either variable to become <code class="code"><span class="hl-literal">true</span></code> and immediately
publish the result <code class="code"><span class="hl-literal">true</span></code>.  Since more than one of these expressions may
publish <code class="code"><span class="hl-literal">true</span></code>, the surrounding <code class="code"><span class="hl-keyword">val</span></code> is necessary to select and
publish only the first result.
</p></div><div class="section" title="2.2.12.&nbsp;Timeout"><div class="titlepage"><div><div><h3 class="title"><a name="N10C88"></a>2.2.12.&nbsp;Timeout</h3></div></div></div><p>
<em class="firstterm">Timeout</em>, the ability to execute an expression for at most a specified
amount of time, is an essential ingredient of fault-tolerant and distributed
programming.  Orc accomplishes timeout using pruning and the <code class="code"><span class="hl-variable">Rwait</span></code> site.
The following program runs F for at most one second, publishing its result if
available and the value <code class="code"><span class="hl-literal">0</span></code> otherwise.
</p><pre class="programlisting">
<span class="hl-site">Let</span>( <span class="bold"><strong>F</strong></span> <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">0</span> )
</pre><div class="section" title="2.2.12.1.&nbsp;Auction with timeout"><div class="titlepage"><div><div><h4 class="title"><a name="example.auction-with-timeout"></a>2.2.12.1.&nbsp;Auction with timeout</h4></div></div></div><p>
In the <a class="link" href="#example.auction" title="2.2.8.2.&nbsp;Example: Simple parallel auction">auction example</a> given previously, the auction may never complete if 
one of the bidders does not respond. We can add a timeout so that a bidder has at most 8 seconds to provide a bid:
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">auction</span>([]) <span class="hl-operator">=</span> <span class="hl-literal">0</span>
<span class="hl-keyword">def</span> <span class="hl-site">auction</span>(<span class="hl-variable">b</span><span class="hl-operator">:</span><span class="hl-variable">bs</span>) <span class="hl-operator">=</span> 
  <span class="hl-keyword">val</span> <span class="hl-variable">bid</span> <span class="hl-operator">=</span> <span class="hl-variable">b</span>.<span class="hl-site">ask</span>() <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">8000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">0</span>
  <span class="hl-site">max</span>(<span class="hl-variable">bid</span>, <span class="hl-site">auction</span>(<span class="hl-variable">bs</span>))
</pre><p>
This version of the auction is guaranteed to complete within 8 seconds.
</p></div><div class="section" title="2.2.12.2.&nbsp;Detecting timeout"><div class="titlepage"><div><div><h4 class="title"><a name="N10CAA"></a>2.2.12.2.&nbsp;Detecting timeout</h4></div></div></div><p>
Sometimes, rather than just yielding a default value, we would like to
determine whether an expression has timed out, and if so, perform some other
computation.  To detect the timeout, we pair the result of the original
expression with <code class="code"><span class="hl-literal">true</span></code> and the result of the timer with <code class="code"><span class="hl-literal">false</span></code>.
Thus, if the expression does time out, then we can distinguish that case
using the boolean value.
</p><p>
Here, we run expression F with a time limit <code class="code"><span class="hl-variable">t</span></code>. If it publishes
within the time limit, we bind its result to <code class="code"><span class="hl-variable">r</span></code> and execute G.
Otherwise, we execute H.

</p><pre class="programlisting">
<span class="hl-keyword">val</span> (<span class="hl-variable">r</span>, <span class="hl-variable">b</span>) <span class="hl-operator">=</span> (<span class="bold"><strong>F</strong></span>, <span class="hl-literal">true</span>) <span class="hl-combinator">|</span> (<span class="hl-site">Rwait</span>(<span class="hl-variable">t</span>), <span class="hl-literal">false</span>)
<span class="hl-keyword">if</span> <span class="hl-variable">b</span> <span class="hl-keyword">then</span> <span class="bold"><strong>G</strong></span> <span class="hl-keyword">else</span> <span class="bold"><strong>H</strong></span>
</pre><p>

Instead of using a boolean and conditional, we could use pattern matching:

</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">s</span> <span class="hl-operator">=</span> <span class="hl-site">Some</span>(<span class="bold"><strong>F</strong></span>) <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-variable">t</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">None</span>()
  <span class="hl-variable">s</span> <span class="hl-combinator">&gt;</span><span class="hl-site">Some</span>(<span class="hl-variable">r</span>)<span class="hl-combinator">&gt;</span> <span class="bold"><strong>G</strong></span>
<span class="hl-combinator">|</span> <span class="hl-variable">s</span> <span class="hl-combinator">&gt;</span><span class="hl-site">None</span>()<span class="hl-combinator">&gt;</span>  <span class="bold"><strong>H</strong></span>
</pre><p>

</p><p>

It is even possible to encapsulate timeout as a function.

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">timeout</span>(<span class="hl-variable">x</span>, <span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-site">Let</span>(<span class="hl-site">Some</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-variable">t</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">None</span>())
</pre><p>

<code class="code"><span class="hl-site">timeout</span>(<span class="bold"><strong>F</strong></span>, <span class="hl-variable">t</span>)</code> waits 
<code class="code"><span class="hl-variable">t</span></code> milliseconds for F to publish a value. If F publishes <code class="code"><span class="hl-variable">v</span></code> within
the time limit, <code class="code"><span class="hl-variable">timeout</span></code> returns <code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">v</span>)</code>. Otherwise, it returns
<code class="code"><span class="hl-site">None</span>()</code> when the time limit is reached.

</p><div class="section" title="2.2.12.2.1.&nbsp;Timeout streams"><div class="titlepage"><div><div><h5 class="title"><a name="N10CF6"></a>2.2.12.2.1.&nbsp;Timeout streams</h5></div></div></div><p>
We can also apply timeout to <a class="link" href="#methodology.streams" title="2.2.3.&nbsp;Streams">streams</a>. Let's
define a modified version of the <code class="code"><span class="hl-variable">repeat</span></code> function as follows:

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">repeatWithTimeout</span>(<span class="hl-variable">f</span>, <span class="hl-variable">t</span>) <span class="hl-operator">=</span> 
  <span class="hl-site">timeout</span>(<span class="hl-site">f</span>(), <span class="hl-variable">t</span>) 
    <span class="hl-combinator">&gt;</span><span class="hl-site">Some</span>(<span class="hl-variable">x</span>)<span class="hl-combinator">&gt;</span> 
  (<span class="hl-variable">x</span> <span class="hl-combinator">|</span> <span class="hl-site">repeatWithTimeout</span>(<span class="hl-variable">f</span>, <span class="hl-variable">t</span>))

</pre><p>
</p><p>
We call <code class="code"><span class="hl-site">f</span>()</code> as before, but apply a timeout of <code class="code"><span class="hl-variable">t</span></code> to the call.
If a value becomes available from <code class="code"><span class="hl-variable">f</span></code> before the timeout, then the call to
<code class="code"><span class="hl-variable">timeout</span></code> publishes <code class="code"><span class="hl-site">Some</span>(<span class="hl-variable">x</span>)</code>, which we match, and then publish
<code class="code"><span class="hl-variable">x</span></code> and recursively wait for further values from the stream.
</p><p>
However, if no value is available from <code class="code"><span class="hl-variable">f</span></code> within the timeout, the call 
to <code class="code"><span class="hl-variable">timeout</span></code> publishes <code class="code"><span class="hl-site">None</span>()</code>. Since <code class="code"><span class="hl-site">None</span>()</code> does 
not match the pattern, the entire expression halts, indicating that the end of the
stream has been reached.
</p><p>
It is also possible to achieve this behavior with the existing <code class="code"><span class="hl-variable">repeat</span></code> function,
simply by changing the function passed to <code class="code"><span class="hl-variable">repeat</span></code>:

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-variable">f</span>'() <span class="hl-operator">=</span> <span class="hl-site">timeout</span>(<span class="hl-site">f</span>(), <span class="hl-variable">t</span>) <span class="hl-combinator">&gt;</span><span class="hl-site">Some</span>(<span class="hl-variable">x</span>)<span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span>
<span class="hl-site">repeat</span>(<span class="hl-variable">f</span>')
</pre><p>

</p></div></div></div><div class="section" title="2.2.13.&nbsp;Priority"><div class="titlepage"><div><div><h3 class="title"><a name="N10D32"></a>2.2.13.&nbsp;Priority</h3></div></div></div><p>
We can use a timer to give a window of priority to one computation over
another.  In this example, we run expressions F and G concurrently.  For
one second, F has priority; F's result is published immediately,
but G's result is held until the time interval has elapsed.  If neither F nor
G publishes a result within one second, then the first result from either
is published.

</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">x</span> <span class="hl-operator">=</span> <span class="bold"><strong>F</strong></span>
<span class="hl-keyword">val</span> <span class="hl-variable">y</span> <span class="hl-operator">=</span> <span class="bold"><strong>G</strong></span>
<span class="hl-site">Let</span>( <span class="hl-variable">y</span> <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">x</span> )
</pre><p>

</p></div><div class="section" title="2.2.14.&nbsp;Metronome"><div class="titlepage"><div><div><h3 class="title"><a name="N10D42"></a>2.2.14.&nbsp;Metronome</h3></div></div></div><p>
A timer can be used to execute an expression repeatedly at regular
intervals, for example to poll a service.
Recall the definition of <code class="code"><span class="hl-variable">metronome</span></code> from the previous chapter:

</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">metronome</span>(<span class="hl-variable">t</span>) <span class="hl-operator">=</span> <span class="hl-keyword">signal</span> <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-variable">t</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">metronome</span>()
</pre><p>
</p><p>
The following example publishes "tick" once per second and "tock" once per
second after an initial half-second delay.  The publications alternate: "tick
tock tick tock ...". Note that this program is not defined recursively;
the recursion is entirely contained within <code class="code"><span class="hl-variable">metronome</span></code>.
</p><p>
</p><pre class="orc">
  <span class="hl-site">metronome</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"tick"</span>
<span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">500</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">metronome</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"tock"</span>
</pre><p>
</p></div><div class="section" title="2.2.15.&nbsp;Routing"><div class="titlepage"><div><div><h3 class="title"><a name="N10D58"></a>2.2.15.&nbsp;Routing</h3></div></div></div><p>
The Orc combinators restrict the passing of values among their component
expressions. However, some programs will require greater
flexibility.  For example, <code class="code"><span class="hl-variable">F</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-variable">G</span></code> provides F with the first 
publication of G, but what if F needs the first n publications of G?  
In cases like this we use channels or other stateful sites to redirect or 
store publications.  We call this technique <em class="firstterm">routing</em>
because it involves routing values from one execution to another.
</p><div class="section" title="2.2.15.1.&nbsp;Generalizing Termination"><div class="titlepage"><div><div><h4 class="title"><a name="N10D63"></a>2.2.15.1.&nbsp;Generalizing Termination</h4></div></div></div><p>
The pruning combinator terminates an expression after it publishes its first
value. We have <a class="link" href="#style.pruning" title="2.1.3.&nbsp;Pruning combinator">already seen</a> how to use 
pruning just for its termination capability, without binding a variable, using 
the <code class="code"><span class="hl-variable">let</span></code> site. Now, we use routing to terminate an expression
under different conditions, not just when it publishes a value; it may
publish many values, or none, before being terminated.
</p><p>
Our implementation strategy is to route the publications of the expression
through a channel, so that we can put the expression inside a pruning combinator
and still see its publications without those publications terminating the
expression. 
</p><div class="section" title="2.2.15.1.1.&nbsp;Enhanced Timeout"><div class="titlepage"><div><div><h5 class="title"><a name="N10D71"></a>2.2.15.1.1.&nbsp;Enhanced Timeout</h5></div></div></div><p>
As a simple demonstration of this concept, we construct a more powerful form 
of timeout: allow an expression to execute, publishing arbitrarily many values 
(not just one), until a time limit is reached.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
<span class="hl-site">repeat</span>(<span class="hl-variable">c</span>.<span class="hl-variable">get</span>) <span class="hl-combinator">&lt;</span><span class="hl-combinator">&lt;</span> 
    <span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> 
  <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()</pre><p>
This program allows F to execute for one second and then terminates it. Each
value published by F is routed through channel <code class="code"><span class="hl-variable">c</span></code> so that it does
not terminate F. After one second, <code class="code"><span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>)</code> responds,
triggering the call <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()</code>.  The call
<code class="code"><span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()</code> closes <code class="code"><span class="hl-variable">c</span></code> and publishes a signal,
terminating F.  The library function <code class="code"><span class="hl-variable">repeat</span></code> is used to repeatedly
take and publish values from <code class="code"><span class="hl-variable">c</span></code> until it is closed.
</p></div><div class="section" title="2.2.15.1.2.&nbsp;Test Pruning"><div class="titlepage"><div><div><h5 class="title"><a name="N10D93"></a>2.2.15.1.2.&nbsp;Test Pruning</h5></div></div></div><p>
We can also decide to terminate based on the values published. This expression
executes F until it publishes a negative number, and then terminates it:
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
<span class="hl-site">repeat</span>(<span class="hl-variable">c</span>.<span class="hl-variable">get</span>) <span class="hl-combinator">&lt;</span><span class="hl-combinator">&lt;</span> 
  <span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> 
    (<span class="hl-keyword">if</span> <span class="hl-variable">x</span> <span class="hl-operator">&gt;=</span> <span class="hl-literal">0</span> 
        <span class="hl-keyword">then</span> <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
        <span class="hl-keyword">else</span> <span class="hl-variable">c</span>.<span class="hl-site">closeD</span>())
</pre><p>
Each value published by F is tested. If it is non-negative, it is placed on
channel <code class="code"><span class="hl-variable">c</span></code> (silently) and read by <code class="code"><span class="hl-site">repeat</span>(<span class="hl-variable">c</span>.<span class="hl-variable">get</span>)</code>. 
If it is negative, the channel is closed, publishing a signal and causing
the termination of F.
</p></div><div class="section" title="2.2.15.1.3.&nbsp;Interrupt"><div class="titlepage"><div><div><h5 class="title"><a name="N10DA6"></a>2.2.15.1.3.&nbsp;Interrupt</h5></div></div></div><p>
We can use routing to interrupt an expression based on a signal from
elsewhere in the program.  We set up the expression like a timeout, but instead
of waiting for a timer, we wait for the semaphore <code class="code"><span class="hl-variable">done</span></code> to be released. Any
call to <code class="code"><span class="hl-variable">done</span>.<span class="hl-variable">release</span></code> will terminate the expression (because it will
cause <code class="code"><span class="hl-variable">done</span>.<span class="hl-site">acquire</span>()</code> to publish), but otherwise F executes as normal and
may publish any number of values.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
<span class="hl-keyword">val</span> <span class="hl-variable">done</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>)
<span class="hl-site">repeat</span>(<span class="hl-variable">c</span>.<span class="hl-variable">get</span>) <span class="hl-combinator">&lt;</span><span class="hl-combinator">&lt;</span>
    <span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
  <span class="hl-combinator">|</span> <span class="hl-variable">done</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()</pre></div><div class="section" title="2.2.15.1.4.&nbsp;Publication Limit"><div class="titlepage"><div><div><h5 class="title"><a name="N10DBA"></a>2.2.15.1.4.&nbsp;Publication Limit</h5></div></div></div><p>
We can limit an expression to <span class="emphasis"><em>n</em></span> publications,
rather than just one. Here is an expression which executes F until
it publishes 5 values, and then terminates it.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
<span class="hl-keyword">val</span> <span class="hl-variable">done</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>)
<span class="hl-keyword">def</span> <span class="hl-site">allow</span>(<span class="hl-literal">0</span>) <span class="hl-operator">=</span> <span class="hl-variable">done</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-keyword">def</span> <span class="hl-site">allow</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span> <span class="hl-variable">c</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> (<span class="hl-variable">x</span> <span class="hl-combinator">|</span> <span class="hl-site">allow</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>))
<span class="hl-site">allow</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">&lt;</span><span class="hl-combinator">&lt;</span> 
    <span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> 
  <span class="hl-combinator">|</span> <span class="hl-variable">done</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()

</pre><p>
We use the auxiliary function <code class="code"><span class="hl-variable">allow</span></code> to get only the first 5
publications from the channel <code class="code"><span class="hl-variable">c</span></code>.  When no more publications are allowed,
<code class="code"><span class="hl-variable">allow</span></code> uses the interrupt idiom to halt F and close <code class="code"><span class="hl-variable">c</span></code>.
</p></div></div><div class="section" title="2.2.15.2.&nbsp;Non-Terminating Pruning"><div class="titlepage"><div><div><h4 class="title"><a name="N10DD6"></a>2.2.15.2.&nbsp;Non-Terminating Pruning</h4></div></div></div><p>
We can use routing to create a modified version of the pruning combinator.
As in <code class="code"><span class="hl-variable">F</span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-variable">G</span></code>, we'll run F and G in parallel and make the first
value published by G available to F.  However instead of terminating G after
it publishes a value, we will continue running it, ignoring its remaining
publications.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">r</span> <span class="hl-operator">=</span> <span class="hl-site">Cell</span>()
<span class="hl-keyword">signal</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
   (<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&lt;</span><span class="hl-variable">x</span><span class="hl-combinator">&lt;</span> <span class="hl-variable">c</span>.<span class="hl-site">read</span>()) <span class="hl-combinator">|</span> (<span class="bold"><strong>G</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">write</span>(<span class="hl-variable">x</span>))

</pre></div><div class="section" title="2.2.15.3.&nbsp;Sequencing Otherwise"><div class="titlepage"><div><div><h4 class="title"><a name="N10DE8"></a>2.2.15.3.&nbsp;Sequencing Otherwise</h4></div></div></div><p>
We can also use routing to create a modified version of the otherwise combinator. We'll
run F until it halts, and then run G, regardless of whether F published any values
or not.
</p><pre class="programlisting">
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
<span class="hl-site">repeat</span>(<span class="hl-variable">c</span>.<span class="hl-variable">get</span>) <span class="hl-combinator">|</span> (<span class="bold"><strong>F</strong></span> <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> <span class="hl-combinator">;</span> <span class="hl-variable">c</span>.<span class="hl-site">close</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="bold"><strong>G</strong></span>)  
</pre>

We use <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">close</span>()</code> instead of the more common <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()</code>
to ensure that G does not execute until all the publications of F have been
routed. Recall that <code class="code"><span class="hl-variable">c</span>.<span class="hl-site">close</span>()</code> does not return until <code class="code"><span class="hl-variable">c</span></code> is
empty.

</div></div><div class="section" title="2.2.16.&nbsp;Interruption"><div class="titlepage"><div><div><h3 class="title"><a name="N10E04"></a>2.2.16.&nbsp;Interruption</h3></div></div></div><p>
We can write a function <code class="code"><span class="hl-variable">interruptible</span></code> that implements the interrupt idiom
to execute any function in an interruptible way.  <code class="code"><span class="hl-site">interruptible</span>(<span class="hl-variable">g</span>)</code>
calls the function <code class="code"><span class="hl-variable">g</span></code>, which is assumed to take no arguments, and
silences its publications. It immediately publishes another function, which we
can call at any time to terminate the execution of <code class="code"><span class="hl-variable">g</span></code>. For simplicity,
we assume that <code class="code"><span class="hl-variable">g</span></code> itself publishes no values.
</p><p>
Here is a naive implementation that doesn't quite work:
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">interruptible</span>(<span class="hl-variable">f</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">done</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>)
  <span class="hl-variable">done</span>.<span class="hl-variable">release</span>
    <span class="hl-combinator">&lt;</span><span class="hl-combinator">&lt;</span> <span class="hl-site">f</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> 
     <span class="hl-combinator">|</span> <span class="hl-variable">done</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()

<span class="hl-comment">{- wrong! -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">stopper</span> <span class="hl-operator">=</span> <span class="hl-site">interruptible</span>(<span class="hl-variable">g</span>)
...

</pre><p>
The function <code class="code"><span class="hl-variable">interruptible</span></code> is correct, but the way it is used causes a strange error.
The function <code class="code"><span class="hl-variable">g</span></code> executes, but is always immediately terminated! This happens because the
<code class="code"><span class="hl-keyword">val</span></code> declaration which binds <code class="code"><span class="hl-variable">stopper</span></code> also kills all of the remaining
computation in <code class="code"><span class="hl-site">interruptible</span>(<span class="hl-variable">g</span>)</code>, including the execution of <code class="code"><span class="hl-variable">g</span></code> itself.
</p><p>
The solution is to bind the variable differently:
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">interruptible</span>(<span class="hl-variable">f</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">done</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>)
  <span class="hl-variable">done</span>.<span class="hl-variable">release</span>
    <span class="hl-combinator">&lt;</span><span class="hl-combinator">&lt;</span> <span class="hl-site">f</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> 
     <span class="hl-combinator">|</span> <span class="hl-variable">done</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">closeD</span>()

<span class="hl-site">interruptible</span>(<span class="hl-variable">g</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">stopper</span><span class="hl-combinator">&gt;</span>
...

</pre><p>
This idiom, wherein a function publishes some value that can be used to monitor or control its 
execution, arises occasionally in Orc programming. When using this idiom, always remember to
avoid terminating that execution accidentally. Since Orc is a structured concurrent language,
every process is contained with some other process; kill the containing process, and the
contained processes die too.
</p></div><div class="section" title="2.2.17.&nbsp;Fold"><div class="titlepage"><div><div><h3 class="title"><a name="N10E36"></a>2.2.17.&nbsp;Fold</h3></div></div></div><p>
We consider various concurrent implementations of the classic "list fold"
function from functional programming:
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">fold</span>(<span class="hl-variable">_</span>, [<span class="hl-variable">x</span>])  <span class="hl-operator">=</span> <span class="hl-variable">x</span>
<span class="hl-keyword">def</span> <span class="hl-site">fold</span>(<span class="hl-variable">f</span>, <span class="hl-variable">x</span><span class="hl-operator">:</span><span class="hl-variable">xs</span>) <span class="hl-operator">=</span> <span class="hl-site">f</span>(<span class="hl-variable">x</span>, <span class="hl-site">fold</span>(<span class="hl-variable">xs</span>))</pre><p>
This is a seedless fold (sometimes called <code class="code"><span class="hl-variable">fold1</span></code>) which requires that the
list be nonempty and uses its first element as a seed.  This implementation is
short-circuiting --- it may finish early if the reduction operator <code class="code"><span class="hl-variable">f</span></code> does
not use its second argument --- but it is not concurrent; no two calls to <code class="code"><span class="hl-variable">f</span></code>
can proceed in parallel.  However, if <code class="code"><span class="hl-variable">f</span></code> is associative, we can overcome this restriction 
and implement fold concurrently. If <code class="code"><span class="hl-variable">f</span></code> is also commutative, we can further increase concurrency.
</p><div class="section" title="2.2.17.1.&nbsp;Associative Fold"><div class="titlepage"><div><div><h4 class="title"><a name="N10E4E"></a>2.2.17.1.&nbsp;Associative Fold</h4></div></div></div><p>
We first consider the case when the reduction operator is associative.  We
define <code class="code"><span class="hl-site">afold</span>(<span class="hl-variable">f</span>,<span class="hl-variable">xs</span>)</code> where <code class="code"><span class="hl-variable">f</span></code> is a binary associative function and
<code class="code"><span class="hl-variable">xs</span></code> is a non-empty list.  The implementation iteratively reduces <code class="code"><span class="hl-variable">xs</span></code>
to a single value.  Each step of the iteration applies the auxiliary function
<code class="code"><span class="hl-variable">step</span></code>, which halves the size of <code class="code"><span class="hl-variable">xs</span></code> by reducing disjoint pairs of
adjacent items. 
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">afold</span>(<span class="hl-variable">_</span>, [<span class="hl-variable">x</span>]) <span class="hl-operator">=</span> <span class="hl-variable">x</span>
<span class="hl-keyword">def</span> <span class="hl-site">afold</span>(<span class="hl-variable">f</span>, <span class="hl-variable">xs</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">def</span> <span class="hl-site">step</span>([]) <span class="hl-operator">=</span> []
  <span class="hl-keyword">def</span> <span class="hl-site">step</span>([<span class="hl-variable">x</span>]) <span class="hl-operator">=</span> [<span class="hl-variable">x</span>]
  <span class="hl-keyword">def</span> <span class="hl-site">step</span>(<span class="hl-variable">x</span><span class="hl-operator">:</span><span class="hl-variable">y</span><span class="hl-operator">:</span><span class="hl-variable">xs</span>) <span class="hl-operator">=</span> <span class="hl-site">f</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)<span class="hl-operator">:</span><span class="hl-site">step</span>(<span class="hl-variable">xs</span>)
  <span class="hl-site">afold</span>(<span class="hl-variable">f</span>, <span class="hl-site">step</span>(<span class="hl-variable">xs</span>))
</pre><p>
Notice that <code class="code"><span class="hl-site">f</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)<span class="hl-operator">:</span><span class="hl-site">step</span>(<span class="hl-variable">xs</span>)</code> is an implicit
fork-join. Thus, the call <code class="code"><span class="hl-site">f</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)</code>
executes in parallel with the recursive call <code class="code"><span class="hl-site">step</span>(<span class="hl-variable">xs</span>)</code>. 
As a result, all calls to <code class="code"><span class="hl-variable">f</span></code> execute concurrently within
each iteration of <code class="code"><span class="hl-variable">afold</span></code>.   
</p></div><div class="section" title="2.2.17.2.&nbsp;Associative, Commutative Fold"><div class="titlepage"><div><div><h4 class="title"><a name="N10E78"></a>2.2.17.2.&nbsp;Associative, Commutative Fold</h4></div></div></div><p>
We can make the implementation even more concurrent when the fold operator 
is both associative and commutative. We define <code class="code"><span class="hl-site">cfold</span>(<span class="hl-variable">f</span>,<span class="hl-variable">xs</span>)</code>, where 
<code class="code"><span class="hl-variable">f</span></code> is a associative and commutative binary function and <code class="code"><span class="hl-variable">xs</span></code> is a non-empty list. 
The implementation initially copies all list items into a channel in arbitrary
order using the auxiliary function <code class="code"><span class="hl-variable">xfer</span></code>, counting the total
number of items copied. The auxiliary function <code class="code"><span class="hl-variable">combine</span></code> repeatedly 
pulls pairs of items from the channel, reduces
them, and places the result back in the channel. Each pair of items is reduced
in parallel as they become available. The last item in the channel is the
result of the overall fold.
</p><pre class="programlisting">
<span class="hl-keyword">def</span> <span class="hl-site">cfold</span>(<span class="hl-variable">f</span>, <span class="hl-variable">xs</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
  
  <span class="hl-keyword">def</span> <span class="hl-site">xfer</span>([])    <span class="hl-operator">=</span> <span class="hl-literal">0</span>
  <span class="hl-keyword">def</span> <span class="hl-site">xfer</span>(<span class="hl-variable">x</span><span class="hl-operator">:</span><span class="hl-variable">xs</span>)  <span class="hl-operator">=</span> <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-variable">x</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> <span class="hl-combinator">|</span> <span class="hl-site">xfer</span>(<span class="hl-variable">xs</span>)<span class="hl-operator">+</span><span class="hl-literal">1</span>

  <span class="hl-keyword">def</span> <span class="hl-site">combine</span>(<span class="hl-literal">0</span>) <span class="hl-operator">=</span> <span class="hl-keyword">stop</span>
  <span class="hl-keyword">def</span> <span class="hl-site">combine</span>(<span class="hl-literal">1</span>) <span class="hl-operator">=</span>  <span class="hl-variable">c</span>.<span class="hl-site">get</span>()
  <span class="hl-keyword">def</span> <span class="hl-site">combine</span>(<span class="hl-variable">m</span>) <span class="hl-operator">=</span>  <span class="hl-variable">c</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">x</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">y</span><span class="hl-combinator">&gt;</span> 
                    ( <span class="hl-variable">c</span>.<span class="hl-site">put</span>(<span class="hl-site">f</span>(<span class="hl-variable">x</span>,<span class="hl-variable">y</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span> <span class="hl-combinator">|</span> <span class="hl-site">combine</span>(<span class="hl-variable">m</span><span class="hl-operator">-</span><span class="hl-literal">1</span>))

  <span class="hl-site">xfer</span>(<span class="hl-variable">xs</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">n</span><span class="hl-combinator">&gt;</span> <span class="hl-site">combine</span>(<span class="hl-variable">n</span>)
</pre></div></div></div><div class="section" title="2.3.&nbsp;Larger Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ug.methodology.example"></a>2.3.&nbsp;Larger Examples</h2></div></div></div><p>
In this section we show a few larger Orc programs to demonstrate programming techniques. 
There are many more such examples available at the Orc website, on the
<a class="link" href="http://orc.csres.utexas.edu/wiki/Wiki.jsp?page=WikiLab" target="_top">community wiki</a>.
</p><div class="section" title="2.3.1.&nbsp;Dining Philosophers"><div class="titlepage"><div><div><h3 class="title"><a name="N10E9D"></a>2.3.1.&nbsp;Dining Philosophers</h3></div></div></div><p>
The dining philosophers problem is a well known and intensely studied problem
in concurrent programming. Five philosophers sit around a circular table. Each
philosopher has two forks that she shares with her neighbors (giving five forks
in total).  Philosophers think until they become hungry.  A hungry philosopher
picks up both forks, one at a time, eats, puts down both forks, and then
resumes thinking.  Without further refinement, this scenario allows deadlock;
if all philosophers become hungry and pick up their left-hand forks
simultaneously, no philosopher will be able to pick up her right-hand fork to
eat.  Lehmann and Rabin's solution<sup>[<a href="#ftn.N10EA2" name="N10EA2" class="footnote">3</a>]</sup>, which we implement,
requires that each philosopher pick up her forks in a random order.  If the
second fork is not immediately available, the philosopher must set down both
forks and try again.  While livelock is still possible if all philosophers
take forks in the same order, randomization makes this possibility vanishingly
unlikely.
</p><pre class="orc">
<span class="hl-comment">{- Dining Philosophers -}</span>

<span class="hl-comment">{- Randomly swap order of fork pick-up -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">shuffle</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> (<span class="hl-site">Random</span>(<span class="hl-literal">2</span>) <span class="hl-operator">=</span> <span class="hl-literal">1</span>) <span class="hl-keyword">then</span> (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-keyword">else</span> (<span class="hl-variable">b</span>,<span class="hl-variable">a</span>)

<span class="hl-keyword">def</span> <span class="hl-site">take</span>((<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)) <span class="hl-operator">=</span>    
  <span class="hl-variable">a</span>.<span class="hl-site">acquire</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">acquireD</span>() <span class="hl-combinator">;</span>
  <span class="hl-variable">a</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">take</span>(<span class="hl-site">shuffle</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>))
    
<span class="hl-keyword">def</span> <span class="hl-site">drop</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-operator">=</span> (<span class="hl-variable">a</span>.<span class="hl-site">release</span>(), <span class="hl-variable">b</span>.<span class="hl-site">release</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">signal</span>

<span class="hl-comment">{- Define a philosopher -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">phil</span>(<span class="hl-variable">n</span>,<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">def</span> <span class="hl-site">thinking</span>() <span class="hl-operator">=</span> 
    <span class="hl-site">Println</span>(<span class="hl-variable">n</span> <span class="hl-operator">+</span> <span class="hl-literal">" thinking"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
    <span class="hl-keyword">if</span> (<span class="hl-site">Random</span>(<span class="hl-literal">10</span>) <span class="hl-operator">&lt;:</span> <span class="hl-literal">9</span>)
      <span class="hl-keyword">then</span> <span class="hl-site">Rwait</span>(<span class="hl-site">Random</span>(<span class="hl-literal">1000</span>))
      <span class="hl-keyword">else</span> <span class="hl-keyword">stop</span>
  <span class="hl-keyword">def</span> <span class="hl-site">hungry</span>() <span class="hl-operator">=</span> <span class="hl-site">take</span>((<span class="hl-variable">a</span>,<span class="hl-variable">b</span>))
  <span class="hl-keyword">def</span> <span class="hl-site">eating</span>() <span class="hl-operator">=</span> 
    <span class="hl-site">Println</span>(<span class="hl-variable">n</span> <span class="hl-operator">+</span> <span class="hl-literal">" eating"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
    <span class="hl-site">Rwait</span>(<span class="hl-site">Random</span>(<span class="hl-literal">1000</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
    <span class="hl-site">Println</span>(<span class="hl-variable">n</span> <span class="hl-operator">+</span> <span class="hl-literal">" done eating"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> 
    <span class="hl-site">drop</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)
  <span class="hl-site">thinking</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">hungry</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">eating</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">phil</span>(<span class="hl-variable">n</span>,<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)

<span class="hl-keyword">def</span> <span class="hl-site">philosophers</span>(<span class="hl-literal">1</span>,<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-operator">=</span> <span class="hl-site">phil</span>(<span class="hl-literal">1</span>,<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)
<span class="hl-keyword">def</span> <span class="hl-site">philosophers</span>(<span class="hl-variable">n</span>,<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">1</span>)
  <span class="hl-site">philosophers</span>(<span class="hl-variable">n</span><span class="hl-operator">-</span><span class="hl-literal">1</span>,<span class="hl-variable">a</span>,<span class="hl-variable">c</span>) <span class="hl-combinator">|</span> <span class="hl-site">phil</span>(<span class="hl-variable">n</span>,<span class="hl-variable">c</span>,<span class="hl-variable">b</span>)

<span class="hl-comment">{- Test the definitions -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">fork</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">1</span>)
<span class="hl-site">philosophers</span>(<span class="hl-literal">5</span>,<span class="hl-variable">fork</span>,<span class="hl-variable">fork</span>)

<span class="hl-comment">{-
OUTPUT:EXAMPLE
5 thinking
4 thinking
3 thinking
2 thinking
1 thinking
1 eating
4 eating
...
-}</span></pre><p>
The <code class="code"><span class="hl-variable">phil</span></code> function simulates a single philosopher.  It takes as arguments
two binary semaphores representing the philosopher's forks, and calls
the <code class="code"><span class="hl-variable">thinking</span></code>, <code class="code"><span class="hl-variable">hungry</span></code>, and <code class="code"><span class="hl-variable">eating</span></code> functions in a continuous
loop. A <code class="code"><span class="hl-variable">thinking</span></code> philosopher waits for a random amount of time, with a
10% chance of thinking forever. A <code class="code"><span class="hl-variable">hungry</span></code> philosopher uses the <code class="code"><span class="hl-variable">take</span></code>
function to acquire two forks. An <code class="code"><span class="hl-variable">eating</span></code> philosopher waits for a random
time interval and then uses the <code class="code"><span class="hl-variable">drop</span></code> function to relinquish ownership of
her forks.
</p><p>
Calling <code class="code"><span class="hl-site">take</span>(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)</code> attempts to acquire a pair of forks <code class="code">(<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)</code> in two steps:
wait for fork <code class="code"><span class="hl-variable">a</span></code> to become available, then immediately attempt to acquire fork <code class="code"><span class="hl-variable">b</span></code>.
The call <code class="code"><span class="hl-variable">b</span>.<span class="hl-site">acquireD</span>()</code> either acquires <code class="code"><span class="hl-variable">b</span></code> and responds immediately, or halts if <code class="code"><span class="hl-variable">b</span></code> is not available.
If <code class="code"><span class="hl-variable">b</span></code> is acquired, signal success; otherwise, release <code class="code"><span class="hl-variable">a</span></code>, and
then try again, randomly changing the order in which the forks are acquired
using the auxiliary function <code class="code"><span class="hl-variable">shuffle</span></code>.
</p><p>
The function call <code class="code"><span class="hl-site">philosophers</span>(<span class="hl-variable">n</span>,<span class="hl-variable">a</span>,<span class="hl-variable">b</span>)</code> recursively creates a chain of <code class="code"><span class="hl-variable">n</span></code>
philosophers, bounded by fork <code class="code"><span class="hl-variable">a</span></code> on the left and <code class="code"><span class="hl-variable">b</span></code> on the right. The
goal expression of the program calls <code class="code"><span class="hl-variable">philosophers</span></code> to create a chain of
five philosophers bounded on the left and right by the same fork; hence, a
ring.
</p><p>
This Orc solution has several nice properties.  The overall structure of the
program is functional, with each behavior encapsulated in its own function,
making the program easy to understand and modify.  Mutable state is isolated to
the "fork" semaphores and associated <code class="code"><span class="hl-variable">take</span></code> and <code class="code"><span class="hl-variable">get</span></code> functions,
simplifying the implementation of the philosophers.  The program never
manipulates threads explicitly, but instead expresses relationships between
activities using Orc's combinators.
</p></div><div class="section" title="2.3.2.&nbsp;Hygienic Dining Philosophers"><div class="titlepage"><div><div><h3 class="title"><a name="methodology.examples.hygenic"></a>2.3.2.&nbsp;Hygienic Dining Philosophers</h3></div></div></div><p>
Here we implement a different solution to the Dining Philosophers problem,
described in "The Drinking Philosophers Problem", by K. M. Chandy and J. Misra.
Briefly, this algorithm efficiently and fairly solves the dining philosophers
problem for philosophers connected in an arbitrary graph (as opposed to a
simple ring).  The algorithm works by augmenting each fork with a clean/dirty
state.  Initially, all forks are dirty.  A philosopher is only obliged to
relinquish a fork to its neighbor if the fork is dirty. On receiving a fork,
the philosopher cleans it. On eating, the philosopher dirties all forks.  For
full details of the algorithm, consult the original paper.
</p><pre class="orc">
<span class="hl-comment">{- Start a philosopher actor; never publishes.
   Messages sent between philosophers include:
   - ("fork", p): philosopher p relinquishes the fork
   - ("request", p): philosopher p requests the fork
   - ("rumble", p): sent by a philosopher to itself when it should
     become hungry

   name: identify this process in status messages
   mbox: our mailbox; the "address" of this philosopher is mbox.put
   missing: set of neighboring philosophers holding our forks
-}</span>

<span class="hl-comment">{- Define philosopher -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">philosopher</span>(<span class="hl-variable">name</span>, <span class="hl-variable">mbox</span>, <span class="hl-variable">missing</span>) <span class="hl-operator">=</span>
  <span class="hl-comment">{- deferred requests for forks -}</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">deferred</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
  <span class="hl-comment">{- forks we hold which are clean -}</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">clean</span> <span class="hl-operator">=</span> <span class="hl-site">Set</span>()

  <span class="hl-keyword">def</span> <span class="hl-site">sendFork</span>(<span class="hl-variable">p</span>) <span class="hl-operator">=</span>
    <span class="hl-comment">{- remember that we no longer hold the fork -}</span>
    <span class="hl-variable">missing</span>.<span class="hl-site">add</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">p</span>((<span class="hl-literal">"fork"</span>, <span class="hl-variable">mbox</span>.<span class="hl-variable">put</span>))
 
  <span class="hl-keyword">def</span> <span class="hl-site">requestFork</span>(<span class="hl-variable">p</span>) <span class="hl-operator">=</span>
    <span class="hl-site">p</span>((<span class="hl-literal">"request"</span>, <span class="hl-variable">mbox</span>.<span class="hl-variable">put</span>))
  
  <span class="hl-comment">{- Start a timer which will tell us when we're hungry. -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">digesting</span>() <span class="hl-operator">=</span>
      <span class="hl-site">Println</span>(<span class="hl-variable">name</span> <span class="hl-operator">+</span> <span class="hl-literal">" thinking"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-site">thinking</span>()
    <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-site">Random</span>(<span class="hl-literal">1000</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-variable">mbox</span>.<span class="hl-site">put</span>((<span class="hl-literal">"rumble"</span>, <span class="hl-variable">mbox</span>.<span class="hl-variable">put</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-keyword">stop</span>

  <span class="hl-comment">{- Wait to become hungry -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">thinking</span>() <span class="hl-operator">=</span>
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"rumble"</span>, <span class="hl-variable">_</span>)) <span class="hl-operator">=</span>
      <span class="hl-site">Println</span>(<span class="hl-variable">name</span> <span class="hl-operator">+</span> <span class="hl-literal">" hungry"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-site">map</span>(<span class="hl-variable">requestFork</span>, <span class="hl-variable">missing</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-site">hungry</span>()
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"request"</span>, <span class="hl-variable">p</span>)) <span class="hl-operator">=</span>
      <span class="hl-site">sendFork</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">thinking</span>()
    <span class="hl-site">on</span>(<span class="hl-variable">mbox</span>.<span class="hl-site">get</span>())

  <span class="hl-comment">{- Eat once we receive all forks -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">hungry</span>() <span class="hl-operator">=</span>
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"fork"</span>, <span class="hl-variable">p</span>)) <span class="hl-operator">=</span>
      <span class="hl-variable">missing</span>.<span class="hl-site">remove</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-variable">clean</span>.<span class="hl-site">add</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      <span class="hl-keyword">if</span> <span class="hl-variable">missing</span>.<span class="hl-site">isEmpty</span>()
      <span class="hl-keyword">then</span> <span class="hl-site">Println</span>(<span class="hl-variable">name</span> <span class="hl-operator">+</span> <span class="hl-literal">" eating"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">eating</span>()
      <span class="hl-keyword">else</span> <span class="hl-site">hungry</span>()
    <span class="hl-keyword">def</span> <span class="hl-site">on</span>((<span class="hl-literal">"request"</span>, <span class="hl-variable">p</span>)) <span class="hl-operator">=</span>
      <span class="hl-keyword">if</span> <span class="hl-variable">clean</span>.<span class="hl-site">contains</span>(<span class="hl-variable">p</span>)
      <span class="hl-keyword">then</span> <span class="hl-variable">deferred</span>.<span class="hl-site">put</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">hungry</span>()
      <span class="hl-keyword">else</span> <span class="hl-site">sendFork</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">requestFork</span>(<span class="hl-variable">p</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">hungry</span>()
    <span class="hl-site">on</span>(<span class="hl-variable">mbox</span>.<span class="hl-site">get</span>())

  <span class="hl-comment">{- Dirty forks, process deferred requests, then digest -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">eating</span>() <span class="hl-operator">=</span>
    <span class="hl-variable">clean</span>.<span class="hl-site">clear</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">Rwait</span>(<span class="hl-site">Random</span>(<span class="hl-literal">1000</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">map</span>(<span class="hl-variable">sendFork</span>, <span class="hl-variable">deferred</span>.<span class="hl-site">getAll</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">digesting</span>()

  <span class="hl-comment">{- All philosophers start out digesting -}</span>
  <span class="hl-site">digesting</span>()

<span class="hl-comment">{- Create an NxN 4-connected grid of philosophers.  Each philosopher
   holds the fork for the connections below and to the right (so the
   top left philosopher holds both its forks).
-}</span>

<span class="hl-keyword">def</span> <span class="hl-site">philosophers</span>(<span class="hl-variable">n</span>) <span class="hl-operator">=</span>
  <span class="hl-comment">{- A set with 1 item -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">Set1</span>(<span class="hl-variable">item</span>) <span class="hl-operator">=</span> <span class="hl-site">Set</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">add</span>(<span class="hl-variable">item</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>
  <span class="hl-comment">{- A set with 2 items -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">Set2</span>(<span class="hl-variable">i1</span>, <span class="hl-variable">i2</span>) <span class="hl-operator">=</span> <span class="hl-site">Set</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">s</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">add</span>(<span class="hl-variable">i1</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">add</span>(<span class="hl-variable">i2</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>

  <span class="hl-comment">{- create an NxN matrix of mailboxes -}</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">cs</span> <span class="hl-operator">=</span> <span class="hl-site">uncurry</span>(<span class="hl-site">Table</span>(<span class="hl-variable">n</span>, <span class="hl-keyword">lambda</span> (<span class="hl-variable">_</span>) <span class="hl-operator">=</span> <span class="hl-site">Table</span>(<span class="hl-variable">n</span>, <span class="hl-site">ignore</span>(<span class="hl-variable">Channel</span>))))

  <span class="hl-comment">{- create the first row of philosophers -}</span>
  <span class="hl-site">philosopher</span>((<span class="hl-literal">0</span>,<span class="hl-literal">0</span>), <span class="hl-site">cs</span>(<span class="hl-literal">0</span>,<span class="hl-literal">0</span>), <span class="hl-site">Set</span>())
  <span class="hl-combinator">|</span> <span class="hl-site">for</span>(<span class="hl-literal">1</span>, <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">j</span><span class="hl-combinator">&gt;</span>
    <span class="hl-site">philosopher</span>((<span class="hl-literal">0</span>,<span class="hl-variable">j</span>), <span class="hl-site">cs</span>(<span class="hl-literal">0</span>,<span class="hl-variable">j</span>), <span class="hl-site">Set1</span>(<span class="hl-site">cs</span>(<span class="hl-literal">0</span>,<span class="hl-variable">j</span><span class="hl-operator">-</span><span class="hl-literal">1</span>).<span class="hl-variable">put</span>))

  <span class="hl-comment">{- create remaining rows -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">for</span>(<span class="hl-literal">1</span>, <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">i</span><span class="hl-combinator">&gt;</span> (
      <span class="hl-site">philosopher</span>((<span class="hl-variable">i</span>,<span class="hl-literal">0</span>), <span class="hl-site">cs</span>(<span class="hl-variable">i</span>,<span class="hl-literal">0</span>), <span class="hl-site">Set1</span>(<span class="hl-site">cs</span>(<span class="hl-variable">i</span><span class="hl-operator">-</span><span class="hl-literal">1</span>,<span class="hl-literal">0</span>).<span class="hl-variable">put</span>))
      <span class="hl-combinator">|</span> <span class="hl-site">for</span>(<span class="hl-literal">1</span>, <span class="hl-variable">n</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">j</span><span class="hl-combinator">&gt;</span>
        <span class="hl-site">philosopher</span>((<span class="hl-variable">i</span>,<span class="hl-variable">j</span>), <span class="hl-site">cs</span>(<span class="hl-variable">i</span>,<span class="hl-variable">j</span>), <span class="hl-site">Set2</span>(<span class="hl-site">cs</span>(<span class="hl-variable">i</span><span class="hl-operator">-</span><span class="hl-literal">1</span>,<span class="hl-variable">j</span>).<span class="hl-variable">put</span>, <span class="hl-site">cs</span>(<span class="hl-variable">i</span>,<span class="hl-variable">j</span><span class="hl-operator">-</span><span class="hl-literal">1</span>).<span class="hl-variable">put</span>))
    )

<span class="hl-comment">{- Simulate a 3x3 grid of philosophers for 10 seconds -}</span>
<span class="hl-site">Let</span>(
  <span class="hl-site">philosophers</span>(<span class="hl-literal">3</span>)
  <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">10000</span>)
) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">"HALTED"</span>

<span class="hl-comment">{-
OUTPUT:EXAMPLE
(0, 0) thinking
(0, 1) thinking
(0, 2) thinking
(1, 0) thinking
(2, 0) thinking
(1, 1) thinking
(2, 1) thinking
(1, 2) thinking
(2, 2) thinking
(1, 0) hungry
(0, 0) hungry
(0, 1) hungry
...
"HALTED"
-}</span></pre><p>
Our implementation is based on the <a class="link" href="http://en.wikipedia.org/wiki/Actor_model" target="_top">actor model</a> of
concurrency.  An actor is a state machine which reacts to messages.  On
receiving a message, an actor can send asynchronous messages to other actors,
change its state, or create new actors.  Each actor is single-threaded and
processes messages sequentially, which makes some concurrent programs easier to
reason about and avoids explicit locking. <a class="link" href="http://www.erlang.org/" target="_top">Erlang</a> is one popular
language based on the actor model.
</p><p>
Orc emulates the actor model very naturally.  In Orc, an actor is an Orc thread
of execution, together with a <code class="code"><span class="hl-variable">Channel</span></code> which serves as a mailbox.  To send a
message to an actor, you place it in the actor's mailbox, and to receive a
message, the actor gets the next item from the mailbox.  The internal states of
the actor are represented by functions: while an actor's thread of execution is
evaluating a function, it is considered to be in the corresponding state.
Because Orc implements <a class="link" href="http://en.wikipedia.org/wiki/Tail_call" target="_top">tail-call optimization</a>,
state transitions can be encoded as function calls without running out of stack
space.
</p><p>
In this program, a philosopher is implemented by an actor with three primary
states: <code class="code"><span class="hl-variable">eating</span></code>, <code class="code"><span class="hl-variable">thinking</span></code>, and <code class="code"><span class="hl-variable">hungry</span></code>.
An additional transient state, <code class="code"><span class="hl-variable">digesting</span></code>, is used to start a timer
which will trigger the state change from <code class="code"><span class="hl-variable">thinking</span></code> to
<code class="code"><span class="hl-variable">hungry</span></code>.  Each state is implemented by a function which reads a
message from the mailbox, selects the appropriate action using pattern
matching, performs the action, and finally transitions to the next state
(possibly the same as the current state) by calling the corresponding function.
</p><p>
Forks are never represented explicitly.  Instead each philosopher identifies a
fork with the "address" (sending end of a mailbox) of the neighbor who shares
the fork.  Every message sent includes the sender's address.  Therefore when a
philosopher receives a request for a fork, it knows who requested it and
therefore which fork to relinquish.  Likewise when a philosopher receives a
fork, it knows who sent it and therefore which fork was received.
</p></div><div class="section" title="2.3.3.&nbsp;Readers-Writers"><div class="titlepage"><div><div><h3 class="title"><a name="N10F34"></a>2.3.3.&nbsp;Readers-Writers</h3></div></div></div><p>
Here we present an Orc solution to the <a class="link" href="http://en.wikipedia.org/wiki/Readers-writers_problem" target="_top">readers-writers
problem</a>.  Briefly, the readers-writers problem involves concurrent
access to a mutable resource.  Multiple readers can access the resource
concurrently, but writers must have exclusive access.  When readers and writers
conflict, different solutions may resolve the conflict in favor of one or the
other, or fairly.  In the following solution, when a writer tries to acquire
the lock, current readers are allowed to finish but new readers are postponed
until after the writer finishes.  Lock requests are granted in the order
received, guaranteeing fairness.  Normally, such a service would be provided to
Orc programs by a site, but it is educational to see how it can be implemented
directly in Orc.
</p><pre class="orc">
<span class="hl-comment">{- A solution to the readers-writers problem -}</span>

<span class="hl-comment">{- Queue of lock requests -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">m</span> <span class="hl-operator">=</span> <span class="hl-site">Channel</span>()
<span class="hl-comment">{- Count of active readers/writers -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">c</span> <span class="hl-operator">=</span> <span class="hl-site">Counter</span>()

<span class="hl-comment">{- Process requests in sequence -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">process</span>() <span class="hl-operator">=</span>
  <span class="hl-comment">{- Grant read request -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">grant</span>((<span class="hl-literal">false</span>,<span class="hl-variable">s</span>)) <span class="hl-operator">=</span> <span class="hl-variable">c</span>.<span class="hl-site">inc</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">release</span>()
  <span class="hl-comment">{- Grant write request -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">grant</span>((<span class="hl-literal">true</span>,<span class="hl-variable">s</span>)) <span class="hl-operator">=</span>
    <span class="hl-variable">c</span>.<span class="hl-site">onZero</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">inc</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">c</span>.<span class="hl-site">onZero</span>()
  <span class="hl-comment">{- Goal expression of process() -}</span>
  <span class="hl-variable">m</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">r</span><span class="hl-combinator">&gt;</span> <span class="hl-site">grant</span>(<span class="hl-variable">r</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">process</span>()

<span class="hl-comment">{- Acquire the lock: argument is "true" if writing -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">acquire</span>(<span class="hl-variable">write</span>) <span class="hl-operator">=</span>
  <span class="hl-keyword">val</span> <span class="hl-variable">s</span> <span class="hl-operator">=</span> <span class="hl-site">Semaphore</span>(<span class="hl-literal">0</span>)
  <span class="hl-variable">m</span>.<span class="hl-site">put</span>((<span class="hl-variable">write</span>, <span class="hl-variable">s</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>.<span class="hl-site">acquire</span>()

<span class="hl-comment">{- Release the lock -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">release</span>() <span class="hl-operator">=</span> <span class="hl-variable">c</span>.<span class="hl-site">dec</span>()

<span class="hl-comment">-------------------------------------------------</span>

<span class="hl-comment">{- These definitions are for testing only -}</span>
<span class="hl-keyword">def</span> <span class="hl-site">reader</span>(<span class="hl-variable">start</span>) <span class="hl-operator">=</span> <span class="hl-site">Rwait</span>(<span class="hl-variable">start</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">acquire</span>(<span class="hl-literal">false</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"START READ"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"END READ"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>
<span class="hl-keyword">def</span> <span class="hl-site">writer</span>(<span class="hl-variable">start</span>) <span class="hl-operator">=</span> <span class="hl-site">Rwait</span>(<span class="hl-variable">start</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">acquire</span>(<span class="hl-literal">true</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"START WRITE"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">Rwait</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">Println</span>(<span class="hl-literal">"END WRITE"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">release</span>() <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-keyword">stop</span>

<span class="hl-site">Let</span>(
    <span class="hl-site">process</span>()  <span class="hl-comment">{- Output:     -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">10</span>) <span class="hl-comment">{- START READ  -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">20</span>) <span class="hl-comment">{- START READ  -}</span>
               <span class="hl-comment">{- END READ    -}</span>
               <span class="hl-comment">{- END READ    -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">writer</span>(<span class="hl-literal">30</span>) <span class="hl-comment">{- START WRITE -}</span>
               <span class="hl-comment">{- END WRITE   -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">40</span>) <span class="hl-comment">{- START READ  -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">reader</span>(<span class="hl-literal">50</span>) <span class="hl-comment">{- START READ  -}</span>
               <span class="hl-comment">{- END READ    -}</span>
               <span class="hl-comment">{- END READ    -}</span>
  <span class="hl-comment">{- halt after the last reader finishes -}</span>
  <span class="hl-combinator">|</span> <span class="hl-site">Rwait</span>(<span class="hl-literal">60</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">acquire</span>(<span class="hl-literal">true</span>)
)

<span class="hl-comment">{-
OUTPUT:EXAMPLE
END READ
START WRITE
END WRITE
START READ
START READ
END READ
END READ
signal
-}</span></pre><p>
The lock receives requests over the channel <code class="code"><span class="hl-variable">m</span></code> and processes them
sequentially with the function <code class="code"><span class="hl-variable">grant</span></code>. Each request includes a
boolean flag which is true for write requests and false for read requests, and a
<code class="code"><span class="hl-variable">Semaphore</span></code> which the requester blocks on.  The lock grants access
by releasing the semaphore, unblocking the requester.
</p><p>
The counter <code class="code"><span class="hl-variable">c</span></code> tracks the number of readers or writers currently
holding the lock.  Whenever the lock is granted, <code class="code"><span class="hl-variable">grant</span></code> increments
<code class="code"><span class="hl-variable">c</span></code>, and when the lock is released, <code class="code"><span class="hl-variable">c</span></code> is decremented.
To ensure that a writer has exclusive access, <code class="code"><span class="hl-variable">grant</span></code> waits for the
<code class="code"><span class="hl-variable">c</span></code> to become zero before granting the lock to the writer, and then
waits for <code class="code"><span class="hl-variable">c</span></code> to become zero again before granting any more requests.
</p></div><div class="section" title="2.3.4.&nbsp;Quicksort"><div class="titlepage"><div><div><h3 class="title"><a name="N10F62"></a>2.3.4.&nbsp;Quicksort</h3></div></div></div><p>
The original quicksort algorithm
<sup>[<a href="#ftn.N10F67" name="N10F67" class="footnote">4</a>]</sup>
was designed for efficient execution on a uniprocessor.
Encoding it as a functional program typically ignores its efficient
rearrangement of the elements of an array.
Further, no known implementation highlights its concurrent aspects.
The following program attempts to overcome these two limitations.
The program is mostly functional in its structure, though it manipulates the
array elements in place.
We encode parts of the algorithm as concurrent activities where sequentiality
is unneeded.
</p><p>
The following listing gives the implementation of the <code class="code"><span class="hl-variable">quicksort</span></code>
function which sorts the array <code class="code"><span class="hl-variable">a</span></code> in place.
The auxiliary function <code class="code"><span class="hl-variable">sort</span></code> sorts the subarray given by indices
<code class="code"><span class="hl-variable">s</span></code> through <code class="code"><span class="hl-variable">t</span></code> by calling <code class="code"><span class="hl-variable">part</span></code> to partition
the subarray and then recursively sorting the partitions.
</p><pre class="programlisting">
<span class="hl-comment">{- Perform Quicksort on a list -}</span>

<span class="hl-keyword">def</span> <span class="hl-site">quicksort</span>(<span class="hl-variable">a</span>) <span class="hl-operator">=</span>

  <span class="hl-keyword">def</span> <span class="hl-site">swap</span>(<span class="hl-variable">x</span>, <span class="hl-variable">y</span>) <span class="hl-operator">=</span> <span class="hl-site">a</span>(<span class="hl-variable">x</span>)<span class="hl-operator">?</span> <span class="hl-combinator">&gt;</span><span class="hl-variable">z</span><span class="hl-combinator">&gt;</span> <span class="hl-site">a</span>(<span class="hl-variable">x</span>) <span class="hl-operator">:=</span> <span class="hl-site">a</span>(<span class="hl-variable">y</span>)<span class="hl-operator">?</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">a</span>(<span class="hl-variable">y</span>) <span class="hl-operator">:=</span> <span class="hl-variable">z</span>

  <span class="hl-comment">{- Partition the elements based on pivot point 'p' -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">part</span>(<span class="hl-variable">p</span>, <span class="hl-variable">s</span>, <span class="hl-variable">t</span>) <span class="hl-operator">=</span>
    <span class="hl-keyword">def</span> <span class="hl-site">lr</span>(<span class="hl-variable">i</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> <span class="hl-variable">i</span> <span class="hl-operator">&lt;:</span> <span class="hl-variable">t</span> <span class="hl-operator">&amp;&amp;</span> <span class="hl-site">a</span>(<span class="hl-variable">i</span>)<span class="hl-operator">?</span> <span class="hl-operator">&lt;=</span> <span class="hl-variable">p</span> <span class="hl-keyword">then</span> <span class="hl-site">lr</span>(<span class="hl-variable">i</span><span class="hl-operator">+</span><span class="hl-literal">1</span>) <span class="hl-keyword">else</span> <span class="hl-variable">i</span>
    <span class="hl-keyword">def</span> <span class="hl-site">rl</span>(<span class="hl-variable">i</span>) <span class="hl-operator">=</span> <span class="hl-keyword">if</span> <span class="hl-site">a</span>(<span class="hl-variable">i</span>)<span class="hl-operator">?</span> <span class="hl-operator">:&gt;</span> <span class="hl-variable">p</span> <span class="hl-keyword">then</span> <span class="hl-site">rl</span>(<span class="hl-variable">i</span><span class="hl-operator">-</span><span class="hl-literal">1</span>) <span class="hl-keyword">else</span> <span class="hl-variable">i</span>

    <span class="hl-keyword">signal</span> <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
      (<span class="hl-site">lr</span>(<span class="hl-variable">s</span>), <span class="hl-site">rl</span>(<span class="hl-variable">t</span>)) <span class="hl-combinator">&gt;</span>(<span class="hl-variable">s</span>', <span class="hl-variable">t</span>')<span class="hl-combinator">&gt;</span>
      ( <span class="hl-site">Ift</span> (<span class="hl-variable">s</span>' <span class="hl-operator">+</span> <span class="hl-literal">1</span> <span class="hl-operator">&lt;:</span> <span class="hl-variable">t</span>') <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">swap</span>(<span class="hl-variable">s</span>', <span class="hl-variable">t</span>') <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">part</span>(<span class="hl-variable">p</span>, <span class="hl-variable">s</span>'<span class="hl-operator">+</span><span class="hl-literal">1</span>, <span class="hl-variable">t</span>'<span class="hl-operator">-</span><span class="hl-literal">1</span>)
      <span class="hl-combinator">|</span> <span class="hl-site">Ift</span> (<span class="hl-variable">s</span>' <span class="hl-operator">+</span> <span class="hl-literal">1</span> <span class="hl-operator">=</span> <span class="hl-variable">t</span>') <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-site">swap</span>(<span class="hl-variable">s</span>', <span class="hl-variable">t</span>') <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">s</span>'
      <span class="hl-combinator">|</span> <span class="hl-site">Ift</span> (<span class="hl-variable">s</span>' <span class="hl-operator">+</span> <span class="hl-literal">1</span> <span class="hl-operator">:&gt;</span> <span class="hl-variable">t</span>') <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">t</span>'
      )

  <span class="hl-comment">{- Sort the elements -}</span>
  <span class="hl-keyword">def</span> <span class="hl-site">sort</span>(<span class="hl-variable">s</span>, <span class="hl-variable">t</span>) <span class="hl-operator">=</span>
     <span class="hl-keyword">if</span> <span class="hl-variable">s</span> <span class="hl-operator">&gt;=</span> <span class="hl-variable">t</span> <span class="hl-keyword">then</span> <span class="hl-keyword">signal</span>
     <span class="hl-keyword">else</span> <span class="hl-site">part</span>(<span class="hl-site">a</span>(<span class="hl-variable">s</span>)<span class="hl-operator">?</span>, <span class="hl-variable">s</span><span class="hl-operator">+</span><span class="hl-literal">1</span>, <span class="hl-variable">t</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">m</span><span class="hl-combinator">&gt;</span>
          <span class="hl-site">swap</span>(<span class="hl-variable">m</span>, <span class="hl-variable">s</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
          (<span class="hl-site">sort</span>(<span class="hl-variable">s</span>, <span class="hl-variable">m</span><span class="hl-operator">-</span><span class="hl-literal">1</span>), <span class="hl-site">sort</span>(<span class="hl-variable">m</span><span class="hl-operator">+</span><span class="hl-literal">1</span>, <span class="hl-variable">t</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
          <span class="hl-keyword">signal</span>

  <span class="hl-site">sort</span>(<span class="hl-literal">0</span>, <span class="hl-variable">a</span>.<span class="hl-site">length</span>()<span class="hl-operator">-</span><span class="hl-literal">1</span>)
  
<span class="hl-site">quicksort</span>([<span class="hl-literal">1</span>,<span class="hl-literal">3</span>,<span class="hl-literal">2</span>])</pre><p>
The function <code class="code"><span class="hl-variable">part</span></code> partitions the subarray given by indices
<code class="code"><span class="hl-variable">s</span></code> through <code class="code"><span class="hl-variable">t</span></code> into two partitions, one containing values
less than or equal to <code class="code"><span class="hl-variable">p</span></code> and the other containing values &gt; <code class="code"><span class="hl-variable">p</span></code>.  The last index of the lower partition is returned.
The value at <code class="code"><span class="hl-site">a</span>(<span class="hl-variable">s</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)</code> is assumed to be less than or equal to <code class="code"><span class="hl-variable">p</span></code> --- this is satisfied
by choosing <code class="code"><span class="hl-variable">p</span> <span class="hl-operator">=</span> <span class="hl-site">a</span>(<span class="hl-variable">s</span><span class="hl-operator">-</span><span class="hl-literal">1</span>)<span class="hl-operator">?</span></code> initially.  To create the partitions, <code class="code"><span class="hl-variable">part</span></code>
calls two auxiliary functions <code class="code"><span class="hl-variable">lr</span></code> and <code class="code"><span class="hl-variable">rl</span></code> concurrently.  These
functions scan from the left and right of the subarray respectively, looking
for out-of-place elements.  Once two such elements have been found, they are
swapped using the auxiliary function <code class="code"><span class="hl-variable">swap</span></code>, and then the unscanned portion
of the subarray is partitioned further.  Partitioning is complete when the
entire subarray has been scanned.
</p><p>
This program uses the syntactic sugar <code class="code"><span class="hl-variable">x</span><span class="hl-operator">?</span></code> for <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">read</span>()</code>
and <code class="code"><span class="hl-variable">x</span> <span class="hl-operator">:=</span> <span class="hl-variable">y</span></code> for <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">write</span>(<span class="hl-variable">y</span>)</code>.  Also note that the expression
<code class="code"><span class="hl-site">a</span>(<span class="hl-variable">i</span>)</code> returns a reference to the element of array <code class="code"><span class="hl-variable">a</span></code> at index
<code class="code"><span class="hl-variable">i</span></code>, counting from 0.
</p></div><div class="section" title="2.3.5.&nbsp;Meeting Scheduler"><div class="titlepage"><div><div><h3 class="title"><a name="N10FC2"></a>2.3.5.&nbsp;Meeting Scheduler</h3></div></div></div><p>
Orc makes very few assumptions about the behaviors of services it uses. Therefore
it is straightforward to write programs which interact with human agents and
network services.  This makes Orc especially suitable for encoding
<em class="firstterm">workflows</em>, the coordination of multiple activities
involving multiple participants.  The following program illustrates a simple
workflow for scheduling a business meeting.  Given a list of people and a date
range, the program asks each person when they are available for a meeting.  It
then combines all the responses, selects a meeting time which is acceptable to
everyone, and notifies everyone of the selected time.
</p><pre class="programlisting">
<span class="hl-keyword">include</span> <span class="hl-literal">"net.inc"</span>
<span class="hl-keyword">val</span> <span class="hl-variable">during</span> <span class="hl-operator">=</span> <span class="hl-site">Interval</span>(<span class="hl-site">LocalDate</span>(<span class="hl-literal">2009</span>, <span class="hl-literal">9</span>, <span class="hl-literal">10</span>),
                      <span class="hl-site">LocalDate</span>(<span class="hl-literal">2009</span>, <span class="hl-literal">10</span>, <span class="hl-literal">17</span>))
<span class="hl-keyword">val</span> <span class="hl-variable">invitees</span> <span class="hl-operator">=</span> [<span class="hl-literal">"john@example.com"</span>, <span class="hl-literal">"jane@example.com"</span>]

<span class="hl-keyword">def</span> <span class="hl-site">invite</span>(<span class="hl-variable">invitee</span>) <span class="hl-operator">=</span>
  <span class="hl-site">Form</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">f</span><span class="hl-combinator">&gt;</span>
  <span class="hl-variable">f</span>.<span class="hl-site">addPart</span>(<span class="hl-site">DateTimeRangesField</span>(<span class="hl-literal">"times"</span>,
    <span class="hl-literal">"When are you available for a meeting?"</span>, <span class="hl-variable">during</span>, <span class="hl-literal">9</span>, <span class="hl-literal">17</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-variable">f</span>.<span class="hl-site">addPart</span>(<span class="hl-site">Button</span>(<span class="hl-literal">"submit"</span>, <span class="hl-literal">"Submit"</span>)) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">SendForm</span>(<span class="hl-variable">f</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">receiver</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">SendMail</span>(<span class="hl-variable">invitee</span>, <span class="hl-literal">"Meeting Request"</span>, <span class="hl-variable">receiver</span>.<span class="hl-site">getURL</span>()) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
  <span class="hl-variable">receiver</span>.<span class="hl-site">get</span>() <span class="hl-combinator">&gt;</span><span class="hl-variable">response</span><span class="hl-combinator">&gt;</span>
  <span class="hl-variable">response</span>.<span class="hl-site">get</span>(<span class="hl-literal">"times"</span>)

<span class="hl-keyword">def</span> <span class="hl-site">notify</span>([]) <span class="hl-operator">=</span>
  <span class="hl-site">each</span>(<span class="hl-variable">invitees</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">invitee</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">SendMail</span>(<span class="hl-variable">invitee</span>, <span class="hl-literal">"Meeting Request Failed"</span>,
                    <span class="hl-literal">"No meeting time found."</span>)
<span class="hl-keyword">def</span> <span class="hl-site">notify</span>(<span class="hl-variable">first</span><span class="hl-operator">:</span><span class="hl-variable">_</span>) <span class="hl-operator">=</span>
  <span class="hl-site">each</span>(<span class="hl-variable">invitees</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">invitee</span><span class="hl-combinator">&gt;</span>
  <span class="hl-site">SendMail</span>(<span class="hl-variable">invitee</span>, <span class="hl-literal">"Meeting Request Succeeded"</span>,
                    <span class="hl-variable">first</span>.<span class="hl-site">getStart</span>())

<span class="hl-site">map</span>(<span class="hl-variable">invite</span>, <span class="hl-variable">invitees</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">responses</span><span class="hl-combinator">&gt;</span>
<span class="hl-site">afold</span>(<span class="hl-keyword">lambda</span> (<span class="hl-variable">a</span>,<span class="hl-variable">b</span>) <span class="hl-operator">=</span> <span class="hl-variable">a</span>.<span class="hl-site">intersect</span>(<span class="hl-variable">b</span>), <span class="hl-variable">responses</span>) <span class="hl-combinator">&gt;</span><span class="hl-variable">times</span><span class="hl-combinator">&gt;</span>
<span class="hl-site">notify</span>(<span class="hl-variable">times</span>)</pre><p>
This program begins with declarations of <code class="code"><span class="hl-variable">during</span></code> (the date range for the
proposed meeting) and <code class="code"><span class="hl-variable">invitees</span></code> (the list of people to invite represented
by email addresses).
</p><p>
The <code class="code"><span class="hl-variable">invite</span></code> function obtains possible meeting times from a given invitee, as
follows.  First it uses library sites (<code class="code"><span class="hl-variable">Form</span></code>, <code class="code"><span class="hl-variable">DateTimeRangesField</span></code>,
<code class="code"><span class="hl-variable">Button</span></code>, and <code class="code"><span class="hl-variable">SendForm</span></code>) to construct a web form which may be used to
submit possible meeting times.  Then it emails the URL of this form to the
invitee and blocks waiting for a response.  When the invitee receives the
email, he or she will use a web browser to visit the URL, complete the form,
and submit it.  The corresponding execution of <code class="code"><span class="hl-variable">invite</span></code> receives the
response in the variable <code class="code"><span class="hl-variable">response</span></code> and extracts the chosen meeting times.
</p><p>
The <code class="code"><span class="hl-variable">notify</span></code> function takes a list of possible meeting times, selects the
first meeting time in the list, and emails everyone with this time.  If the
list of possible meeting times is empty, it emails everyone indicating that no
meeting time was found.
</p><p>
The goal expression of the program uses the library function <code class="code"><span class="hl-variable">map</span></code> to
apply <code class="code"><span class="hl-variable">notify</span></code> to each invitee and collect the responses in a list. It
then uses the library function <code class="code"><span class="hl-variable">afold</span></code> to intersect all of the responses.
The result is a set of meeting times which are acceptable to everyone. Finally,
<code class="code"><span class="hl-variable">notify</span></code> is called to select one of these times and notify everyone of the result.
</p><p>
This program may be extended to add more sophisticated features, such as a
quorum (to select a meeting as soon as some subset of invitees responds) or
timeouts (to remind invitees if they don't respond in a timely manner).  These
modifications are local and do not affect the overall structure of the program.
For complete details, see <a class="link" href="http://orc.csres.utexas.edu/tryorc.shtml" target="_top">examples on our website</a>.
</p></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N10984" id="ftn.N10984" class="para">1</a>] </sup>R. Milner. <em class="citetitle">Communicating and Mobile Systems:
the &#960;-Calculus</em>. Cambridge University Press, May
1999.</p></div><div class="footnote"><p><sup>[<a href="#N1098B" id="ftn.N1098B" class="para">2</a>] </sup>J. Armstrong, R.
Virding, C. Wikstr&ouml;m, and M. Williams. <em class="citetitle">Concurrent programming in
ERLANG (2nd ed.)</em>. Prentice Hall International (UK) Ltd.,
Hertfordshire, UK, UK, 1996.</p></div><div class="footnote"><p><sup>[<a href="#N10EA2" id="ftn.N10EA2" class="para">3</a>] </sup>D. J. Lehmann and M. O. Rabin. On the advantages of free choice: A symmetric
and fully distributed solution to the dining philosophers problem. In <span class="emphasis"><em>POPL</em></span>, pages
133&ndash;138, 1981.</p></div><div class="footnote"><p><sup>[<a href="#N10F67" id="ftn.N10F67" class="para">4</a>] </sup>C. A. R. Hoare. Partition: Algorithm 63, Quicksort: Algorithm 64, and
Find: Algorithm 65. <span class="emphasis"><em>Communications of the ACM</em></span>,
4(7):321&ndash;322, 1961.</p></div></div></div></div><script type="text/javascript" src="/orchard/orc.js"></script></body></html>