<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title></title><link href="style.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#language">1. The Orc Programming Language</a></span></dt><dd><dl><dt><span class="section"><a href="#N2001A">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#language.base">1.2. Base Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#N20044">Constants</a></span></dt><dt><span class="section"><a href="#N2007F">Variables</a></span></dt><dt><span class="section"><a href="#N20087">Call</a></span></dt><dt><span class="section"><a href="#language.base.oeprators">Operators</a></span></dt><dt><span class="section"><a href="#N20199">If</a></span></dt><dt><span class="section"><a href="#N201BA">Data structures</a></span></dt><dt><span class="section"><a href="#N201F0">Messages</a></span></dt><dt><span class="section"><a href="#N20237">Stop</a></span></dt></dl></dd><dt><span class="section"><a href="#language.combinators">1.3. Combinators</a></span></dt><dd><dl><dt><span class="section"><a href="#language.combinators.bar">Bar ( | )</a></span></dt><dt><span class="section"><a href="#language.combinators.push">Push ( &gt;&gt; )</a></span></dt><dt><span class="section"><a href="#language.combinators.pull">Pull ( &lt;&lt; )</a></span></dt><dt><span class="section"><a href="#language.combinators.before">Before ( ; )</a></span></dt></dl></dd><dt><span class="section"><a href="#language.patterns">1.4. Patterns</a></span></dt><dd><dl><dt><span class="section"><a href="#N202EE">Syntax</a></span></dt><dt><span class="section"><a href="#N203CF">Occurrences</a></span></dt><dt><span class="section"><a href="#N20406">Patterns as views</a></span></dt></dl></dd><dt><span class="section"><a href="#language.declarations">1.5. Declarations</a></span></dt><dd><dl><dt><span class="section"><a href="#language.declarations.val">Val</a></span></dt><dt><span class="section"><a href="#N20451">Functions</a></span></dt><dt><span class="section"><a href="#N204DC">Services</a></span></dt><dt><span class="section"><a href="#N20503">Includes</a></span></dt></dl></dd><dt><span class="section"><a href="#N2050F">1.6. Comments</a></span></dt></dl></dd></dl></div>


<span class="date"></span>

<div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="language"></a>Chapter&nbsp;1.&nbsp;The Orc Programming Language</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#N2001A">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#language.base">1.2. Base Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#N20044">Constants</a></span></dt><dt><span class="section"><a href="#N2007F">Variables</a></span></dt><dt><span class="section"><a href="#N20087">Call</a></span></dt><dt><span class="section"><a href="#language.base.oeprators">Operators</a></span></dt><dt><span class="section"><a href="#N20199">If</a></span></dt><dt><span class="section"><a href="#N201BA">Data structures</a></span></dt><dt><span class="section"><a href="#N201F0">Messages</a></span></dt><dt><span class="section"><a href="#N20237">Stop</a></span></dt></dl></dd><dt><span class="section"><a href="#language.combinators">1.3. Combinators</a></span></dt><dd><dl><dt><span class="section"><a href="#language.combinators.bar">Bar ( | )</a></span></dt><dt><span class="section"><a href="#language.combinators.push">Push ( &gt;&gt; )</a></span></dt><dt><span class="section"><a href="#language.combinators.pull">Pull ( &lt;&lt; )</a></span></dt><dt><span class="section"><a href="#language.combinators.before">Before ( ; )</a></span></dt></dl></dd><dt><span class="section"><a href="#language.patterns">1.4. Patterns</a></span></dt><dd><dl><dt><span class="section"><a href="#N202EE">Syntax</a></span></dt><dt><span class="section"><a href="#N203CF">Occurrences</a></span></dt><dt><span class="section"><a href="#N20406">Patterns as views</a></span></dt></dl></dd><dt><span class="section"><a href="#language.declarations">1.5. Declarations</a></span></dt><dd><dl><dt><span class="section"><a href="#language.declarations.val">Val</a></span></dt><dt><span class="section"><a href="#N20451">Functions</a></span></dt><dt><span class="section"><a href="#N204DC">Services</a></span></dt><dt><span class="section"><a href="#N20503">Includes</a></span></dt></dl></dd><dt><span class="section"><a href="#N2050F">1.6. Comments</a></span></dt></dl></div>

<p>
In this chapter, we describe the full capabilities of the Orc programming language. This is intended
to be a comprehensive reference for the Orc programmer.  
</p>

<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N2001A"></a>1.1.&nbsp;Introduction</h2></div></div></div>
<p>
Orc more strongly resembles functional programming languages such as Haskell and ML than imperative
languages such as Java and C. The reader is assumed to have at least a passing familiarity with the
concept of variable binding (as opposed to variable assignment), as encountered in functional
languages, as well as lexical scope. It may also help to be familiar with the concepts of lexical 
closure and pattern matching.
</p>

<p>
An Orc program is a structured expressions which does computation, invokes services, and then
<em class="firstterm">publishes</em> some number of values. Publishing a value is similar to
returning a value in other languages, except that an expression may publish multiple times,
or it might never publish at all. An expression which never publishes is called 
<em class="firstterm">silent</em>.
</p>

<p>
An Orc program is built up from <a class="link" href="#language.base" title="1.2.&nbsp;Base Expressions">base expressions</a>, the simplest 
programs. These are connected by <a class="link" href="#language.combinators" title="1.3.&nbsp;Combinators">combinators</a> to form 
larger expressions. Such expressions may also be enclosed by 
<a class="link" href="#language.declarations" title="1.5.&nbsp;Declarations">declarations</a> which define functions, compute values, or 
introduce new sites. Orc expressions are always compositional: two expressions joined by a combinator
form an expression, and an expression prefixed by a declaration also forms an expression.
</p>
</div>




<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="language.base"></a>1.2.&nbsp;Base Expressions</h2></div></div></div>
<p>
An Orc program is built up from base expressions. A base expression on its own is always a valid Orc program. 
</p>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20044"></a>Constants</h3></div></div></div>
<p>
The simplest program one can write is a constant value. Orc supports the following set of constants:

<div class="itemizedlist"><ul type="disc"><li>
<p>
Integer constants: <code class="code">( ... -1, 0, 1 ... )</code>
</p>
</li><li>
<p>
Booleans: <code class="code">true</code> and <code class="code">false</code>
</p>
</li><li>
<p>
Strings: <code class="code">"orc"</code>, <code class="code">"ceci n'est pas une |"</code>
</p>
</li><li>
<p>
A special value <code class="code">signal</code>, which carries no information (analagous to the unit value <code class="code">()</code> in ML). 
</p>
</li></ul></div>
</p>

<p>
When evaluated, a constant simply publishes that value immediately.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N2007F"></a>Variables</h3></div></div></div>
<p>
An identifier on its own is a valid expression; it represents a variable. It waits for that variable to 
be bound, and then publishes that bound value. If the variable is already bound when the expression is 
evaluated, its bound value is published immediately. The expression never publishes if the variable never
becomes bound.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20087"></a>Call</h3></div></div></div>
<p>
An identifier followed by a parenthesized sequence of <em class="firstterm">arguments</em> is a call.
A call may have zero arguments, in which case we write an identifier followed by empty parens <code class="code">()</code>.
The identifier is a variable which names the value that will be called. For now, we assume that
the arguments are either variables or constants.  
</p>

<p>
A call does nothing until the identifier is bound to a value (the <em class="firstterm">target</em>).
Once the target is known, the behavior of the call depends on whether the target is a site or a 
<a class="link" href="#"> defined function</a>.

<div class="itemizedlist"><ul type="disc"><li>
If the target is a site, the call subsequently waits for each variable argument to be bound;
we say that calls to sites are <em class="firstterm">strict</em> since they must wait for all of
their arguments to be bound. Once the values of all of the arguments are known (constants
are always known and variables are known once they have bound values), the service associated
with that site is invoked with those values. The call waits for the service to respond with
a value. If the service responds, the call publishes that value. The call acknowledges at most
one response from the service, so at most one publication occurs.  
</li><li>
If the target is a defined function, the call is replaced by the body of the function, 
where each of the call's arguments is substituted for the function's formal parameters in
the body (even if those arguments are unbound variables). We say that function calls are
<em class="firstterm">lenient</em> because they do not need to wait for their arguments to be
bound. 
</li></ul></div>

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
Any Orc expression can be used as an argument; see 
<a class="link" href="#language.combinators.pull.args">the pull combinator</a> for more details.
</div>

</p>


</div>
 

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.base.oeprators"></a>Operators</h3></div></div></div>
<p>
Orc supports a standard set of arithmetic, logical, and comparison operators. 
They are written in the usual infix style, and have C-like precedence. 


<div class="informaltable"><a name="ops-table"></a> 



<table border="0" width="80%"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th colspan="2" align="left">Arithmetic</th><th colspan="2" align="left">Comparison</th><th colspan="2" align="left">Logical</th></tr></thead><tbody><tr><td align="left"><code class="code">+</code></td><td align="left">addition</td><td align="left"><code class="code">=</code></td><td align="left">equality</td><td align="left"><code class="code">&amp;&amp;</code></td><td align="left">logical and</td></tr><tr><td align="left"><code class="code">-</code></td><td align="left">subtraction</td><td align="left"><code class="code">/=</code></td><td align="left">inequality</td><td align="left"><code class="code">||</code></td><td align="left">logical or</td></tr><tr><td align="left"><code class="code">*</code></td><td align="left">multiplication</td><td align="left"><code class="code">&lt;</code></td><td align="left">less than</td><td align="left"><code class="code">~</code></td><td align="left">logical not</td></tr><tr><td align="left"><code class="code">/</code></td><td align="left">division</td><td align="left"><code class="code">&gt;</code></td><td align="left">greater than</td><td colspan="2" align="left">&nbsp;</td></tr><tr><td align="left"><code class="code">%</code></td><td align="left">modulus</td><td align="left"><code class="code">&lt;=</code></td><td align="left">less than or equal</td><td colspan="2" align="left">&nbsp;</td></tr><tr><td colspan="2" align="left">&nbsp;</td><td align="left"><code class="code">&gt;=</code></td><td align="left">greater than or equal</td><td colspan="2" align="left">&nbsp;</td></tr></tbody></table>
</div>

</p>

<p>
These operators are actually sites, and behave like sites; they differ only in syntax. 
Accordingly, any Orc expression can be used as an operand; it undergoes the same 
<a class="link" href="#language.combinators.pull.args">translation</a> as an argument to a call.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20199"></a>If</h3></div></div></div>
<p>
The expression <code class="code">if(b)</code>, where <code class="code">b</code> is some boolean expression,
will publish a signal if <code class="code">b</code> evaluates to true, and otherwise remains silent.
<code class="code">if</code> is used together with the <a class="link" href="#language.combinators.push" title="Push ( >> )">push
combinator</a> to form conditional expressions.
</p>

<p>
<code class="code">if</code> is a site; it is called a <em class="firstterm">fundamental site</em> because it
is always available.
</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N201BA"></a>Data structures</h3></div></div></div>
<p>
Orc supports two basic data structures:

<div class="itemizedlist"><ul type="disc"><li>
A <em class="firstterm">tuple</em> is a comma-separated sequence of arguments enclosed
by parentheses. It looks like a call without a preceding identifier: <code class="code">(x,2,y)</code>. 
A tuple must have at least two arguments. Like a site call, a tuple waits for each of its 
arguments to become bound. Then, it publishes a tuple value containing each of those bound values.
</li><li>
A <em class="firstterm">list</em> is a comma-separated sequence of arguments enclosed by
square brackets: <code class="code">[2,11,0]</code>. It may be of any length, including zero; the
empty list is written <code class="code">[]</code>. A list can also be extended using the 
<em class="firstterm">cons</em> operation, written <code class="code">h:t</code>, which publishes a new 
list whose first element is <code class="code">h</code> and whose tail is <code class="code">t</code>.  
</li></ul></div>
</p>

<p>
Again, as with operators, each data structuring operation is actually a site call.
</p>

<p>
To learn more about inspecting and using these data structures after they have been
created, read about <a class="link" href="#language.patterns" title="1.4.&nbsp;Patterns">patterns</a>.
</p>

</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N201F0"></a>Messages</h3></div></div></div>
<p>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code class="code">obj.m()</code> calls the method
<code class="code">m</code> of the object <code class="code">obj</code>. 
</p>

<p>
There is a special kind of call in Orc which serves a similar purpose. One may write
<code class="code">x.msg</code>, for any identifiers <code class="code">x</code> and <code class="code">msg</code>. This attempts
to send the <em class="firstterm">message</em> 'msg' to the value bound to <code class="code">x</code>. 
The message may not be understood, in which case no publication occurs. 
</p>

<p>
Typically this capability is used so that sites may be treated like objects, with multiple
methods and fields. For example, a channel <code class="code">c</code> might understand the messages
<code class="code">get</code> and <code class="code">put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code class="code">c.get()</code>, or <code class="code">c.put(6)</code>.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
Such calls actually occur in two steps: first <code class="code">c.put</code> sends the message
<code class="code">put</code> to the value <code class="code">c</code>; this publishes a site whose only purpose
is to put values to that channel. Then, that 'put site' is called on the argument
<code class="code">6</code>, sending 6 on that channel. Readers familiar with functional programming
will recognize this technique as <span class="emphasis"><em>currying</em></span>.
</div>
</p>



</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20237"></a>Stop</h3></div></div></div>
<p>
<code class="code">stop</code> is a special base expression which is silent and does no computation. 
It is typically used together with a <a class="link" href="#language.combinators.push" title="Push ( >> )">push</a>
to silence the publications of another expression.
</p>
</div>



</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="language.combinators"></a>1.3.&nbsp;Combinators</h2></div></div></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.combinators.bar"></a>Bar ( <code class="code">|</code> )</h3></div></div></div>
<p>
The bar combinator <code class="code">|</code> executes two expressions in parallel, 
and publishes each of their publications as they occur. It is associative and commutative. 
</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.combinators.push"></a>Push ( <code class="code">&gt;&gt;</code> )</h3></div></div></div>

<p>
The push combinator <code class="code">&gt;x&gt;</code> executes its left side; for each publication on the left side, 
a new copy of the right side starts, with the variable <code class="code">x</code> bound to that published value.
</p>

<p>
A push can be written as <code class="code">&gt;&gt;</code>, with no variable name, which behaves similarly except that
no variable binding occurs.
</p>

<p>
The variable name within the combinator may be replaced with an arbitrary pattern 
(see <a class="link" href="#language.patterns" title="1.4.&nbsp;Patterns">Patterns</a>). 
</p>

<p>
Pushing is right-associative, and it has higher precedence than bar.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.combinators.pull"></a>Pull ( <code class="code">&lt;&lt;</code> )</h3></div></div></div>
<p>
The pull combinator executes its left and right sides in parallel. 
Calls using <code class="code">x</code> on the left side block until it is bound. 
The first publication of the right side is bound to <code class="code">x</code>;
this causes the rest of the right side to stop executing. That
expression may not evaluate further; any site calls already in progress
will continue, but their return values will be ignored.
</p>

<p>
A pull can be written as <code class="code">&lt;&lt;</code>, with no variable name, which behaves similarly except that
no variable binding occurs. 
</p>

<p>
The variable name within the combinator may be replaced with an arbitrary pattern 
(see <a class="link" href="#language.patterns" title="1.4.&nbsp;Patterns">Patterns</a>). 
</p>

<p>
Pulling is left-associative, and it has lower precedence than bar.
</p>

<p><a name="language.combinators.pull.args"></a>
A call may be written with complex expressions as arguments. This is actually a shorthand for using a pull
to evaluate each of those expressions and bind its result to a variable. For example,

<pre class="programlisting">
M(x+5, 4, N() | R())
</pre>

is just another way of writing

<pre class="programlisting">
M(y, 4, z)
	&lt;y&lt; x+5
	&lt;z&lt; N() | R()
</pre>

Thus, all of the rules governing pull apply to using an expression as an argument: it may publish at most one
value, and it terminates when it publishes a value.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.combinators.before"></a>Before ( <code class="code">;</code> )</h3></div></div></div>
<p>
The before combinator executes its left side, publishing each of its publications as they occur.
When the left side has completely finished executing (i.e. it is equivalent to <a class="link" href="#"><code class="code">stop</code></a>), then the right side executes.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
The before combinator is intended to capture as closely as possible the notion of sequential
processing, as denoted by <code class="code">;</code> in other languages. It was not present in the
original formulation of the Orc concurrency calculus; it has been added to support computation
and iteration over strictly finite data. 
</div>

</p>

</div>



</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="language.patterns"></a>1.4.&nbsp;Patterns</h2></div></div></div>

<p>
A <em class="firstterm">pattern</em> is a special construct that may take the place of a variable binding. It examines the structure
of a published value, rather than simply binding that value to a single variable. It may <em class="firstterm">match</em> the value, 
capturing components of the value, and then bind those component values to variables or publish them. Or, it may <em class="firstterm">refuse</em> 
the value, silencing that publication entirely. A pattern is called <em class="firstterm">refutable</em> if it can refuse a value;
otherwise it is <em class="firstterm">irrefutable</em>. 
</p>



<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
<p>
Whenever possible, the structure of a pattern mimics the structure of an expression that would publish a value recognized by that pattern.
For example, the pattern <code class="code">(x,[y,z])</code> matches the value published by the expression <code class="code">(true,[3,4])</code>. However, the
converse is not true: if a pattern matches a value, the source of that value is not necessarily an expression with the same structure.
This is particularly true when <a class="link" href="#">views</a> are used. 
</p>
</div>




<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N202EE"></a>Syntax</h3></div></div></div>

<p>
This section describes the syntax of patterns. All patterns are assumed to be refutable 
unless stated otherwise. 
</p>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N202F5"></a>Variable</h4></div></div></div>
<p>
Variables are the most basic patterns.
A variable pattern simply binds the matched value to that variable. 
It is an irrefutable pattern. 
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
Patterns must be <em class="firstterm">linear</em>, meaning that a 
pattern may not mention the same variable more than once.
</div>
</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20303"></a>Wildcard</h4></div></div></div>
<p>
A wildcard pattern, written <code class="code">_</code>,  matches any value, and does not bind any variables. 
It is the same as binding a variable which is not used anywhere. Like variables, wildcards are irrefutable.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
The empty push (<code class="code">&gt;&gt;</code>) and empty pull (<code class="code">&lt;&lt;</code>) combinator forms 
are just shorthand for (<code class="code">&gt;_&gt;</code>) and (<code class="code">&lt;_&lt;</code>) respectively.
</div> 

</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N2031D"></a>Literal</h4></div></div></div>
A literal pattern can be any <a class="link" href="#">constant value</a>.
It will only match that value, and will refuse any others.
</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20326"></a>Tuple</h4></div></div></div>
<p>
A tuple of patterns matches only a tuple value of exactly the same size; it refuses any other value.
It recursively matches the elements of the tuple against its own member patterns.
A tuple pattern must contain at least two subpatterns.
</p>

<p>
For example, the expression

<pre class="programlisting">
( (1,2) | (1,3) | (5,4) )  &gt;(1,x)&gt;  x
</pre>

will publish <code class="code">2</code> and <code class="code">3</code> but not <code class="code">4</code>, because the pattern 
<code class="code">(1,x)</code> refuses the value <code class="code">(5,4)</code>.
</p>

</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20343"></a>List</h4></div></div></div>
<p>
A list of patterns matches a list value of exactly the same length, refusing any other value.
It recursively matches each item of the list value against each of its member patterns. 
A list pattern may have any number of subpatterns, including zero.
</p>

<p>
For example, the expression

<pre class="programlisting">
( [4] | [5,6] | [7,8,9] )  &gt;[x,y]&gt;  x+y
</pre>

publishes only <code class="code">11</code>; the pattern refuses the other two lists because they are of the wrong length.
</p>

</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20354"></a>Cons</h4></div></div></div>
<p>
It is also possible to use the cons (<code class="code">:</code>) operator in a pattern, to split a list into its head and tail.

<pre class="programlisting">
[1,2,3]  &gt;h:t&gt;  ( h | t )
</pre>

This publishes <code class="code">1</code> and <code class="code">[2,3]</code>. 

Note that a cons pattern refuses the empty list.

</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20368"></a>Bang</h4></div></div></div>

<p>
A bang pattern, written <code class="code">!p</code>, will publish the value that matches the pattern 
<code class="code">p</code> if the match is successful. This pattern is refutable only if <code class="code">p</code> is refutable.

<pre class="programlisting">
(1,2,3)  &gt;(x,!y,!z)&gt; stop
</pre>

This publishes <code class="code">2</code> and <code class="code">3</code>. 
</p>

<p>
Note that a bang pattern will not publish if the overall match fails, even if its particular match succeeds:

<pre class="programlisting">
( (1,2,3) | (4,5,6) )  &gt;(1,!x,y)&gt;  stop
</pre>

This publishes only <code class="code">2</code>. Even though the pattern <code class="code">x</code> matches the value <code class="code">5</code>, 
the overall pattern <code class="code">(1,!x,y)</code> refuses the value <code class="code">(4,5,6)</code>, so <code class="code">5</code> is not published.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N2039A"></a>As</h4></div></div></div>
<p>
The pattern <code class="code">p as x</code> can be used to capture a whole subpattern <code class="code">p</code> and bind it to the variable <code class="code">x</code>.
This pattern is refutable only if <code class="code">p</code> is refutable.

<pre class="programlisting">
(1,(2,3))  &gt;(x,(2,z) as w)&gt;  w
</pre>

This publishes <code class="code">(2,3)</code>.
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N203B4"></a>Site</h4></div></div></div>
<p>
A site pattern, written <code class="code">M(p,...,p)</code>, matches any value which was published by a call to the
site <code class="code">M</code> with arguments that match the tuple <code class="code">(p,...,p)</code>. 
</p>

<p>
Site patterns provide a generalized version of datatype matching, as seen in the <code class="code">case .. of</code>
 or <code class="code">match .. with </code> constructs provided by Haskell and ML.
</p> 
 
</div>


</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N203CF"></a>Occurrences</h3></div></div></div>
<p>These are the syntactic contexts in which a pattern may replace a normal variable binding.
The effect of a pattern may be subtly different depending on the syntactic context in which it appears.</p>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N203D6"></a>In a push</h4></div></div></div>
<p>
A pattern may replace the variable name in a push combinator. When the left side publishes a value, that value
is checked against the pattern. If it matches, a new copy of the right hand side starts with all of the pattern's
variables bound in it. If the pattern refuses the value, that publication is ignored; no new copy of the right
hand side is created.
</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N203DE"></a>In a pull</h4></div></div></div>
<p>
A pattern may replace the variable name in a pull combinator. When the right side publishes a value, that value
is checked against the pattern. If it matches, the pattern's variables become bound in the left side and the
right side terminates, as expected. However, if the pattern refuses the value, then the publication is ignored
and the right side continues to execute as normal.
</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N203E6"></a>In a <code class="code">val</code> declaration</h4></div></div></div>
<p>
A pattern may replace the variable name in a 
<a class="link" href="#language.declarations.val" title="Val"><code class="code">val</code> declaration</a>. Since a val is just a shorthand
for writing a pull, its behavior is exactly the same: whenever the expression publishes a value, it is checked
against the pattern; if the pattern refuses, the publication is ignored and the expression continues executing,
whereas if if matches, the pattern's variables are bound and the expression terminates.
</p>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N203F7"></a>As function arguments</h4></div></div></div>
<p>
A pattern may replace any formal parameter in a function clause. Whenever that function is called, its
arguments are matched against the argument patterns of each clause in linear order. If every argument
pattern of a clause matches, then the patterns' variables are bound in that clause's body and the body
executes. Otherwise, the next clause is tried.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3> 
Since function calls in Orc are not strict, some of the arguments may not be bound when they are matched
against a pattern. If an unbound argument is matched against a <span class="emphasis"><em>refutable</em></span> pattern,
then that match waits for the variable to become bound, since it is impossible to tell if the pattern
will refuse without knowing the bound value. 
</div>
</p>
</div>

</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20406"></a>Patterns as views</h3></div></div></div>
<p>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <em class="firstterm">view</em> of that data.
</p>

<p>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</p>




</div>


</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="language.declarations"></a>1.5.&nbsp;Declarations</h2></div></div></div>

<p>
In addition to using combinators, Orc expressions can also be built up by adding declarations. 
A declaration is a directive that precedes an expression. It does not publish any values on its
own; instead introducing one or more new identifiers so that they can be used in that expression. 
The expression following a declaration is called the <em class="firstterm">scoped expression</em> 
of that declaration. 
</p>

<p>
Unless specifically stated otherwise, the scoped expression begins executing 
immediately, without waiting for the declaration to do any computation. If the scoped expression
reaches an identifier introduced by that declaration before the declaration has given it a value,
the identifier is considered unbound.
</p>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="language.declarations.val"></a>Val</h3></div></div></div>
<p>
The simplest declaration is a value declaration. It binds the first publication of an expression 
to a variable. It is written:
</p>

<p>
<code class="code">val x = </code><span class="emphasis"><em>expr</em></span>
</p>

<p>
 
This evaluates the expression <span class="emphasis"><em>expr</em></span> until it publishes a value, and then binds
that value to the variable <span class="emphasis"><em>x</em></span> and terminates <span class="emphasis"><em>expr</em></span>. It is a shorthand
for a pull combinator; if the scoped expression is <span class="emphasis"><em>g</em></span>, then writing this
declaration is exactly the same as writing:
</p>

<p>
<span class="emphasis"><em>g</em></span> <code class="code">&lt;x&lt;</code> <span class="emphasis"><em>expr</em></span>
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20451"></a>Functions</h3></div></div></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20455"></a>Introduction</h4></div></div></div>

<p>
<pre class="programlisting">
def E(x,y) = x | y | x+y
E(2,3)
</pre>
</p>

<p>
As discussed in the <a class="link" href="#">section on calls</a>, functions are lenient,
or 'call-by-name'. Function calls do not need to wait for all of their arguments to be bound

<pre class="programlisting">
E(a,b) 
    &lt;a&lt; stop
    &lt;b&lt; 4
</pre>

This will publish 4, even though the variable <code class="code">a</code> is never bound. 
The call <code class="code">E(a,b)</code> occurs immediately, effectively executing the 
expression <code class="code">a | b | a+b</code> in its place.

</p>


</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20473"></a>Recursion</h4></div></div></div>

Definitions can be recursive; that is, the name of a definition is bound in its own body.

<pre class="programlisting">
def countdown(n) = if(n &gt; 0) &gt;&gt; ( n | countdown(n-1) )
countdown(3)
</pre>

This publishes 3, 2, and 1. 

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N2047B"></a>Mutual Recursion</h4></div></div></div>

Mutual recursion is also supported: 

<pre class="programlisting">
def even(n) = 
  if(n &gt; 0) &gt;&gt; odd(n-1)
| if(n &lt; 0) &gt;&gt; odd(n+1)
| if(n = 0) &gt;&gt; true
def odd(n) = 
  if(n &gt; 0) &gt;&gt; even(n-1)
| if(n &lt; 0) &gt;&gt; even(n+1)
| if(n = 0) &gt;&gt; false
</pre>

There is no special keyword for mutual recursion; any contiguous sequence of definitions is assumed to be 
mutually recursive.


</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N20483"></a>Lexical Closure</h4></div></div></div>

<p>
Like any other declaration, a function definition may appear within the context of any expression. This
means that variables from that context may appear in the body of the function:

<pre class="programlisting">
val pi = 3.14159
def area(r) = pi * r * r
</pre>

Functions are also values in Orc, so the function <code class="code">area</code> might be published, and then called
in some other context. What happens to the variable <code class="code">pi</code>? It 'remembers' the value that it
had when the function <code class="code">area</code> was defined (3.14159), and uses that value, even if <code class="code">pi</code>
has a different value in the scope where the function is called: 

<pre class="programlisting">
val pi = 2.71828
area(10)
</pre>

This is called lexical closure: the body of the function is 'closed' because it remembers the values of all of its 
free variables, and the closure is 'lexical' because it occurs when the function is defined, not when
it is used.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
Lexical closure has an interesting subtlety when combined with variables that are in scope but have
not yet been bound to a value (such as pull variables). Since the closure must capture the values of
each of those variables, the closure operation itself must actually wait for all of those variables
to become bound. Thus, the function name itself is unbound until the closure can be created. 
</div>  

</p>


Definitions are actually values, just like any other value. Defining an expression creates a special 
value called a <code class="code">closure</code> and binds it. Thus, it can be published, or put into a data structure, 
like any other value:

<pre class="programlisting">
f(1) | f(3)
&lt;f&lt; 
(def E(x) = x+1
 E)
</pre>

This publishes 2 and 4. It defines the expression <code class="code">E</code>, then publishes that 
definition as a closure, which is then bound to the variable <code class="code">f</code> and called twice. 

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N204AC"></a>Anonymouns Functions</h4></div></div></div>
Sometimes one would like to create a closure directly without bothering to name the defined expression. 
There is a special keyword <code class="code">lambda</code> for this purpose:

<pre class="programlisting">
lambda (x) = x+1
{-    equivalent to (def E(x) = x+1  E)    -}
</pre>

</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N204B7"></a>Currying</h4></div></div></div>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N204BC"></a>Patterns</h4></div></div></div>

A defined expression, just like the push and pull combinators, may have patterns instead of variables as its arguments:

<pre class="programlisting">
def E([x,y]) = x | y
</pre>

This definition publishes two elements of a list, but only if its argument is in fact a two-element list. 
Otherwise, the call remains silent.

Note that using patterns as arguments interacts with the call-by-name semantics of defined expressions: 
if a pattern is refutable, then the body of the expression cannot execute until that argument is bound.


</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N204C4"></a>Clauses</h4></div></div></div>

<p>
A function may have multiple clauses, each of which has a sequence of patterns to match each formal argument, 
and a body expression. All clauses of a function must have the same number of arguments. Clauses are matched 
in linear order. 
</p> 


The combination of functions and pattern matching offers a much more powerful capability: 
<em class="firstterm">clausal</em> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. Here's an example:

<pre class="programlisting">
def sum([]) = 0
def sum(h:t) = h + sum(t)
</pre>

<code class="code">sum(L)</code> publishes the sum of the numbers in the list <code class="code">L</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.

Any contiguous sequence of definitions with the same name and different arguments is interpreted as 
a clausal definition, where each individual definition is a clause of the larger function. When the 
function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.

Mutual recursion and clausal definitions are allowed to occur together.
For example, this definition takes a list and publishes a new list with every other element repeated:

<pre class="programlisting">
def stutter([]) = []
def stutter(h:t) = h:h:mutter(t)
def mutter([]) = []
def mutter(h:t) = h:stutter(t)
</pre>

</div>



</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N204DC"></a>Services</h3></div></div></div>
<p>
Certain declarations are used to provide access to external services.
</p>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N204E3"></a>Sites</h4></div></div></div>

<p>
A <code class="code">site</code> declaration instantiates a Java object to be used as a site in an Orc program:

<pre class="programlisting">
{-  Define the Buffer site  -}
site Buffer = orc.lib.state.Buffer
</pre>
</p>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N204F1"></a>Classes</h4></div></div></div>
<p>

A <code class="code">class</code> declaration looks very similar to a <code class="code">site</code> declaration, 
but serves a different purpose. Rather than creating a Java object to be used as a site, 
this declaration actually creates a proxy for the class's constructor, which can then be 
invoked, and its publications used like Java objects by using the dot syntax:

<pre class="programlisting">
class Str = java.lang.String
val s = Str("foo")
s.concat("bar")
</pre>

Thus, it makes all of the capabilities of sequential Java programming, including its
large standard library, available to the Orc programmer. 

</p>

</div>

</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N20503"></a>Includes</h3></div></div></div>
<p>
An include declaration names a file containing a sequence of declarations. It loads all
of those declarations in the order given in the file, as if they had been written 
directly into the program at that point. This is a convenient way to organize large groups 
of declarations.

<pre class="programlisting">
{-  include some useful list functions  -}
include "inc/orc/list.inc"
</pre>

</p>

</div>

</div>


<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N2050F"></a>1.6.&nbsp;Comments</h2></div></div></div>
<p>
The implementation supports two kinds of comments.   

</p>

<p>
A line which begins with two dashes (<code class="code">--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<pre class="programlisting">
-- This is a single line comment.
	 -- This is also a single line comment.
</pre>
</p>

<p>
Multiline comments are enclosed by matching braces of the form <code class="code">{- -}</code>. 
Multiline comments may be nested. They may appear anywhere, even in the middle of an expression.

<pre class="programlisting">
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

1 | 2 {- They may appear anywhere, -} &gt;x&gt; {- even in the middle of an expression. -} x+3
</pre>

</p>

<p>
Commented regions are ignored by the compiler. They are often eliminated entirely by the parser, 
and do not appear in intermediate representations of a program.
</p>

</div>

</div>


 
</div></body></html>