<?xml version='1.0' encoding='UTF-8'?>
<appendix>
      <!--Generated by OrcDocgen from: {core.inc,idioms.inc,list.inc,reflect.inc,state.inc,text.inc,time.inc,util.inc} on Jan 5, 2011 3:45:02 PM-->
      <title>Standard Library</title>
      <section> 
      <title>core.inc</title>
      <para>Fundamental sites and operators.
</para><para>These declarations include both prefix and infix sites (operators).  For
consistency, all declarations are written in prefix form, with the site name
followed by the operands.  When the site name is surrounded in parentheses, as
in <code>(+)</code>, it denotes an infix operator.
</para><para>For a more complete description of the built-in operators and their syntax, see
the <link linkend="language.base.operators">Operators</link> section of the
User Guide.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>let</code></term>
      <listitem>
        <para><code>site let() :: Signal</code></para>
        <para>When applied to no arguments, return a signal.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>let</code></term>
      <listitem>
        <para><code>site let(A) :: A</code></para>
        <para>When applied to a single argument, return that argument (behaving as the identity function).
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>let</code></term>
      <listitem>
        <para><code>site let(A, ...) :: (A, ...)</code></para>
        <para>When applied to two or more arguments, return the arguments in a tuple.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>If</code></term>
      <listitem>
        <para><code>site If(Boolean) :: Signal</code></para>       
        <para>Fail silently if the argument is false. Otherwise return a signal.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Always publishes"
  If(false) >> "Never publishes"
| If(true) >> "Always publishes"]]></programlisting>
</para>
      </listitem> 
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Unless</code></term>
      <listitem>
        <para><code>site Unless(Boolean) :: Signal</code></para>
        <para>Fail silently if the argument is true. Otherwise return a signal.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Always publishes"
  Unless(false) >> "Always publishes"
| Unless(true) >> "Never publishes"]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>error</code></term>
      <listitem>
        <para><code>site error(String) :: Bot</code></para>
        <para>Halt with the given error message.
</para><para>Example, using <code>error</code> to implement assertions:
<programlisting language="orc-demo"><![CDATA[
def assert(b) =
  if b then signal else error("assertion failed")
</para><para>-- Fail with the error message: "assertion failed"
assert(false)]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (+)(Number, Number) :: Number</code></para>
        <para><code>a+b</code> returns the sum of <code>a</code> and <code>b</code>.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (-)(Number, Number) :: Number</code></para>
        <para><code>a-b</code> returns the value of <code>a</code> minus the value of <code>b</code>.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (0-)(Number) :: Number</code></para>
        <para>Return the additive inverse of the argument.
When this site appears as an operator, it is written in prefix form without the
zero, i.e. <code>(-a)</code>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (*)(Number, Number) :: Number</code></para>
        <para><code>a*b</code> returns the product of <code>a</code> and <code>b</code>.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (**)(Number, Number) :: Number</code></para>
        <para><code>a ** b</code> returns
<inlineequation><mathphrase>a<superscript>b</superscript></mathphrase></inlineequation>,
i.e. <code>a</code> raised to the <code>b</code>th power.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (/)(Number, Number) :: Number</code></para>
        <para><code>a/b</code> returns <code>a</code> divided by <code>b</code>.
If both arguments have integral types, <code>(/)</code> performs integral
division, rounding towards zero. Otherwise, it performs floating-point
division. If <code>b=0</code>, <code>a/b</code> halts with an error.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
  7/3   -- publishes 2
| 7/3.0 -- publishes 2.333...]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (%)(Number, Number) :: Number</code></para>
        <para><code>a%b</code> computes the remainder of <code>a/b</code>. If <code>a</code>
and <code>b</code> have integral types, then the remainder is given by
the expression <code>a - (a/b)*b</code>. For a full description, see the
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.17.3">Java Language Specification, 3rd edition</link>.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (&lt;:)(Top, Top) :: Boolean</code></para>
        <para><code>a &lt;: b</code> returns true if <code>a</code> is less than <code>b</code>, and false otherwise.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (&lt;=)(Top, Top) :: Boolean</code></para>
        <para><code>a &lt;= b</code> returns true if <code>a</code> is less than or equal to <code>b</code>, and false otherwise.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (:&gt;)(Top, Top) :: Boolean</code></para>
        <para><code>a :> b</code> returns true if <code>a</code> is greater than <code>b</code>, and false otherwise.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (&gt;=)(Top, Top) :: Boolean</code></para>
        <para><code>a >= b</code> returns true if <code>a</code> is greater than or equal to <code>b</code>, and false otherwise.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (=)(Top, Top) :: Boolean</code></para>
        <para><code>a = b</code> returns true if <code>a</code> is equal to <code>b</code>,
and false otherwise.  The precise definition of "equal" depends on the values
being compared, but always obeys the rule that if two values are considered
equal, then one may be substituted locally for the other without affecting the
behavior of the program.
</para><para>Two values with the same object identity are always considered equal.
In addition, Cor <link linkend="cor.constants">constant values</link> and <link
linkend="cor.data">data structures</link> are considered equal if their
contents are equal. Other types are free to implement their own equality
relationship provided it conforms to the rules given here.
</para><para>Note that although values of dUnlesserent types may be compared with
<code>=</code>, the substitutability principle requires that such values are
always considered inequal, i.e. the comparison will return <code>false</code>.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (/=)(Top, Top) :: Boolean</code></para>
        <para><code>a/=b</code> returns false if <code>a=b</code>, and true otherwise.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (~)(Boolean) :: Boolean</code></para>
        <para>Return the logical negation of the argument.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (&amp;&amp;)(Boolean, Boolean) :: Boolean</code></para>
        <para>Return the logical conjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (||)(Boolean, Boolean) :: Boolean</code></para>
        <para>Return the logical disjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>site (:)[A](A, List[A]) :: List[A]</code></para>
        <para>The list <code>a:b</code> is formed by prepending the element <code>a</code> to
the list <code>b</code>.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: (3, [4, 5])
3:4:5:[] >x:xs> (x,xs)]]></programlisting>
</para><para>In patterns, the <code>(:)</code> deconstructor can be applied to a variety of
list-like values such as <code>Array</code>s and Java <code>Iterable</code>s,
in which case it returns the first element of the list-like value, and a new
list-like value (not necessarily of the same type as the original list-like
value) representing the tail.  Modifying the structure of the original
value (e.g. adding an element to an <code>Iterable</code>) may render
old "tail"s unusable, so you should refrain from modifying a value
while you are deconstructing it.  This feature is highly experimental
and will probably change in future versions of the implementation.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>abs</code></term>
      <listitem>
        <para><code>def abs(Number) :: Number</code></para>
        <para>Return the absolute value of the argument.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def abs(Number) :: Number
def abs(x) = if x <: 0 then -x else x

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>signum</code></term>
      <listitem>
        <para><code>def signum(Number) :: Number</code></para>
        <para><code>signum(a)</code> returns <code>-1</code> if <code>a&lt;0</code>,
<code>1</code> if <code>a&gt;0</code>, and <code>0</code> if <code>a=0</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def signum(Number) :: Number
def signum(x) =
  if x <: 0 then -1
  else if x :> 0 then 1
  else 0

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>min</code></term>
      <listitem>
        <para><code>def min[A](A,A) :: A</code></para>
        <para>Return the lesser of the arguments. If the arguments
are equal, return the first argument.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def min[A](A,A) :: A
def min(x,y) = if y <: x then y else x

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>max</code></term>
      <listitem>
        <para><code>def max[A](A,A) :: A</code></para>
        <para>Return the greater of the arguments. If the arguments
are equal, return the second argument.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def max[A](A,A) :: A
def max(x,y) = if x :> y then x else y


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>floor</code></term>
      <listitem>
        <para><code>site floor(Number) :: Integer</code></para>
        <para>Return the greatest integer less than
or equal to this number.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>ceil</code></term>
      <listitem>
        <para><code>site ceil(Number) :: Integer</code></para>
        <para>Return the least integer greater than
or equal to this number.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>idioms.inc</title>
      <para>Higher-order Orc programming idioms.
Many of these are standard functional-programming
combinators borrowed from Haskell or Scheme.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>apply</code></term>
      <listitem>
        <para><code>site apply[A, ..., B](lambda (A, ...) :: B, List[A]) :: B</code></para>
        <para>Apply a function to a list of arguments.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>curry</code></term>
      <listitem>
        <para><code>def curry[A,B,C](lambda (A,B) :: C)(A)(B) :: C</code></para>
        <para>Curry a function of two arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def curry[A,B,C](lambda (A,B) :: C)(A)(B) :: C
def curry(f)(x)(y) = f(x,y)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>curry3</code></term>
      <listitem>
        <para><code>def curry3[A,B,C,D](lambda (A,B,C) :: D)(A)(B)(C) :: D</code></para>
        <para>Curry a function of three arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def curry3[A,B,C,D](lambda (A,B,C) :: D)(A)(B)(C) :: D
def curry3(f)(x)(y)(z) = f(x,y,z)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>uncurry</code></term>
      <listitem>
        <para><code>def uncurry[A,B,C](lambda (A)(B) :: C)(A, B) :: C</code></para>
        <para>Uncurry a function of two arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def uncurry[A,B,C](lambda (A)(B) :: C)(A, B) :: C
def uncurry(f)(x,y) = f(x)(y)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>uncurry3</code></term>
      <listitem>
        <para><code>def uncurry3[A,B,C,D](lambda (A)(B)(C) :: D)(A,B,C) :: D</code></para>
        <para>Uncurry a function of three arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def uncurry3[A,B,C,D](lambda (A)(B)(C) :: D)(A,B,C) :: D
def uncurry3(f)(x,y,z) = f(x)(y)(z)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>flip</code></term>
      <listitem>
        <para><code>def flip[A,B,C](lambda (A, B) :: C)(B, A) :: C</code></para>
        <para>Flip the order of parameters of a two-argument function.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def flip[A,B,C](lambda (A, B) :: C)(B, A) :: C
def flip(f)(x,y) = f(y,x)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>constant</code></term>
      <listitem>
        <para><code>def constant[A](A)() :: A</code></para>
        <para>Create a function which returns a constant value.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def constant[A](A)() :: A
def constant(x)() = x

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>defer</code></term>
      <listitem>
        <para><code>def defer[A,B](lambda (A) :: B, A)() :: B</code></para>
        <para>Given a function and its argument, return a thunk which applies the function.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def defer[A,B](lambda (A) :: B, A)() :: B
def defer(f, x)() = f(x)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>defer2</code></term>
      <listitem>
        <para><code>def defer2[A,B,C](lambda (A,B) :: C, A, B)() :: C</code></para>
        <para>Given a function and its arguments, return a thunk which applies the function.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def defer2[A,B,C](lambda (A,B) :: C, A, B)() :: C
def defer2(f, x, y)() = f(x, y)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>ignore</code></term>
      <listitem>
        <para><code>def ignore[A,B](lambda () :: B)(A) :: B</code></para>
        <para>From a function of no arguments, create a function
of one argument, which is ignored.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def ignore[A,B](lambda () :: B)(A) :: B
def ignore(f)(_) = f()

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>ignore2</code></term>
      <listitem>
        <para><code>def ignore2[A,B,C](lambda () :: C)(A, B) :: C</code></para>
        <para>From a function of no arguments, create a function
of two arguments, which are ignored.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def ignore2[A,B,C](lambda () :: C)(A, B) :: C
def ignore2(f)(_, _) = f()

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>compose</code></term>
      <listitem>
        <para><code>def compose[A,B,C](lambda (B) :: C, lambda (A) :: B)(A) :: C</code></para>
        <para>Compose two single-argument functions.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def compose[A,B,C](lambda (B) :: C,
                   lambda (A) :: B)(A) :: C
def compose(f,g)(x) = f(g(x))

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>while</code></term>
      <listitem>
        <para><code>def while[A](lambda (A) :: Boolean, lambda (A) :: A)(A) :: A</code></para>
        <para>Iterate a function while a predicate is satisfied, publishing
each value passed to the function. The exact behavior is specified
by the following implementation:
</para><para><programlisting><![CDATA[
def while(p,f) = 
  def loop(x) = If(p(x)) >> ( x | loop(f(x)) )
  loop]]></programlisting>
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2 3 4 5
while(
  lambda (n) = (n <= 5),
  lambda (n) = n+1
)(0)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def while[A](lambda (A) :: Boolean,
             lambda (A) :: A)(A) 
  :: A
def while(p,f) = 
  def loop(A) :: A
  def loop(x) = If(p(x)) >> ( x | loop(f(x)) )
  loop

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>repeat</code></term>
      <listitem>
        <para><code>def repeat[A](lambda () :: A) :: A</code></para>
        <para>Call a function sequentially, publishing each value returned by the function.
The expression <code>repeat(f)</code> is equivalent to
the infinite expression <code>f() >x> ( x | f() >x> ( x | f() >x> ... ) )</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def repeat[A](lambda () :: A) :: A
def repeat(f) = f() >x> (x | repeat(f))

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>fork</code></term>
      <listitem>
        <para><code>def fork[A](List[lambda () :: A]) :: A</code></para>
        <para>Call a list of functions in parallel, publishing
all values published by the functions.
</para><para>The expression <code>fork([f,g,h])</code> is equivalent to
the expression <code>f() | g() | h()</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def fork[A](List[lambda () :: A]) :: A
def fork([]) = stop
def fork(p:ps) = p() | fork(ps)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>forkMap</code></term>
      <listitem>
        <para><code>def forkMap[A,B](lambda (A) :: B, List[A]) :: B</code></para>
        <para>Apply a function to a list in parallel, publishing all values published
by the applications.
</para><para>The expression <code>forkMap(f, [a,b,c])</code> is equivalent to
the expression <code>f(a) | f(b) | f(c)</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def forkMap[A,B](lambda (A) :: B, List[A]) :: B
def forkMap(f, []) = stop
def forkMap(f, x:xs) = f(x) | forkMap(f, xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>seq</code></term>
      <listitem>
        <para><code>def seq[A](List[lambda () :: A]) :: Signal</code></para>
        <para>Call a list of functions in sequence, publishing
a signal whenever the last function publishes. The
actual publications of the given functions are not
published.
</para><para>The expression <code>seq([f,g,h])</code> is equivalent to
the expression <code>f() >> g() >> h() >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def seq[A](List[lambda () :: A]) :: Signal
def seq([]) = signal
def seq(p:ps) = p() >> seq(ps)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>seqMap</code></term>
      <listitem>
        <para><code>def seqMap[A,B](lambda (A) :: B, List[A]) :: Signal</code></para>
        <para>Apply a function to a list in in sequence, publishing
a signal whenever the last application publishes. The
actual publications of the given functions are not
published.
</para><para>The expression <code>seqMap(f, [a,b,c])</code> is equivalent to
the expression <code>f(a) >> f(b) >> f(c) >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def seqMap[A,B](lambda (A) :: B, List[A]) :: Signal
def seqMap(f, []) = signal
def seqMap(f, x:xs) = f(x) >> seqMap(f, xs)
 
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>join</code></term>
      <listitem>
        <para><code>def join[A](List[lambda () :: A]) :: Signal</code></para>
        <para>Call a list of functions in parallel and publish
a signal once all functions have completed.
</para><para>The expression <code>join([f,g,h])</code> is equivalent to
the expression <code>(f(), g(), h()) >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def join[A](List[lambda () :: A]) :: Signal
def join([]) = signal
def join(p:ps) = (p(), join(ps)) >> signal
 
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>joinMap</code></term>
      <listitem>
        <para><code>def joinMap[A,B](lambda (A) :: B, List[A]) :: Signal</code></para>
        <para>Apply a function to a list in parallel and publish
a signal once all applications have completed.
</para><para>The expression <code>joinMap(f, [a,b,c])</code> is equivalent to
the expression <code>(f(a), f(b), f(c)) >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def joinMap[A,B](lambda (A) :: B, List[A]) :: Signal
def joinMap(f, []) = signal
def joinMap(f, x:xs) = (f(x), joinMap(f, xs)) >> signal

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>alt</code></term>
      <listitem>
        <para><code>def alt[A](List[lambda () :: A]) :: A</code></para>
        <para>Call each function in the list until one publishes.
</para><para>The expression <code>alt([f,g,h])</code> is equivalent to
the expression <code>f() ; g() ; h()</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def alt[A](List[lambda () :: A]) :: A
def alt([]) = stop
def alt(p:ps) = p() ; alt(ps)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>altMap</code></term>
      <listitem>
        <para><code>def altMap[A,B](lambda (A) :: B, List[A]) :: B</code></para>
        <para>Apply the function to each element in the list until one publishes.
</para><para>The expression <code>altMap(f, [a,b,c])</code> is equivalent to
the expression <code>f(a) ; f(b) ; f(c)</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def altMap[A,B](lambda (A) :: B, List[A]) :: B
def altMap(f, []) = stop
def altMap(f, x:xs) = f(x) ; altMap(f, xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>por</code></term>
      <listitem>
        <para><code>def por(List[lambda () :: Boolean]) :: Boolean</code></para>
        <para>Parallel or. Evaluate a list of boolean functions in parallel, publishing
a value as soon as possible, and terminating any unnecessary ongoing
computation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def por(List[lambda () :: Boolean]) :: Boolean
def por([]) = false
def por(p:ps) =
  let(
    val b1 = p()
    val b2 = por(ps)
    If(b1) >> true | If(b2) >> true | (b1 || b2)
  )
  
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>pand</code></term>
      <listitem>
        <para><code>def pand(List[lambda () :: Boolean]) :: Boolean</code></para>
        <para>Parallel and. Evaluate a list of boolean functions in parallel, publishing
a value as soon as possible, and terminating any unnecessary ongoing
computation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def pand(List[lambda () :: Boolean]) :: Boolean
def pand([]) = true
def pand(p:ps) =
  let(
    val b1 = p()
    val b2 = pand(ps)
    Unless(b1) >> false | Unless(b2) >> false | (b1 && b2)
  )
 
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>collect</code></term>
      <listitem>
        <para><code>def collect[A](lambda () :: A) :: List[A]</code></para>
        <para>Run a function, collecting all publications in a list.
Return the list when the function terminates.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [signal, signal, signal, signal, signal]
collect(defer(signals, 5))]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def collect[A](lambda () :: A) :: List[A]
def collect(p) =
  val b = Buffer[A]()
  p() >x> b.put(x) >> stop
  ; b.getAll()
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>list.inc</title>
      <para>Operations on lists.
Many of these functions are similar to those in the Haskell prelude, but
operate on the elements of a list in parallel.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>each</code></term>
      <listitem>
        <para><code>def each[A](List[A]) :: A</code></para>
        <para>Publish every value in a list, simultaneously.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def each[A](List[A]) :: A
def each([]) = stop
def each(h:t) = h | each(t)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>map</code></term>
      <listitem>
        <para><code>def map[A,B](lambda (A) :: B, List[A]) :: List[B]</code></para>
        <para>Apply a function to every element of a list (in parallel),
returning a list of the results.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def map[A,B](lambda (A) :: B, List[A]) :: List[B]
def map(f,[]) = []
def map(f,h:t) = f(h):map(f,t)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>reverse</code></term>
      <listitem>
        <para><code>def reverse[A](List[A]) :: List[A]</code></para>
        <para>Return the reverse of the given list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def reverse[A](List[A]) :: List[A]
def reverse(l) = 
  def tailrev(List[A], List[A]) :: List[A] 
  def tailrev([],x) = x
  def tailrev(h:t,x) = tailrev(t,h:x)
  tailrev(l,[]) 

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>filter</code></term>
      <listitem>
        <para><code>def filter[A](lambda (A) :: Boolean, List[A]) :: List[A]</code></para>
        <para>Return a list containing only those elements which satisfy the predicate.
The filter is applied to all list elements in parallel.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def filter[A](lambda (A) :: Boolean, List[A]) :: List[A]
def filter(p,[]) = []
def filter(p,x:xs) =
  val fxs = filter(p, xs)
  if p(x) then x:fxs else fxs

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>head</code></term>
      <listitem>
        <para><code>def head[A](List[A]) :: A</code></para>
        <para>Return the first element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def head[A](List[A]) :: A
def head(x:xs) = x

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>tail</code></term>
      <listitem>
        <para><code>def tail[A](List[A]) :: List[A]</code></para>
        <para>Return all but the first element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def tail[A](List[A]) :: List[A]
def tail(x:xs) = xs

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>init</code></term>
      <listitem>
        <para><code>def init[A](List[A]) :: List[A]</code></para>
        <para>Return all but the last element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def init[A](List[A]) :: List[A]
def init([x]) = []
def init(x:xs) = x:init(xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>last</code></term>
      <listitem>
        <para><code>def last[A](List[A]) :: A</code></para>
        <para>Return the last element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def last[A](List[A]) :: A
def last([x]) = x
def last(x:xs) = last(xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>empty</code></term>
      <listitem>
        <para><code>def empty[A](List[A]) :: Boolean</code></para>
        <para>Is the list empty?
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def empty[A](List[A]) :: Boolean
def empty([]) = true
def empty(_) = false

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>index</code></term>
      <listitem>
        <para><code>def index[A](List[A], Integer) :: A</code></para>
        <para>Return the nth element of a list, counting from 0.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def index[A](List[A], Integer) :: A
def index(h:t, 0) = h
def index(h:t, n) = index(t, n-1)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>append</code></term>
      <listitem>
        <para><code>def append[A](List[A], List[A]) :: List[A]</code></para>
        <para>Return the first list concatenated with the second.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def append[A](List[A], List[A]) :: List[A]
def append([],l) = l
def append(h:t,l) = h:append(t,l)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>foldl</code></term>
      <listitem>
        <para><code>def foldl[A,B](lambda (B, A) :: B, B, List[A]) :: B</code></para>
        <para>Reduce a list using the given left-associative binary operation and initial value.
Given the list <code>[x1, x2, x3, ...]</code> and initial value <code>x0</code>,
returns <code>f(... f(f(f(x0, x1), x2), x3) ...)</code>
</para><para>Example using <code>foldl</code> to reverse a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [3, 2, 1]
foldl(flip((:)), [], [1,2,3])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldl[A,B](lambda (B, A) :: B, B, List[A]) :: B
def foldl(f,z,[]) = z
def foldl(f,z,x:xs) = foldl(f,f(z,x),xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>foldl1</code></term>
      <listitem>
        <para><code>def foldl1[A](lambda (A, A) :: A, List[A]) :: A</code></para>
        <para>A special case of <code>foldl</code> which uses the last element of the list as the
initial value. It is an error to call this on an empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldl1[A](lambda (A, A) :: A, List[A]) :: A
def foldl1(f,x:xs) = foldl(f,x,xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>foldr</code></term>
      <listitem>
        <para><code>def foldr[A,B](lambda (A, B) :: B, B, List[A]) :: B</code></para>
        <para>Reduce a list using the given right-associative binary operation and initial value.
Given the list <code>[..., x3, x2, x1]</code> and initial value <code>x0</code>,
returns <code>f(... f(x3, f(x2, f(x1, x0))) ...)</code>
</para><para>Example summing the numbers in a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 6
foldr((+), 0, [1,2,3])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldr[A,B](lambda (A, B) :: B, B, List[A]) :: B
def foldr(f,z,xs) = foldl(flip(f),z,reverse(xs))
  
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>foldr1</code></term>
      <listitem>
        <para><code>def foldr1[A](lambda (A, A) :: A, List[A]) :: A</code></para>
        <para>A special case of <code>foldr</code> which uses the last element of the list as the
initial value. It is an error to call this on an empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldr1[A](lambda (A, A) :: A, List[A]) :: A
def foldr1(f,xs) = foldl1(flip(f),reverse(xs))

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>afold</code></term>
      <listitem>
        <para><code>def afold[A](lambda (A, A) :: A, List[A]) :: A</code></para>
        <para>Reduce a non-empty list using the given associative binary operation.
This function reduces independent subexpressions in parallel; the
calls exhibit a balanced tree structure, so the number of sequential 
reductions performed is O(log n).  For expensive reductions, this
is much more efficient than <code>foldl</code> or <code>foldr</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def afold[A](lambda (A, A) :: A, List[A]) :: A
def afold(f, [x]) = x
{- Here's the interesting part -}
def afold(f, xs) =
  def afold'(List[A]) :: List[A]
  def afold'([]) = []
  def afold'([x]) = [x]
  def afold'(x:y:xs) = f(x,y):afold'(xs)
  afold(f, afold'(xs))


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>cfold</code></term>
      <listitem>
        <para><code>def cfold[A](lambda (A, A) :: A, List[A]) :: A</code></para>
        <para>Reduce a non-empty list using the given associative and commutative binary operation.
This function opportunistically reduces independent subexpressions in parallel, so the number of
sequential reductions performed is as small as possible.  For expensive reductions, this
is much more efficient than <code>foldl</code> or <code>foldr</code>. In cases
where the reduction does not always take the same amount of time to complete, it 
is also more efficient than <code>afold</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def cfold[A](lambda (A, A) :: A, List[A]) :: A
def cfold(f, []) = stop
def cfold(f, [x]) = x
def cfold(f, [x,y]) = f(x,y)
def cfold(f, L) =
  val c = Buffer[A]()
  def work(Number, List[A]) :: A
  def work(i, x:y:rest) =
    c.put(f(x,y)) >> stop | work(i+1, rest)
  def work(i, [x]) = c.put(x) >> stop | work(i+1, [])
  def work(i, []) =
    if (i <: 2) then c.get() 
    else c.get() >x> c.get() >y>
         ( c.put(f(x,y)) >> stop | work(i-1,[]) ) 
  work(0, L)



]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>zip</code></term>
      <listitem>
        <para><code>def zip[A,B](List[A], List[B]) :: List[(A,B)]</code></para>
        <para>Combine two lists into a list of pairs.
The length of the shortest list determines the length of the result.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def zip[A,B](List[A], List[B]) :: List[(A,B)]
def zip([],_) = []
def zip(_,[]) = []
def zip(x:xs,y:ys) = (x,y):zip(xs,ys)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>unzip</code></term>
      <listitem>
        <para><code>def unzip[A,B](List[(A,B)]) :: (List[A], List[B])</code></para>
        <para>Split a list of pairs into a pair of lists.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def unzip[A,B](List[(A,B)]) :: (List[A], List[B])
def unzip([]) = ([],[])
def unzip((x,y):z) = (x:xs,y:ys) <(xs,ys)< unzip(z)


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>concat</code></term>
      <listitem>
        <para><code>def concat[A](List[List[A]]) :: List[A]</code></para>
        <para>Concatenate a list of lists into a single list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def concat[A](List[List[A]]) :: List[A]
def concat([]) = []
def concat(h:t) = append(h,concat(t))


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>length</code></term>
      <listitem>
        <para><code>def length[A](List[A]) :: Integer</code></para>
        <para>Return the number of elements in a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def length[A](List[A]) :: Integer
def length([]) = 0
def length(h:t) = 1 + length(t)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>take</code></term>
      <listitem>
        <para><code>def take[A](Integer, List[A]) :: List[A]</code></para>
        <para>Given a number <code>n</code> and a list <code>l</code>,
return the first <code>n</code> elements of <code>l</code>.
If <code>n</code> exceeds the length of <code>l</code>,
or <code>n &lt; 0</code>, take halts with an error.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def take[A](Integer, List[A]) :: List[A]
def take(0, _) = []
def take(n, x:xs) =
  if n :> 0 then x:take(n-1, xs)
  else error("Cannot take(" + n + ", _)")

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>drop</code></term>
      <listitem>
        <para><code>def drop[A](Integer, List[A]) :: List[A]</code></para>
        <para>Given a number <code>n</code> and a list <code>l</code>,
return the elements of <code>l</code> after the first <code>n</code>.
If <code>n</code> exceeds the length of <code>l</code>,
or <code>n &lt; 0</code>, drop halts with an error.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def drop[A](Integer, List[A]) :: List[A]
def drop(0, xs) = xs
def drop(n, x:xs) =
  if n :> 0 then drop(n-1, xs)
  else error("Cannot drop(" + n + ", _)")

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>member</code></term>
      <listitem>
        <para><code>def member[A](A, List[A]) :: Boolean</code></para>
        <para>Return true if the given item is a member of the given list, and false
otherwise.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def member[A](A, List[A]) :: Boolean
def member(item, []) = false
def member(item, h:t) =
  if item = h then true
  else member(item, t)
  
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>merge</code></term>
      <listitem>
        <para><code>def merge[A](List[A], List[A]) :: List[A]</code></para>
        <para>Merge two sorted lists.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 2, 3, 4, 5]
merge([1,2,3], [2,4,5])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def merge[A](List[A], List[A]) :: List[A]
def merge(xs,ys) = mergeBy((<:), xs, ys)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>mergeBy</code></term>
      <listitem>
        <para><code>def mergeBy[A](lambda (A,A) :: Boolean, List[A], List[A]) :: List[A]</code></para>
        <para>Merge two lists using the given less-than relation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def mergeBy[A](lambda (A,A) :: Boolean,
               List[A], List[A]) :: List[A]
def mergeBy(lt, xs, []) = xs
def mergeBy(lt, [], ys) = ys
def mergeBy(lt, x:xs, y:ys) =
  if lt(y,x) then y:mergeBy(lt,x:xs,ys)
  else x:mergeBy(lt,xs,y:ys)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>sort</code></term>
      <listitem>
        <para><code>def sort[A](List[A]) :: List[A]</code></para>
        <para>Sort a list.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sort([1,3,2])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sort[A](List[A]) :: List[A]
def sort(xs) = sortBy((<:), xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>sortBy</code></term>
      <listitem>
        <para><code>def sortBy[A](lambda (A,A) :: Boolean, List[A]) :: List[A]</code></para>
        <para>Sort a list using the given less-than relation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sortBy[A](lambda (A,A) :: Boolean, List[A]) :: List[A]
def sortBy(lt, []) = []
def sortBy(lt, [x]) = [x]
def sortBy(lt, xs) =
  val half = floor(length(xs)/2)
  val front = take(half, xs)
  val back = drop(half, xs)
  mergeBy(lt, sortBy(lt, front), sortBy(lt, back))
 
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>mergeUnique</code></term>
      <listitem>
        <para><code>def mergeUnique[A](List[A], List[A]) :: List[A]</code></para>
        <para>Merge two sorted lists, discarding duplicates.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3, 4, 5]
mergeUnique([1,2,3], [2,4,5])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def mergeUnique[A](List[A], List[A]) :: List[A]
def mergeUnique(xs,ys) = mergeUniqueBy((=), (<:), xs, ys)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>mergeUniqueBy</code></term>
      <listitem>
        <para><code>def mergeUniqueBy[A](lambda (A,A) :: Boolean, lambda (A,A) :: Boolean, List[A], List[A]) :: List[A]</code></para>
        <para>Merge two lists, discarding duplicates, using the given equality and less-than relations.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def mergeUniqueBy[A](lambda (A,A) :: Boolean,
                     lambda (A,A) :: Boolean,
                      List[A], List[A])
  :: List[A]
def mergeUniqueBy(eq, lt, xs, []) = xs
def mergeUniqueBy(eq, lt, [], ys) = ys
def mergeUniqueBy(eq, lt, x:xs, y:ys) =
  if eq(y,x) then mergeUniqueBy(eq, lt, xs, y:ys)
  else if lt(y,x) then y:mergeUniqueBy(eq,lt,x:xs,ys)
  else x:mergeUniqueBy(eq,lt,xs,y:ys)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>sortUnique</code></term>
      <listitem>
        <para><code>def sortUnique[A](List[A]) :: List[A]</code></para>
        <para>Sort a list, discarding duplicates.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sortUnique([1,3,2,3])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sortUnique[A](List[A]) :: List[A]
def sortUnique(xs) = sortUniqueBy((=), (<:), xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>sortUniqueBy</code></term>
      <listitem>
        <para><code>def sortUniqueBy[A](lambda (A,A) :: Boolean, lambda (A,A) :: Boolean, List[A]) :: List[A]</code></para>
        <para>Sort a list, discarding duplicates, using the given equality and less-than relations.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sortUniqueBy[A](lambda (A,A) :: Boolean,
                    lambda (A,A) :: Boolean,
                    List[A])
  :: List[A]
def sortUniqueBy(eq, lt, []) = []
def sortUniqueBy(eq, lt, [x]) = [x]
def sortUniqueBy(eq, lt, xs) =
  val half = floor(length(xs)/2)
  val front = take(half, xs)
  val back = drop(half, xs)
  mergeUniqueBy(eq, lt,
    sortUniqueBy(eq, lt, front),
    sortUniqueBy(eq, lt, back))
  
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>group</code></term>
      <listitem>
        <para><code>def group[A,B](List[(A,B)]) :: List[(A,List[B])]</code></para>
        <para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [(1, [1, 2]), (2, [3]), (3, [4]), (1, [3])]
group([(1,1), (1,2), (2,3), (3,4), (1,3)])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def group[A,B](List[(A,B)]) :: List[(A,List[B])]
def group(xs) = groupBy((=), xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>groupBy</code></term>
      <listitem>
        <para><code>def groupBy[A,B](lambda (A,A) :: Boolean, List[(A,B)]) :: List[(A,List[B])]</code></para>
        <para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements,
using the given equality relation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def groupBy[A,B](lambda (A,A) :: Boolean,
                 List[(A,B)])
  :: List[(A,List[B])]
def groupBy(eq, []) = []
def groupBy(eq, (k,v):kvs) =
  def helper(A, List[B], List[(A,B)]) :: List[(A,List[B])]
  def helper(k,vs, []) = [(k,vs)]
  def helper(k,vs, (k2,v):kvs) =
    if eq(k2,k) then helper(k, v:vs, kvs)
    else (k,vs):helper(k2, [v], kvs)
  helper(k,[v], kvs)
 
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>rangeBy</code></term>
      <listitem>
        <para><code>def rangeBy(Number, Number, Number) :: List[Number]</code></para>
        <para><code>rangeBy(low, high, skip)</code> returns a sorted list of
numbers <code>n</code> which satisfy <code>n = low + skip*i</code> (for some
integer <code>i</code>), <code>n &gt;= low</code>, and <code>n &lt; high</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def rangeBy(Number, Number, Number) :: List[Number]
def rangeBy(low, high, skip) =
  if low <: high
  then low:rangeBy(low+skip, high, skip)
  else []
 
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>range</code></term>
      <listitem>
        <para><code>def range(Number, Number) :: List[Number]</code></para>
        <para>Generate a list of numbers in the given half-open range.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def range(Number, Number) :: List[Number]
def range(low, high) = rangeBy(low, high, 1)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>any</code></term>
      <listitem>
        <para><code>def any[A](lambda (A) :: Boolean, List[A]) :: Boolean</code></para>
        <para>Return true if any of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def any[A](lambda (A) :: Boolean, List[A]) :: Boolean
def any(p, []) = false
def any(p, x:xs) =
  let(
    val b1 = p(x)
    val b2 = any(p, xs)
    If(b1) >> true | If(b2) >> true | (b1 || b2)
  )
  
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>all</code></term>
      <listitem>
        <para><code>def all[A](lambda (A) :: Boolean, List[A]) :: Boolean</code></para>
        <para>Return true if all of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def all[A](lambda (A) :: Boolean, List[A]) :: Boolean
def all(p, []) = true
def all(p, x:xs) =
  let(
    val b1 = p(x)
    val b2 = all(p, xs)
    Unless(b1) >> false | Unless(b2) >> false | (b1 && b2)
  )

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>sum</code></term>
      <listitem>
        <para><code>def sum(List[Number]) :: Number</code></para>
        <para>Return the sum of all numbers in a list.
The sum of an empty list is 0.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sum(List[Number]) :: Number
def sum(xs) = foldl(
  (+) :: lambda (Number, Number) :: Number,
  0, xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>product</code></term>
      <listitem>
        <para><code>def product(List[Number]) :: Number</code></para>
        <para>Return the product of all numbers in a list.
The product of an empty list is 1.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def product(List[Number]) :: Number
def product(xs) = foldl(
  (*) :: lambda (Number, Number) :: Number,
  1, xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>and</code></term>
      <listitem>
        <para><code>def and(List[Boolean]) :: Boolean</code></para>
        <para>Return the boolean conjunction of all boolean values in the list.
The conjunction of an empty list is <code>true</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def and(List[Boolean]) :: Boolean
def and([]) = true
def and(false:xs) = false
def and(true:xs) = and(xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>or</code></term>
      <listitem>
        <para><code>def or(List[Boolean]) :: Boolean</code></para>
        <para>Return the boolean disjunction of all boolean values in the list.
The disjunction of an empty list is <code>false</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def or(List[Boolean]) :: Boolean
def or([]) = false
def or(true:xs) = true
def or(false:xs) = or(xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>minimum</code></term>
      <listitem>
        <para><code>def minimum[A](List[A]) :: A</code></para>
        <para>Return the minimum element of a non-empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def minimum[A](List[A]) :: A
def minimum(xs) =
  -- this def appeases the typechecker
  def minA(x::A,y::A) = min(x,y)
  foldl1(minA, xs)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>maximum</code></term>
      <listitem>
        <para><code>def maximum[A](List[A]) :: A</code></para>
        <para>Return the maximum element of a non-empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def maximum[A](List[A]) :: A
def maximum(xs) =
  -- this def appeases the typechecker
  def maxA(x::A,y::A) = max(x,y)
  foldl1(maxA, xs)
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>reflect.inc</title>
      <para>Metalanguage operations.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>MakeSite</code></term>
      <listitem>
        <para><code>site MakeSite[A](A) :: A</code></para>
        <para>This site promotes an Orc closure to a site; when the site is called, the
closure is executed on those arguments. These executions behave
like site calls; in particular, the following four properties hold:
</para><para><itemizedlist>
<listitem> The site, like all sites, is strict in its arguments. </listitem>
<listitem> The site returns only the first value published by the executed closure. The closure continues to run, but its subsequent publications are discarded. </listitem>
<listitem> The execution of the closure is protected from termination. If the site call is terminated, the closure still runs, and its publications are simply ignored. </listitem>
<listitem> If the execution of the closure halts, so does the site call. </listitem>
</itemizedlist>
</para><para>The typical usage of MakeSite looks like:
</para><para><programlisting language="orc-demo"><![CDATA[
def foo(...) = ...
val Foo = MakeSite(foo)]]></programlisting>
</para><para>The typing of MakeSite will enforce the side condition that the type A is an arrow
type.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>state.inc</title>
      <para>General-purpose supplemental data structures.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Some</code></term>
      <listitem>
        <para><code>site Some[A](A) :: Option[A]</code></para>
        <para>An optional value which is available.
This site may also be used in a pattern.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: (3,4)
Some((3,4)) >s> (
    s >Some((x,y))> (x,y)
  | s >None()> signal
)]]></programlisting>
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>None</code></term>
      <listitem>
        <para><code>site None[A]() :: Option[A]</code></para>
        <para>An optional value which is not available.
This site may also be used in a pattern.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Cell</code></term>
      <listitem>
        <para><code>site Cell[A]() :: Cell[A]</code></para>
        <para>Create a write-once storage location.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 5 5
val c = Cell()
  c.write(5) >> c.read()
| Rtimer(1) >> ( c.write(10) ; c.read() )]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Cell</code></term>
      <listitem>
        <para><code>site Cell[A].read() :: A</code></para>
        <para>Read a value from the cell. If the cell does not yet have a value, block until it receives one.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Cell</code></term>
      <listitem>
        <para><code>site Cell[A].readnb() :: A</code></para>
        <para>Read a value from the cell. If the cell does not yet have a value, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Cell</code></term>
      <listitem>
        <para><code>site Cell[A].write() :: Signal</code></para>
        <para>Write a value to the cell. If the cell already has a value, halt.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>def (?)[A](Ref[A]) :: A</code></para>
        <para>Get the value held by a reference.
<code>x?</code> is equivalent to <code>x.read()</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def (?)[A](Ref[A]) :: A
def (?)(r) = r.read()

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code></code></term>
      <listitem>
        <para><code>def (:=)[A](Ref[A], A) :: Signal</code></para>
        <para>Set the value held by a reference.
<code>x := y</code> is equivalent to <code>x.write(y)</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def (:=)[A](Ref[A], A) :: Signal
def (:=)(r,v) = r.write(v)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>swap</code></term>
      <listitem>
        <para><code>def swap[A](Ref[A], Ref[A]) :: Signal</code></para>
        <para>Swap the values in two references.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def swap[A](Ref[A], Ref[A]) :: Signal
def swap(r,s) = (r?,s?) >(rval,sval)> (r := sval, s := rval) >> signal


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Semaphore</code></term>
      <listitem>
        <para><code>site Semaphore(Integer) :: Semaphore</code></para>
        <para>Return a semaphore with the given value. The semaphore maintains the invariant
that its value is always non-negative.
</para><para>An example using a semaphore as a lock for a critical section:
<programlisting language="orc-demo"><![CDATA[
-- Prints:
-- Entering critical section
-- Leaving critical section
val lock = Semaphore(1)
lock.acquire() >>
println("Entering critical section") >>
println("Leaving critical section") >>
lock.release()]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Semaphore.acquire</code></term>
      <listitem>
        <para><code>site Semaphore.acquire() :: Signal</code></para>
        <para>If the semaphore's value is greater than <code>0</code>, decrement the semaphore and return a signal.
If the semaphore's value is <code>0</code>, block until it becomes greater than <code>0</code>.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Semaphore.acquirenb</code></term>
      <listitem>
        <para><code>site Semaphore.acquirenb() :: Signal</code></para>
        <para>If the semaphore's value is greater than <code>0</code>, decrement the semaphore and return a signal.
If the semaphore's value is <code>0</code>, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Semaphore.release</code></term>
      <listitem>
        <para><code>site Semaphore.release() :: Signal</code></para>
        <para>If any calls to <code>acquire</code> are blocked, allow the oldest such call
to return.  Otherwise, increment the value of the semaphore.  This may
increment the value beyond that with which the semaphore was constructed.  
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Semaphore.snoop</code></term>
      <listitem>
        <para><code>site Semaphore.snoop() :: Signal</code></para>
        <para>If any calls to <code>acquire</code> are blocked, return a signal.
Otherwise, block until some call to <code>acquire</code> blocks.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Semaphore.snoopnb</code></term>
      <listitem>
        <para><code>site Semaphore.snoopnb() :: Signal</code></para>
        <para>If any calls to <code>acquire</code> are blocked, return a signal.
Otherwise, halt.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A]() :: Buffer[A]</code></para>
        <para><!-- XSL/FO doesn't like me using an anchor tag here -->
<para id="orc.lib.Buffer.close">
Create a new buffer (FIFO channel) of unlimited size. A buffer supports
get, put and close operations.
</para>
</para><para>A buffer may be either empty or non-empty, and either open or closed.  When
empty and open, calls to <code>get</code> block.  When empty and closed, calls
to <code>get</code> halt.  When closed, calls to <code>put</code> halt.  In all
other cases, calls return normally.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 10
val b = Buffer()
  Rtimer(1000) >> b.put(10) >> stop
| b.get()]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].get() :: A</code></para>
        <para>Get an item from the buffer. If the buffer is open and no items are available,
block until one becomes available. If the buffer is <link
linkend="orc.lib.Buffer.close">closed</link> and no items are available, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].getnb() :: A</code></para>
        <para>Get an item from the buffer. If no items are available, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].put(A) :: Signal</code></para>
        <para>Put an item in the buffer. If the buffer is <link
linkend="orc.lib.Buffer.close">closed</link>, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].close() :: Signal</code></para>
        <para>Close the buffer and block until it is empty.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].closenb() :: Signal</code></para>
        <para>Close the buffer and return a signal immediately.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].isClosed() :: Boolean</code></para>
        <para>If the buffer is currently closed, return true, otherwise return false.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Buffer</code></term>
      <listitem>
        <para><code>site Buffer[A].getAll() :: List[A]</code></para>
        <para>Get all of the items currently in the buffer, emptying the buffer and returning
a list of the items in the order they were added. If there are no items in the
buffer, return an empty list.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A](Integer) :: BoundedBuffer[A]</code></para>
        <para>Create a new buffer (FIFO channel) with the given number of slots.
Putting an item into the buffer fills a slot, and getting an item opens a slot.
A buffer with zero slots is equivalent to a
<link linkend="orc.lib.state.SyncChannel">synchronous channel</link>.
</para><para>A bounded buffer may be empty, partly filled, or full, and either open or
closed.  When empty and open, calls to <code>get</code> block.  When empty and
closed, calls to <code>get</code> halt. When full and open, calls to
<code>put</code> block. When closed, calls to <code>put</code> halt.  In all
other cases, calls return normally.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Put 1" "Got 1" "Put 2" "Got 2"
val c = BoundedBuffer(1)
  c.put(1) >> "Put " + 1
| c.put(2) >> "Put " + 2
| Rtimer(1000) >> (
    c.get() >n> "Got " + n
  | c.get() >n> "Got " + n
  )]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].get() :: A</code></para>
        <para>Get an item from the buffer. If the buffer is open and no items are available,
block until one becomes available. If the buffer is <link
linkend="orc.lib.BoundedBuffer.close">closed</link> and no items are available, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].getnb() :: A</code></para>
        <para>Get an item from the buffer. If no items are available, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].put(A) :: Signal</code></para>
        <para>Put an item in the buffer. If no slots are open, block until one becomes open.
If the buffer is <link linkend="orc.lib.BoundedBuffer.close">closed</link>, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].putnb(A) :: Signal</code></para>
        <para>Put an item in the buffer. If no slots are open, halt.
If the buffer is <link linkend="orc.lib.BoundedBuffer.close">closed</link>, halt.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].close() :: Signal</code></para>
        <para><!-- XSL/FO doesn't like me using an anchor tag here -->
<para id="orc.lib.BoundedBuffer.close">
Close the buffer and block until it is empty.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt. Note that any blocked calls to <code>put</code>
initiated prior to closing the buffer may still be allowed to return as usual.
</para>
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].closenb() :: Signal</code></para>
        <para>Close the buffer and return a signal immediately.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt. Note that any blocked calls to <code>put</code>
initiated prior to closing the buffer may still be allowed to return as usual.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].isClosed() :: Boolean</code></para>
        <para>If the buffer is currently closed, return true, otherwise return false.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].getOpen() :: Integer</code></para>
        <para>Return the number of open slots in the buffer. Because of concurrency
this value may become out-of-date so it should only be used for debugging
or statistical measurements.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].getBound() :: Integer</code></para>
        <para>Return the total number of slots (open or filled) in the buffer.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>BoundedBuffer</code></term>
      <listitem>
        <para><code>site BoundedBuffer[A].getAll() :: [A]</code></para>
        <para>Get all of the items currently in the buffer or waiting to be added, emptying
the buffer and returning a list of the items in the order they were added. If
there are no items in the buffer or waiting to be added, return an empty list.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A](Integer) :: Array[A]</code></para>
        <para>Create a new native array of the given size. The array is initialized
to contain <code>null</code>s.
</para><para>The resulting array can be called directly with an index, as if
its type were <code>lambda (Integer) :: Ref[A]</code>.
In this case, it returns a <link linkend="orc.lib.state.Ref">Ref</link>
pointing to the element of the array specified by an index,
counting from 0. Changes to the array are reflected immediately
in the ref and visa versa.
</para><para>Simple example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 3
val a = Array(1)
a(0) := 3 >>
a(0)?]]></programlisting>
</para><para>More complex example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2
val a = Array(3)
for(0, a.length?) >i>
a(i) := i >>
stop
; a(0)? | a(1)? | a(2)?]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A](Integer, String) :: Array[A]</code></para>
        <para>Create a new primitive array of the given size with the given primitive type.
The initial values in the array depend on the primitive type: for numeric types,
it is <code>0</code>; for booleans, <code>false</code>; for chars, the character
with codepoint <code>0</code>.
</para><para>The element type of the array should be the appropriate wrapper type for the given
primitive type, although a typechecker may not be able to verify this. This
constructor is only necessary when interfacing with certain Java libraries; most
programs will just use the  <code>Array(Integer)</code> constructor.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A].get(Integer) :: A</code></para>
        <para>Get the element of the array given by the index, counting from 0.
<code>a.get(i)</code> is equivalent to <code>a(i)?</code>.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A].set(Integer, A) :: Signal</code></para>
        <para>Set the element of the array given by the index, counting from 0.
<code>a.set(i,v)</code> is equivalent to <code>a(i) := v</code>.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A].slice(Integer, Integer) :: Array[A]</code></para>
        <para>Return a copy of the portion of the array with indices covered by the given
half-open range. The result array is still indexed counting from 0.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A].length? :: Integer</code></para>
        <para>Return the size of the array.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Array</code></term>
      <listitem>
        <para><code>site Array[A].fill(A) :: Signal</code></para>
        <para>Set every element of the array to the given value. The given value is not
copied, but is shared by every element of the array, so for example
<code>a.fill(Semaphore(1))</code> would allow you to access the same semaphore
from every element <code>a</code>.
</para><para>This method is primarily useful to initialize or reset an array to a constant
value,
for example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 0 0
val a = Array(3)
a.fill(0) >> each(a)]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Table</code></term>
      <listitem>
        <para><code>def Table[A](Integer, lambda (Integer) :: A)(Integer) :: A</code></para>
        <para>The call <code>Table(n,f)</code>, where <code>n</code> is a
natural number and <code>f</code> a total function over natural numbers,
creates and returns a partial, pre-computed version of <code>f</code>
restricted to the range (0, <code>n</code>-1). <code>Table</code> does
not return a value until all calls to <code>f</code> have completed.
Consequently, if <code>f</code> halts on any call, the call to 
<code>Table</code> will halt.
</para><para>The user may also think of the call as returning an immutable array whose
<code>i</code>th element is accessed by calling <code>f(i)</code>.
</para><para>This function provides a simple form of memoisation; we avoid recomputing
the value of <code>f(i)</code> by internally storing the result in an array.
</para><para>Example:
<programlisting><![CDATA[
val a = Table(5, fib)
-- Publishes the 4th number of the fibonnaci sequence: 5
a(3)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def Table[A](Integer, lambda (Integer) :: A)(Integer) :: A
def Table(n, f) =
  val a = Array[A](n) :: Array[A]
  def fill(Integer, lambda (Integer) :: A) :: Signal
  def fill(i, f) =
    if i <: 0 then signal
    else ((a(i) := f(i)), fill(i-1, f)) >> signal
  fill(n-1, f) >> (lambda (i :: Integer) = a(i)?)


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A]() :: Set[A]</code></para>
        <para>Construct an empty mutable set. The set considers two
values <code>a</code> and <code>b</code> to be the same if
and only if <code>a=b</code>. This site conforms to the Java interface
<code>java.util.Set</code>, except that it obeys Orc rules for equality of
elements rather than Java rules.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A].add(A) :: Boolean</code></para>
        <para>Add a value to the set, returning true if the set did not already contain the value,
and false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A].remove(Signal) :: Boolean</code></para>
        <para>Remove a value from the set, returning true if the set contained the value,
and false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A].contains(Signal) :: Boolean</code></para>
        <para>Return true if the set contains the given value, and false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A].isEmpty() :: Boolean</code></para>
        <para>Return true if the set contains no values.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A].clear() :: Signal</code></para>
        <para>Remove all values from the set.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Set</code></term>
      <listitem>
        <para><code>site Set[A].size() :: Integer</code></para>
        <para>Return the number of unique values currently contained in the set.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Counter</code></term>
      <listitem>
        <para><code>site Counter(Integer) :: Counter</code></para>
        <para>Create a new counter initialized to the given value.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Counter</code></term>
      <listitem>
        <para><code>site Counter() :: Counter</code></para>
        <para>Create a new counter initialized to zero.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Counter.inc</code></term>
      <listitem>
        <para><code>site Counter.inc() :: Signal</code></para>
        <para>Increment the counter.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Counter.dec</code></term>
      <listitem>
        <para><code>site Counter.dec() :: Signal</code></para>
        <para>If the counter is already at zero, halt. Otherwise, decrement
the counter and return a signal.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Counter.onZero</code></term>
      <listitem>
        <para><code>site Counter.onZero() :: Signal</code></para>
        <para>If the counter is at zero, return a signal. Otherwise
block until the counter reaches zero.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Counter.value</code></term>
      <listitem>
        <para><code>site Counter.value() :: Integer</code></para>
        <para>Return the current value of the counter.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes five signals
val c = Counter(5)
repeat(c.dec)]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Dictionary</code></term>
      <listitem>
        <para><code>site Dictionary() :: Dictionary</code></para>
        <para>Create a new dictionary (a mutable map from field names to values), initially
empty.  The first time each field of the dictionary is accessed (using dot
notation), the dictionary creates and returns a new empty <link
linkend="orc.lib.state.Ref">Ref</link> which will also be returned on
subsequent accesses of the same field.  Dictionaries allow you to easily create
object-like data structures.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Prints: 1 2
val d = Dictionary()
  println(d.one.read()) >>
  println(d.two.read()) >>
  stop
| d.one.write(1) >>
  d.two.write(2) >>
  stop]]></programlisting>
</para><para>Here is the same example rewritten using Orc's reference syntax to improve
clarity:
<programlisting language="orc-demo"><![CDATA[
-- Prints: 1 2
val d = Dictionary()
  println(d.one?) >>
  println(d.two?) >>
  stop
| d.one := 1 >>
  d.two := 2 >>
  stop]]></programlisting>
</para><para>To create a multi-level dictionary, you must explicitly create sub-dictionaries
for each field. For example:
<programlisting language="orc-demo"><![CDATA[
-- Prints: 2
val d = Dictionary()
d.one := Dictionary() >>
d.one?.two := 2 >>
println(d.one?.two?) >>
stop]]></programlisting>
</para><para>Note that you cannot write <code>d.one.two</code>: because <code>d.one</code>
is a reference to a dictionary, and not simply a dictionary, you must
dereference before accessing its fields, as in <code>d.one? >x> x.two</code>.
For readers familiar with the C language, this is the same reason you must
write <code language="c">s->field</code> instead of <code>s.field</code> when
<code>s</code> is a pointer to a struct.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>fst</code></term>
      <listitem>
        <para><code>def fst[A,B]((A,B)) :: A</code></para>
        <para>Return the first element of a pair.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def fst[A,B]((A,B)) :: A
def fst((x,_)) = x

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>snd</code></term>
      <listitem>
        <para><code>def snd[A,B]((A,B)) :: B</code></para>
        <para>Return the second element of a pair.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def snd[A,B]((A,B)) :: B
def snd((_,y)) = y

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A](A, A) :: Interval[A]</code></para>
        <para><code>Interval(a,b)</code> returns an object representing the half-open
interval [<code>a</code>,<code>b</code>).
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A].isEmpty() :: Boolean</code></para>
        <para>Return true if this interval is empty.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A].spans(A) :: Boolean</code></para>
        <para>Return true if the interval spans the given point, false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A].intersects(Interval[A]) :: Boolean</code></para>
        <para>Return true if the given interval has a non-empty intersection with this one,
and false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A].intersect(Interval[A]) :: Interval[A]</code></para>
        <para>Return the intersection of this interval with another. If
the two intervals do not intersect, returns an empty interval.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A].contiguous(Interval[A]) :: Boolean</code></para>
        <para>Return true if the given interval is contiguous with this one
(overlaps or abuts), and false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Interval</code></term>
      <listitem>
        <para><code>site Interval[A].union(Interval[A]) :: Interval[A]</code></para>
        <para>Return the union of this interval with another. Halts with an error if
the two intervals are not contiguous.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Intervals</code></term>
      <listitem>
        <para><code>site Intervals[A]() :: Intervals[A]</code></para>
        <para>Return an empty set of intervals. An Intervals object is iterable;
iterating over the set returns disjoint intervals in increasing order.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Intervals</code></term>
      <listitem>
        <para><code>site Intervals[A].isEmpty() :: Boolean</code></para>
        <para>Return true if this set of intervals is empty.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Intervals</code></term>
      <listitem>
        <para><code>site Intervals[A].spans(A) :: Boolean</code></para>
        <para>Return true if this set of intervals spans the given point, and false otherwise.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Intervals</code></term>
      <listitem>
        <para><code>site Intervals[A].intersect(Intervals[A]) :: Intervals[A]</code></para>
        <para>Return the intersection of this set of intervals with another.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>Intervals</code></term>
      <listitem>
        <para><code>site Intervals[A].union(Interval[A]) :: Intervals[A]</code></para>
        <para>Return the union of this set of intervals with the given interval.
This method is most efficient when the given interval is before
most of the intervals in the set.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>text.inc</title>
      <para>Operations on strings.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>String</code></term>
      <listitem>
        <para><code>site String</code></para>
        <para>Strings themselves have a set of methods associated with them. These methods can
be invoked on any string literal or any variable bound to a string.
</para><para>The methods documented here are only a subset of those available in the Java
implementation. In practice, strings in the Java implementation support all 
methods provided by Java's <code>String</code> class.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>String.length</code></term>
      <listitem>
        <para><code>site String.length() :: Integer</code></para>
        <para>Return the length of the string.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 4
"four".length()]]></programlisting>
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>String.substring</code></term>
      <listitem>
        <para><code>site String.substring(Integer, Integer) :: String</code></para>
        <para>Return the substring of this string covered by the given half-open range.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "orc"
val s = "apple orchard"
s.substring(6,9)]]></programlisting>
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>String.indexOf</code></term>
      <listitem>
        <para><code>site String.indexOf(String) :: Integer</code></para>
        <para>Return the starting index of the first occurrence of the given string.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 6
"apple orchard".indexOf("orc")]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>print</code></term>
      <listitem>
        <para><code>site print(Top) :: Signal</code></para>
        <para>Print a value as a string to standard output.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>read</code></term>
      <listitem>
        <para><code>site read[A](String) :: A</code></para>
        <para>Given a string representing an Orc value (using standard
Orc literal syntax), return the corresponding value. If
the argument does not conform to Orc literal syntax,
halt with an error.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
  read("true") -- publishes the boolean true
| read("1") -- publishes the integer 1
| read("(3.0, [])") -- publishes the tuple (3.0, [])
| read("\"hi\"") -- publishes the string "hi"]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>write</code></term>
      <listitem>
        <para><code>site write(Top) :: String</code></para>
        <para>Given an Orc value, return its string representation
using standard Orc literal syntax.  If the value is
of a type with no literal syntax,
(for example, it is a site), return an arbitrary string
representation which is intended to be human-readable.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
  write(true) -- publishes "true"
| write(1) -- publishes "1"
| write((3.0, [])) -- publishes "(3.0, [])"
| write("hi") -- publishes "\"hi\""]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>lines</code></term>
      <listitem>
        <para><code>def lines(String) :: List[String]</code></para>
        <para>Split a string into lines, which are substrings
terminated by an endline or the end of the string.
DOS, Mac, and Unix endline conventions are all accepted.
Endline characters are not included in the result.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def lines(String) :: List[String]
def lines(text) =
  (
  val out = text.split("\n|\r\n|\r")
  if out.get(out.length()-1) = "" then
    out.split(0, out.length()-1)
  else out
  )  :!: List[String]

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>unlines</code></term>
      <listitem>
        <para><code>def unlines(List[String]) :: String</code></para>
        <para>Append a linefeed, "\n", to each string in the sequence
and concatenate the results.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def unlines(List[String]) :: String
def unlines(line:lines) = line + "\n" + unlines(lines)
def unlines([]) = ""
  
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>words</code></term>
      <listitem>
        <para><code>def words(String) :: List[String]</code></para>
        <para>Split a string into words, which are sequences of non-whitespace characters separated by whitespace.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[

def words(String) :: List[String]
def words(text) = (text.trim().split("\\s+"))  :!: List[String]


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>unwords</code></term>
      <listitem>
        <para><code>def unwords(List[String]) :: String</code></para>
        <para>Concatenate a sequence of strings with a single space between
each string.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def unwords(List[String]) :: String
def unwords([]) = ""
def unwords([word]) = word
def unwords(word:words) = word + " " + unwords(words)
]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>time.inc</title>
      <para>Real and logical time.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Rtimer</code></term>
      <listitem>
        <para><code>site Rtimer(Integer) :: Signal</code></para>
        <para>Publish a signal after the given number of milliseconds.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Rtimer.time</code></term>
      <listitem>
        <para><code>site Rtimer.time() :: Integer</code></para>
        <para>Return the current real time in milliseconds, as
measured from midnight January 1, 1970 UTC.
Ranges from 0 to <code>Long.MAX_VALUE</code>.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Clock</code></term>
      <listitem>
        <para><code>def Clock()() :: Number</code></para>
        <para>A call to <code>Clock</code> creates a new relative real-time clock.
Calling a relative clock returns the number
of milliseconds which have elapsed since the
clock was created.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes a value near 1000
val c = Clock()
Rtimer(1000) >> c()]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Ltimer</code></term>
      <listitem>
        <para><code>site Ltimer(Integer) :: Signal</code></para>
        <para>Publish a signal after the given number of logical timesteps,
as measured by the current logical clock.
The logical time advances whenever the computation controlled
by the logical clock is quiescent (i.e. cannot advance on its own).
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Ltimer.time</code></term>
      <listitem>
        <para><code>site Ltimer.time() :: Integer</code></para>
        <para>Return the current logical time, as measured by logical
clock which was current when <code>Ltimer.time</code> was evaluated.
Ranges from 0 to <code>Integer.MAX_VALUE</code>.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>withLtimer</code></term>
      <listitem>
        <para><code>def withLtimer[A](lambda () :: A) :: A</code></para>
        <para>Run the given thunk in the context of a new inner logical clock.
Within the computation represented by the thunk, calls to
<code>Ltimer</code> refer to the new clock. The
outer clock can only advance when the inner clock becomes
quiescent.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>metronome</code></term>
      <listitem>
        <para><code>def metronome(Integer) :: Signal</code></para>
        <para>Publish a signal at regular intervals, indefinitely. The period is given by the
argument, in milliseconds.
</para>
      </listitem>
    </varlistentry>
          </variablelist>
    </section><section> 
      <title>util.inc</title>
      <para>Miscellaneous utility functions.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>random</code></term>
      <listitem>
        <para><code>site random() :: Integer</code></para>
        <para>Return a random Integer value
chosen from the range of all possible 32-bit Integer values.
</para>
      </listitem>
    </varlistentry><varlistentry>
      <term><code>random</code></term>
      <listitem>
        <para><code>site random(Integer) :: Integer</code></para>
        <para>Return a pseudorandom, uniformly distributed Integer value
between 0 (inclusive) and the specified value (exclusive).
If the argument is 0, halt.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>urandom</code></term>
      <listitem>
        <para><code>site urandom() :: Number</code></para>
        <para>Returns a pseudorandom, uniformly distributed Double value
between 0.0 (inclusive) and 1.0 (exclusive).
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>UUID</code></term>
      <listitem>
        <para><code>site UUID() :: String</code></para>
        <para>Return a random (type 4) UUID represented as a string.
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>Prompt</code></term>
      <listitem>
        <para><code>site Prompt(String) :: String</code></para>
        <para>Prompt the user for some input. The user may cancel the prompt,
in which case the site fails silently. Otherwise their response
is returned as soon as it is received.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes the user's name
Prompt("What is your name?")]]></programlisting>
</para><para>The user response is always taken to be a string. Thus, integer 
3 as a response will be treated as "3". To convert the response 
to its appropriate data type, use the library function
<code>read</code>:
</para><para><programlisting language="orc-demo"><![CDATA[
-- Prompts the user to enter an integer, then parses the response.
Prompt("Enter an integer:") >r> read(r)]]></programlisting>
</para>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>signals</code></term>
      <listitem>
        <para><code>def signals(Integer) :: Signal</code></para>
        <para>Publish the given number of signals, simultaneously.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes five signals
signals(5)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def signals(Integer) :: Signal
def signals(n) = if n :> 0 then (signal | signals(n-1)) else stop

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>for</code></term>
      <listitem>
        <para><code>def for(Integer, Integer) :: Integer</code></para>
        <para>Publish all values in the given half-open range, simultaneously.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 1 2 3 4 5
for(1,6)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def for(Integer, Integer) :: Integer
def for(low, high) =
  if low >= high then stop
  else ( low | for(low+1, high) )

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>upto</code></term>
      <listitem>
        <para><code>def upto(Integer) :: Integer</code></para>
        <para><code>upto(n)</code> publishes all values in the range <code>(0..n-1)</code>
simultaneously.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2 3 4
upto(5)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def upto(Integer) :: Integer
def upto(high) = for(0, high)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>fillArray</code></term>
      <listitem>
        <para><code>def fillArray[A](Array[A], lambda (Integer) :: A) :: Array[A]</code></para>
        <para>Given an array and a function from indices to values, populate the array
by calling the function for each index in the array. Return the array
once it has been populated.
</para><para>For example, to set all elements of an array to zero:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 0 0
val a = fillArray(Array(3), lambda (_) = 0)
a.get(0) | a.get(1) | a.get(2)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def fillArray[A](Array[A], lambda (Integer) :: A)
  :: Array[A]
def fillArray(a, f) =
  val n = a.length?
  def fill(Integer, lambda(Integer) :: A) :: Bot
  def fill(i, f) =
    if i = n then stop
    else ( a(i) := f(i) >> stop
         | fill(i+1, f) )
  fill(0, f) ; a

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>takePubs</code></term>
      <listitem>
        <para><code>def takePubs[A](Integer, lambda () :: A) :: A</code></para>
        <para><code>takePubs(n, f)</code> calls <code>f()</code>,
publishes the first <code>n</code> values published
by <code>f()</code> (as they are published), and then
halts.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[

def takePubs[A](Integer, lambda () :: A) :: A
def takePubs(n, f) =
  val out = Buffer[A]()
  val c = Counter(n)
  let(
    f() >x>
    If(c.dec() >> out.put(x) >> false
       ; out.closenb() >> true)
  ) >> stop | repeat(out.get)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>withLock</code></term>
      <listitem>
        <para><code>def withLock[A](Semaphore, lambda () :: A) :: A</code></para>
        <para>Acquire the semaphore and run a thunk which is expected to publish
no more than one value. Publishes the value published by the
thunk and releases the semaphore.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[

def withLock[A](Semaphore, lambda () :: A) :: A
def withLock(s, f) =
  s.acquire() >> (
    let(f()) >x>
    s.release() >>
    x
    ; s.release() >> stop
  )


]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
      <term><code>synchronized</code></term>
      <listitem>
        <para><code>def synchronized[A](Semaphore, lambda () :: A)() :: A</code></para>
        <para>Given a lock and thunk, return a new thunk which is serialized
on the lock. Similar to Java's synchronized keyword.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[

def synchronized[A](Semaphore, lambda () :: A)() :: A
def synchronized(s,f)() = withLock(s, f)

]]>
      </programlisting>
    </formalpara>
      </listitem>
    </varlistentry>
          </variablelist>
    </section>
    </appendix>