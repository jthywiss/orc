<?xml version="1.0"?>
<section><title>Reference</title>
<section><title>core.inc: Fundamental sites and operators.</title>
<para>Fundamental sites and operators.
For a more complete description of the built-in operators and their syntax, see
the <link linkend="language.base.operators">Operators</link> section of the
User Guide.</para>
<variablelist>
<varlistentry><term><code>let</code></term><listitem><para><code>site let(A) :: A</code></para>
<para>When applied to a single argument, return that argument (behaving as the identity function).</para>
</listitem></varlistentry>
<varlistentry><term><code>let</code></term><listitem><para><code>site let(A, ...) :: (A, ...)</code></para>
<para>When applied to zero, two, or more arguments, return the arguments in a tuple.</para>
</listitem></varlistentry>
<varlistentry><term><code>if</code></term><listitem><para><code>site if(Boolean) :: Signal</code></para>
<para>Fail silently if the argument is false. Otherwise return a signal.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Always publishes"
  if(false) >> "Never publishes"
| if(true) >> "Always publishes"]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>error</code></term><listitem><para><code>site error(String) :: Bot</code></para>
<para>Fail with the given error message.</para>
<para>Example, using <code>error</code> to implement assertions:
<programlisting language="orc-demo"><![CDATA[
def assert(b) =
  if b then signal else error("assertion failed")

-- Fail with the error message: "assertion failed"
assert(false)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>(+)</code></term><listitem><para><code>site (+)(Number, Number) :: Number</code></para>
<para><code>a+b</code> returns the sum of <code>a</code> and <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(-)</code></term><listitem><para><code>site (-)(Number, Number) :: Number</code></para>
<para><code>a-b</code> returns the value of <code>a</code> minus the value of <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(0-)</code></term><listitem><para><code>site (0-)(Number) :: Number</code></para>
<para>Return the additive inverse of the argument.
When this site appears as an operator, it is written without the zero,
i.e. <code>(-a)</code></para>
</listitem></varlistentry>
<varlistentry><term><code>(*)</code></term><listitem><para><code>site (*)(Number, Number) :: Number</code></para>
<para><code>a*b</code> returns the product of <code>a</code> and <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(**)</code></term><listitem><para><code>site (**)(Number, Number) :: Number</code></para>
<para><code>a ** b</code> returns
<inlineequation><mathphrase>a<superscript>b</superscript></mathphrase></inlineequation>,
i.e. <code>a</code> raised to the <code>b</code>th power.</para>
</listitem></varlistentry>
<varlistentry><term><code>(/)</code></term><listitem><para><code>site (/)(Number, Number) :: Number</code></para>
<para><code>a/b</code> returns <code>a</code> divided by <code>b</code>.
If both arguments have integral types, <code>(/)</code> performs integral
division, rounding towards zero. Otherwise, it performs floating-point
division.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
  7 / 3   -- publishes 2
| 7 / 3.0 -- publishes 2.333...]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>(%)</code></term><listitem><para><code>site (%)(Number, Number) :: Number</code></para>
<para><code>a%b</code> computes the remainder of <code>a/b</code>. If <code>a</code>
and <code>b</code> have integral types, then the remainder is given by
the expression <code>a - (a/b)*b</code>. For a full description, see the
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.17.3">Java Language Specification, 3rd edition</link>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&lt;)</code></term><listitem><para><code>site (&lt;)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a &lt; b</code> returns true if <code>a</code> is less than <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&lt;=)</code></term><listitem><para><code>site (&lt;=)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a &lt;= b</code> returns true if <code>a</code> is less than or equal to <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&gt;)</code></term><listitem><para><code>site (&gt;)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a > b</code> returns true if <code>a</code> is greater than <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&gt;=)</code></term><listitem><para><code>site (&gt;=)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a >= b</code> returns true if <code>a</code> is greater than or equal to <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(=)</code></term><listitem><para><code>site (=)(Top, Top) :: Boolean</code></para>
<para><code>a = b</code> returns true if <code>a</code> is equal to <code>b</code>, and false otherwise.
The precise definition of "equal" depends on the values being compared, but
obeys the rule that if two values are considered equal, then one may be
substituted locally for the other without affecting the behavior of the
program.  Generally, two values are guaranteed to be considered equal only if
they are identical (in the sense of having the same object identity). In most
cases, immutable objects are also considered equal if their contents are equal.</para>
</listitem></varlistentry>
<varlistentry><term><code>(/=)</code></term><listitem><para><code>site (/=)(Top, Top) :: Boolean</code></para>
<para><code>a/=b</code> returns false if <code>a=b</code>, and true otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(~)</code></term><listitem><para><code>site (~)(Boolean) :: Boolean</code></para>
<para>Return the logical negation of the argument.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&amp;&amp;)</code></term><listitem><para><code>site (&amp;&amp;)(Boolean, Boolean) :: Boolean</code></para>
<para>Return the logical conjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.</para>
</listitem></varlistentry>
<varlistentry><term><code>(||)</code></term><listitem><para><code>site (||)(Boolean, Boolean) :: Boolean</code></para>
<para>Return the logical disjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.</para>
</listitem></varlistentry>
<varlistentry><term><code>(:)</code></term><listitem><para><code>site (:)(A, [A]) :: [A]</code></para>
<para><code>a:b</code> returns the list formed by prepending the element <code>a</code>
to the list <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(:)</code></term><listitem><para><code>pattern (:)([A]) :: (A, [A])</code></para>
<para>The inverse of the list constructor <code>(:)</code>. Returns the head and tail
of the list.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: (3, [4, 5])
[3,4,5] >x:xs> (x,xs)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>abs</code></term><listitem><para><code>def abs(Number) :: Number</code></para>
<para>Return the absolute value of the argument.</para>
</listitem></varlistentry>
<varlistentry><term><code>signum</code></term><listitem><para><code>def signum(Number) :: Number</code></para>
<para>If the argument is 0, return 0. Otherwise return the sign of the argument,
as given by the equation <code>signum(a) = a/abs(a)</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>min</code></term><listitem><para><code>def min(A,A) :: A, A &lt;: Comparable</code></para>
<para>Return the lesser of the arguments. If the arguments
are equal, return the first argument.</para>
</listitem></varlistentry>
<varlistentry><term><code>max</code></term><listitem><para><code>def max(A,A) :: A, A &lt;: Comparable</code></para>
<para>Return the greater of the arguments. If the arguments
are equal, return the second argument.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>data.inc: General-purpose supplemental data structures.</title>
<para>General-purpose supplemental data structures.</para>
<variablelist>
<varlistentry><term><code>Semaphore</code></term><listitem><para><code>site Semaphore(Integer) :: Semaphore</code></para>
<para>Return a semaphore with the given number of available items.</para>
<para>An example using a semaphore as a lock for a critical section:
<programlisting language="orc-demo"><![CDATA[
-- Prints:
-- Entering critical section
-- Leaving critical section
val lock = Semaphore(1)
lock.acquire() >>
println("Entering critical section") >>
println("Leaving critical section") >>
lock.release()]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Semaphore.acquire</code></term><listitem><para><code>site Semaphore.acquire() :: Signal</code></para>
<para>Acquire an item. If none are available, block until one becomes available.</para>
</listitem></varlistentry>
<varlistentry><term><code>Semaphore.acquirenb</code></term><listitem><para><code>site Semaphore.acquirenb() :: Signal</code></para>
<para>Acquire an item. If no items are available, fail silently.</para>
</listitem></varlistentry>
<varlistentry><term><code>Semaphore.release</code></term><listitem><para><code>site Semaphore.release() :: Signal</code></para>
<para>Release an item.  This may be called to add items beyond
the initial number of available items with which the semaphore was constructed.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Buffer</code></term><listitem><para><code>site Buffer() :: Buffer&lt;A&gt;</code></para>
<para>Create a new buffer (FIFO channel) of unlimited size.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 10
val b = Buffer()
  Rtimer(1000) >> b.put(10) >> stop
| b.get()]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Buffer.get</code></term><listitem><para><code>site Buffer&lt;A&gt;.get() :: A</code></para>
<para>Get an item from the buffer. If no items are available, block until one becomes available.</para>
</listitem></varlistentry>
<varlistentry><term><code>Buffer.getnb</code></term><listitem><para><code>site Buffer&lt;A&gt;.getnb() :: A</code></para>
<para>Get an item from the buffer. If no items are available, fail silently.</para>
</listitem></varlistentry>
<varlistentry><term><code>Buffer.put</code></term><listitem><para><code>site Buffer&lt;A&gt;.put(A) :: Signal</code></para>
<para>Put an item in the buffer.</para>
</listitem></varlistentry>
<varlistentry><term><code>Buffer.close</code></term><listitem><para><code>site Buffer&lt;A&gt;.close() :: Signal</code></para>
<para>Close the buffer. This has the effect of immediately causing any blocked calls
to <code>get</code> to fail silently. In addition, any subsequent calls to
<code>get</code> or <code>put</code> will fail silently.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>SyncChannel</code></term><listitem><para><code>site SyncChannel() :: SyncChannel&lt;A&gt;</code></para>
<para>Create a synchronous channel, or rendezvous.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publish: 10
val c = SyncChannel()
  c.put(10)
| Rtimer(1000) >> c.get()]]></programlisting></para>
<variablelist>
<varlistentry><term><code>SyncChannel.get</code></term><listitem><para><code>site SyncChannel&lt;A&gt;.get() :: A</code></para>
<para>Receive an item over the channel. If no sender is available, block until one becomes available.</para>
</listitem></varlistentry>
<varlistentry><term><code>SyncChannel.put</code></term><listitem><para><code>site SyncChannel&lt;A&gt;.put(A) :: Signal</code></para>
<para>Send an item over the channel. If no receiver is available, block until one becomes available.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Cell</code></term><listitem><para><code>site Cell() :: Cell&lt;A&gt;</code></para>
<para>Create a write-once storage location.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 5 5
val c = Cell()
  c.write(5) >> c.read()
| Rtimer(1) >> ( c.write(10) ; c.read() )]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Cell.read</code></term><listitem><para><code>site Cell&lt;A&gt;.read() :: A</code></para>
<para>Read a value from the cell. If the cell does not yet have a value, block until it receives one.</para>
</listitem></varlistentry>
<varlistentry><term><code>Cell.readnb</code></term><listitem><para><code>site Cell&lt;A&gt;.readnb() :: A</code></para>
<para>Read a value from the cell. If the cell does not yet have a value, fail silently.</para>
</listitem></varlistentry>
<varlistentry><term><code>Cell.write</code></term><listitem><para><code>site Cell&lt;A&gt;.write() :: Signal</code></para>
<para>Write a value to the cell. If the cell already has a value, fail silently.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Ref</code></term><listitem><para><code>site Ref() :: Ref&lt;A&gt;</code></para>
<para>Create an empty rewritable storage location.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
val r = Ref()
Rtimer(1000) >> r.write(5) >> stop
| println(r.read()) >>
  r.write(10) >>
  println(r.read()) >>
  stop]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Ref</code></term><listitem><para><code>site Ref&lt;A&gt;(A) :: Ref&lt;A&gt;</code></para>
<para>Create a rewritable storage location containing the provided value.</para>
</listitem></varlistentry>
<varlistentry><term><code>Ref.read</code></term><listitem><para><code>site Ref&lt;A&gt;.read() :: A</code></para>
<para>Read the value of the ref. If the ref is empty, block until it is no longer empty.</para>
</listitem></varlistentry>
<varlistentry><term><code>Ref.readnb</code></term><listitem><para><code>site Ref&lt;A&gt;.readnb() :: A</code></para>
<para>Read the value of the ref. If the ref is empty, fail silently.</para>
</listitem></varlistentry>
<varlistentry><term><code>Ref.write</code></term><listitem><para><code>site Ref&lt;A&gt;.write(A) :: Signal</code></para>
<para>Write a value to the ref.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Null</code></term><listitem><para><code>site Null() :: Bot</code></para>
<para>Return a Java null value. This is only necessary to interface with certain
Java libraries, Orc programs should use the <code>None()</code> constructor
instead of null values.</para>
</listitem></varlistentry>
<varlistentry><term><code>Array</code></term><listitem><para><code>site Array(Integer) :: Array&lt;A&gt;</code></para>
<para>Create a new array of the given size.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2
val a = Array(3)
for(0, a.length()) >i>
a.set(i, f(i)) >>
stop
; a.get(0) | a.get(1) | a.get(2)]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Array</code></term><listitem><para><code>site Array&lt;A&gt;(Integer, String) :: Array&lt;A&gt;</code></para>
<para>Create a new primitive array of the given size with the given primitive type.
The primitive type should match the element type of the array, although a
typechecker may not be able to verify this. This constructor is only necessary
when interfacing with certain Java libraries; most programs will just use the 
<code>Array&lt;A&gt;(Integer)</code> constructor.</para>
</listitem></varlistentry>
<varlistentry><term><code>Array.get</code></term><listitem><para><code>site Array&lt;A&gt;.get(Integer) :: A</code></para>
<para>Get the element of the array given by the index, counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>Array.set</code></term><listitem><para><code>site Array&lt;A&gt;.set(Integer, A) :: Signal</code></para>
<para>Set the element of the array given by the index, counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>Array.slice</code></term><listitem><para><code>site Array&lt;A&gt;.slice(Integer, Integer) :: Array&lt;A&gt;</code></para>
<para>Return a copy of the portion of the array with indices covered by the given
half-open range. The result array is still indexed counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>Array.length</code></term><listitem><para><code>site Array&lt;A&gt;.length() :: Integer</code></para>
<para>Return the size of the array.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>fillArray</code></term><listitem><para><code>def fillArray(Array&lt;A&gt;, lambda (Integer) :: A) :: Array&lt;A&gt;</code></para>
<para>Given an array and a function from indices to values, populate the array.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 1 2 3
val a = fillArray(Array(3), let)
a.get(0) | a.get(1) | a.get(2)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>IArray</code></term><listitem><para><code>def IArray(Integer, lambda (Integer) :: A)(Integer) :: A</code></para>
<para>Create an immutable mapping (array) from integers to values.
The first argument gives the upper exclusive bound of the mapping
(the lower inclusive bound is always 0). The second argument
is a function which gives the value of the mapping for each index in the array.</para>
<para>You can think of the immutable mapping as a memoized version of the
function over a finite range.</para>
</listitem></varlistentry>
<varlistentry><term><code>Some</code></term><listitem><para><code>site Some(A) :: Option&lt;A&gt;</code></para>
<para>Construct an available optional value.</para>
</listitem></varlistentry>
<varlistentry><term><code>Some</code></term><listitem><para><code>pattern Some(Option&lt;A&gt;) :: (A)</code></para>
<para>Deconstruct an available optional value.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 3
Some(3) >Some(x)> x]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>None</code></term><listitem><para><code>site None(A) :: Option&lt;A&gt;</code></para>
<para>Construct an unavailable optional value.</para>
</listitem></varlistentry>
<varlistentry><term><code>None</code></term><listitem><para><code>pattern None(Option&lt;A&gt;) :: ()</code></para>
<para>Deconstruct an unavailable optional value.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: true
  None() >None()> true
| Some(3) >None()> false]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>Left</code></term><listitem><para><code>site Left(A) :: Either&lt;A&gt;</code></para>
<para>Construct a "left" member of a union which may be tagged either "left" or "right".</para>
</listitem></varlistentry>
<varlistentry><term><code>Left</code></term><listitem><para><code>pattern Left(Either&lt;A&gt;) :: A</code></para>
<para>Deconstruct a "left" member of a union.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "left"
Left(3) >x> (
   x >Right(_)> "right"
 | x >Left(_)> "left"
)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>Right</code></term><listitem><para><code>site Right(A) :: Either&lt;A&gt;</code></para>
<para>Construct a "right" member of a union which may be tagged either "left" or "right".</para>
</listitem></varlistentry>
<varlistentry><term><code>Right</code></term><listitem><para><code>pattern Right(Either&lt;A&gt;) :: A</code></para>
<para>Deconstruct a "right" member of a union.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "right"
Right(3) >x> (
   x >Right(_)> "right"
 | x >Left(_)> "left"
)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>fst</code></term><listitem><para><code>def fst((A,B)) :: A</code></para>
<para>Return the first element of a pair.</para>
</listitem></varlistentry>
<varlistentry><term><code>snd</code></term><listitem><para><code>def snd((A,B)) :: B</code></para>
<para>Return the second element of a pair.</para>
</listitem></varlistentry>
<varlistentry><term><code>swap</code></term><listitem><para><code>def swap((A,B)) :: (B,A)</code></para>
<para>Swap the elements of a pair.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>idioms.inc: Higher-order Orc programming idioms.</title>
<para>Higher-order Orc programming idioms.
Many of these are standard functional-programming
combinators borrowed from Haskell or Scheme.</para>
<variablelist>
<varlistentry><term><code>apply</code></term><listitem><para><code>site apply(lambda (A, ...) :: B, [A]) :: B</code></para>
<para>Apply a function to a list of arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>curry</code></term><listitem><para><code>def curry(lambda (A,B) :: C)(A)(B) :: C</code></para>
<para>Curry a function of two arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>curry3</code></term><listitem><para><code>def curry3(lambda (A,B,C) :: D)(A)(B)(C) :: D</code></para>
<para>Curry a function of three arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>uncurry</code></term><listitem><para><code>def uncurry(lambda (A)(B) :: C)(A, B) :: C</code></para>
<para>Uncurry a function of two arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>uncurry3</code></term><listitem><para><code>def uncurry3(lambda (A)(B)(C) :: D)(A,B,C) :: D</code></para>
<para>Uncurry a function of three arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>flip</code></term><listitem><para><code>def flip(lambda (A, B) :: C)(B, A) :: C</code></para>
<para>Flip the order of parameters of a two-argument function.</para>
</listitem></varlistentry>
<varlistentry><term><code>constant</code></term><listitem><para><code>def constant(A)() :: A</code></para>
<para>Create a function which returns a constant value.</para>
</listitem></varlistentry>
<varlistentry><term><code>bind</code></term><listitem><para><code>def bind(lambda (A) :: B, A)() :: B</code></para>
<para>Given a function and its argument, return a thunk which applies the function.</para>
</listitem></varlistentry>
<varlistentry><term><code>bind2</code></term><listitem><para><code>def bind2(lambda (A,B) :: C, A, B)() :: C</code></para>
<para>Given a function and its arguments, return a thunk which applies the function.</para>
</listitem></varlistentry>
<varlistentry><term><code>ignore</code></term><listitem><para><code>def ignore(lambda () :: B)(A) :: B</code></para>
<para>From a function of no arguments, create a function
of one argument, which is ignored.</para>
</listitem></varlistentry>
<varlistentry><term><code>ignore2</code></term><listitem><para><code>def ignore2(lambda () :: C)(A, B) :: C</code></para>
<para>From a function of no arguments, create a function
of two arguments, which are ignored.</para>
</listitem></varlistentry>
<varlistentry><term><code>compose</code></term><listitem><para><code>def compose(lambda (B) :: C, lambda (A) :: B)(A) :: C</code></para>
<para>Compose two single-argument functions.</para>
</listitem></varlistentry>
<varlistentry><term><code>while</code></term><listitem><para><code>def while(lambda (A) :: Boolean, lambda (A) :: A)(A) :: A</code></para>
<para>Iterate a function while a predicate is satisfied, publishing
each value passed to the function. The exact behavior is specified
by the following implementation:</para>
<para><programlisting><![CDATA[
def while(p,f) = 
  def loop(x) = if(p(x)) >> ( x | loop(f(x)) )
  loop]]></programlisting></para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2 3 4 5
while(
  lambda (n) = (n <= 5),
  lambda (n) = n+1
)(0)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>repeat</code></term><listitem><para><code>def repeat(lambda () :: A) :: A</code></para>
<para>Call a function sequentially, publishing each value returned by the function.
The expression <code>repeat(f)</code> is equivalent to
the infinite expression <code>f() >!_> f() >!_> f() >!_> ...</code></para>
</listitem></varlistentry>
<varlistentry><term><code>fork</code></term><listitem><para><code>def fork([lambda () :: A]) :: A</code></para>
<para>Call a list of functions in parallel, publishing
all values published by the functions.</para>
<para>The expression <code>fork([f,g,h])</code> is equivalent to
the expression <code>f() | g() | h()</code></para>
</listitem></varlistentry>
<varlistentry><term><code>sequence</code></term><listitem><para><code>def sequence([lambda () :: A]) :: Signal</code></para>
<para>Call a list of functions in sequence, publishing
a signal whenever the last function publishes. The
actual publications of the given functions are not
published.</para>
<para>The expression <code>sequence([f,g,h])</code> is equivalent to
the expression <code>f() >> g() >> h() >> signal</code></para>
</listitem></varlistentry>
<varlistentry><term><code>join</code></term><listitem><para><code>def join([lambda () :: A]) :: Signal</code></para>
<para>Call a list of functions in parallel and publish
a signal once all functions have completed.</para>
<para>The expression <code>join([f,g,h])</code> is equivalent to
the expression <code>f() >> stop | g() >> stop | h() >> stop ; signal</code></para>
</listitem></varlistentry>
<varlistentry><term><code>por</code></term><listitem><para><code>def por(lambda () :: Boolean, lambda () :: Boolean) :: Boolean</code></para>
<para>Parallel or. Evaluate two boolean functions in parallel, publishing
a value as soon as possible, and terminating any unnecessary ongoing
computation.</para>
</listitem></varlistentry>
<varlistentry><term><code>pand</code></term><listitem><para><code>def pand(lambda () :: Boolean, lambda () :: Boolean) :: Boolean</code></para>
<para>Parallel and. Evaluate two boolean functions in parallel, publishing
a value as soon as possible, and terminating any unnecessary ongoing
computation.</para>
</listitem></varlistentry>
<varlistentry><term><code>collect</code></term><listitem><para><code>def collect(lambda () :: A) :: [A]</code></para>
<para>Run a function, collecting all publications in a list.
Return the list when the function terminates.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [signal, signal, signal, signal, signal]
collect(bind(signals, 5))]]></programlisting></para>
</listitem></varlistentry></variablelist>
</section>
<section><title>list.inc: Operations on lists.</title>
<para>Operations on lists.
Many of these functions are similar to those in the Haskell prelude, but
operate on the elements of a list in parallel.</para>
<variablelist>
<varlistentry><term><code>each</code></term><listitem><para><code>def each([A]) :: A</code></para>
<para>Publish every value in a list, simultaneously.</para>
</listitem></varlistentry>
<varlistentry><term><code>map</code></term><listitem><para><code>def map(lambda (A) :: B, [A]) :: [B]</code></para>
<para>Apply a function to every element of a list (in parallel),
returning a list of the results.</para>
</listitem></varlistentry>
<varlistentry><term><code>reverse</code></term><listitem><para><code>def reverse([A]) :: [A]</code></para>
<para>Return the reverse of the given list.</para>
</listitem></varlistentry>
<varlistentry><term><code>filter</code></term><listitem><para><code>def filter(lambda (A) :: Boolean, [A]) :: [A]</code></para>
<para>Return a list containing only those elements which satisfy the predicate.
The filter is applied to all list elements in parallel.</para>
</listitem></varlistentry>
<varlistentry><term><code>head</code></term><listitem><para><code>def head([A]) :: A</code></para>
<para>Return the first element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>tail</code></term><listitem><para><code>def tail([A]) :: [A]</code></para>
<para>Return all but the first element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>init</code></term><listitem><para><code>def init([A]) :: [A]</code></para>
<para>Return all but the last element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>last</code></term><listitem><para><code>def last([A]) :: A</code></para>
<para>Return the last element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>empty</code></term><listitem><para><code>def empty([A]) :: Boolean</code></para>
<para>Is the list empty?</para>
</listitem></varlistentry>
<varlistentry><term><code>index</code></term><listitem><para><code>def index(Integer, [A]) :: A</code></para>
<para>Return the nth element of a list, counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>append</code></term><listitem><para><code>def append([A], [A]) :: [A]</code></para>
<para>Return the first list concatenated with the second.</para>
</listitem></varlistentry>
<varlistentry><term><code>foldl</code></term><listitem><para><code>def foldl(lambda (B, A) :: B, B, [A]) :: B</code></para>
<para>Reduce a list using the given left-associative binary operation and initial value.
Given the list <code>[x1, x2, x3, ...]</code> and initial value <code>x0</code>,
returns <code>f(... f(f(f(x0, x1), x2), x3) ...)</code></para>
<para>Example using <code>foldl</code> to reverse a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [3, 2, 1]
foldl(flip((:)), [], [1,2,3])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>foldl1</code></term><listitem><para><code>def foldl1(lambda (A, A) :: A, [A]) :: A</code></para>
<para>A special case of <code>foldl</code> which uses the last element of the list as the
initial value.</para>
</listitem></varlistentry>
<varlistentry><term><code>foldr</code></term><listitem><para><code>def foldr(lambda (A, B) :: B, B, [A]) :: B</code></para>
<para>Reduce a list using the given right-associative binary operation and initial value.
Given the list <code>[..., x3, x2, x1]</code> and initial value <code>x0</code>,
returns <code>f(... f(x3, f(x2, f(x1, x0))) ...)</code></para>
<para>Example summing the numbers in a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 6
foldr((+), 0, [1,2,3])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>foldr1</code></term><listitem><para><code>def foldr1(lambda (A, A) :: A, [A]) :: A</code></para>
<para>A special case of <code>foldr</code> which uses the last element of the list as the
initial value.</para>
</listitem></varlistentry>
<varlistentry><term><code>zip</code></term><listitem><para><code>def zip([A], [B]) :: (A, B)</code></para>
<para>Combine two lists into a list of pairs.
The length of the shortest list determines the length of the result.</para>
</listitem></varlistentry>
<varlistentry><term><code>unzip</code></term><listitem><para><code>def unzip([(A,B)]) :: ([A], [B])</code></para>
<para>Split a list of pairs into a pair of lists.</para>
</listitem></varlistentry>
<varlistentry><term><code>length</code></term><listitem><para><code>def length([A]) :: Integer</code></para>
<para>Return the number of elements in a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>take</code></term><listitem><para><code>def take(Integer, [A]) :: [A]</code></para>
<para>Given a number <code>n</code> and a list <code>l</code>,
return the first <code>n</code> elements of <code>l</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>drop</code></term><listitem><para><code>def drop(Integer, [A]) :: [A]</code></para>
<para>Given a number <code>n</code> and a list <code>l</code>,
return the elements of <code>l</code> after the first <code>n</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>member</code></term><listitem><para><code>def member(A, [A]) :: Boolean</code></para>
<para>Return true if the given item is a member of the given list, and false
otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>merge</code></term><listitem><para><code>def merge([A], [A]) :: [A], A &lt;: Comparable</code></para>
<para>Merge two sorted lists.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 2, 3, 4, 5]
merge([1,2,3], [2,4,5])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>mergeBy</code></term><listitem><para><code>def mergeBy(lambda (A,A) :: Boolean, [A], [A]) :: [A]</code></para>
<para>Merge two lists using the given less-than relation.</para>
</listitem></varlistentry>
<varlistentry><term><code>sort</code></term><listitem><para><code>def sort([A]) :: [A], A &lt;: Comparable</code></para>
<para>Sort a list.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sort([1,3,2])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>sortBy</code></term><listitem><para><code>def sortBy(lambda (A,A) :: Boolean, [A]) :: [A]</code></para>
<para>Sort a list using the given less-than relation.</para>
</listitem></varlistentry>
<varlistentry><term><code>group</code></term><listitem><para><code>def group([(A,B)]) :: [(A,[B])]</code></para>
<para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [(1, [1, 2]), (2, [3]), (3, [4]), (1, [3])]
group([(1,1), (1,2), (2,3), (3,4), (1,3)])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>groupBy</code></term><listitem><para><code>def groupBy(lambda (A,A) :: Boolean, [(A,B)]) :: [(A,[B])]</code></para>
<para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements,
using the given equality relation.</para>
</listitem></varlistentry>
<varlistentry><term><code>range</code></term><listitem><para><code>def range(Integer, Integer) :: [Integer]</code></para>
<para>Generate a list of integers in the given half-open range.</para>
</listitem></varlistentry>
<varlistentry><term><code>any</code></term><listitem><para><code>def any(lambda (A) :: Boolean, [A]) :: Boolean</code></para>
<para>Return true if any of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.</para>
</listitem></varlistentry>
<varlistentry><term><code>all</code></term><listitem><para><code>def all(lambda (A) :: Boolean, [A]) :: Boolean</code></para>
<para>Return true if all of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.</para>
</listitem></varlistentry>
<varlistentry><term><code>sum</code></term><listitem><para><code>def sum([Number]) :: Number</code></para>
<para>Return the sum of all numbers in a list.
The sum of an empty list is 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>product</code></term><listitem><para><code>def product([Number]) :: Number</code></para>
<para>Return the product of all numbers in a list.
The product of an empty list is 1.</para>
</listitem></varlistentry>
<varlistentry><term><code>and</code></term><listitem><para><code>def and([Boolean]) :: Boolean</code></para>
<para>Return the boolean conjunction of all boolean values in the list.
The conjunction of an empty list is <code>true</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>or</code></term><listitem><para><code>def or([Boolean]) :: Boolean</code></para>
<para>Return the boolean disjunction of all boolean values in the list.
The disjunction of an empty list is <code>true</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>minimum</code></term><listitem><para><code>def minimum([A]) :: A, A &lt;: Comparable</code></para>
<para>Return the minimum element of a non-empty list.</para>
</listitem></varlistentry>
<varlistentry><term><code>maximum</code></term><listitem><para><code>def maximum([A]) :: A, A &lt;: Comparable</code></para>
<para>Return the maximum element of a non-empty list.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>text.inc: Operations on strings.</title>
<para>Operations on strings.</para>
<variablelist>
<varlistentry><term><code>cat</code></term><listitem><para><code>site cat(Top, ...) :: String</code></para>
<para>Return the string representation of one or more values, concatenated.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.</para>
</listitem></varlistentry>
<varlistentry><term><code>print</code></term><listitem><para><code>site print(Top, ...) :: Signal</code></para>
<para>Print one or more values as strings, concatenated, to standard output.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.</para>
</listitem></varlistentry>
<varlistentry><term><code>println</code></term><listitem><para><code>site println(Top, ...) :: Signal</code></para>
<para>Print one or more values as strings, concatenated,
to standard output, with each value followed by a newline.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.</para>
</listitem></varlistentry>
<varlistentry><term><code>parseInt</code></term><listitem><para><code>site parseInt(String) :: BigInteger</code></para>
<para>Parse a string as a BigInteger.</para>
</listitem></varlistentry>
<varlistentry><term><code>parseBool</code></term><listitem><para><code>site parseBool(String) :: Boolean</code></para>
<para>Parse a string as a Boolean (true/false).</para>
</listitem></varlistentry>
<varlistentry><term><code>lines</code></term><listitem><para><code>def lines(String) :: [String]</code></para>
<para>Split a string into lines, which are substrings
terminated by an endline or the end of the string.
DOS, Mac, and Unix endline conventions are all accepted.
Endline characters are not included in the result.</para>
</listitem></varlistentry>
<varlistentry><term><code>unlines</code></term><listitem><para><code>def unlines([String]) :: String</code></para>
<para>Append a linefeed, "\n", to each string in the sequence
and concatenate the results.</para>
</listitem></varlistentry>
<varlistentry><term><code>words</code></term><listitem><para><code>def words(String) :: [String]</code></para>
<para>Split a string into words, which are sequences of non-whitespace characters separated by whitespace.</para>
</listitem></varlistentry>
<varlistentry><term><code>unwords</code></term><listitem><para><code>def unwords([String]) :: String</code></para>
<para>Concatenate a sequence of strings with a single space between
each string.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>time.inc: Real and logical time.</title>
<para>Real and logical time.</para>
<variablelist>
<varlistentry><term><code>Rtimer</code></term><listitem><para><code>site Rtimer(Integer) :: Signal</code></para>
<para>Publish a signal after the given number of milliseconds.</para>
</listitem></varlistentry>
<varlistentry><term><code>Clock</code></term><listitem><para><code>site Clock()() :: Integer</code></para>
<para>A call to <code>Clock</code> creates a new relative clock.
Calling a relative clock returns the number
of milliseconds which have elapsed since the
clock was created.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes a value near 1000
val c = Clock()
Rtimer(1000) >> c()]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>Ltimer</code></term><listitem><para><code>site Ltimer(Integer) :: Signal</code></para>
<para>Publish a signal after the given number of logical timesteps.
A logical timestep is complete as soon as all outstanding site
calls (other than calls to <code>Ltimer</code>) have published.</para>
</listitem></varlistentry>
<varlistentry><term><code>Metronome</code></term><listitem><para><code>def Metronome() :: Signal</code></para>
<para>Publish a signal every second, indefinitely.</para>
</listitem></varlistentry>
<varlistentry><term><code>MetronomeT</code></term><listitem><para><code>def MetronomeT(Integer) :: Signal</code></para>
<para>Publish a signal at regular intervals, indefinitely. The period is given by the
argument, in milliseconds.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>util.inc: Miscellaneous utility functions.</title>
<para>Miscellaneous utility functions.</para>
<variablelist>
<varlistentry><term><code>random</code></term><listitem><para><code>site random() :: Integer</code></para>
<para>Return a random Integer value
chosen from the range of all possible 32-bit Integer values.</para>
</listitem></varlistentry>
<varlistentry><term><code>random</code></term><listitem><para><code>site random(Integer) :: Integer</code></para>
<para>Return a pseudorandom, uniformly distributed Integer value
between 0 (inclusive) and the specified value (exclusive).
If the argument is 0, fail silently.</para>
</listitem></varlistentry>
<varlistentry><term><code>urandom</code></term><listitem><para><code>site urandom() :: Double</code></para>
<para>Returns a pseudorandom, uniformly distributed Double value
between 0 and 1, inclusive.</para>
</listitem></varlistentry>
<varlistentry><term><code>UUID</code></term><listitem><para><code>site UUID() :: String</code></para>
<para>Return a random (type 4) UUID represented as a string.</para>
</listitem></varlistentry>
<varlistentry><term><code>Thread</code></term><listitem><para><code>site Thread(Site) :: Site</code></para>
<para>Given a site, return a new site which calls the original site
in a separate thread.  This is necessary when calling
a Java site which does not cooperate with Orc's scheduler
and may block for an unpredictable amount of time.</para>
<para>A limited number of threads are reserved in a pool for use
by this site, so there is a limit to the number of blocking,
uncooperative sites that can be called simultaneously.</para>
</listitem></varlistentry>
<varlistentry><term><code>Prompt</code></term><listitem><para><code>site Prompt(String) :: String</code></para>
<para>Prompt the user for some input. The user may cancel the prompt,
in which case the site fails silently. Otherwise their response
is returned as soon as it is received.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes the user's name
Prompt("What is your name?")]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>signals</code></term><listitem><para><code>def signals(Integer) :: Signal</code></para>
<para>Publish the given number of signals, simultaneously.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes five signals
signals(5)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>for</code></term><listitem><para><code>def for(Integer, Integer) :: Integer</code></para>
<para>Publish all values in the given half-open range, simultaneously.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 1 2 3 4 5
for(1,6)]]></programlisting></para>
</listitem></varlistentry></variablelist>
</section>
</section>
