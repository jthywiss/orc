<?xml version="1.0"?>
<section><title>Reference</title>
<section><title>core.inc: Fundamental sites and operators.</title>
<para>Fundamental sites and operators.</para>
<para>These declarations include both prefix and infix sites (operators).  For
consistency, all declarations are written in prefix form, with the site name
followed by the operands.  When the site name is surrounded in parentheses, as
in <code>(+)</code>, it denotes an infix operator.</para>
<para>For a more complete description of the built-in operators and their syntax, see
the <link linkend="language.base.operators">Operators</link> section of the
User Guide.</para>
<variablelist>
<varlistentry><term><code>let</code></term><listitem><para><code>site let(A) :: A</code></para>
<para>When applied to a single argument, return that argument (behaving as the identity function).</para>
</listitem></varlistentry>
<varlistentry><term><code>let</code></term><listitem><para><code>site let(A, ...) :: (A, ...)</code></para>
<para>When applied to zero, two, or more arguments, return the arguments in a tuple.</para>
</listitem></varlistentry>
<varlistentry><term><code>if</code></term><listitem><para><code>site if(Boolean) :: Signal</code></para>
<para>Fail silently if the argument is false. Otherwise return a signal.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Always publishes"
  if(false) >> "Never publishes"
| if(true) >> "Always publishes"]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>error</code></term><listitem><para><code>site error(String) :: Bot</code></para>
<para>Halt with the given error message.</para>
<para>Example, using <code>error</code> to implement assertions:
<programlisting language="orc-demo"><![CDATA[
def assert(b) =
  if b then signal else error("assertion failed")

-- Fail with the error message: "assertion failed"
assert(false)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>(+)</code></term><listitem><para><code>site (+)(Number, Number) :: Number</code></para>
<para><code>a+b</code> returns the sum of <code>a</code> and <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(-)</code></term><listitem><para><code>site (-)(Number, Number) :: Number</code></para>
<para><code>a-b</code> returns the value of <code>a</code> minus the value of <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(0-)</code></term><listitem><para><code>site (0-)(Number) :: Number</code></para>
<para>Return the additive inverse of the argument.
When this site appears as an operator, it is written in prefix form without the
zero, i.e. <code>(-a)</code></para>
</listitem></varlistentry>
<varlistentry><term><code>(*)</code></term><listitem><para><code>site (*)(Number, Number) :: Number</code></para>
<para><code>a*b</code> returns the product of <code>a</code> and <code>b</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(**)</code></term><listitem><para><code>site (**)(Number, Number) :: Number</code></para>
<para><code>a ** b</code> returns
<inlineequation><mathphrase>a<superscript>b</superscript></mathphrase></inlineequation>,
i.e. <code>a</code> raised to the <code>b</code>th power.</para>
</listitem></varlistentry>
<varlistentry><term><code>(/)</code></term><listitem><para><code>site (/)(Number, Number) :: Number</code></para>
<para><code>a/b</code> returns <code>a</code> divided by <code>b</code>.
If both arguments have integral types, <code>(/)</code> performs integral
division, rounding towards zero. Otherwise, it performs floating-point
division. If <code>b=0</code>, <code>a/b</code> halts with an error.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
  7/3   -- publishes 2
| 7/3.0 -- publishes 2.333...]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>(%)</code></term><listitem><para><code>site (%)(Number, Number) :: Number</code></para>
<para><code>a%b</code> computes the remainder of <code>a/b</code>. If <code>a</code>
and <code>b</code> have integral types, then the remainder is given by
the expression <code>a - (a/b)*b</code>. For a full description, see the
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.17.3">Java Language Specification, 3rd edition</link>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&lt;)</code></term><listitem><para><code>site (&lt;)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a &lt; b</code> returns true if <code>a</code> is less than <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&lt;=)</code></term><listitem><para><code>site (&lt;=)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a &lt;= b</code> returns true if <code>a</code> is less than or equal to <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&gt;)</code></term><listitem><para><code>site (&gt;)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a > b</code> returns true if <code>a</code> is greater than <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&gt;=)</code></term><listitem><para><code>site (&gt;=)(Comparable, Comparable) :: Boolean</code></para>
<para><code>a >= b</code> returns true if <code>a</code> is greater than or equal to <code>b</code>, and false otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(=)</code></term><listitem><para><code>site (=)(Top, Top) :: Boolean</code></para>
<para><code>a = b</code> returns true if <code>a</code> is equal to <code>b</code>,
and false otherwise.  The precise definition of "equal" depends on the values
being compared, but always obeys the rule that if two values are considered
equal, then one may be substituted locally for the other without affecting the
behavior of the program.</para>
<para>Two values with the same object identity are always considered equal.
In addition, Cor <link linkend="cor.constants">constant values</link> and <link
linkend="cor.data">data structures</link> are considered equal if their
contents are equal. Other types are free to implement their own equality
relationship provided it conforms to the rules given here.</para>
<para>Note that although values of different types may be compared with
<code>=</code>, the substitutability principle requires that such values are
always considered inequal, i.e. the comparison will return <code>false</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>(/=)</code></term><listitem><para><code>site (/=)(Top, Top) :: Boolean</code></para>
<para><code>a/=b</code> returns false if <code>a=b</code>, and true otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>(~)</code></term><listitem><para><code>site (~)(Boolean) :: Boolean</code></para>
<para>Return the logical negation of the argument.</para>
</listitem></varlistentry>
<varlistentry><term><code>(&amp;&amp;)</code></term><listitem><para><code>site (&amp;&amp;)(Boolean, Boolean) :: Boolean</code></para>
<para>Return the logical conjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.</para>
</listitem></varlistentry>
<varlistentry><term><code>(||)</code></term><listitem><para><code>site (||)(Boolean, Boolean) :: Boolean</code></para>
<para>Return the logical disjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.</para>
</listitem></varlistentry>
<varlistentry><term><code>(:)</code></term><listitem><para><code>site (:)(A, [A]) :: [A]</code></para>
<para><code>a:b</code> returns the list formed by prepending the element <code>a</code>
to the list <code>b</code>.</para>
<variablelist>
<varlistentry><term><code>(:)</code></term><listitem><para><code>pattern (:)([A]) :: (A, [A])</code></para>
<para>The inverse of the list constructor <code>(:)</code>. Returns the head and tail
of the list.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: (3, [4, 5])
[3,4,5] >x:xs> (x,xs)]]></programlisting></para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>abs</code></term><listitem><para><code>def abs(Number) :: Number</code></para>
<para>Return the absolute value of the argument.</para>
</listitem></varlistentry>
<varlistentry><term><code>signum</code></term><listitem><para><code>def signum(Number) :: Number</code></para>
<para><code>signum(a)</code> returns <code>-1</code> if <code>a&lt;0</code>,
<code>1</code> if <code>a&gt;0</code>, and <code>0</code> if <code>a=0</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>min</code></term><listitem><para><code>def min(A,A) :: A, A &lt;: Comparable</code></para>
<para>Return the lesser of the arguments. If the arguments
are equal, return the first argument.</para>
<para>Recall that the type constraint <code>A &lt;: Comparable</code>
means that <code>min</code> can only be applied to arguments
which are subtypes of <code>Comparable</code>; in other words,
they must have a total order.</para>
</listitem></varlistentry>
<varlistentry><term><code>max</code></term><listitem><para><code>def max(A,A) :: A, A &lt;: Comparable</code></para>
<para>Return the greater of the arguments. If the arguments
are equal, return the second argument.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>data.inc: General-purpose supplemental data structures.</title>
<para>General-purpose supplemental data structures.</para>
<variablelist>
<varlistentry><term><code>Semaphore</code></term><listitem><para><code>site Semaphore(Integer) :: Semaphore</code></para>
<para>Return a semaphore with the given value. The semaphore maintains the invariant
that its value is always non-negative.</para>
<para>An example using a semaphore as a lock for a critical section:
<programlisting language="orc-demo"><![CDATA[
-- Prints:
-- Entering critical section
-- Leaving critical section
val lock = Semaphore(1)
lock.acquire() >>
println("Entering critical section") >>
println("Leaving critical section") >>
lock.release()]]></programlisting></para>
<variablelist>
<varlistentry><term><code>acquire</code></term><listitem><para><code>site Semaphore.acquire() :: Signal</code></para>
<para>If the semaphore's value is greater than <code>0</code>, decrement the semaphore and return a signal.
If the semaphore's value is <code>0</code>, block until it becomes greater than <code>0</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>acquirenb</code></term><listitem><para><code>site Semaphore.acquirenb() :: Signal</code></para>
<para>If the semaphore's value is greater than <code>0</code>, decrement the semaphore and return a signal.
If the semaphore's value is <code>0</code>, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>release</code></term><listitem><para><code>site Semaphore.release() :: Signal</code></para>
<para>If any calls to <code>acquire</code> are blocked, allow the oldest such call
to return.  Otherwise, increment the value of the semaphore.  This may
increment the value beyond that with which the semaphore was constructed.</para>
</listitem></varlistentry>
<varlistentry><term><code>snoop</code></term><listitem><para><code>site Semaphore.snoop() :: Signal</code></para>
<para>If any calls to <code>acquire</code> are blocked, return a signal.
Otherwise, block until some call to <code>acquire</code> blocks.</para>
</listitem></varlistentry>
<varlistentry><term><code>snoopnb</code></term><listitem><para><code>site Semaphore.snoopnb() :: Signal</code></para>
<para>If any calls to <code>acquire</code> are blocked, return a signal.
Otherwise, halt.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Buffer</code></term><listitem><para><code>site Buffer() :: Buffer&lt;A&gt;</code></para>
<para>Create a new buffer (FIFO channel) of unlimited size.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 10
val b = Buffer()
  Rtimer(1000) >> b.put(10) >> stop
| b.get()]]></programlisting></para>
<variablelist>
<varlistentry><term><code>get</code></term><listitem><para><code>site Buffer&lt;A&gt;.get() :: A</code></para>
<para>Get an item from the buffer. If no items are available, block until one becomes available.</para>
<para>Recall that the type signature <code>site Buffer&lt;A&gt;.get() :: A</code> means that
when the <code>get</code> method is called on a buffer holding an arbitrary
element type <code>A</code>, it will return a value of the same type.</para>
</listitem></varlistentry>
<varlistentry><term><code>getnb</code></term><listitem><para><code>site Buffer&lt;A&gt;.getnb() :: A</code></para>
<para>Get an item from the buffer. If no items are available, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>put</code></term><listitem><para><code>site Buffer&lt;A&gt;.put(A) :: Signal</code></para>
<para>Put an item in the buffer.</para>
</listitem></varlistentry>
<varlistentry><term><code>close</code></term><listitem><para><code>site Buffer&lt;A&gt;.close() :: Signal</code></para>
<para>Close the buffer and block until it is empty.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>closenb</code></term><listitem><para><code>site Buffer&lt;A&gt;.closenb() :: Signal</code></para>
<para>Close the buffer and return a signal immediately.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>isClosed</code></term><listitem><para><code>site Buffer&lt;A&gt;.isClosed() :: Boolean</code></para>
<para>If the buffer is currently closed, return true, otherwise return false.</para>
</listitem></varlistentry>
<varlistentry><term><code>getAll</code></term><listitem><para><code>site Buffer&lt;A&gt;.getAll() :: [A]</code></para>
<para>Get all of the items currently in the buffer, emptying the buffer and returning
a list of the items in the order they were added. If there are no items in the
buffer, return an empty list.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>BoundedBuffer</code></term><listitem><para><code>site BoundedBuffer(Integer) :: BoundedBuffer&lt;A&gt;</code></para>
<para>Create a new buffer (FIFO channel) with the given number of slots.
Putting an item into the buffer fills a slot, and removing an item opens a slot.
A buffer with zero slots is equivalent to a
<link linkend="orc.lib.state.SyncChannel">synchronous channel</link>.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Put 1" "Got 1" "Put 2" "Got 2"
val c = BoundedBuffer(1)
  c.put(1) >> "Put " + 1
| c.put(2) >> "Put " + 2
| Rtimer(1000) >> (
    c.get() >n> "Got " + n
  | c.get() >n> "Got " + n
  )]]></programlisting></para>
<variablelist>
<varlistentry><term><code>get</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.get() :: A</code></para>
<para>Get an item from the buffer. If no items are available, block until one becomes available.</para>
</listitem></varlistentry>
<varlistentry><term><code>getnb</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.getnb() :: A</code></para>
<para>Get an item from the buffer. If no items are available, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>put</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.put(A) :: Signal</code></para>
<para>Put an item in the buffer. If no slots are open, block until one becomes open.</para>
</listitem></varlistentry>
<varlistentry><term><code>putnb</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.putnb(A) :: Signal</code></para>
<para>Put an item in the buffer. If no slots are open, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>close</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.close() :: Signal</code></para>
<para>Close the buffer and block until it is empty.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt. Note that any blocked calls to <code>put</code>
initiated prior to closing the buffer may still be allowed to return as usual.</para>
</listitem></varlistentry>
<varlistentry><term><code>closenb</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.closenb() :: Signal</code></para>
<para>Close the buffer and return a signal immediately.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt. Note that any blocked calls to <code>put</code>
initiated prior to closing the buffer may still be allowed to return as usual.</para>
</listitem></varlistentry>
<varlistentry><term><code>isClosed</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.isClosed() :: Boolean</code></para>
<para>If the buffer is currently closed, return true, otherwise return false.</para>
</listitem></varlistentry>
<varlistentry><term><code>getOpen</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.getOpen() :: Integer</code></para>
<para>Return the number of open slots in the buffer. Because of concurrency
this value may become out-of-date so it should only be used for debugging
or statistical measurements.</para>
</listitem></varlistentry>
<varlistentry><term><code>getBound</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.getBound() :: Integer</code></para>
<para>Return the total number of slots (open or filled) in the buffer.</para>
</listitem></varlistentry>
<varlistentry><term><code>getAll</code></term><listitem><para><code>site BoundedBuffer&lt;A&gt;.getAll() :: [A]</code></para>
<para>Get all of the items currently in the buffer or waiting to be added, emptying
the buffer and returning a list of the items in the order they were added. If
there are no items in the buffer or waiting to be added, return an empty list.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>SyncChannel</code></term><listitem><para><code>site SyncChannel() :: SyncChannel&lt;A&gt;</code></para>
<para><!-- XSL/FO doesn't like me using an anchor tag here -->
<para id="orc.lib.state.SyncChannel">
Create a synchronous channel, or rendezvous.
</para></para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publish: 10
val c = SyncChannel()
  c.put(10)
| Rtimer(1000) >> c.get()]]></programlisting></para>
<variablelist>
<varlistentry><term><code>get</code></term><listitem><para><code>site SyncChannel&lt;A&gt;.get() :: A</code></para>
<para>Receive an item over the channel. If no sender is available, block until one becomes available.</para>
</listitem></varlistentry>
<varlistentry><term><code>put</code></term><listitem><para><code>site SyncChannel&lt;A&gt;.put(A) :: Signal</code></para>
<para>Send an item over the channel. If no receiver is available, block until one becomes available.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Cell</code></term><listitem><para><code>site Cell() :: Cell&lt;A&gt;</code></para>
<para>Create a write-once storage location.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 5 5
val c = Cell()
  c.write(5) >> c.read()
| Rtimer(1) >> ( c.write(10) ; c.read() )]]></programlisting></para>
<variablelist>
<varlistentry><term><code>read</code></term><listitem><para><code>site Cell&lt;A&gt;.read() :: A</code></para>
<para>Read a value from the cell. If the cell does not yet have a value, block until it receives one.</para>
</listitem></varlistentry>
<varlistentry><term><code>readnb</code></term><listitem><para><code>site Cell&lt;A&gt;.readnb() :: A</code></para>
<para>Read a value from the cell. If the cell does not yet have a value, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>write</code></term><listitem><para><code>site Cell&lt;A&gt;.write() :: Signal</code></para>
<para>Write a value to the cell. If the cell already has a value, halt.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Ref</code></term><listitem><para><code>site Ref() :: Ref&lt;A&gt;</code></para>
<para>Create a rewritable storage location without an initial value.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
val r = Ref()
Rtimer(1000) >> r.write(5) >> stop
| println(r.read()) >>
  r.write(10) >>
  println(r.read()) >>
  stop]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Ref</code></term><listitem><para><code>site Ref(A) :: Ref&lt;A&gt;</code></para>
<para>Create a rewritable storage location initialized to the provided value.</para>
</listitem></varlistentry>
<varlistentry><term><code>read</code></term><listitem><para><code>site Ref&lt;A&gt;.read() :: A</code></para>
<para>Read the value of the ref. If the ref does not yet have a value, block until it receives one.</para>
</listitem></varlistentry>
<varlistentry><term><code>readnb</code></term><listitem><para><code>site Ref&lt;A&gt;.readnb() :: A</code></para>
<para>Read the value of the ref. If the ref does not yet have a value, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>write</code></term><listitem><para><code>site Ref&lt;A&gt;.write(A) :: Signal</code></para>
<para>Write a value to the ref.</para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Null</code></term><listitem><para><code>site Null() :: Bot</code></para>
<para>Return a Java null value. This is only necessary to interface with certain
Java libraries, Orc programs should use the <code>None()</code> constructor
instead of null values.</para>
</listitem></varlistentry>
<varlistentry><term><code>Array</code></term><listitem><para><code>site Array(Integer) :: Array&lt;A&gt;</code></para>
<para>Create a new native array of the given size.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2
val a = Array(3)
for(0, a.length()) >i>
a.set(i, f(i)) >>
stop
; a.get(0) | a.get(1) | a.get(2)]]></programlisting></para>
<variablelist>
<varlistentry><term><code>Array</code></term><listitem><para><code>site Array(Integer, String) :: Array&lt;A&gt;</code></para>
<para>Create a new primitive array of the given size with the given primitive type.
The primitive type should match the element type of the array, although a
typechecker may not be able to verify this. This constructor is only necessary
when interfacing with certain Java libraries; most programs will just use the 
<code>Array(Integer)</code> constructor.</para>
</listitem></varlistentry>
<varlistentry><term><code>get</code></term><listitem><para><code>site Array&lt;A&gt;.get(Integer) :: A</code></para>
<para>Get the element of the array given by the index, counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>set</code></term><listitem><para><code>site Array&lt;A&gt;.set(Integer, A) :: Signal</code></para>
<para>Set the element of the array given by the index, counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>slice</code></term><listitem><para><code>site Array&lt;A&gt;.slice(Integer, Integer) :: Array&lt;A&gt;</code></para>
<para>Return a copy of the portion of the array with indices covered by the given
half-open range. The result array is still indexed counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>length</code></term><listitem><para><code>site Array&lt;A&gt;.length() :: Integer</code></para>
<para>Return the size of the array.</para>
</listitem></varlistentry>
<varlistentry><term><code>fill</code></term><listitem><para><code>site Array&lt;A&gt;.fill(A) :: Signal</code></para>
<para>Set every element of the array to the given value. The given value is not
copied, but is shared by every element of the array, so for example
<code>a.fill(Semaphore(1))</code> would allow you to access the same semaphore
from every element <code>a</code>.</para>
<para>This method is primarily useful to initialize or reset an array to a constant
value,
for example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 0 0
val a = Array(3)
a.fill(0) >> each(a)]]></programlisting></para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>IArray</code></term><listitem><para><code>def IArray(Integer, lambda (Integer) :: A)(Integer) :: A</code></para>
<para>The call <code>IArray(n,f)</code>, where <code>n</code> is a
natural number and <code>f</code> a total function over natural numbers,
creates and returns a partial, pre-computed version of <code>f</code>
restricted to the range (0, <code>n</code>-1). If <code>f</code> halts
on any number in this range, the call to <code>IArray</code> will halt.</para>
<para>The user may also think of the call as returning an array whose
<code>i</code>th element is <code>f(i)</code>.</para>
<para>This function provides a simple form of memoisation; we avoid recomputing
the value of <code>f(i)</code> by storing the result in an array.</para>
<para>Example:
<programlisting><![CDATA[
val a = IArray(5, fib)
-- Publishes the 4th number of the fibonnaci sequence: 5
a(3)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>Some</code></term><listitem><para><code>site Some(A) :: Option&lt;A&gt;</code></para>
<para>Construct an available optional value.</para>
<variablelist>
<varlistentry><term><code>Some</code></term><listitem><para><code>pattern Some(Option&lt;A&gt;) :: (A)</code></para>
<para>Deconstruct an available optional value.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 3
Some(3) >Some(x)> x]]></programlisting></para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>None</code></term><listitem><para><code>site None(A) :: Option&lt;A&gt;</code></para>
<para>Construct an unavailable optional value.</para>
<variablelist>
<varlistentry><term><code>None</code></term><listitem><para><code>pattern None(Option&lt;A&gt;) :: ()</code></para>
<para>Deconstruct an unavailable optional value.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: true
  None() >None()> true
| Some(3) >None()> false]]></programlisting></para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Left</code></term><listitem><para><code>site Left(A) :: Either&lt;A&gt;</code></para>
<para>Construct a "left" member of a union which may be tagged either "left" or "right".</para>
<variablelist>
<varlistentry><term><code>Left</code></term><listitem><para><code>pattern Left(Either&lt;A&gt;) :: A</code></para>
<para>Deconstruct a "left" member of a union.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "left"
Left(3) >x> (
   x >Right(_)> "right"
 | x >Left(_)> "left"
)]]></programlisting></para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>Right</code></term><listitem><para><code>site Right(A) :: Either&lt;A&gt;</code></para>
<para>Construct a "right" member of a union which may be tagged either "left" or "right".</para>
<variablelist>
<varlistentry><term><code>Right</code></term><listitem><para><code>pattern Right(Either&lt;A&gt;) :: A</code></para>
<para>Deconstruct a "right" member of a union.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "right"
Right(3) >x> (
   x >Right(_)> "right"
 | x >Left(_)> "left"
)]]></programlisting></para>
</listitem></varlistentry></variablelist>
</listitem></varlistentry>
<varlistentry><term><code>fst</code></term><listitem><para><code>def fst((A,B)) :: A</code></para>
<para>Return the first element of a pair.</para>
</listitem></varlistentry>
<varlistentry><term><code>snd</code></term><listitem><para><code>def snd((A,B)) :: B</code></para>
<para>Return the second element of a pair.</para>
</listitem></varlistentry>
<varlistentry><term><code>swap</code></term><listitem><para><code>def swap((A,B)) :: (B,A)</code></para>
<para>Swap the elements of a pair.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>idioms.inc: Higher-order Orc programming idioms.</title>
<para>Higher-order Orc programming idioms.
Many of these are standard functional-programming
combinators borrowed from Haskell or Scheme.</para>
<variablelist>
<varlistentry><term><code>apply</code></term><listitem><para><code>site apply(lambda (A, ...) :: B, [A]) :: B</code></para>
<para>Apply a function to a list of arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>curry</code></term><listitem><para><code>def curry(lambda (A,B) :: C)(A)(B) :: C</code></para>
<para>Curry a function of two arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>curry3</code></term><listitem><para><code>def curry3(lambda (A,B,C) :: D)(A)(B)(C) :: D</code></para>
<para>Curry a function of three arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>uncurry</code></term><listitem><para><code>def uncurry(lambda (A)(B) :: C)(A, B) :: C</code></para>
<para>Uncurry a function of two arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>uncurry3</code></term><listitem><para><code>def uncurry3(lambda (A)(B)(C) :: D)(A,B,C) :: D</code></para>
<para>Uncurry a function of three arguments.</para>
</listitem></varlistentry>
<varlistentry><term><code>flip</code></term><listitem><para><code>def flip(lambda (A, B) :: C)(B, A) :: C</code></para>
<para>Flip the order of parameters of a two-argument function.</para>
</listitem></varlistentry>
<varlistentry><term><code>constant</code></term><listitem><para><code>def constant(A)() :: A</code></para>
<para>Create a function which returns a constant value.</para>
</listitem></varlistentry>
<varlistentry><term><code>defer</code></term><listitem><para><code>def defer(lambda (A) :: B, A)() :: B</code></para>
<para>Given a function and its argument, return a thunk which applies the function.</para>
</listitem></varlistentry>
<varlistentry><term><code>defer2</code></term><listitem><para><code>def defer2(lambda (A,B) :: C, A, B)() :: C</code></para>
<para>Given a function and its arguments, return a thunk which applies the function.</para>
</listitem></varlistentry>
<varlistentry><term><code>ignore</code></term><listitem><para><code>def ignore(lambda () :: B)(A) :: B</code></para>
<para>From a function of no arguments, create a function
of one argument, which is ignored.</para>
</listitem></varlistentry>
<varlistentry><term><code>ignore2</code></term><listitem><para><code>def ignore2(lambda () :: C)(A, B) :: C</code></para>
<para>From a function of no arguments, create a function
of two arguments, which are ignored.</para>
</listitem></varlistentry>
<varlistentry><term><code>compose</code></term><listitem><para><code>def compose(lambda (B) :: C, lambda (A) :: B)(A) :: C</code></para>
<para>Compose two single-argument functions.</para>
</listitem></varlistentry>
<varlistentry><term><code>while</code></term><listitem><para><code>def while(lambda (A) :: Boolean, lambda (A) :: A)(A) :: A</code></para>
<para>Iterate a function while a predicate is satisfied, publishing
each value passed to the function. The exact behavior is specified
by the following implementation:</para>
<para><programlisting><![CDATA[
def while(p,f) = 
  def loop(x) = if(p(x)) >> ( x | loop(f(x)) )
  loop]]></programlisting></para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2 3 4 5
while(
  lambda (n) = (n <= 5),
  lambda (n) = n+1
)(0)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>repeat</code></term><listitem><para><code>def repeat(lambda () :: A) :: A</code></para>
<para>Call a function sequentially, publishing each value returned by the function.
The expression <code>repeat(f)</code> is equivalent to
the infinite expression <code>f() >!_> f() >!_> f() >!_> ...</code></para>
</listitem></varlistentry>
<varlistentry><term><code>fork</code></term><listitem><para><code>def fork([lambda () :: A]) :: A</code></para>
<para>Call a list of functions in parallel, publishing
all values published by the functions.</para>
<para>The expression <code>fork([f,g,h])</code> is equivalent to
the expression <code>f() | g() | h()</code></para>
</listitem></varlistentry>
<varlistentry><term><code>sequence</code></term><listitem><para><code>def sequence([lambda () :: A]) :: Signal</code></para>
<para>Call a list of functions in sequence, publishing
a signal whenever the last function publishes. The
actual publications of the given functions are not
published.</para>
<para>The expression <code>sequence([f,g,h])</code> is equivalent to
the expression <code>f() >> g() >> h() >> signal</code></para>
</listitem></varlistentry>
<varlistentry><term><code>join</code></term><listitem><para><code>def join([lambda () :: A]) :: Signal</code></para>
<para>Call a list of functions in parallel and publish
a signal once all functions have completed.</para>
<para>The expression <code>join([f,g,h])</code> is equivalent to
the expression <code>f() >> stop | g() >> stop | h() >> stop ; signal</code></para>
</listitem></varlistentry>
<varlistentry><term><code>por</code></term><listitem><para><code>def por(lambda () :: Boolean, lambda () :: Boolean) :: Boolean</code></para>
<para>Parallel or. Evaluate two boolean functions in parallel, publishing
a value as soon as possible, and terminating any unnecessary ongoing
computation.</para>
</listitem></varlistentry>
<varlistentry><term><code>pand</code></term><listitem><para><code>def pand(lambda () :: Boolean, lambda () :: Boolean) :: Boolean</code></para>
<para>Parallel and. Evaluate two boolean functions in parallel, publishing
a value as soon as possible, and terminating any unnecessary ongoing
computation.</para>
</listitem></varlistentry>
<varlistentry><term><code>collect</code></term><listitem><para><code>def collect(lambda () :: A) :: [A]</code></para>
<para>Run a function, collecting all publications in a list.
Return the list when the function terminates.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [signal, signal, signal, signal, signal]
collect(defer(signals, 5))]]></programlisting></para>
</listitem></varlistentry></variablelist>
</section>
<section><title>list.inc: Operations on lists.</title>
<para>Operations on lists.
Many of these functions are similar to those in the Haskell prelude, but
operate on the elements of a list in parallel.</para>
<variablelist>
<varlistentry><term><code>each</code></term><listitem><para><code>def each([A]) :: A</code></para>
<para>Publish every value in a list, simultaneously.</para>
</listitem></varlistentry>
<varlistentry><term><code>map</code></term><listitem><para><code>def map(lambda (A) :: B, [A]) :: [B]</code></para>
<para>Apply a function to every element of a list (in parallel),
returning a list of the results.</para>
</listitem></varlistentry>
<varlistentry><term><code>reverse</code></term><listitem><para><code>def reverse([A]) :: [A]</code></para>
<para>Return the reverse of the given list.</para>
</listitem></varlistentry>
<varlistentry><term><code>filter</code></term><listitem><para><code>def filter(lambda (A) :: Boolean, [A]) :: [A]</code></para>
<para>Return a list containing only those elements which satisfy the predicate.
The filter is applied to all list elements in parallel.</para>
</listitem></varlistentry>
<varlistentry><term><code>head</code></term><listitem><para><code>def head([A]) :: A</code></para>
<para>Return the first element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>tail</code></term><listitem><para><code>def tail([A]) :: [A]</code></para>
<para>Return all but the first element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>init</code></term><listitem><para><code>def init([A]) :: [A]</code></para>
<para>Return all but the last element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>last</code></term><listitem><para><code>def last([A]) :: A</code></para>
<para>Return the last element of a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>empty</code></term><listitem><para><code>def empty([A]) :: Boolean</code></para>
<para>Is the list empty?</para>
</listitem></varlistentry>
<varlistentry><term><code>index</code></term><listitem><para><code>def index(Integer, [A]) :: A</code></para>
<para>Return the nth element of a list, counting from 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>append</code></term><listitem><para><code>def append([A], [A]) :: [A]</code></para>
<para>Return the first list concatenated with the second.</para>
</listitem></varlistentry>
<varlistentry><term><code>foldl</code></term><listitem><para><code>def foldl(lambda (B, A) :: B, B, [A]) :: B</code></para>
<para>Reduce a list using the given left-associative binary operation and initial value.
Given the list <code>[x1, x2, x3, ...]</code> and initial value <code>x0</code>,
returns <code>f(... f(f(f(x0, x1), x2), x3) ...)</code></para>
<para>Example using <code>foldl</code> to reverse a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [3, 2, 1]
foldl(flip((:)), [], [1,2,3])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>foldl1</code></term><listitem><para><code>def foldl1(lambda (A, A) :: A, [A]) :: A</code></para>
<para>A special case of <code>foldl</code> which uses the last element of the list as the
initial value. It is an error to call this on an empty list.</para>
</listitem></varlistentry>
<varlistentry><term><code>foldr</code></term><listitem><para><code>def foldr(lambda (A, B) :: B, B, [A]) :: B</code></para>
<para>Reduce a list using the given right-associative binary operation and initial value.
Given the list <code>[..., x3, x2, x1]</code> and initial value <code>x0</code>,
returns <code>f(... f(x3, f(x2, f(x1, x0))) ...)</code></para>
<para>Example summing the numbers in a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 6
foldr((+), 0, [1,2,3])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>foldr1</code></term><listitem><para><code>def foldr1(lambda (A, A) :: A, [A]) :: A</code></para>
<para>A special case of <code>foldr</code> which uses the last element of the list as the
initial value. It is an error to call this on an empty list.</para>
</listitem></varlistentry>
<varlistentry><term><code>afold</code></term><listitem><para><code>def afold(lambda (A, A) :: A, [A]) :: A</code></para>
<para>Reduce a non-empty list using the given associative and commutative binary operation.
This function reduces independent subexpressions in parallel, so the number of
sequential reductions performed is O(log n).  For expensive reductions, this
is much more efficient than <code>foldl</code> or <code>foldr</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>zip</code></term><listitem><para><code>def zip([A], [B]) :: (A, B)</code></para>
<para>Combine two lists into a list of pairs.
The length of the shortest list determines the length of the result.</para>
</listitem></varlistentry>
<varlistentry><term><code>unzip</code></term><listitem><para><code>def unzip([(A,B)]) :: ([A], [B])</code></para>
<para>Split a list of pairs into a pair of lists.</para>
</listitem></varlistentry>
<varlistentry><term><code>length</code></term><listitem><para><code>def length([A]) :: Integer</code></para>
<para>Return the number of elements in a list.</para>
</listitem></varlistentry>
<varlistentry><term><code>take</code></term><listitem><para><code>def take(Integer, [A]) :: [A]</code></para>
<para>Given a number <code>n</code> and a list <code>l</code>,
return the first <code>n</code> elements of <code>l</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>drop</code></term><listitem><para><code>def drop(Integer, [A]) :: [A]</code></para>
<para>Given a number <code>n</code> and a list <code>l</code>,
return the elements of <code>l</code> after the first <code>n</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>member</code></term><listitem><para><code>def member(A, [A]) :: Boolean</code></para>
<para>Return true if the given item is a member of the given list, and false
otherwise.</para>
</listitem></varlistentry>
<varlistentry><term><code>merge</code></term><listitem><para><code>def merge([A], [A]) :: [A], A &lt;: Comparable</code></para>
<para>Merge two sorted lists.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 2, 3, 4, 5]
merge([1,2,3], [2,4,5])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>mergeBy</code></term><listitem><para><code>def mergeBy(lambda (A,A) :: Boolean, [A], [A]) :: [A]</code></para>
<para>Merge two lists using the given less-than relation.</para>
</listitem></varlistentry>
<varlistentry><term><code>sort</code></term><listitem><para><code>def sort([A]) :: [A], A &lt;: Comparable</code></para>
<para>Sort a list.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sort([1,3,2])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>sortBy</code></term><listitem><para><code>def sortBy(lambda (A,A) :: Boolean, [A]) :: [A]</code></para>
<para>Sort a list using the given less-than relation.</para>
</listitem></varlistentry>
<varlistentry><term><code>mergeUnique</code></term><listitem><para><code>def mergeUnique([A], [A]) :: [A], A &lt;: Comparable</code></para>
<para>Merge two sorted lists, discarding duplicates.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3, 4, 5]
mergeUnique([1,2,3], [2,4,5])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>mergeUniqueBy</code></term><listitem><para><code>def mergeUniqueBy(lambda (A,A) :: Boolean, lambda (A,A) :: Boolean, [A], [A]) :: [A]</code></para>
<para>Merge two lists, discarding duplicates, using the given equality and less-than relations.</para>
</listitem></varlistentry>
<varlistentry><term><code>sortUnique</code></term><listitem><para><code>def sortUnique([A]) :: [A], A &lt;: Comparable</code></para>
<para>Sort a list, discarding duplicates.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sortUnique([1,3,2,3])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>sortUniqueBy</code></term><listitem><para><code>def sortUniqueBy(lambda (A,A) :: Boolean, lambda (A,A) :: Boolean, [A]) :: [A]</code></para>
<para>Sort a list, discarding duplicates, using the given equality and less-than relations.</para>
</listitem></varlistentry>
<varlistentry><term><code>group</code></term><listitem><para><code>def group([(A,B)]) :: [(A,[B])]</code></para>
<para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [(1, [1, 2]), (2, [3]), (3, [4]), (1, [3])]
group([(1,1), (1,2), (2,3), (3,4), (1,3)])]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>groupBy</code></term><listitem><para><code>def groupBy(lambda (A,A) :: Boolean, [(A,B)]) :: [(A,[B])]</code></para>
<para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements,
using the given equality relation.</para>
</listitem></varlistentry>
<varlistentry><term><code>range</code></term><listitem><para><code>def range(Integer, Integer) :: [Integer]</code></para>
<para>Generate a list of integers in the given half-open range.</para>
</listitem></varlistentry>
<varlistentry><term><code>any</code></term><listitem><para><code>def any(lambda (A) :: Boolean, [A]) :: Boolean</code></para>
<para>Return true if any of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.</para>
</listitem></varlistentry>
<varlistentry><term><code>all</code></term><listitem><para><code>def all(lambda (A) :: Boolean, [A]) :: Boolean</code></para>
<para>Return true if all of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.</para>
</listitem></varlistentry>
<varlistentry><term><code>sum</code></term><listitem><para><code>def sum([Number]) :: Number</code></para>
<para>Return the sum of all numbers in a list.
The sum of an empty list is 0.</para>
</listitem></varlistentry>
<varlistentry><term><code>product</code></term><listitem><para><code>def product([Number]) :: Number</code></para>
<para>Return the product of all numbers in a list.
The product of an empty list is 1.</para>
</listitem></varlistentry>
<varlistentry><term><code>and</code></term><listitem><para><code>def and([Boolean]) :: Boolean</code></para>
<para>Return the boolean conjunction of all boolean values in the list.
The conjunction of an empty list is <code>true</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>or</code></term><listitem><para><code>def or([Boolean]) :: Boolean</code></para>
<para>Return the boolean disjunction of all boolean values in the list.
The disjunction of an empty list is <code>false</code>.</para>
</listitem></varlistentry>
<varlistentry><term><code>minimum</code></term><listitem><para><code>def minimum([A]) :: A, A &lt;: Comparable</code></para>
<para>Return the minimum element of a non-empty list.</para>
</listitem></varlistentry>
<varlistentry><term><code>maximum</code></term><listitem><para><code>def maximum([A]) :: A, A &lt;: Comparable</code></para>
<para>Return the maximum element of a non-empty list.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>text.inc: Operations on strings.</title>
<para>Operations on strings.</para>
<variablelist>
<varlistentry><term><code>cat</code></term><listitem><para><code>site cat(Top, ...) :: String</code></para>
<para>Return the string representation of one or more values, concatenated.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.</para>
</listitem></varlistentry>
<varlistentry><term><code>print</code></term><listitem><para><code>site print(Top, ...) :: Signal</code></para>
<para>Print one or more values as strings, concatenated, to standard output.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.</para>
</listitem></varlistentry>
<varlistentry><term><code>println</code></term><listitem><para><code>site println(Top, ...) :: Signal</code></para>
<para>Print one or more values as strings, concatenated,
to standard output, with each value followed by a newline.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.</para>
</listitem></varlistentry>
<varlistentry><term><code>parseInt</code></term><listitem><para><code>site parseInt(String) :: BigInteger</code></para>
<para>Parse a string as a BigInteger.</para>
</listitem></varlistentry>
<varlistentry><term><code>parseBool</code></term><listitem><para><code>site parseBool(String) :: Boolean</code></para>
<para>Parse a string as a Boolean (true/false).</para>
</listitem></varlistentry>
<varlistentry><term><code>lines</code></term><listitem><para><code>def lines(String) :: [String]</code></para>
<para>Split a string into lines, which are substrings
terminated by an endline or the end of the string.
DOS, Mac, and Unix endline conventions are all accepted.
Endline characters are not included in the result.</para>
</listitem></varlistentry>
<varlistentry><term><code>unlines</code></term><listitem><para><code>def unlines([String]) :: String</code></para>
<para>Append a linefeed, "\n", to each string in the sequence
and concatenate the results.</para>
</listitem></varlistentry>
<varlistentry><term><code>words</code></term><listitem><para><code>def words(String) :: [String]</code></para>
<para>Split a string into words, which are sequences of non-whitespace characters separated by whitespace.</para>
</listitem></varlistentry>
<varlistentry><term><code>unwords</code></term><listitem><para><code>def unwords([String]) :: String</code></para>
<para>Concatenate a sequence of strings with a single space between
each string.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>time.inc: Real and logical time.</title>
<para>Real and logical time.</para>
<variablelist>
<varlistentry><term><code>Rtimer</code></term><listitem><para><code>site Rtimer(Integer) :: Signal</code></para>
<para>Publish a signal after the given number of milliseconds.</para>
</listitem></varlistentry>
<varlistentry><term><code>Clock</code></term><listitem><para><code>site Clock()() :: Integer</code></para>
<para>A call to <code>Clock</code> creates a new relative clock.
Calling a relative clock returns the number
of milliseconds which have elapsed since the
clock was created.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes a value near 1000
val c = Clock()
Rtimer(1000) >> c()]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>Ltimer</code></term><listitem><para><code>site Ltimer(Integer) :: Signal</code></para>
<para>Publish a signal after the given number of logical timesteps.
A logical timestep is complete as soon as all outstanding site
calls (other than calls to <code>Ltimer</code>) have published.</para>
</listitem></varlistentry>
<varlistentry><term><code>metronome</code></term><listitem><para><code>def metronome(Integer) :: Signal</code></para>
<para>Publish a signal at regular intervals, indefinitely. The period is given by the
argument, in milliseconds.</para>
</listitem></varlistentry></variablelist>
</section>
<section><title>util.inc: Miscellaneous utility functions.</title>
<para>Miscellaneous utility functions.</para>
<variablelist>
<varlistentry><term><code>random</code></term><listitem><para><code>site random() :: Integer</code></para>
<para>Return a random Integer value
chosen from the range of all possible 32-bit Integer values.</para>
</listitem></varlistentry>
<varlistentry><term><code>random</code></term><listitem><para><code>site random(Integer) :: Integer</code></para>
<para>Return a pseudorandom, uniformly distributed Integer value
between 0 (inclusive) and the specified value (exclusive).
If the argument is 0, halt.</para>
</listitem></varlistentry>
<varlistentry><term><code>urandom</code></term><listitem><para><code>site urandom() :: Double</code></para>
<para>Returns a pseudorandom, uniformly distributed Double value
between 0 and 1, inclusive.</para>
</listitem></varlistentry>
<varlistentry><term><code>UUID</code></term><listitem><para><code>site UUID() :: String</code></para>
<para>Return a random (type 4) UUID represented as a string.</para>
</listitem></varlistentry>
<varlistentry><term><code>Thread</code></term><listitem><para><code>site Thread(Site) :: Site</code></para>
<para>Given a site, return a new site which calls the original site
in a separate thread.  This is necessary when calling
a Java site which does not cooperate with Orc's scheduler
and may block for an unpredictable amount of time.</para>
<para>A limited number of threads are reserved in a pool for use
by this site, so there is a limit to the number of blocking,
uncooperative sites that can be called simultaneously.</para>
</listitem></varlistentry>
<varlistentry><term><code>Prompt</code></term><listitem><para><code>site Prompt(String) :: String</code></para>
<para>Prompt the user for some input. The user may cancel the prompt,
in which case the site fails silently. Otherwise their response
is returned as soon as it is received.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes the user's name
Prompt("What is your name?")]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>signals</code></term><listitem><para><code>def signals(Integer) :: Signal</code></para>
<para>Publish the given number of signals, simultaneously.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes five signals
signals(5)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>for</code></term><listitem><para><code>def for(Integer, Integer) :: Integer</code></para>
<para>Publish all values in the given half-open range, simultaneously.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 1 2 3 4 5
for(1,6)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>upto</code></term><listitem><para><code>def upto(Integer) :: Integer</code></para>
<para><code>upto(n)</code> publishes all values in the range <code>(0..n-1)</code>
simultaneously.</para>
<para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2 3 4
upto(5)]]></programlisting></para>
</listitem></varlistentry>
<varlistentry><term><code>fillArray</code></term><listitem><para><code>def fillArray(Array&lt;A&gt;, lambda (Integer) :: A) :: Array&lt;A&gt;</code></para>
<para>Given an array and a function from indices to values, populate the array
by calling the function for each index in the array.</para>
<para>For example, to set all elements of an array to zero:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 0 0
val a = fillArray(Array(3), lambda (_) = 0)
a.get(0) | a.get(1) | a.get(2)]]></programlisting></para>
</listitem></varlistentry></variablelist>
</section>
</section>
