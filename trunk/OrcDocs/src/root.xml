<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC " -//OASIS//DTD DocBook XML V5.0//EN" "../docbook-xml/dtd/docbook.dtd" >

<book>
<!-- 
<chapter><title>Introducing Orc</title>

<para>
To learn more about Orc and its community of users, <ulink url="http://orc.csres.utexas.edu">visit our website</ulink>.
</para>

<section><title>What is Orc?</title>
<para>
Orc is a programming language designed to make distributed and concurrent programs simple and intuitive to write. 
</para>

<para>
Orc expresses <firstterm>orchestration</firstterm>, a type of structured concurrency. It emphasizes the flow of
control and gives a global view of a concurrent system. Most other concurrency-oriented languages, such as Erlang,
emphasize unstructured concurrency, describing the individual pieces of a system and their local interactions, but
without a global view.    
</para>




</section>

<section><title>Using Orc</title>
<para>
One of the easiest ways to use Orc is to <ulink url="http://orc.csres.utexas.edu/tryorc.shtml">try it out</ulink> in your web browser. 
</para>
</section>

<section><title>Writing simple programs in Orc</title>
<para>
This section provides a simple introduction to Orc and its key features. To learn the full capabilities of the language,
consult <link linkend="language">the language reference</link>.
</para>
 
<section><title>Basic expressions</title>
<para>

</para>
</section>


<section><title>Sites</title>
<para>
</para>
</section>

<section><title>Putting sites together</title>
<para>For more information, read the <link linkend="language.combinators">Combinators</link> section of the language reference.</para>
</section>

<section><title>Larger programs</title>
<para></para>
</section>
 
</section>

</chapter>
-->

<date/>

<chapter id="language"><title>The Orc Programming Language</title>

<para>
In this chapter, we describe the full capabilities of the Orc programming language. This is intended
to be a comprehensive reference for the Orc programmer.  
</para>

<section><title>Introduction</title>
<para>
Orc more strongly resembles functional programming languages such as Haskell and ML than imperative
languages such as Java and C. The reader is assumed to have at least a passing familiarity with the
concept of variable binding (as opposed to variable assignment), as encountered in functional
languages, as well as lexical scope. It may also help to be familiar with the concepts of lexical 
closure and pattern matching.
</para>

<para>
An Orc program is a structured expressions which does computation, invokes services, and then
<firstterm>publishes</firstterm> some number of values. Publishing a value is similar to
returning a value in other languages, except that an expression may publish multiple times,
or it might never publish at all. An expression which never publishes is called 
<firstterm>silent</firstterm>.
</para>

<para>
An Orc program is built up from <link linkend="language.base">base expressions</link>, the simplest 
programs. These are connected by <link linkend="language.combinators">combinators</link> to form 
larger expressions. Such expressions may also be enclosed by 
<link linkend="language.declarations">declarations</link> which define functions, compute values, or 
introduce new sites. Orc expressions are always compositional: two expressions joined by a combinator
form an expression, and an expression prefixed by a declaration also forms an expression.
</para>
</section>

<!-- 
<programlisting><![CDATA[
]]></programlisting>

<para>
</para>

<section><title></title>
<para>
</para>
</section>

-->


<section id="language.base"><title>Base Expressions</title>
<para>
An Orc program is built up from base expressions. A base expression on its own is always a valid Orc program. 
</para>

<section><title>Constants</title>
<para>
The simplest program one can write is a constant value. Orc supports the following set of constants:

<itemizedlist>

<listitem>
<para>
Integer constants: <code>( ... -1, 0, 1 ... )</code>
</para>
</listitem> 

<listitem>
<para>
Booleans: <code>true</code> and <code>false</code>
</para>
</listitem>

<listitem>
<para>
Strings: <code>"orc"</code>, <code>"ceci n'est pas une |"</code>
</para>
</listitem>

<listitem>
<para>
A special value <code>signal</code>, which carries no information (analagous to the unit value <code>()</code> in ML). 
</para>
</listitem>

</itemizedlist>
</para>

<para>
When evaluated, a constant simply publishes that value immediately.
</para>

</section>

<section><title>Variables</title>
<para>
An identifier on its own is a valid expression; it represents a variable. It waits for that variable to 
be bound, and then publishes that bound value. If the variable is already bound when the expression is 
evaluated, its bound value is published immediately. The expression never publishes if the variable never
becomes bound.
</para>

</section>

<section><title>Call</title>
<para>
An identifier followed by a parenthesized sequence of <firstterm>arguments</firstterm> is a call.
A call may have zero arguments, in which case we write an identifier followed by empty parens <code>()</code>.
The identifier is a variable which names the value that will be called. For now, we assume that
the arguments are either variables or constants.  
</para>

<para>
A call does nothing until the identifier is bound to a value (the <firstterm>target</firstterm>).
Once the target is known, the behavior of the call depends on whether the target is a site or a 
<link linkend="language.declarations.functions"> defined function</link>.

<itemizedlist>
<listitem>
If the target is a site, the call subsequently waits for each variable argument to be bound;
we say that calls to sites are <firstterm>strict</firstterm> since they must wait for all of
their arguments to be bound. Once the values of all of the arguments are known (constants
are always known and variables are known once they have bound values), the service associated
with that site is invoked with those values. The call waits for the service to respond with
a value. If the service responds, the call publishes that value. The call acknowledges at most
one response from the service, so at most one publication occurs.  
</listitem>

<listitem>
If the target is a defined function, the call is replaced by the body of the function, 
where each of the call's arguments is substituted for the function's formal parameters in
the body (even if those arguments are unbound variables). We say that function calls are
<firstterm>lenient</firstterm> because they do not need to wait for their arguments to be
bound. 
</listitem>

</itemizedlist>

<note>
Any Orc expression can be used as an argument; see 
<link linkend="language.combinators.pull.args">the pull combinator</link> for more details.
</note>

</para>


</section>
 

<section id="language.base.oeprators"><title>Operators</title>
<para>
Orc supports a standard set of arithmetic, logical, and comparison operators. 
They are written in the usual infix style, and have C-like precedence. 


<informaltable id="ops-table" frame="none" rowsep="0" colsep="0"> 
<!-- <title>Primitive operators in Orc</title> -->
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="6" >
<colspec colnum="1" colname="arith-names" colwidth="1*" align="left"/>
<colspec colnum="2" colname="arith-ops" colwidth="3*" align="left"/>
<colspec colnum="3" colname="comp-names" colwidth="1*" align="left"/>
<colspec colnum="4" colname="comp-ops" colwidth="3*" align="left"/>
<colspec colnum="5" colname="logic-names" colwidth="1*" align="left"/>
<colspec colnum="6" colname="logic-ops" colwidth="3*" align="left"/>
<thead>
<row>
<entry namest="arith-names" nameend="arith-ops" align="left">Arithmetic</entry>
<entry namest="comp-names" nameend="comp-ops" align="left">Comparison</entry>
<entry namest="logic-names" nameend="logic-ops" align="left">Logical</entry>
</row>
</thead>
<tbody>

<row>
<entry><code><![CDATA[+]]></code></entry>
<entry>addition</entry>

<entry><code><![CDATA[=]]></code></entry>
<entry>equality</entry>

<entry><code><![CDATA[&&]]></code></entry>
<entry>logical and</entry>
</row>

<row>
<entry><code><![CDATA[-]]></code></entry>
<entry>subtraction</entry>

<entry><code><![CDATA[/=]]></code></entry>
<entry>inequality</entry>

<entry><code><![CDATA[||]]></code></entry>
<entry>logical or</entry>
</row>

<row>
<entry><code><![CDATA[*]]></code></entry>
<entry>multiplication</entry>

<entry><code><![CDATA[<]]></code></entry>
<entry>less than</entry>

<entry><code><![CDATA[~]]></code></entry>
<entry>logical not</entry>
</row>

<row>
<entry><code><![CDATA[/]]></code></entry>
<entry>division</entry>

<entry><code><![CDATA[>]]></code></entry>
<entry>greater than</entry>

<entry namest="logic-names" nameend="logic-ops"/>
</row>

<row>
<entry><code><![CDATA[%]]></code></entry>
<entry>modulus</entry>

<entry><code><![CDATA[<=]]></code></entry>
<entry>less than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
</row>

<row>
<entry namest="arith-names" nameend="arith-ops"/>

<entry><code><![CDATA[>=]]></code></entry>
<entry>greater than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
</row>

</tbody>
</tgroup>
</informaltable>

</para>

<para>
These operators are actually sites, and behave like sites; they differ only in syntax. 
Accordingly, any Orc expression can be used as an operand; it undergoes the same 
<link linkend="language.combinators.pull.args">translation</link> as an argument to a call.
</para>

</section>

<section><title>If</title>
<para>
The expression <code>if(b)</code>, where <code>b</code> is some boolean expression,
will publish a signal if <code>b</code> evaluates to true, and otherwise remains silent.
<code>if</code> is used together with the <link linkend="language.combinators.push">push
combinator</link> to form conditional expressions.
</para>

<para>
<code>if</code> is a site; it is called a <firstterm>fundamental site</firstterm> because it
is always available.
</para>
</section>

<section><title>Data structures</title>
<para>
Orc supports two basic data structures:

<itemizedlist>
<listitem>
A <firstterm>tuple</firstterm> is a comma-separated sequence of arguments enclosed
by parentheses. It looks like a call without a preceding identifier: <code>(x,2,y)</code>. 
A tuple must have at least two arguments. Like a site call, a tuple waits for each of its 
arguments to become bound. Then, it publishes a tuple value containing each of those bound values.
</listitem>

<listitem>
A <firstterm>list</firstterm> is a comma-separated sequence of arguments enclosed by
square brackets: <code>[2,11,0]</code>. It may be of any length, including zero; the
empty list is written <code>[]</code>. A list can also be extended using the 
<firstterm>cons</firstterm> operation, written <code>h:t</code>, which publishes a new 
list whose first element is <code>h</code> and whose tail is <code>t</code>.  
</listitem>

</itemizedlist>
</para>

<para>
Again, as with operators, each data structuring operation is actually a site call.
</para>

<para>
To learn more about inspecting and using these data structures after they have been
created, read about <link linkend="language.patterns">patterns</link>.
</para>

</section>


<section><title>Messages</title>
<para>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code>obj.m()</code> calls the method
<code>m</code> of the object <code>obj</code>. 
</para>

<para>
There is a special kind of call in Orc which serves a similar purpose. One may write
<code>x.msg</code>, for any identifiers <code>x</code> and <code>msg</code>. This attempts
to send the <firstterm>message</firstterm> 'msg' to the value bound to <code>x</code>. 
The message may not be understood, in which case no publication occurs. 
</para>

<para>
Typically this capability is used so that sites may be treated like objects, with multiple
methods and fields. For example, a channel <code>c</code> might understand the messages
<code>get</code> and <code>put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code>c.get()</code>, or <code>c.put(6)</code>.

<note>
Such calls actually occur in two steps: first <code>c.put</code> sends the message
<code>put</code> to the value <code>c</code>; this publishes a site whose only purpose
is to put values to that channel. Then, that 'put site' is called on the argument
<code>6</code>, sending 6 on that channel. Readers familiar with functional programming
will recognize this technique as <emphasis>currying</emphasis>.
</note>
</para>



</section>


<section><title>Stop</title>
<para>
<code>stop</code> is a special base expression which is silent and does no computation. 
It is typically used together with a <link linkend="language.combinators.push">push</link>
to silence the publications of another expression.
</para>
</section>



</section>

<section id="language.combinators"><title>Combinators</title>

<section id="language.combinators.bar"><title>Bar ( <code><![CDATA[|]]></code> )</title>
<para>
The bar combinator <code><![CDATA[|]]></code> executes two expressions in parallel, 
and publishes each of their publications as they occur. It is associative and commutative. 
</para>
</section>

<section id="language.combinators.push"><title>Push ( <code><![CDATA[>>]]></code> )</title>

<para>
The push combinator <code><![CDATA[>x>]]></code> executes its left side; for each publication on the left side, 
a new copy of the right side starts, with the variable <code>x</code> bound to that published value.
</para>

<para>
A push can be written as <code><![CDATA[>>]]></code>, with no variable name, which behaves similarly except that
no variable binding occurs.
</para>

<para>
The variable name within the combinator may be replaced with an arbitrary pattern 
(see <link linkend="language.patterns">Patterns</link>). 
</para>

<para>
Pushing is right-associative, and it has higher precedence than bar.
</para>

</section>

<section id="language.combinators.pull"><title>Pull ( <code><![CDATA[<<]]></code> )</title>
<para>
The pull combinator executes its left and right sides in parallel. 
Calls using <code>x</code> on the left side block until it is bound. 
The first publication of the right side is bound to <code>x</code>;
this causes the rest of the right side to stop executing. That
expression may not evaluate further; any site calls already in progress
will continue, but their return values will be ignored.
</para>

<para>
A pull can be written as <code><![CDATA[<<]]></code>, with no variable name, which behaves similarly except that
no variable binding occurs. 
</para>

<para>
The variable name within the combinator may be replaced with an arbitrary pattern 
(see <link linkend="language.patterns">Patterns</link>). 
</para>

<para>
Pulling is left-associative, and it has lower precedence than bar.
</para>

<para id="language.combinators.pull.args">
A call may be written with complex expressions as arguments. This is actually a shorthand for using a pull
to evaluate each of those expressions and bind its result to a variable. For example,

<programlisting><![CDATA[
M(x+5, 4, N() | R())
]]></programlisting>

is just another way of writing

<programlisting><![CDATA[
M(y, 4, z)
	<y< x+5
	<z< N() | R()
]]></programlisting>

Thus, all of the rules governing pull apply to using an expression as an argument: it may publish at most one
value, and it terminates when it publishes a value.
</para>

</section>

<section id="language.combinators.before"><title>Before ( <code><![CDATA[;]]></code> )</title>
<para>
The before combinator executes its left side, publishing each of its publications as they occur.
When the left side has completely finished executing (i.e. it is equivalent to <link
linkend="language.base.stop"><code>stop</code></link>), then the right side executes.

<note>
The before combinator is intended to capture as closely as possible the notion of sequential
processing, as denoted by <code>;</code> in other languages. It was not present in the
original formulation of the Orc concurrency calculus; it has been added to support computation
and iteration over strictly finite data. 
</note>

</para>

</section>

<!--  
<section id="language.combinators.atomic"><title>Atomic ( <code><![CDATA[atomic]]></code> )</title>
<para>
</para>
</section>
-->

</section>

<section id="language.patterns"><title>Patterns</title>

<para>
A <firstterm>pattern</firstterm> is a special construct that may take the place of a variable binding. It examines the structure
of a published value, rather than simply binding that value to a single variable. It may <firstterm>match</firstterm> the value, 
capturing components of the value, and then bind those component values to variables or publish them. Or, it may <firstterm>refuse</firstterm> 
the value, silencing that publication entirely. A pattern is called <firstterm>refutable</firstterm> if it can refuse a value;
otherwise it is <firstterm>irrefutable</firstterm>. 
</para>

<!-- 
<footnote>
The refutable/irrefutable terminology is borrowed from the pattern matching semantics of Haskell.
</footnote> 
 -->

<note>
<para>
Whenever possible, the structure of a pattern mimics the structure of an expression that would publish a value recognized by that pattern.
For example, the pattern <code>(x,[y,z])</code> matches the value published by the expression <code>(true,[3,4])</code>. However, the
converse is not true: if a pattern matches a value, the source of that value is not necessarily an expression with the same structure.
This is particularly true when <link linkend="patterns.views">views</link> are used. 
</para>
</note>


<!-- 
<para>
<note>
Patterns do not actually exist in the core semantics of Orc; they are translated by the compiler into simpler 
expressions using combinators and a special set of sites. For more information, see 
<link linkend="implementation.patterns">the implementation discussion on patterns</link>.   
</note>
</para>
 -->

<section><title>Syntax</title>

<para>
This section describes the syntax of patterns. All patterns are assumed to be refutable 
unless stated otherwise. 
</para>

<section><title>Variable</title>
<para>
Variables are the most basic patterns.
A variable pattern simply binds the matched value to that variable. 
It is an irrefutable pattern. 
<important>
Patterns must be <firstterm>linear</firstterm>, meaning that a 
pattern may not mention the same variable more than once.
</important>
</para>
</section>

<section><title>Wildcard</title>
<para>
A wildcard pattern, written <code>_</code>,  matches any value, and does not bind any variables. 
It is the same as binding a variable which is not used anywhere. Like variables, wildcards are irrefutable.

<note>
The empty push (<code><![CDATA[>>]]></code>) and empty pull (<code><![CDATA[<<]]></code>) combinator forms 
are just shorthand for (<code><![CDATA[>_>]]></code>) and (<code><![CDATA[<_<]]></code>) respectively.
</note> 

</para>
</section>

<section><title>Literal</title>
A literal pattern can be any <link linkend="language.constant">constant value</link>.
It will only match that value, and will refuse any others.
</section>


<section><title>Tuple</title>
<para>
A tuple of patterns matches only a tuple value of exactly the same size; it refuses any other value.
It recursively matches the elements of the tuple against its own member patterns.
A tuple pattern must contain at least two subpatterns.
</para>

<para>
For example, the expression

<programlisting><![CDATA[
( (1,2) | (1,3) | (5,4) )  >(1,x)>  x
]]></programlisting>

will publish <code>2</code> and <code>3</code> but not <code>4</code>, because the pattern 
<code>(1,x)</code> refuses the value <code>(5,4)</code>.
</para>

</section>


<section><title>List</title>
<para>
A list of patterns matches a list value of exactly the same length, refusing any other value.
It recursively matches each item of the list value against each of its member patterns. 
A list pattern may have any number of subpatterns, including zero.
</para>

<para>
For example, the expression

<programlisting><![CDATA[
( [4] | [5,6] | [7,8,9] )  >[x,y]>  x+y
]]></programlisting>

publishes only <code>11</code>; the pattern refuses the other two lists because they are of the wrong length.
</para>

</section>


<section><title>Cons</title>
<para>
It is also possible to use the cons (<code>:</code>) operator in a pattern, to split a list into its head and tail.

<programlisting><![CDATA[
[1,2,3]  >h:t>  ( h | t )
]]></programlisting>

This publishes <code>1</code> and <code>[2,3]</code>. 

Note that a cons pattern refuses the empty list.

</para>
</section>

<section><title>Bang</title>

<para>
A bang pattern, written <code>!p</code>, will publish the value that matches the pattern 
<code>p</code> if the match is successful. This pattern is refutable only if <code>p</code> is refutable.

<programlisting><![CDATA[
(1,2,3)  >(x,!y,!z)> stop
]]></programlisting>

This publishes <code>2</code> and <code>3</code>. 
</para>

<para>
Note that a bang pattern will not publish if the overall match fails, even if its particular match succeeds:

<programlisting><![CDATA[
( (1,2,3) | (4,5,6) )  >(1,!x,y)>  stop
]]></programlisting>

This publishes only <code>2</code>. Even though the pattern <code>x</code> matches the value <code>5</code>, 
the overall pattern <code>(1,!x,y)</code> refuses the value <code>(4,5,6)</code>, so <code>5</code> is not published.
</para>

</section>

<section><title>As</title>
<para>
The pattern <code>p as x</code> can be used to capture a whole subpattern <code>p</code> and bind it to the variable <code>x</code>.
This pattern is refutable only if <code>p</code> is refutable.

<programlisting><![CDATA[
(1,(2,3))  >(x,(2,z) as w)>  w
]]></programlisting>

This publishes <code>(2,3)</code>.
</para>

</section>

<section><title>Site</title>
<para>
A site pattern, written <code>M(p,...,p)</code>, matches any value which was published by a call to the
site <code>M</code> with arguments that match the tuple <code>(p,...,p)</code>. 
</para>

<para>
Site patterns provide a generalized version of datatype matching, as seen in the <code>case .. of</code>
 or <code>match .. with </code> constructs provided by Haskell and ML.
</para> 
 
</section>


</section>


<section><title>Occurrences</title>
<para>These are the syntactic contexts in which a pattern may replace a normal variable binding.
The effect of a pattern may be subtly different depending on the syntactic context in which it appears.</para>

<section><title>In a push</title>
<para>
A pattern may replace the variable name in a push combinator. When the left side publishes a value, that value
is checked against the pattern. If it matches, a new copy of the right hand side starts with all of the pattern's
variables bound in it. If the pattern refuses the value, that publication is ignored; no new copy of the right
hand side is created.
</para>
</section>

<section><title>In a pull</title>
<para>
A pattern may replace the variable name in a pull combinator. When the right side publishes a value, that value
is checked against the pattern. If it matches, the pattern's variables become bound in the left side and the
right side terminates, as expected. However, if the pattern refuses the value, then the publication is ignored
and the right side continues to execute as normal.
</para>
</section>

<section><title>In a <code>val</code> declaration</title>
<para>
A pattern may replace the variable name in a 
<link linkend="language.declarations.val"><code>val</code> declaration</link>. Since a val is just a shorthand
for writing a pull, its behavior is exactly the same: whenever the expression publishes a value, it is checked
against the pattern; if the pattern refuses, the publication is ignored and the expression continues executing,
whereas if if matches, the pattern's variables are bound and the expression terminates.
</para>
</section>

<section><title>As function arguments</title>
<para>
A pattern may replace any formal parameter in a function clause. Whenever that function is called, its
arguments are matched against the argument patterns of each clause in linear order. If every argument
pattern of a clause matches, then the patterns' variables are bound in that clause's body and the body
executes. Otherwise, the next clause is tried.

<note> 
Since function calls in Orc are not strict, some of the arguments may not be bound when they are matched
against a pattern. If an unbound argument is matched against a <emphasis>refutable</emphasis> pattern,
then that match waits for the variable to become bound, since it is impossible to tell if the pattern
will refuse without knowing the bound value. 
</note>
</para>
</section>

</section>


<section><title>Patterns as views</title>
<para>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <firstterm>view</firstterm> of that data.
</para>

<para>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</para>


<!-- 
<footnote>
The concept of views and view patterns is not new in programming languages; it has been demonstrated
in other languages, most notably <ulink url="http://www.scala-lang.org/">Scala</ulink>. In fact, the 
underlying implementation strategy for using sites as view patterns is very similar to the use of
extractor objects and the <code>unapply</code> method in Scala.
</footnote>
 -->

</section>


</section>


<section id="language.declarations"><title>Declarations</title>

<para>
In addition to using combinators, Orc expressions can also be built up by adding declarations. 
A declaration is a directive that precedes an expression. It does not publish any values on its
own; instead introducing one or more new identifiers so that they can be used in that expression. 
The expression following a declaration is called the <firstterm>scoped expression</firstterm> 
of that declaration. 
</para>

<para>
Unless specifically stated otherwise, the scoped expression begins executing 
immediately, without waiting for the declaration to do any computation. If the scoped expression
reaches an identifier introduced by that declaration before the declaration has given it a value,
the identifier is considered unbound.
</para>

<section id="language.declarations.val"><title>Val</title>
<para>
The simplest declaration is a value declaration. It binds the first publication of an expression 
to a variable. It is written:
</para>

<para>
<code>val x = </code><emphasis>expr</emphasis>
</para>

<para>
 
This evaluates the expression <emphasis>expr</emphasis> until it publishes a value, and then binds
that value to the variable <emphasis>x</emphasis> and terminates <emphasis>expr</emphasis>. It is a shorthand
for a pull combinator; if the scoped expression is <emphasis>g</emphasis>, then writing this
declaration is exactly the same as writing:
</para>

<para>
<emphasis>g</emphasis> <code><![CDATA[<x<]]></code> <emphasis>expr</emphasis>
</para>

</section>

<section><title>Functions</title>

<section><title>Introduction</title>

<para>
<programlisting><![CDATA[
def E(x,y) = x | y | x+y
E(2,3)
]]></programlisting>
</para>

<para>
As discussed in the <link linkend="language.base.calls">section on calls</link>, functions are lenient,
or 'call-by-name'. Function calls do not need to wait for all of their arguments to be bound

<programlisting><![CDATA[
E(a,b) 
    <a< stop
    <b< 4
]]></programlisting>

This will publish 4, even though the variable <code>a</code> is never bound. 
The call <code>E(a,b)</code> occurs immediately, effectively executing the 
expression <code>a | b | a+b</code> in its place.

</para>


</section>

<section><title>Recursion</title>

Definitions can be recursive; that is, the name of a definition is bound in its own body.

<programlisting><![CDATA[
def countdown(n) = if(n > 0) >> ( n | countdown(n-1) )
countdown(3)
]]></programlisting>

This publishes 3, 2, and 1. 

</section>

<section><title>Mutual Recursion</title>

Mutual recursion is also supported: 

<programlisting><![CDATA[
def even(n) = 
  if(n > 0) >> odd(n-1)
| if(n < 0) >> odd(n+1)
| if(n = 0) >> true
def odd(n) = 
  if(n > 0) >> even(n-1)
| if(n < 0) >> even(n+1)
| if(n = 0) >> false
]]></programlisting>

There is no special keyword for mutual recursion; any contiguous sequence of definitions is assumed to be 
mutually recursive.


</section>

<section><title>Lexical Closure</title>

<para>
Like any other declaration, a function definition may appear within the context of any expression. This
means that variables from that context may appear in the body of the function:

<programlisting><![CDATA[
val pi = 3.14159
def area(r) = pi * r * r
]]></programlisting>

Functions are also values in Orc, so the function <code>area</code> might be published, and then called
in some other context. What happens to the variable <code>pi</code>? It 'remembers' the value that it
had when the function <code>area</code> was defined (3.14159), and uses that value, even if <code>pi</code>
has a different value in the scope where the function is called: 

<programlisting><![CDATA[
val pi = 2.71828
area(10)
]]></programlisting>

This is called lexical closure: the body of the function is 'closed' because it remembers the values of all of its 
free variables, and the closure is 'lexical' because it occurs when the function is defined, not when
it is used.

<note>
Lexical closure has an interesting subtlety when combined with variables that are in scope but have
not yet been bound to a value (such as pull variables). Since the closure must capture the values of
each of those variables, the closure operation itself must actually wait for all of those variables
to become bound. Thus, the function name itself is unbound until the closure can be created. 
</note>  

</para>


Definitions are actually values, just like any other value. Defining an expression creates a special 
value called a closure and binds it. Thus, it can be published, or put into a data structure, 
like any other value:

<programlisting><![CDATA[
f(1) | f(3)
<f< 
(def E(x) = x+1
 E)
]]></programlisting>

This publishes 2 and 4. It defines the expression <code>E</code>, then publishes that 
definition as a closure, which is then bound to the variable <code>f</code> and called twice. 

</section>

<section><title>Anonymouns Functions</title>
Sometimes one would like to create a closure directly without bothering to name the defined expression. 
There is a special keyword <code>lambda</code> for this purpose:

<programlisting><![CDATA[
lambda (x) = x+1
{-    equivalent to (def E(x) = x+1  E)    -}
]]></programlisting>

</section>


<section><title>Currying</title>

</section>

<section><title>Patterns</title>

A defined expression, just like the push and pull combinators, may have patterns instead of variables as its arguments:

<programlisting><![CDATA[
def E([x,y]) = x | y
]]></programlisting>

This definition publishes two elements of a list, but only if its argument is in fact a two-element list. 
Otherwise, the call remains silent.

Note that using patterns as arguments interacts with the call-by-name semantics of defined expressions: 
if a pattern is refutable, then the body of the expression cannot execute until that argument is bound.


</section>

<section><title>Clauses</title>

<para>
A function may have multiple clauses, each of which has a sequence of patterns to match each formal argument, 
and a body expression. All clauses of a function must have the same number of arguments. Clauses are matched 
in linear order. 
</para> 


The combination of functions and pattern matching offers a much more powerful capability: 
<firstterm>clausal</firstterm> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. Here's an example:

<programlisting><![CDATA[
def sum([]) = 0
def sum(h:t) = h + sum(t)
]]></programlisting>

<code>sum(L)</code> publishes the sum of the numbers in the list <code>L</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.

Any contiguous sequence of definitions with the same name and different arguments is interpreted as 
a clausal definition, where each individual definition is a clause of the larger function. When the 
function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.

Mutual recursion and clausal definitions are allowed to occur together.
For example, this definition takes a list and publishes a new list with every other element repeated:

<programlisting><![CDATA[
def stutter([]) = []
def stutter(h:t) = h:h:mutter(t)
def mutter([]) = []
def mutter(h:t) = h:stutter(t)
]]></programlisting>

</section>



</section>


<section><title>Services</title>
<para>
Certain declarations are used to provide access to external services.
</para>

<section><title>Sites</title>

<para>
A <code>site</code> declaration instantiates a Java object to be used as a site in an Orc program:

<programlisting><![CDATA[
{-  Define the Buffer site  -}
site Buffer = orc.lib.state.Buffer
]]></programlisting>
</para>

</section>

<section><title>Classes</title>
<para>

A <code>class</code> declaration looks very similar to a <code>site</code> declaration, 
but serves a different purpose. Rather than creating a Java object to be used as a site, 
this declaration actually creates a proxy for the class's constructor, which can then be 
invoked, and its publications used like Java objects by using the dot syntax:

<programlisting><![CDATA[
class Str = java.lang.String
val s = Str("foo")
s.concat("bar")
]]></programlisting>

Thus, it makes all of the capabilities of sequential Java programming, including its
large standard library, available to the Orc programmer. 

</para>

</section>

</section>

<section><title>Includes</title>
<para>
An include declaration names a file containing a sequence of declarations. It loads all
of those declarations in the order given in the file, as if they had been written 
directly into the program at that point. This is a convenient way to organize large groups 
of declarations.

<programlisting><![CDATA[
{-  include some useful list functions  -}
include "inc/orc/list.inc"
]]></programlisting>

</para>

</section>

</section>


<section><title>Comments</title>
<para>
The implementation supports two kinds of comments.   

</para>

<para>
A line which begins with two dashes (<code>--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<programlisting><![CDATA[
-- This is a single line comment.
	 -- This is also a single line comment.
]]></programlisting>
</para>

<para>
Multiline comments are enclosed by matching braces of the form <code><![CDATA[{- -}]]></code>. 
Multiline comments may be nested. They may appear anywhere, even in the middle of an expression.

<programlisting><![CDATA[
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

1 | 2 {- They may appear anywhere, -} >x> {- even in the middle of an expression. -} x+3
]]></programlisting>

</para>

<para>
Commented regions are ignored by the compiler. They are often eliminated entirely by the parser, 
and do not appear in intermediate representations of a program.
</para>

</section>

</chapter>

<!-- 
<chapter><title>Programming Techniques</title>
<para></para>


</chapter>

<chapter><title>Execution Environment</title>
<para></para>
</chapter>

<chapter><title>Debugging</title>
<para></para>
</chapter>

<chapter><title>The Implementation</title>
<para></para>
</chapter>

<chapter><title>FAQ</title>
<para></para>
</chapter>
 -->
 
</book>