<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC " -//OASIS//DTD DocBook XML V5.0//EN" "../docbook-xml/dtd/docbook.dtd" >

<book>

<chapter><title>The Orc Programming Language</title>

<section><title>Introduction</title>

<para>
Orc is a programming language designed to make distributed and
concurrent programs simple and intuitive to write.  Orc expresses
orchestration, a type of structured concurrency. It emphasizes the
flow of control and gives a global view of a concurrent system. Most
other concurrency-oriented languages describe the individual pieces of
a system and their local interactions, but without a global view.  Orc
is particularly well-suited for task orchestration, a form of
concurrent programming with applications in workflow, business process
management, and web service orchestration. Orc provides constructs to
orchestrate the concurrent invocation of services while managing
time-outs, priorities, and failures of services or communication.  To
learn more about Orc and its community of users, visit our website:
<ulink url="http://orc.csres.utexas.edu">http://orc.csres.utexas.edu</ulink>
</para>

<para>
This chapter describes the Orc programming language. The language is
built around <firstterm>expressions</firstterm>. Given that <code>f</code>, 
<code>g</code> and <code>h</code> are Orc expressions, an expression is defined by

<code>f</code> <code>::=</code> base expression | <code>g | h</code> | <code><![CDATA[g >x> h]]></code> | <code><![CDATA[g <x< h]]></code>

The language supports a variety of other ways of writing expressions
in structured manner, but they are all based on the constructs shown
above. The combinators (<code>|</code>, <![CDATA[>x>]]> and <![CDATA[<x<]]>) 
are concurrency combinators that allow, respectively, concurrent computations, 
(a general form of) sequential execution with spawning of computations and 
concurrency combined with computation termination. We describe the language
features that support the concurrency combinators in Section ... . Next, we
describe base expressions. 
</para>

<section><title>Base Expression</title>

<para>
Base expressions are either calls to
external <firstterm>services</firstterm> (described in Section  .. ), 
or simple (functional) expressions that can evaluated locally, (next Section ..). 
</para>

</section>

<section><title>Cor</title>
<para>
Cor is a functional subset of Orc. The original Orc
calculus [reference] did not include a functional subset; thus to
compute 3+4, an external service for addition was called with the
arguments 3 and 4. We retain the underlying philosophy of Orc, but
we also allow the user to simply write <code>3+4</code>, or even functional
programs in a restricted language, which are then translated to calls
on appropriate services.
</para>

</section>

</section> 

<section><title>Cor</title>
 
<para>
In this section we introduce <emphasis>Cor</emphasis>, a subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</para>

<para>
A Cor program is called an <firstterm>expression</firstterm>. Cor expressions are built
up recursively from smaller expressions. Cor <firstterm>evaluates</firstterm> an expression
to reduce it to some simple <firstterm>value</firstterm> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <firstterm>
result</firstterm> of the expression.
</para>

<para>
In the following subsections we'll introduce the concepts of Cor. First, we'll talk about
simple constants, such as numbers and truth values, and the operations that we can perform
on those values. Then we'll introduce conditionals (<code>if/then/else</code>). Then we'll 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we'll talk about constructing data structures, and examining those structures
using patterns. Lastly, we'll introduce functions.
</para> 


<section><title>Constants</title>
<para>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</para>

<para>

Cor has three types of constants, and thus for the moment three types of values:

<itemizedlist>

<listitem>
Integers: <code> ... -1, 0, 1 ... </code>
</listitem> 

<listitem>
Booleans: <code>true</code> and <code>false</code>
</listitem>

<listitem>
Strings: <code>"orc"</code>, <code>"ceci n'est pas une |"</code>
</listitem>

</itemizedlist>
</para>

</section>

<section id="language.base.oeprators"><title>Operators</title>
<para>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>1+2</code> evaluates to <code>3</code>.</listitem>
<listitem><code>(98+2)*17</code> evaluates to <code>1700</code>.</listitem>
<listitem><code>4 = 20 / 5</code> evaluates to <code>true</code>.</listitem>
<listitem><code>3-5 >= 5-3 </code> evaluates to <code>false</code>.</listitem>
<listitem><code><![CDATA[true && (false || true)]]></code> evaluates to <code>true</code>.</listitem>
<listitem><code>"leap" + "frog"</code> evaluates to <code>"leapfrog"</code>.</listitem>
</itemizedlist>
</para>

<para>
Here is the full set of operators that Cor supports:

<informaltable id="ops-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="8" >
<colspec colnum="1" colname="arith-names" colwidth="1*" align="left"/>
<colspec colnum="2" colname="arith-ops" colwidth="3*" align="left"/>
<colspec colnum="3" colname="comp-names" colwidth="1*" align="left"/>
<colspec colnum="4" colname="comp-ops" colwidth="3*" align="left"/>
<colspec colnum="5" colname="logic-names" colwidth="1*" align="left"/>
<colspec colnum="6" colname="logic-ops" colwidth="3*" align="left"/>
<colspec colnum="7" colname="string-names" colwidth="1*" align="left"/>
<colspec colnum="8" colname="string-ops" colwidth="3*" align="left"/>

<thead>
<row>
<entry namest="arith-names" nameend="arith-ops" align="left">Arithmetic</entry>
<entry namest="comp-names" nameend="comp-ops" align="left">Comparison</entry>
<entry namest="logic-names" nameend="logic-ops" align="left">Logical</entry>
<entry namest="string-names" nameend="string-ops" align="left">String</entry>
</row>
</thead>
<tbody>

<row>
<entry><code><![CDATA[+]]></code></entry>
<entry>addition</entry>

<entry><code><![CDATA[=]]></code></entry>
<entry>equality</entry>

<entry><code><![CDATA[&&]]></code></entry>
<entry>logical and</entry>

<entry><code><![CDATA[+]]></code></entry>
<entry>concatenation</entry>

</row>

<row>
<entry><code><![CDATA[-]]></code></entry>
<entry>subtraction</entry>

<entry><code><![CDATA[/=]]></code></entry>
<entry>inequality</entry>

<entry><code><![CDATA[||]]></code></entry>
<entry>logical or</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>


<row>
<entry><code><![CDATA[*]]></code></entry>
<entry>multiplication</entry>

<entry><code><![CDATA[<]]></code></entry>
<entry>less than</entry>

<entry><code><![CDATA[~]]></code></entry>
<entry>logical not</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>

<row>
<entry><code><![CDATA[/]]></code></entry>
<entry>division</entry>

<entry><code><![CDATA[>]]></code></entry>
<entry>greater than</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry><code><![CDATA[%]]></code></entry>
<entry>modulus</entry>

<entry><code><![CDATA[<=]]></code></entry>
<entry>less than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry namest="arith-names" nameend="arith-ops"/>

<entry><code><![CDATA[>=]]></code></entry>
<entry>greater than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

</tbody>
</tgroup>
</informaltable>

</para>


<para>
The <code>=</code> operator can compare values of any type.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>10 = true</code> evaluates to <code>false</code>.</listitem>
</itemizedlist>
</para>

<para>
Sometimes, there are situations where an expression is stuck, because it is attempting to perform 
some impossible operation and cannot reach a value. If this is the case, we say that the expression
is <firstterm>silent</firstterm>. An expression is also silent if it depends on the result of a silent 
subexpression.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>10 / 0</code> is silent.</listitem>
<listitem><code>6 + false</code> is silent.</listitem>
<listitem><code>3 + 1/0</code> is silent.</listitem>
<listitem><code>4 + true = 5</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
Note that Cor is a dynamically typed language. It does not statically check the type correctness
of an expression; instead, an expression with a type error is simply silent when evaluated.
</para>

</section>


<section><title>Conditionals</title>

<para>
A conditional expression in Cor is of the form 
<code>if</code> <emphasis>b</emphasis> <code>then></code> <emphasis>f</emphasis> <code>else</code> <emphasis>g</emphasis>. 
Its meaning is similar to that in other languages: the value
of the expression is the value of <emphasis>f</emphasis> if <emphasis>b</emphasis> is true, 
or the value of <emphasis>g</emphasis> if <emphasis>b</emphasis> is false. Note that <emphasis>f</emphasis> is 
evaluated only if <emphasis>b</emphasis> is true and <emphasis>g</emphasis> only if <emphasis>b</emphasis> is false. 
Thus, evaluation of <code>if 3 = 3 then 5 else 1/0</code> does not cause any error. 
</para>

<para>
Unlike other languages, expressions in Cor may be silent. If <emphasis>b</emphasis> is
silent, then the entire expression is silent. And, if <emphasis>b</emphasis> is true but <emphasis>f</emphasis>
is silent then also the expression is silent (similarly, if <emphasis>b</emphasis> is false
and <emphasis>g</emphasis> is silent).
</para>

<para>
The behavior of conditionals is summarized by the following table,
where <emphasis>v</emphasis> denotes a value.

<informaltable id="cond-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="50%" ?>
<?dbfo table-width="50%" ?>
<tgroup cols="4" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="center"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="1*" align="center"/>
<colspec colnum="4" colname="whole exp" colwidth="1*" align="center"/>
<thead>
<row>
<entry><emphasis>bexp</emphasis></entry>
<entry><emphasis>texp</emphasis></entry>
<entry><emphasis>fexp</emphasis></entry>
<entry><emphasis>result</emphasis></entry>
</row>
</thead>
<tbody>

<row>
<entry><code>true</code></entry>
<entry><emphasis>v</emphasis></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>true</code></entry>
<entry>silent</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry>silent</entry>
<entry>silent</entry>
</row>

<row>
<entry>silent</entry>
<entry>-</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

</tbody>
</tgroup>
</informaltable>

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>if true then 4 else 5</code> evaluates to <code>5</code>.</listitem>
<listitem><code><![CDATA[if  2 < 3 && 5 < 4  then "blue" else "green"]]></code> evaluates to "green".</listitem>
<listitem><code>if  true || "fish"  then "yes" else "no"</code> is silent.</listitem>
<listitem><code>if  false || false  then 4+true else 4+5</code> is silent.</listitem>
<listitem><code><![CDATA[if 0 < 5 then 0/5 else 5/0]]></code> evaluates to 0.</listitem>
</itemizedlist>
</para>


</section>


<section><title>Variables</title>

<para>
A <firstterm>variable</firstterm> is a way of naming the value of some expression so that we can use it later.
Expression <code>x</code>, where x is some variable name, evaluates to the result <firstterm>bound</firstterm>
to the variable x.
</para>

<para>
Variables are bound using a <firstterm>declaration</firstterm>. A declaration is a statement that has no value 
of its own but instead binds one or more variables. The simplest declaration is <code>val</code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<ulink url="http://en.wikipedia.org/wiki/Lexical_scope">lexical scoping</ulink>.
</para>

<para>
<programlisting><![CDATA[
val x = 1 + 2 + 3 + 4 + 5
val y = x + x
]]></programlisting>

These declarations bind variable <code>x</code> to 15 and variable <code>y</code> to 30.
</para>


<para>
If the expression on the right side of a <code>val</code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions can continue. If an evaluated expression depends on that
variable, that expression is silent.

<programlisting><![CDATA[
val x = 1/0
val y = 4+5
if false then x else y
]]></programlisting>

Evaluation of the declaration and <code>val y = 4+5</code> and the expression <code>if false then x else y</code>
may continue even though <code>x</code> is not bound. The expression evaluates to 9.

</para>

<note>
<code>val</code> expresses a limited form of concurrency called <emphasis>declarative concurrency</emphasis> (add
biblio reference to CTMCP). A declaration may be evaluated in parallel with the declarations and expressions that
follow it; any expression which uses a variable introduced by a declaration that is still evaluating will wait for
that evaluation to complete. However, since Cor is a purely declarative language, and cannot express state changes
or the progress of time, it is impossible to distinguish a parallel evaluation from a sequential evaluation within
Cor.
</note>


</section>

<section><title>Data Structures</title>

<para>
Cor supports two basic data structures, <firstterm>tuples</firstterm> and <firstterm>lists</firstterm>.
</para>

<para>
A <firstterm>tuple expression</firstterm> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple value containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+2, 7)</code> evaluates to <code>(3,7)</code>.</listitem>
<listitem><code><![CDATA[ ("true" + "false", true || false, true && false) ]]></code> evaluates to <code>("truefalse", true, false)</code>.</listitem>
<listitem><code>(2/2, 2/1, 2/0)</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
A <firstterm>list expression</firstterm> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list value containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>[1,2+3] </code> evaluates to <code>[1,5]</code>.</listitem>
<listitem><code><![CDATA[ [true && true] ]]> </code> evaluates to <code>[true]</code>.</listitem>
<listitem><code>[]</code> evaluates trivially to <code>[]</code>, the empty list.</listitem>
<listitem><code>[5, 5 + true, 5]</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
There is also a concatenation (<firstterm>cons</firstterm>) operation on lists,
written <emphasis>h</emphasis><code>:</code><emphasis>t</emphasis>, where <emphasis>h</emphasis>
and <emphasis>t</emphasis> are expressions. Its result is a new list whose first element is the 
result of <emphasis>h</emphasis> and whose remaining elements are the list result of
<emphasis>t</emphasis>.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+3):[2+5,6]</code> evaluates to <code>[4,7,6]</code>.</listitem>
<listitem><code>2:2:5:[] </code> evaluates to <code>[2,2,5]</code>.</listitem>
<listitem>Suppose <code>t</code> is bound to [3,5]. Then <code>1:t</code> evaluates to <code>[1,3,5]</code>.</listitem>
<listitem><code>2:3</code> is silent, because <code>3</code> is not a list.</listitem>
</itemizedlist>
</para>


</section>

<section><title>Patterns</title>

<para>
We have seen how to construct data structures. But how do we examine them, and use them? We use <firstterm>patterns</firstterm>.
</para>

<para>
A pattern is a powerful way to bind variables. When writing <code>val</code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <firstterm>shape</firstterm>; a
pattern may take the shape of any structured value. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,y) = (2+3,2*3)</code> binds <code>x</code> to 5 and <code>y</code> to 6.</listitem>
<listitem>
<code>val [a,b,c] = ["one", "two", "three"]</code> binds <code>a</code> to "one", 
<code>b</code> to "two", and <code>c</code> to "three".
</listitem>
<listitem>
<code>val ((a,b),c) = ((1, true), (2, false))</code> binds <code>a</code> to 1, <code>b</code> to <code>true</code>,
and <code>c</code> to <code>(2,false)</code>.
</listitem>
</itemizedlist>
</para>

<para>
A pattern must not use a variable name more than once; patterns are <firstterm>linear</firstterm>. 
For example, <code>(x,y,x)</code> is not a valid pattern.
</para>

<para>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code>val</code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evalauted, it is silent.
</para>

<para>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code>_</code>, to do this; it matches any shape and binds no
variables.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,_,_) = (1,(2,2),[3,3,3])</code> binds <code>x</code> to 1.</listitem>
<listitem><code>val [[_,x],[_,y]] = [[1,3],[2,4]]</code> binds <code>x</code> to 3 and <code>y</code> to 4.</listitem>
</itemizedlist>
</para>

</section>

<section><title>Functions</title>

<para>
Like most other programming languages, Cor has the capability to define <firstterm>functions</firstterm>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code>def</code>, in the following way.

<programlisting><![CDATA[
def add(x,y) = x+y
]]></programlisting>

The expression on the right of the <code>=</code> is called the <firstterm>body</firstterm> of the function.
</para>

<para>
After defining the function, we can <firstterm>call</firstterm> it. A call looks just like the left side of
the declaration except that the variables have been replaced by expressions. To evaluate a call, first we 
evaluate each of its arguments. Then, we evaluate the body of the function with each of the argument 
names bound to the values of the arguments. The result of the call is the result of the function body.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>add(10,10*10)</code> evaluates to <code>110</code>.</listitem>
<listitem><code>add(add(5,3),5)</code> evaluates to <code>13</code>.</listitem>
</itemizedlist>
</para>

<para>
A call may have zero arguments, in which case we write <code>()</code> for the arguments.

<programlisting><![CDATA[
def zero() = 0
]]></programlisting>
</para>


<section><title>Non-strict evaluation</title>

<para>
Function calls are not strict in their arguments. Even if some of the argument expressions
to a call are silent, the function body will still be evaluated. Any argument variable
that corresponds to a silent expression will be silent if it is used in the function body.
</para>


</section>

<section><title>Recursion</title>

<para>
Definitions can be recursive; that is, the name of a definition is bound in its own body.

<programlisting><![CDATA[
def sumto(n) = if n < 1 then 0 else n + sumto(n-1)
]]></programlisting>

Then, <code>sumto(5)</code> evaluates to 15.
</para>  

</section>

<section><title>Mutual Recursion</title>

Mutual recursion is also supported: 

<programlisting><![CDATA[
def even(n) = 
  if (n > 0) then odd(n-1)
  else if (n < 0) then odd(n+1)
  else true
def odd(n) = 
  if (n > 0) then even(n-1)
  else if (n < 0) then even(n+1)
  else false
]]></programlisting>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.

</section>

<section><title>Closure</title>

<para>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<firstterm>closure</firstterm>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

<programlisting><![CDATA[
def a(x) = x-3
def b(y) = y*4
val funs = (a,b)
]]></programlisting>
</para>

<para>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
has <emphasis>higher-order</emphasis> functions.

<programlisting><![CDATA[
def onetwosum(f) = f(1) + f(2)
def triple(x) = x * 3
onetwosum(triple)
]]></programlisting>

Then, <code>onetwosum(triple)</code> is <code>triple(1) + triple(2)</code>, which is <code>1 * 3 + 2 * 3</code>, which evaluates to <code>9</code>.

</para>

<note>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<emphasis>lexical closures</emphasis>.
</note>

</section>

<section><title>Lambda</title>

<para>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code>lambda</code> for this purpose. By writing a function
definition with the keyword <code>lambda</code> instead of a function name, that definition
becomes an expression which evaluates to a closure. 

<programlisting><![CDATA[
def onetwosum(f) = f(1) + f(2)
onetwosum( lambda(x) = x * 3 )
{- 
  identical to:
 
  def onetwosum(f) = f(1) + f(2)
  def triple(x) = x * 3
  onetwosum(triple)
-}
]]></programlisting>

Then, <code>onetwosum( lambda(x) = x * 3 )</code> evaluates to 9. 

</para>

</section>


<section><title>Clauses</title>

<para>
The combination of functions and pattern matching offers a powerful capability: 
<firstterm>clausal</firstterm> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</para>


<para>
Here's an example.

<programlisting><![CDATA[
def sum([]) = 0
def sum(h:t) = h + sum(t)
]]></programlisting>

<code>sum(L)</code> publishes the sum of the numbers in the list <code>L</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</para>

<para>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</para>

<para>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</para>

<para>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

<programlisting><![CDATA[
{- Fibonacci numbers -}
def fib(1) = 1
def fib(n) = if (n < 1) then 0 else fib(n-1) + fib(n-2)
]]></programlisting>

<programlisting><![CDATA[
{- Take up to the first n elements from a list -}
def take(0,_) = []
def take(_,[]) = []
def take(n,h:t) = h:(take(n-1,t))
]]></programlisting>
</para>

<para>
Mutual recursion and clausal definitions are allowed to occur together.
For example, this function takes a list and evaluates to a new list with every other element repeated:

<programlisting><![CDATA[
def stutter([]) = []
def stutter(h:t) = h:h:mutter(t)
def mutter([]) = []
def mutter(h:t) = h:stutter(t)
]]></programlisting>

<code>stutter([1,2,3])</code> evaluates to <code>[1,1,2,3,3]</code>.
</para>

<para>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

<programlisting><![CDATA[
def even(0) = true
def odd(0) = false
def even(n) = odd(if n > 0 then n-1 else n+1)
def odd(n) = even(if n > 0 then n-1 else n+1)
]]></programlisting>

</para>

</section>

</section>

<section><title>Comments</title>
<para>
Cor has two kinds of comments.   

</para>

<para>
A line which begins with two dashes (<code>--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<programlisting><![CDATA[
-- This is a single line comment.
	 -- This is also a single line comment.
]]></programlisting>
</para>

<para>
Multiline comments are enclosed by matching braces of the form <code><![CDATA[{- -}]]></code>. 
Multiline comments may be nested. They may appear anywhere, even in the middle of an expression.

<programlisting><![CDATA[
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

{- They may appear anywhere, -} 
1 + {- even in the middle of an expression. -} 2 + 3
]]></programlisting>

</para>

</section>

</section>


<section><title>Communicating with external services</title>

<para>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. It cannot communicate with the outside world except by producing 
a value. Clearly, the full Orc language must transcend this limitation, because the
orchestration of external services is critical to Orc's purpose.
</para>

<para>
We now introduce <firstterm>sites</firstterm>: Orc's interface to external services.
Sites are called using the same syntax as a function call, but with a slightly different 
meaning. Sites are values, introduced and bound to variables by a special declaration.
</para>

<section><title>Calling a site</title>

<para>
Suppose that the variable <code>Google</code> is bound to a site which sends a 
string to the Google search engine and returns the URL of the top result. A call to
<code>Google</code> looks just like a function call.

<programlisting><![CDATA[
{- Get the top search result for "computation orchestration" -}
Google("computation orchestration")
]]></programlisting>

When the Google service determines the top result for this search, it responds with
some URL. The site call then evaluates to that URL value. Note that the service might
never respond: Google's servers might be down, the network might be down, or the search 
might yield no result URL. If the service fails to respond, the site call remains
silent.
</para>


<para>
A site call involves only one roundtrip communication with an external service. All 
of the information needed for the call must be present before contacting the service.
Thus, site calls are strict; all arguments must be bound before the call can proceed. 
If any argument is silent, the call never occurs.
</para>


<para>
A site is sometimes called purely for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <firstterm>signal</firstterm>: a special value which carries no 
information (analogous to the unit value <code>()</code> in ML). The signal value
can be written as <code>signal</code> within Orc programs.

<programlisting><![CDATA[
-- Print a string to some output console
-- The return value of this site call is a signal
print("Hello, World!")
]]></programlisting>
</para>


</section>


<section><title>Declaring sites</title>

<para>
Sites are bound to variables by a <code>site</code> declaration. This declaration makes
some external service available as a site and binds that site to the given variable.

This example instantiates a Java object to be used as a site in an Orc program, specifically
a Java object which provides an asynchronous buffer service.

<programlisting><![CDATA[
{-  Define the Buffer site  -}
site Buffer = orc.lib.state.Buffer
]]></programlisting>
</para>

  
</section>

</section>


<section><title>The concurrency combinators of Orc</title>

<para>
The Cor language has no concurrency. We extend Cor's simple model with powerful
concurrent capabilities by adding three <firstterm>combinators</firstterm>: special
operators that connect expressions together so that they can evaluate concurrently
in useful ways. We also generalize the simple notion of evaluation to a more
powerful notion that makes more sense in a concurrent context.
</para>

<section><title>Bar: Parallelism and publications</title>

<para>
The first combinator we introduce is the bar combinator, written <code>|</code>. Two
expressions combined by <code>|</code> evaluate in parallel with each other.
But what is the value of such an expression? For example, what is the value of 
<code>1+2 | 3+4</code> ? 
</para>

<para>
At this point, we can no longer talk about evaluation of an expression, because expressions 
may not have a single unique value. Instead, we <firstterm>execute</firstterm> an expression, 
which <firstterm>publishes</firstterm> some number of values. Whenever a Cor expression
is executed, it is evaluated, and its value is published. If the expression is silent,
then no value is published. An expression whose execution publishes no values is also
called silent.
</para>

<para>
So, two expressions combined by <code>|</code> execute in parallel, and whenever one of
those execution publishes a value, the combined execution publishes that value.
</para>   

<para>
<itemizedlist><title>Examples</title>
<listitem><code>3+4</code> publishes 7.</listitem>
<listitem><code>3/0 | 3/1</code> publishes <code>3</code>.</listitem>
<listitem><code>1 | 2 | 1+2</code> publishes 1, 2, and 3, in unspecified order.</listitem>
</itemizedlist>
</para>

</section>

<section><title>Push: Capturing publications</title>

<para>
Now that we have expressions which publish multiple values, what can we do with those
publications? The push combinator, written <code><![CDATA[>x>]]></code>, combines an
expression which publishes some values with another expression which will use those
values.
</para>

<para>
<emphasis>f</emphasis> <code><![CDATA[>x>]]></code> <emphasis>g</emphasis> executes
only the expression <emphasis>f</emphasis>. Each time that <emphasis>f</emphasis> publishes
a value <emphasis>v</emphasis>, a new parallel copy of <emphasis>g</emphasis> executes, in which 
the variable <code>x</code> is bound to that value <emphasis>v</emphasis>. The combined
execution does not publish the value <emphasis>v</emphasis>; it is <firstterm>hidden</firstterm>.
However, whenever some copy of <emphasis>g</emphasis> publishes a value, the combined
execution also publishes that value.
</para>

<para>
The variable is optional; a push without a variable is written <code><![CDATA[>>]]></code>.
</para>

<para>
<code>stop</code> is a special expression which is always silent. 
It is typically used together with a push to silence the publications of another expression.
</para>

</section>


<section><title>Pull: Making <code>val</code> concurrent</title>

<para>
The pull combinator, written <emphasis>g</emphasis> <code><![CDATA[<x<]]></code> <emphasis>f</emphasis>,
allows us to block a computation waiting for a result, or terminate a computation. In fact,
we have already seen this combinator: it is often useful to write it as a declaration of
the form <code>val x =</code> <emphasis>f</emphasis> preceding an expression <emphasis>g</emphasis>.
In a functional setting, its behavior is exactly as previously described. However, in a concurrent 
setting, <code>val</code> takes on two new properties.
</para>

<para>
First, we cannot simply bind the variable to the result of the expression, because an expression may
now publish many values as it executes. Instead, the variable is bound to the first value
published by the execution of the expression. Additionally, as soon as that expression publishes
its first value, it <firstterm>terminates</firstterm>; its execution immediately stops. 
</para>

<para>
Second, execution of subsequent statements and expressions continues immediately, without
waiting for the expression to publish a value and bind the variable. If the variable is used 
before it is bound, the execution using that variable <firstterm>blocks</firstterm> until the 
variable is bound. If the variable is never bound, then that execution blocks forever and 
becomes silent.
</para>

</section>



</section>




<section><title>Additional Features</title>

<para>
Orc has some advanced features that are useful in writing certain kinds of programs.
</para>

<section><title>Special call forms</title>

<section><title>The <code>.</code> notation</title>

<para>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code>obj.m()</code> calls the method
<code>m</code> of the object <code>obj</code>. 
</para>

<para>
There is a special kind of call in Orc which serves a similar purpose. One may write
<code>x.msg</code>, for any identifiers <code>x</code> and <code>msg</code>. This attempts
to send the <firstterm>message</firstterm> 'msg' to the value bound to <code>x</code>. 
The message may not be understood, in which case no publication occurs. 
</para>

<para>
Typically this capability is used so that sites may be treated like objects, with multiple
methods and fields. For example, a channel <code>c</code> might understand the messages
<code>get</code> and <code>put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code>c.get()</code>, or <code>c.put(6)</code>.

<note>
Such calls actually occur in two steps: first <code>c.put</code> sends the message
<code>put</code> to the value <code>c</code>; this publishes a site whose only purpose
is to put values to that channel. Then, that 'put site' is called on the argument
<code>6</code>, sending 6 on that channel. Readers familiar with functional programming
will recognize this technique as <emphasis>currying</emphasis>.
</note>
</para>

</section>

<section><title>Currying</title>

<para>
It is sometimes useful to <emphasis>stage</emphasis> the arguments to a function; that is,
rather than writing a function on two arguments, one instead writes a function on one
argument which returns a function taking the second argument and performing the remainder
of the evaluation. (form of curried applications)
</para>



<para>
This technique is known as <emphasis>currying</emphasis> and it is common in functional
programming languages. It is obviously supported in Orc since it is possible to define
closures. However, there is additional support in defining functions directly in a curried way.
</para>

<para>
For example, instead of writing

<programlisting><![CDATA[
def f(x) = lambda(y) = x+y
]]></programlisting>

it is also permissible to simply write

<programlisting><![CDATA[
def f(x)(y) = x+y
]]></programlisting>

Separate stages of application are separated by parentheses around their argument lists.
</para>

</section>


</section>

<section><title>Special patterns</title>

<section><title>Bang pattern</title>

<para>
A bang pattern, written <code>!p</code>, will publish the value that matches the pattern 
<code>p</code> if the match is successful. This pattern is refutable only if <code>p</code> is refutable.

<programlisting><![CDATA[
(1,2,3)  >(x,!y,!z)> stop
]]></programlisting>

This publishes <code>2</code> and <code>3</code>. 
</para>

<para>
Note that a bang pattern will not publish if the overall match fails, even if its particular match succeeds:

<programlisting><![CDATA[
( (1,2,3) | (4,5,6) )  >(1,!x,y)>  stop
]]></programlisting>

This publishes only <code>2</code>. Even though the pattern <code>x</code> matches the value <code>5</code>, 
the overall pattern <code>(1,!x,y)</code> refuses the value <code>(4,5,6)</code>, so <code>5</code> is not published.
</para>

</section>

<section><title>As pattern</title>

<para>
In taking apart a value with a pattern, it is often useful to capture intermediate results.

<programlisting><![CDATA[
val (a,b) = ((1,2),(3,4))
val (ax,ay) = a
val (bx,by) = b
]]></programlisting>

We can use the <code>as</code> keyword to simplify this process, giving a name to an entire
subpattern. Here is an equivalent version of the above code.

<programlisting><![CDATA[
val ((ax,ay) as a, (bx,by) as b) = ((1,2),(3,4))
]]></programlisting>
</para>

</section>

<section><title>Site patterns</title>

<para>
A site pattern, written <code>M(p,...,p)</code>, matches any value which was published by a call to the
site <code>M</code> with arguments that match the tuple <code>(p,...,p)</code>. 
</para>

<para>
Site patterns provide a generalized version of datatype matching, as seen in the <code>case .. of</code>
 or <code>match .. with </code> constructs provided by Haskell and ML.
</para> 

</section>


<section><title>Patterns as views</title>

<para>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <firstterm>view</firstterm> of that data.
</para>

<para>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</para>


<note>
The concept of views and view patterns is not new in programming languages; it has been demonstrated
in other languages, most notably <ulink url="http://www.scala-lang.org/">Scala</ulink>. In fact, the 
underlying implementation strategy for using sites as view patterns is very similar to the use of
extractor objects and the <code>unapply</code> method in Scala.
</note>


</section>


</section>

<section><title>The before combinator</title>

<para>
Orc has a fourth concurrent combinator: the <firstterm>before</firstterm> combinator,
written <code>f ; g</code>. The before combinator executes its left side, publishing 
each of its publications as they occur. When the left side has completely finished 
executing (i.e. it is equivalent to <link linkend="language.base.stop"><code>stop</code></link>), 
then the right side executes.
</para>

<para>
The before combinator is intended to capture as closely as possible the notion of sequential
processing, as denoted by <code>;</code> in other languages. It was not present in the
original formulation of the Orc concurrency calculus; it has been added to support computation
and iteration over strictly finite data. Sequential programs conflate the concept of
producing a value with the concept of termination. Orc separates these two concepts; variable
binding combinators like <code><![CDATA[>x>]]></code> and <code><![CDATA[<x<]]></code> handle
values, whereas <code>;</code> detects the completion of an execution.
</para>

</section>


</section>

</chapter>

<!-- 
 <chapter><title>Programming Techniques</title>
<para></para>


</chapter>

<chapter><title>Execution Environment</title>
<para></para>
</chapter>

<chapter><title>Accessing External Services</title>
<para></para>
</chapter>

<chapter><title>Debugging</title>
<para></para>
</chapter>

<chapter><title>The Implementation</title>
<para></para>

To answer: why don't nested expressions decode into >x> instead of <x<?

</chapter>

<chapter><title>FAQ</title>
<para>

val x = def E() = 5  E

E is different from E() !

</para>
</chapter>
-->
 
</book>