<?xml version="1.0" encoding="UTF-8"?>

<!--
<!DOCTYPE chapter PUBLIC " -//OASIS//DTD DocBook XML V5.0//EN" "../docbook-xml/dtd/docbook.dtd" >
-->

<book
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Orc User Guide</title>
  
<preface><title>Introduction</title>
	
<para>
Orc is a programming language designed to make distributed and
concurrent programs simple and intuitive to write. Orc expresses
orchestration, a type of structured concurrency. It emphasizes the
flow of control and gives a global view of a concurrent system. Orc
is well-suited for task orchestration, a form of
concurrent programming with applications in workflow, business process
management, and web service orchestration. Orc provides constructs to
orchestrate the concurrent invocation of services while managing
time-outs, priorities, and failures of services or communication.  To
learn more about Orc and run your own Orc programs, visit the website:
<ulink url="http://orc.csres.utexas.edu/"><code>http://orc.csres.utexas.edu/</code></ulink>.
</para>


</preface>

 
<chapter id="chapter.language"><title>The Orc Programming Language</title>

<section><title>Introduction</title>


<para>
This chapter describes the Orc programming language in three steps. In Section 1.2, we
discuss a small subset of Orc called Cor. Cor is a pure functional language,
which has no features for concurrency, has no state, and does not communicate 
with external services. Cor introduces us to the parts of Orc that are most familiar 
from existing programming languages, such as arithmetic operations, variables,
conditionals, and functions.
</para>

<para>
In Section 1.3, we consider Orc itself, which in addition to Cor, comprises 
external services and combinators for concurrent orchestration of those services. 
We show how Orc interacts with these external services, how the combinators can be
used to build up complex orchestrations from simple base expressions, and how the 
functional constructs of Cor take on new, subtler behaviors in the concurrent 
context of Orc.
</para>

<para>
In Section 1.4, we discuss some additional features of Orc that extend 
the basic syntax. These are useful for creating large-scale Orc programs, but 
they are not essential to the understanding of the language.
</para>
 
</section> 


<section><title>Cor: A Functional Subset</title>



 
<para>
In this section we introduce Cor, a pure functional subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</para>

<para>
A Cor program is an <firstterm>expression</firstterm>. Cor expressions are built
up recursively from smaller expressions. Cor <firstterm>evaluates</firstterm> an expression
to reduce it to some simple <firstterm>value</firstterm> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <firstterm>
result</firstterm> of the expression.
</para>

<para>
In the following subsections we introduce the concepts of Cor. First, we talk about
simple constants, such as numbers and truth values, and the operations that we can perform
on those values. Then we introduce conditionals (<code>if then else</code>). Then we 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we talk about constructing data structures, and examining those structures
using patterns. Lastly, we introduce functions.
</para> 

<para>
Table 1.1 describes the syntax of Cor. Each part of the syntax is explained 
in a subsequent section.
</para>

<para>
<table id="cor-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Syntax of the Functional Subset of Orc (Cor)</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="4*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>operator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>function call</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>


<row>
<entry>C</entry>
<entry>::=</entry>

<entry><emphasis>Boolean</emphasis> | <emphasis>Number</emphasis> | <emphasis>String</emphasis></entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>Identifier</emphasis></entry>

<entry><emphasis>Identifier</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>


<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>

</tbody>
</tgroup>
</table>
</para>



<section id="cor.constants"><title>Constants</title>
<para>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</para>

<para>

Cor has three types of constants, and thus for the moment three types of values:

<itemizedlist>

<listitem>
Boolean: <code>true</code> and <code>false</code>
</listitem>

<listitem>
Number: <code> 5, -1, 2.71828, ... </code>
</listitem> 

<listitem>
String: <code>"orc"</code>, <code>"ceci n'est pas une |"</code>
</listitem>

</itemizedlist>
</para>

</section>

<section id="language.base.operators"><title>Operators</title>
<para>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>1+2</code> evaluates to <code>3</code>.</listitem>
<listitem><code>(98+2)*17</code> evaluates to <code>1700</code>.</listitem>
<listitem><code>4 = 20 / 5</code> evaluates to <code>true</code>.</listitem>
<listitem><code>3-5 >= 5-3 </code> evaluates to <code>false</code>.</listitem>
<listitem><code><![CDATA[true && (false || true)]]></code> evaluates to <code>true</code>.</listitem>
<listitem><code>"leap" + "frog"</code> evaluates to <code>"leapfrog"</code>.</listitem>
</itemizedlist>
</para>

<para>
Here is the full set of operators that Cor supports:

<table id="ops-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="95%" ?>
<?dbfo keep-together="always" ?>
<title>Operators of Cor</title>
<tgroup cols="8" >
<colspec colnum="1" colname="arith-names" colwidth="1*" align="left"/>
<colspec colnum="2" colname="arith-ops" colwidth="4*" align="left"/>
<colspec colnum="3" colname="comp-names" colwidth="1*" align="left"/>
<colspec colnum="4" colname="comp-ops" colwidth="6*" align="left"/>
<colspec colnum="5" colname="logic-names" colwidth="1*" align="left"/>
<colspec colnum="6" colname="logic-ops" colwidth="3*" align="left"/>
<colspec colnum="7" colname="string-names" colwidth="1*" align="left"/>
<colspec colnum="8" colname="string-ops" colwidth="4*" align="left"/>

<thead>
<row>
<entry namest="arith-names" nameend="arith-ops" align="left">Arithmetic</entry>
<entry namest="comp-names" nameend="comp-ops" align="left">Comparison</entry>
<entry namest="logic-names" nameend="logic-ops" align="left">Logical</entry>
<entry namest="string-names" nameend="string-ops" align="left">String</entry>
</row>
</thead>
<tbody>

<row>
<entry><code><![CDATA[+]]></code></entry>
<entry>addition</entry>

<entry><code><![CDATA[=]]></code></entry>
<entry>equality</entry>

<entry><code><![CDATA[&&]]></code></entry>
<entry>logical and</entry>

<entry><code><![CDATA[+]]></code></entry>
<entry>concatenation</entry>

</row>

<row>
<entry><code><![CDATA[-]]></code></entry>
<entry>subtraction</entry>

<entry><code><![CDATA[/=]]></code></entry>
<entry>inequality</entry>

<entry><code><![CDATA[||]]></code></entry>
<entry>logical or</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>


<row>
<entry><code><![CDATA[*]]></code></entry>
<entry>multiplication</entry>

<entry><code><![CDATA[<]]></code></entry>
<entry>less than</entry>

<entry><code><![CDATA[~]]></code></entry>
<entry>logical not</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>

<row>
<entry><code><![CDATA[/]]></code></entry>
<entry>division</entry>

<entry><code><![CDATA[>]]></code></entry>
<entry>greater than</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry><code><![CDATA[%]]></code></entry>
<entry>modulus</entry>

<entry><code><![CDATA[<=]]></code></entry>
<entry>less than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry><code><![CDATA[**]]></code></entry>
<entry>exponent</entry>

<entry><code><![CDATA[>=]]></code></entry>
<entry>greater than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

</tbody>
</tgroup>
</table>

</para>

<para>
There is also a unary negation operator, written <code>-</code>, for example <code>-(2 ** 5)</code>.
</para>

<para>
The <code>=</code> operator can compare values of any type. Values of different type are always unequal; for example,
<code>10 = true</code> evaluates to <code>false</code>.
</para>

<section><title>Silent Expression</title>
<para>
There are situations where an expression evaluation is stuck, because it is attempting to perform 
some impossible operation and cannot compute a value. In that case, the expression is <firstterm>silent</firstterm>. 
An expression is also silent if it depends on the result of a silent subexpression. For example, the following
expressions are silent: <code>10/0</code>, <code>6 + false</code>, <code>3 + 1/0</code>, <code>4 + true = 5</code>.
</para>

<para>
Cor is a dynamically typed language. A Cor implementation does not statically check the type correctness
of an expression; instead, an expression with a type error is simply silent when it is evaluated.
</para>

</section>

</section>


<section><title>Conditionals</title>

<para>
A conditional expression in Cor is of the form 
<code>if</code> E <code>then</code> F <code>else</code> G. 
Its meaning is similar to that in other languages: the value
of the expression is the value of F if and only if E evaluates to true, 
or the value of G if and only if E evaluates to false. Note that G is not
evaluated at all if E evaluates to true, and similarly F is not evaluated
at all if E evaluates to false. Thus, for example, evaluation of 
<code>if true then 2+3 else 1/0</code> does not evaluate <code>1/0</code>;
it only evaluates <code>2+3</code>.
</para>

<para>
Unlike other languages, expressions in Cor may be silent. If E is
silent, then the entire expression is silent. And if E evaluates to true 
but F is silent (or if E evaluates to false and G is silent) then the 
expression is silent.
</para>

<para>
The behavior of conditionals is summarized by the following table
(<emphasis>v</emphasis> denotes a value).

<informaltable id="cond-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="60%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="4" >
<colspec colnum="1" colname="E" colwidth="1*" align="center"/>
<colspec colnum="2" colname="F" colwidth="1*" align="center"/>
<colspec colnum="3" colname="G" colwidth="1*" align="center"/>
<colspec colnum="4" colname="result" colwidth="3*" align="center"/>
<thead>
<row>
<entry>E</entry>
<entry>F</entry>
<entry>G</entry>
<entry><code>if</code> E <code>then</code> F <code>else</code> G</entry>
</row>
</thead>
<tbody>

<row>
<entry><code>true</code></entry>
<entry><emphasis>v</emphasis></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>true</code></entry>
<entry>silent</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry>silent</entry>
<entry>silent</entry>
</row>

<row>
<entry>silent</entry>
<entry>-</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

</tbody>
</tgroup>
</informaltable>

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>if true then 4 else 5</code> evaluates to <code>4</code>.</listitem>
<listitem><code><![CDATA[if  2 < 3 && 5 < 4  then "blue" else "green"]]></code> evaluates to "green".</listitem>
<listitem><code>if  true || "fish"  then "yes" else "no"</code> is silent.</listitem>
<listitem><code>if  false || false  then 4+5 else 4+true</code> is silent.</listitem>
<listitem><code><![CDATA[if 0 < 5 then 0/5 else 5/0]]></code> evaluates to 0.</listitem>
</itemizedlist>
</para>


</section>


<section id="cor.variables"><title>Variables</title>

<para>
A <firstterm>variable</firstterm> can be bound to a value. A <firstterm>declaration</firstterm> binds one or
more variables to values. The simplest form of declaration is <code>val</code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<ulink url="http://en.wikipedia.org/wiki/Lexical_scope">lexical scoping</ulink>.
</para>

<para>
<programlisting><![CDATA[
val x = 1 + 2
val y = x + x
]]></programlisting>

These declarations bind variable <code>x</code> to 3 and variable <code>y</code> to 6.
</para>


<para>
If the expression on the right side of a <code>val</code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions continues. If an evaluated expression depends on that
variable, that expression is silent.

<programlisting language="orc-demo"><![CDATA[
val x = 1/0
val y = 4+5
if false then x else y]]></programlisting>

Evaluation of the declaration <code>val y = 4+5</code> and the expression <code>if false then x else y</code>
may continue even though <code>x</code> is not bound. The expression evaluates to 9.

</para>

<!-- 
<note>
<code>val</code> expresses a limited form of concurrency called <emphasis>declarative concurrency</emphasis> (add
biblio reference to CTMCP). A declaration may be evaluated in parallel with the declarations and expressions that
follow it; any expression which uses a variable introduced by a declaration that is still evaluating will wait for
that evaluation to complete. However, since Cor is a purely declarative language, and cannot express state changes
or the progress of time, it is impossible to distinguish a parallel evaluation from a sequential evaluation within
Cor.
</note>
 -->

</section>


<section id="cor.data"><title>Data Structures</title>

<para>
Cor supports two basic data structures, <firstterm>tuples</firstterm> and <firstterm>lists</firstterm>.
</para>

<para>
A <firstterm>tuple expression</firstterm> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+2, 7)</code> evaluates to <code>(3,7)</code>.</listitem>
<listitem><code><![CDATA[ ("true" + "false", true || false, true && false) ]]></code> evaluates to <code>("truefalse", true, false)</code>.</listitem>
<listitem><code>(2/2, 2/1, 2/0)</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
A <firstterm>list expression</firstterm> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>[1,2+3] </code> evaluates to <code>[1,5]</code>.</listitem>
<listitem><code><![CDATA[ [true && true] ]]> </code> evaluates to <code>[true]</code>.</listitem>
<listitem><code>[]</code> evaluates vacuously to <code>[]</code>, the empty list.</listitem>
<listitem><code>[5, 5 + true, 5]</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
There is also a concatenation (<firstterm>cons</firstterm>) operation on lists,
written F<code>:</code>G, where F and G are expressions. Its result is a new list whose first element is the 
value of F and whose remaining elements are the list value of G. The <code>:</code> operator is right associative,
so F<code>:</code>G<code>:</code>H is F<code>(</code>G<code>:</code>H<code>)</code>.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+3):[2+5,6]</code> evaluates to <code>[4,7,6]</code>.</listitem>
<listitem><code>2:2:5:[] </code> evaluates to <code>[2,2,5]</code>.</listitem>
<listitem>Suppose <code>t</code> is bound to [3,5]. Then <code>1:t</code> evaluates to <code>[1,3,5]</code>.</listitem>
<listitem><code>2:3</code> is silent, because <code>3</code> is not a list.</listitem>
</itemizedlist>
</para>


</section>

<section><title>Patterns</title>

<para>
We have seen how to construct data structures. But how do we examine them, and use them? We use <firstterm>patterns</firstterm>.
</para>

<para>
A pattern is a powerful way to bind variables. When writing <code>val</code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <firstterm>shape</firstterm>; a
pattern may take the shape of any structured value. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,y) = (2+3,2*3)</code> binds <code>x</code> to 5 and <code>y</code> to 6.</listitem>
<listitem>
<code>val [a,b,c] = ["one", "two", "three"]</code> binds <code>a</code> to "one", 
<code>b</code> to "two", and <code>c</code> to "three".
</listitem>
<listitem>
<code>val ((a,b),c) = ((1, true), (2, false))</code> binds <code>a</code> to 1, <code>b</code> to <code>true</code>,
and <code>c</code> to <code>(2,false)</code>.
</listitem>
</itemizedlist>
</para>

<para>
Patterns are <firstterm>linear</firstterm>; that is, a pattern may mention a variable name at most once. 
For example, <code>(x,y,x)</code> is not a valid pattern.
</para>

<para>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code>val</code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evaluated, it is silent.
</para>

<para>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code>_</code>, to do this; it matches any shape and binds no
variables.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,_,_) = (1,(2,2),[3,3,3])</code> binds <code>x</code> to 1.</listitem>
<listitem><code>val [[_,x],[_,y]] = [[1,3],[2,4]]</code> binds <code>x</code> to 3 and <code>y</code> to 4.</listitem>
</itemizedlist>
</para>

</section>

<section id="cor.functions"><title>Functions</title>

<para>
Like most other programming languages, Cor provides the capability to define <firstterm>functions</firstterm>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code>def</code>, in the following way.

<programlisting><![CDATA[
def Add(x,y) = x+y
]]></programlisting>

The expression on the right of the <code>=</code> is called the <firstterm>body</firstterm> of the function.
</para>

<para>
After defining the function, we can <firstterm>call</firstterm> it. A call looks just like the left side of
the declaration except that the variable names (the <firstterm>formal parameters</firstterm>) have been 
replaced by expressions (the <firstterm>actual parameters</firstterm>). 
</para>

<para>
To evaluate a call, we treat it as a sequence of <code>val</code> declarations associating the formal
parameters with the actual parameters, followed by the body of the function. 

<programlisting><![CDATA[
{- Evaluation of Add(1+2,3+4) -}
val x = 1+2
val y = 3+4
x+y
]]></programlisting>
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>Add(10,10*10)</code> evaluates to <code>110</code>.</listitem>
<listitem><code>Add(Add(5,3),5)</code> evaluates to <code>13</code>.</listitem>
</itemizedlist>
</para>

<para>
Notice that the evaluation strategy of functions allows a call to proceed even if some of the actual
parameters are silent, so long as the values of those actual parameters are not used in the evaluation
of the body.

<programlisting language="orc-demo"><![CDATA[
def cond(b,x,y) = if b then x else y
cond(true, 3, 5/0)
]]></programlisting>

This evaluates to <code>3</code> even though <code>5/0</code> is silent, because <code>y</code> is not
needed.

</para>


<para>
A function definition or call may have zero arguments, in which case we write <code>()</code> for the arguments.

<programlisting><![CDATA[
def Zero() = 0
]]></programlisting>
</para>


<section><title>Recursion</title>

<para>
Functions can be recursive; that is, the name of a function may be used in its own body.

<programlisting><![CDATA[
def Sumto(n) = if n < 1 then 0 else n + Sumto(n-1)
]]></programlisting>

Then, <code>Sumto(5)</code> evaluates to 15.
</para>  

<para>
Mutual recursion is also supported.

<programlisting><![CDATA[
def Even(n) = 
  if (n > 0) then Odd(n-1)
  else if (n < 0) then Odd(n+1)
  else true
def Odd(n) = 
  if (n > 0) then Even(n-1)
  else if (n < 0) then Even(n+1)
  else false
]]></programlisting>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.
</para>

</section>

<section id="cor.closures"><title>Closures</title>

<para>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<firstterm>closure</firstterm>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

<programlisting><![CDATA[
def a(x) = x-3
def b(y) = y*4
val funs = (a,b)
]]></programlisting>
</para>

<para>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
supports <emphasis>higher-order</emphasis> functions.

<programlisting><![CDATA[
def Onetwosum(f) = f(1) + f(2)
def Triple(x) = x * 3
]]></programlisting>

Then, <code>Onetwosum(Triple)</code> is <code>Triple(1) + Triple(2)</code>, which is <code>1 * 3 + 2 * 3</code> which evaluates to <code>9</code>.

</para>

<para>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<emphasis>lexical closures</emphasis>. This means that when a closure is created, if the body of the
function contains any variables other than the formal parameters, the bindings for those variables are
stored in the closure. Then, when the closure is called, the evaluation of the function body uses those 
stored variable bindings.  
</para>


</section>

<section><title>Lambda</title>

<para>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code>lambda</code> for this purpose. By writing a function
definition without the keyword <code>def</code> and replacing the function name with
the keyword <code>lambda</code>, that definition becomes an expression which evaluates to a closure. 

<programlisting language="orc-demo"><![CDATA[
def Onetwosum(f) = f(1) + f(2)

Onetwosum( lambda(x) = x * 3 )
{- 
  identical to:
  def triple(x) = x * 3
  onetwosum(triple)
-}]]></programlisting>

Then, <code>Onetwosum( lambda(x) = x * 3 )</code> evaluates to 9. 

</para>

</section>


<section><title>Clauses</title>

<para>
The combination of functions and pattern matching offers a powerful capability: 
<firstterm>clausal</firstterm> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</para>


<para>
Here's an example.

<programlisting><![CDATA[
def Sum([]) = 0
def Sum(h:t) = h + Sum(t)
]]></programlisting>

<code>Sum(L)</code> publishes the sum of the numbers in the list <code>L</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</para>

<para>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</para>

<para>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</para>

<para>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

<programlisting><![CDATA[
{- Fibonacci numbers -}
def Fib(0) = 1
def Fib(1) = 1
def Fib(n) = if (n < 0) then 0 else Fib(n-1) + Fib(n-2)
]]></programlisting>

This definition of the Fibonacci function is straightforward, but slow, due to the repeated work in recursive
calls to <code>Fib</code>. We can define a linear-time version, again with the help of pattern matching:

<programlisting><![CDATA[
{- Alternate definition of the Fibonacci function -}

{- A helper function: find the pair (Fibonacci(n-1), Fibonacci(n)) -}
def H(0) = (1,1)
def H(n) = H(n-1) >(x,y)> (y,x+y)

def Fib(n) = if (n < 0) then 0 else H(n) >(x,_)> x
]]></programlisting>
</para>

<para>
As a more complex example of matching, consider the following function which finds
the first <code>n</code> elements of a list (the list is assumed to be at least
<code>n</code> elements long).

<programlisting><![CDATA[
def Take(0,_) = []
def Take(n,h:t) = h:(Take(n-1,t))
]]></programlisting>
</para>


<para>
Mutual recursion and clausal definitions are allowed to occur together.
For example, this function takes a list and computes a new list in which every other element is repeated:

<programlisting><![CDATA[
def Stutter([]) = []
def Stutter(h:t) = h:h:Mutter(t)
def Mutter([]) = []
def Mutter(h:t) = h:Stutter(t)
]]></programlisting>

<code>Stutter([1,2,3])</code> evaluates to <code>[1,1,2,3,3]</code>.
</para>

<para>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

<programlisting><![CDATA[
def Even(0) = true
def Odd(0) = false
def Even(n) = Odd(if n > 0 then n-1 else n+1)
def Odd(n) = Even(if n > 0 then n-1 else n+1)
]]></programlisting>

</para>

</section>

</section>

<section><title>Comments</title>
<para>
Cor has two kinds of comments.   

</para>

<para>
A line which begins with two dashes (<code>--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<programlisting><![CDATA[
-- This is a single line comment.
	 -- This is also a single line comment.
]]></programlisting>
</para>

<para>
Multi-line comments are enclosed by matching braces of the form <code><![CDATA[{- -}]]></code>. 
Multi-line comments may be nested. They may appear anywhere, even in the middle of an expression.

<programlisting><![CDATA[
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

{- They may appear anywhere, -} 
1 + {- even in the middle of an expression. -} 2 + 3
]]></programlisting>

</para>

</section>

</section>



<section><title>Orc: Orchestrating services</title>

<para>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. The full 
Orc language transcends these limitations by incorporating the orchestration of external services.
We introduce the term <firstterm>site</firstterm> to denote an external service which can be
called from an Orc program.
</para>

<para>
As in Cor, an Orc program is an  <firstterm>expression</firstterm>; Orc expressions are built 
up recursively from smaller expressions. Orc is a superset of Cor, i.e., all Cor expressions are 
also Orc expressions. Orc expressions are <firstterm>executed</firstterm>, rather than evaluated; 
an execution may call external services and <firstterm>publish</firstterm> some number of 
values (possibly zero). Different executions of the same expression may have completely different
behaviors; they may call different services, may receive different responses from the same site,
and may publish different values. Expressions in the functional subset, though, will display
the same behavior in all executions.
</para>

<para>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <firstterm>combinators</firstterm>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</para>

<para>
The following figure summarizes the syntax of Orc as an extension of the syntax of Cor. 
The original Cor grammar rules are abbreviated by ellipses (...). 
</para>

<para>
<table id="orc-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Basic Syntax of Orc</title>  
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="4*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>address</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry>C</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>signal</code></entry>

<entry></entry>
<entry><emphasis>signal value</emphasis></entry>
</row>


<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>FATBAR</code> E</entry>

<entry></entry>
<entry><emphasis>parallel combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ <]]></code>P<code><![CDATA[< ]]></code>E</entry>

<entry></entry>
<entry><emphasis>pruning combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>otherwise combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>






</tbody>
</tgroup>
</table>
</para>

<section><title>Communicating with external services</title>

<para>
An Orc expression may be a site call. Sites are called using the same syntax as a 
function call, but with a slightly different meaning. Sites are introduced and bound 
to variables by a special declaration.  
</para>

<section><title>Calling a site</title>

<para>
Suppose that the variable <code>Google</code> is bound to a site which invokes the
Google search engine service in "I'm Feeling Lucky" mode. A call to <code>Google</code> 
looks just like a function call. Calling <code>Google</code> requests the URL of the top 
result for the given search term.

<programlisting><![CDATA[
{- Get the top search result for "computation orchestration" -}
Google("computation orchestration")
]]></programlisting>

Once the Google search service determines the top result, it sends a response. The site 
call then publishes that response. Note that the service might not respond: Google's 
servers might be down, the network might be down, or the search might yield no result URL.  
</para>

<para>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</para>

<para>
A call to a site has exactly one of the following effects: 

<orderedlist>
<listitem>The site returns a value, called its <firstterm>response</firstterm>.</listitem>
<listitem>The site communicates that it will never respond to the call; we say that the call has <firstterm>halted</firstterm></listitem>
<listitem>The site neither returns a value nor indicates that the call has halted; we say that the call is <firstterm>pending</firstterm>.</listitem>
</orderedlist>
</para>

<para>
In the last two cases, the site call is said to be silent. However, unlike a silent expression in Cor, 
a silent site call in Orc might perform some meaningful computation or communication; silence does 
not necessarily indicate an error. Since halted site calls and pending site calls are both silent,
they cannot usually be distinguished from each other; only the <link linkend="combinator.otherwise">
otherwise combinator</link> can tell the difference. 
</para>
 
<!--
<para>
A site call <emphasis>halts</emphasis> when it is certain that the call will never return
a result. This may happen for a variety of reasons. A site may be specifically designed to never 
respond under certain circumstances; for example, <code>if(false)</code> always halts. 
A site may depend on some connection that has failed in a detectable way; for example, 
the call <code>Google("five tons of flax")</code> halts if it is executed on a computer
which has no internet connection. A site may require some resource which is unavailable;
for example, a site call that accesses a website may halt if the website is inaccessible. 
Or the execution of the call may reach some failed or exceptional state; for example,
when calling a Java method from Orc, if an exception is thrown, the call halts. 
Generally speaking, any underlying exception or error which can be detected and which
prevents the site call from ever yielding a result will cause it to halt. A halted site
call can only be distinguished from a blocked site call by the otherwise combinator.
</para>
 -->



<para>
A site is a value, just like an integer or a list. It may be bound to a variable, passed 
as an argument, or published by an execution, just like any other value.
</para> 

<para>
<programlisting><![CDATA[
{-
  Create a search site from a search engine URL,
  bind the variable Search to that site,
  then use that site to search for a term.
-}
val Search = SearchEngine("http://www.google.com/")
Search("first class value")
]]></programlisting>
</para>

<para>
A site is sometimes called only for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <firstterm>signal</firstterm>: a special value which carries no 
information (analogous to the unit value <code>()</code> in ML). The signal value
can be written as <code>signal</code> within Orc programs.


<programlisting language="orc-demo"><![CDATA[
{- 
  Use the 'println' site to print a string, followed by
  a newline, to an output console.
  The return value of this site call is a signal.
-}
println("Hello, World!")
]]></programlisting>
</para>


</section>


<section id="orc-declaring-a-site"><title>Declaring a site</title>

<para>
A <code>site</code> declaration makes some service available as a site and
binds it to a variable. The service might be an object in the host language 
(e.g. a class instance in Java), or an external service on the web which is accessed 
through some protocol like SOAP or REST, or even a primitive operation like addition. 


<!-- (add this section back in when the services chapter is ready to go)
We will discuss the particulars of these declarations, and the guidelines for accessing 
web-based services or creating one's own services, in <link linkend="chapter.services">Chapter 3</link>.
Also, -->
Many useful sites are already defined in the Orc standard library, documented
in <link linkend="appendix.library">Appendix B</link>. For now, we present a simple 
type of site declaration: using an object in the host language as a site.  
</para>

<para>
The following example instantiates a Java object to be used as a site in an Orc program, specifically
a Java object which provides an asynchronous buffer service. The declaration uses a
fully qualified Java class name to find and load a class, and creates an instance of that
class to provide the service. 

<programlisting><![CDATA[
{-  Define the Buffer site  -}
site Buffer = orc.lib.state.Buffer
]]></programlisting>  
</para>

<para>

</para>
  
</section>

</section>


<section><title>The concurrency combinators of Orc</title>

<para>
Orc has four <firstterm>combinators</firstterm>: parallel, sequential, pruning, and otherwise. 
A combinator forms an expression from two component expressions. Each combinator captures a 
different aspect of concurrency.
</para>

<section><title>The parallel combinator</title>

<para>
Orc's simplest combinator is <code>|</code>, the parallel combinator. Orc executes
the expression F <code>|</code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
F <code>|</code> G does so as well. 
</para>   


<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
1 | 1+1
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
{- 
  Access two search sites, Google and Yahoo, in parallel.

  Publish any results they return.
  
  Since each call may publish a value, the expression
  may publish up to two values.
-}  
Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
</para>  

<para>
The parallel combinator is fully associative: (F <code>|</code> G) <code>|</code> H and
F <code>|</code> (G <code>|</code> H) and F <code>|</code> G <code>|</code> H are all
equivalent.
</para> 

<para>
It is also commutative: F <code>|</code> G is equivalent to G <code>|</code> F.  
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1, 2, and 3 in parallel  
1+0 | 1+1 | 1+2
]]></programlisting>
</para>  


</section>

<section><title>The sequential combinator</title>

<para>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F<code><![CDATA[ >x> ]]></code>G, 
combines the expression F, which may publish some values, with another expression G, 
which will use the values as they are published; <code>x</code> transmits the values
from F to G.
</para>

<para>
The execution of F<code><![CDATA[ >x> ]]></code>G starts by executing F. Whenever F publishes a value, 
a new copy of G is executed in parallel with F (and with any previous copies of G); in that
copy of G, variable <code>x</code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
(0 | 1) >n> n+1
]]></programlisting>
</para>  

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 3 and 4 in parallel  
2 >n> (n+1 | n+2)
]]></programlisting>
</para>  


<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 0, 1, 2 and 3 in parallel  
(0 | 2) >n> (n | n+1)
]]></programlisting>
</para>  


<para>
<programlisting><![CDATA[
-- Prepend the site name to each published search result
-- The cat site concatenates any number of arguments into one string  
  Google("cupcake") >s> cat("Google: ", s)
| Yahoo("cupcake") >s> cat("Yahoo: ", s)
]]></programlisting>
</para>  




<para>
The sequential combinator may be written as F<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new copy of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new copy of G is executed.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 3, 6, and 9 in arbitrary order.
(3,6,9)  >(x,y,z)>  ( x | y | z )
]]></programlisting>
</para>


<para>
<programlisting language="orc-demo"><![CDATA[
-- Filter out values of the form (_,false)
( (4,true) | (5,false) | (6,true) )  >(x,true)> x
-- Publishes 4 and 6 
]]></programlisting>
</para>
 


<para>
We may also omit the variable entirely, writing <code><![CDATA[ >> ]]></code>. This
is equivalent to using a wildcard pattern: <code><![CDATA[ >_> ]]></code>
</para>

<para>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code><![CDATA[ >> ]]></code> together with the special expression 
<code>stop</code>, which is always silent.  
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- 
  Print two strings to the console,
  but don't publish the return values of the calls.
-}
( println("goodbye") | println("world") ) >> stop
]]></programlisting>
</para>

<para>
The sequential combinator is right associative: F<code><![CDATA[ >x> ]]></code>G<code><![CDATA[ >y> ]]></code>H
is equivalent to F<code><![CDATA[ >x> (]]></code>G<code><![CDATA[ >y> ]]></code>H<code>)</code>. It has higher
precedence than the parallel combinator: F<code><![CDATA[ >x> ]]></code>G <code>|</code> H is equivalent to
<code>(</code>F<code><![CDATA[ >x> ]]></code>G <code>) |</code> H.
</para>

<para>
The right associativity of the sequential combinator makes it easy to bind variables in sequence and use
them together.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- 
  Publish the cross product of {1,2} and {3,4}:
  (1,3), (1,4), (2,3), and (2,4).
-}
(1 | 2) >x> (3 | 4) >y> (x,y)
]]></programlisting>
</para>


</section>


<section><title>The pruning combinator</title>

<para>
The pruning combinator, written F<code><![CDATA[ <x< ]]></code>G, allows us to block 
a computation waiting for a result, or terminate a computation. The execution of 
F<code><![CDATA[ <x< ]]></code>G starts by executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then the execution of G is immediately 
<firstterm>terminated</firstterm>. A terminated expression cannot call any sites or 
publish any values.
</para>

<para>
During the execution of F, any part of the execution that depends on <code>x</code> 
will be suspended until <code>x</code> is bound (to the first value published by G). If G
never publishes a value, that part of the execution is suspended forever. 
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 5 or 6, but not both
x+2 <x< (3 | 4)
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
-- Query Google and Yahoo for a search result
-- Print out the result that arrives first; ignore the other result
println(result) <result< ( Google("cupcake") | Yahoo("cupcake") )
]]></programlisting>
</para>  

<para>
Though a terminated execution may not make any new calls, the calls
that it has already made will continue normally; their responses are simply
ignored. This may have surprising consequences when a call has side effects,
as in the following example.

<programlisting language="orc-demo"><![CDATA[
{- 
  This example actually prints both "true" and "false" to the
  console, regardless of which call responds first.
-}
stop <x< println("true") | println("false")
]]></programlisting>

Both of the <code>println</code> calls are initiated before either one of
them publishes a value and terminates the expression. Once the expression
is terminated, no new calls occur, but the other <code>println</code> call
still proceeds and still has the effect of printing its message to the
console.
</para>


<para>
The pruning combinator may include a full pattern P instead of just a variable name. Any
value published by G is matched against the pattern P. If this match is successful, then G
terminates and all of the bindings of the pattern P are made in F. Otherwise, the published 
value is simply ignored and G continues to execute.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 9 or 25, but not 16.
x*x <(x,true)< ( (3,true) | (4,false) | (5,true) )
]]></programlisting>
</para>  

<para>
Note that even if <code>(4,false)</code> is published before <code>(3,true)</code> or <code>(5,true)</code>, 
it is ignored. The right side continues to execute and will publish one of <code>(3,true)</code> or 
<code>(5,true)</code>.
</para>


<para>
The pruning combinator is left associative: F<code><![CDATA[ <x< ]]></code>G<code><![CDATA[ <y< ]]></code>H
is equivalent to <code>(</code>F<code><![CDATA[ <x< ]]></code>G<code><![CDATA[) <y< ]]></code>H. It has lower
precedence than the parallel combinator: F<code><![CDATA[ <x< ]]></code>G <code>|</code> H is equivalent to
F<code><![CDATA[ <x< (]]></code>G <code>|</code> H<code>)</code>.
</para>


</section>


<section id="combinator.otherwise"><title>The otherwise combinator</title>

<para>
Orc has a fourth concurrency combinator: the <firstterm>otherwise</firstterm> combinator,
written F<code> ; </code>G. The execution of F<code> ; </code> G proceeds as follows.
First, F is executed. If F <firstterm>completes</firstterm>, and has not published any values, 
then G executes. If F did publish one or more values, then G is ignored. The publications of 
F <code>;</code> G are those of F if F publishes, or those of G otherwise.
</para>

<para>
We determine when an expression completes using the following rules.

<itemizedlist>
<listitem>A Cor expression completes when it is fully evaluated; if it is silent, it completes immediately.</listitem>
<listitem>A site call completes when it has published a value or halted.</listitem>
<listitem>F <code>|</code> G completes when its subexpressions F and G have both completed.</listitem>
<listitem>F<code><![CDATA[ >x> ]]></code>G completes when F has completed and all instantiated copies of G have completed.</listitem>
<listitem>F<code><![CDATA[ <x< ]]></code>G completes when F has completed, and G has either completed or
published a value. Also, if G completes without publishing a value, then all expressions in F which
use <code>x</code> also complete, since they will never be able to proceed.</listitem>
<listitem>F <code>;</code> G completes either when F has published a value and subsequently completed,
or when F and G have both completed.</listitem>
<listitem><code>stop</code> completes immediately.</listitem>
</itemizedlist>

</para>

<para>
The otherwise combinator is fully associative, so F <code>;</code> G <code>;</code> H and
(F <code>;</code> G) <code>;</code> H and F <code>;</code> (G <code>;</code> H) are
all equivalent. It has lower precedence than the other three combinators. 
</para>

<para>
The otherwise combinator was not present in the original formulation of the Orc concurrency 
calculus; it has been added to support computation and iteration over strictly finite data. 
Sequential programs conflate the concept of producing a value with the concept of completion. 
Orc separates these two concepts; variable binding combinators like <code><![CDATA[ >x> ]]></code> 
and <code><![CDATA[ <x< ]]></code> handle values, whereas <code>;</code> detects the completion 
of an execution.
</para>

</section>



</section>



<section><title>Revisiting Cor expressions</title>

<para>
Some Cor expressions have new behaviors in the context of Orc, due to the introduction
of concurrency and of sites.
</para>

<section><title>Arithmetic and Conditional</title>

<para>
The arithmetic, logical, and comparison operators are actually calls to sites, simply
written in infix style with the expected operator symbols. For example, <code>2+3</code>
is actually <code>(+)(2,3)</code>, where <code>(+)</code> is a primitive site provided
by the language itself. All of the operators can be used directly as sites in this way;
the name of the site is the operator enclosed by parentheses, e.g. <code>(**)</code>,
<code>(>=)</code>, etc. Negation (unary minus) is named <code>(0-)</code>.
</para>

<para>
The conditional expression <code>if</code> E <code>then</code> F <code>else</code> G
is actually a derived form based on a site named <code>if</code>. The <code>if</code>
site takes a boolean argument; it returns a signal if that argument is <code>true</code>,
or remains silent if the argument is <code>false</code>.
</para>

<para>
<code>if</code> E <code>then</code> F <code>else</code> G is equivalent 
to <code>(<![CDATA[ if(b) >> ]]></code>F<code><![CDATA[ | if(~b) >> ]]></code>G<code>)<![CDATA[ <b< ]]></code>E.
</para>

<para>
 When the <code>else</code> branch of a conditional is unneeded, we can write <code>if</code> F <code>then</code> G,
 with no <code>else</code> branch. This is equivalent to <code>if(</code>E<code>) >> </code>F.
</para>

</section>

<section><title><code>val</code></title>

<para>
The declaration <code>val x = </code>G, followed by expression F, is 
actually just a different way of writing the expression F<code><![CDATA[ <x< ]]></code>G.
Thus, <code>val</code> shares all of the behavior of the pruning combinator,
which we have already described. (This is also true when a pattern is used instead
of variable name <code>x</code>).
</para>

</section>


<section><title>Nesting Orc expressions</title>

<para>
The execution of an Orc expression may publish many values. What does such an expression 
mean in a context where only one value is expected? For example, what does <code>2 + (3 | 4)</code> 
publish? 
</para>

<para>
The specific contexts in which we are interested are as follows (where E is any Orc expression):

<informaltable id="value-context-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="40%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" align="left"/>
<colspec colnum="2" colwidth="1*" align="right"/>
<tbody>

<row>
<entry>E <emphasis>op</emphasis> E</entry>
<entry><emphasis>operand</emphasis></entry>
</row>

<row>
<entry><code>if</code> E <code>then</code> ...</entry>
<entry><emphasis>conditional test</emphasis></entry>
</row>

<row>
<entry>X<code>(</code> ... <code>,</code> E <code>,</code> ... <code>)</code></entry>
<entry><emphasis>call argument</emphasis></entry>
</row>

<row>
<entry><code>(</code> ... <code>,</code> E <code>,</code> ... <code>)</code></entry>
<entry><emphasis>tuple element</emphasis></entry>
</row>

<row>
<entry><code>[</code> ... <code>,</code> E <code>,</code> ... <code>]</code></entry>
<entry><emphasis>list element</emphasis></entry>
</row>

</tbody>
</tgroup>
</informaltable>
</para>

<para>
Whenever an Orc expression appears in such a context, it executes until it publishes its first value, 
and then it is terminated. The published value is used in the context as if it were the result of evaluating
the expression.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 5 or 6
2 + (3 | 4)
]]></programlisting>
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish exactly one of 0, 1, 2 or 3
(0 | 2) + (0 | 1)
]]></programlisting>
</para>

<para>
To be precise, whenever an Orc expression appears in such a context, it is treated as if it was 
on the right side of a pruning combinator, using a fresh variable name to fill in the hole. 
Thus, C[E] (where E is the Orc expression and C is the context) is equivalent to the expression 
C[<code>x</code>] <code><![CDATA[ <x< ]]></code> E. 
</para>

</section>


<section><title>Functions</title>

<para>
The body of a function in Orc may be any Orc expression; thus, function
bodies in Orc are executed rather than evaluated, and may engage in communication
and publish multiple values.
</para>

<para>
A function call in Orc, as in Cor, binds the values of its actual parameters
to its formal parameters, and then executes the function body with those bindings.
Whenever the function body publishes a value, the function call publishes that
value. Thus, unlike a site call, or a pure functional Cor call, an Orc function
call may publish many values.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish all integers in the interval 1..n, in arbitrary order. 
def range(n) = if (n > 0) then (n | range(n-1)) else stop 

-- Publish 1, 2, and 3 in arbitrary order.
range(3)
]]></programlisting>
</para>

<para>
In the context of Orc, function calls are not strict. When a function call executes,
it begins to execute the function body immediately, and also executes the argument
expressions in parallel. When an argument expression publishes a value, it is terminated,
and the corresponding formal parameter is bound to that value in the execution of
the function body. Any part of the function body which uses a formal parameter
that has not yet been bound suspends until that parameter is bound to a value.
</para>

</section>



</section>


<section><title>Time</title>

<para>
Orc is designed to communicate with the external world, and one of the
most important characteristics of the external world is the passage of
time. Orc implicitly interacts with the passage of time by calling external
services which take time to respond. However, Orc can also explicitly
wait for some amount of time, using the special site <code>Rtimer</code>. 
</para>

<para>
The site <code>Rtimer</code> is a relative timer. It takes as an argument
a number of milliseconds to wait. It waits for exactly that amount of time,
and then responds with a signal.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Print "red", wait for 3 seconds (3000 ms), and then print "green" 
println("red") >> Rtimer(3000) >> println("green") >> stop
]]></programlisting>
</para>

<para>
The following example defines a metronome, which publishes a signal once 
every <code>t</code> milliseconds, indefinitely.
</para>

<para>
<programlisting><![CDATA[
def metronome(t) = signal | Rtimer(t) >> metronome(t)
]]></programlisting>
</para>

<para>
We can also use <code>Rtimer</code> together with the pruning combinator 
to enforce a timeout.
</para>

<para>
<programlisting><![CDATA[
{-
  Publish the result of a Google search.
  If it takes more than 5 seconds, time out.
-}
result 
  <result< ( Google("impatience") 
           | Rtimer(5000) >> "Search timed out.")
]]></programlisting>
</para>



We present many more examples of programming techniques using real time in <link linkend="chapter.methodology">Chapter 2</link>.

</section>


</section>



<section><title>Advanced Features of Orc</title>

<para>
In this section we introduce some advanced features of Orc. These include curried
function definitions and curried calls, writing an arbitrary expression as the
target of a call, a special syntax for writing calls in an object-oriented style, 
extensions to pattern matching, and new forms of declarations.
</para>

<para>
The following figure summarizes further extensions to the syntax of Orc. 
The Orc and Cor grammar rules presented earlier are abbreviated by ellipses (...).
The item G+ means "one or more instances of G concatenated together". 
</para>

<para>
<table id="advanced-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Advanced Syntax of Orc</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="100%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="5*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E G+</entry>

<entry></entry>
<entry><emphasis>generalized call</emphasis></entry>
</row>

<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>curried arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>


<row>
<entry>P</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>!</code>P</entry>

<entry></entry>
<entry><emphasis>publish pattern</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>

<!-- 
<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>site pattern</emphasis></entry>
</row>
 -->

<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>


</tbody>
</tgroup>
</table>
</para>


<section><title>Special call forms</title>

<section><title>The <code>.</code> notation</title>

<para>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code>obj.m()</code> calls the method
<code>m</code> of the object <code>obj</code>. 
</para>

<para>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code>x.msg</code>, for any identifiers <code>x</code> and <code>msg</code>. This treats
 the value bound to <code>x</code> as a site, and calls it with a special 
<firstterm>message</firstterm> value <code>msg</code>. 
If the site understands the message <code>msg</code> (for example, if <code>x</code> is 
bound to a Java object with a field called <code>msg</code>), the site interprets the message 
and responds with some appropriate value. If the site does not 
understand the message sent to it, it does not respond, and no publication occurs. 
If <code>x</code> cannot be interpreted as a site, no call is made. 
</para>

<para>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code>c</code> might understand the messages
<code>get</code> and <code>put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code>c.get()</code>, or <code>c.put(6)</code>.
</para>

<para>
A call such as <code>c.put(6)</code> actually occurs in two steps. First <code>c.put</code> sends the message
<code>put</code> to the site <code>c</code>; this publishes a site whose only purpose
is to put values on the channel. Next, that site is called on the argument
<code>6</code>, sending 6 on the channel. Readers familiar with functional programming
will recognize this technique as <emphasis>currying</emphasis>.
</para>
</section>


<section><title>Currying</title>

<para>
It is sometimes useful to <emphasis>stage</emphasis> the arguments to a function; that is,
rather than writing a function on two arguments, one instead writes a function on one
argument which returns a function taking the second argument and performing the remainder
of the evaluation. 
</para>

<para>
This technique is known as <emphasis>currying</emphasis> and it is common in functional
programming languages. We can write curried functions using <link linkend="cor.closures">closures</link>. Suppose we want to 
define a curried addition function on two arguments, and later apply that function to the 
arguments 3 and 4. We could write such a program in the following way:

<programlisting language="orc-demo"><![CDATA[
def Sum(a) = ( lambda(b) = a+b )  
val f = Sum(3)
f(4)
]]></programlisting>

This defines a function <code>Sum</code> which, given an argument <code>a</code>, creates a function
which will take an argument <code>b</code> and add <code>a</code> to <code>b</code>. It then creates the
function which adds <code>3</code> to its argument, binds that to <code>f</code>, and then invokes
<code>f</code> on <code>4</code> to yield <code>3+4</code>.

</para>

<para>
When defining a curried function, we have abstracted it in two steps, and when
applying it we have written two separate calls. However, this is verbose and
not very clear. Orc has a special syntax for curried function definitions and curried 
applications that will simplify both of these steps. Function definitions may have multiple 
argument sequences; they are enclosed in parentheses and concatenated. Curried function calls 
chain together multiple applications in a similar way. Here is the previous program, written 
in this simplified syntax:

<programlisting language="orc-demo"><![CDATA[
def Sum(a)(b) = a+b
Sum(3)(4)
]]></programlisting>

Naturally, this syntax is backwards compatible; e.g. both of the following programs are also
equivalent:  

<programlisting language="orc-demo"><![CDATA[
def Sum(a) = ( lambda(b) = a+b )  
Sum(3)(4)
]]></programlisting>

<programlisting language="orc-demo"><![CDATA[
def Sum(a)(b) = a+b  
val f = Sum(3)
f(4)
]]></programlisting>

</para>

</section>

<!-- 
Can't find a compelling example for the use of this feature, so this section is commented for now.
However, it is still evident from the grammar that this capability exists.
 -->
<!-- 
<section><title>Expressions as call targets</title>

As a further generalization of calls, we can also write any expression as the target of a call.
In other words, rather than writing an identifier followed by some arguments, a call can even
be a whole expression, whose first publication is used as the site or function to be called.

<programlisting><![CDATA[
 
]]></programlisting>

If the arguments are also expressions, they are executed in parallel with the call target
expression. If the call target expression never publishes, no call occurs.

</section>
 -->

</section>

<section><title>Extensions to pattern matching</title>

<section><title>Publish pattern</title>

<para>
A publish pattern, written <code>!p</code>, will publish the value that matches the pattern 
<code>p</code> if the match is successful.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
(1,2,3)  >(x,!y,!z)> stop
]]></programlisting>
</para>

<para>
This publishes <code>2</code> and <code>3</code>. 
</para>

<para>
Note that a publish pattern will not publish if the overall match fails, even if its particular match succeeds:
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
( (1,2,3) | (4,5,6) )  >(1,!x,y)>  stop
]]></programlisting>
</para>

<para>
This publishes only <code>2</code>. Even though the pattern <code>x</code> matches the value <code>5</code>, 
the overall pattern <code>(1,!x,y)</code> does not match the value <code>(4,5,6)</code>, so <code>5</code> 
is not published.
</para>

<!-- explain the translation of publish patterns? -->

</section>

<section><title>As pattern</title>

<para>
In taking apart a value with a pattern, it is often useful to capture intermediate results.

<programlisting><![CDATA[
val (a,b) = ((1,2),(3,4))
val (ax,ay) = a
val (bx,by) = b
]]></programlisting>

We can use the <code>as</code> keyword to simplify this program fragment, giving a name to an entire
sub-pattern. Here is an equivalent version of the above code.

<programlisting><![CDATA[
val ((ax,ay) as a, (bx,by) as b) = ((1,2),(3,4))
]]></programlisting>
</para>

</section>

<!-- 
<section><title>Site pattern</title>

<para>
A site pattern, written <code>M(p,...,p)</code>, matches any value which was published by a call to the
site <code>M</code> with arguments that match the tuple <code>(p,...,p)</code>. Site patterns only work
for sites which have unique inverses; they are usually used on sites which tag or structure data.
</para>

<para>
Site patterns provide a generalized version of datatype matching, as seen in the <code>case .. of</code>
 or <code>match .. with </code> constructs provided by Haskell and ML.
</para> 

</section>


<section><title>Patterns as views</title>

<para>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <firstterm>view</firstterm> of that data.
</para>

<para>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</para>

<para>
The concept of views and view patterns is not new in programming languages; it has been demonstrated
in other languages, most notably <ulink url="http://www.scala-lang.org/">Scala</ulink>. In fact, the 
underlying implementation strategy for using sites as view patterns is very similar to the use of
extractor objects and the <code>unapply</code> method in Scala.
</para>

</section>
 -->

</section>

<section><title>New forms of declarations</title>

<section><title><code>class</code> declaration</title>

<para>
When Orc is run on top of an object-oriented programming language, classes
from that language may be used as sites in Orc itself, via the <code>class</code>
declaration. 
</para>

<para>
<programlisting><![CDATA[
{- Use the String class from Java's standard library as a site -}
class String = java.lang.String
val s = String("foo")
s.concat("bar")
]]></programlisting>
</para>

<para>
This program binds the variable <code>String</code> to the constructor of Java's
String class. When it is called, it constructs a new instance of String, passing
the given arguments to the constructor.
</para>

<para>
This instance of String is a Java object; its methods are called and its fields
are accessed using the dot (<code>.</code>) notation, just as one would expect in Java.
</para>
</section>


<section><title><code>include</code> declaration</title>

<para>
It is often convenient to group related declarations into units that can be
shared between programs. The <code>include</code> declaration offers a simple
way to do this. It names a source file containing a sequence of Orc declarations;
those declarations are incorporated into the program as if they had textually
replaced the include declaration. An included file may itself contain 
<code>include</code> declarations. 
</para>

<para>
<programlisting><![CDATA[
{- Contents of fold.inc -}
def foldl(f,[],s) = s
def foldl(f,h:t,s) = foldl(f,t,f(h,s))

def foldr(f,l,s) = foldl(f,rev(l),s)
]]></programlisting>
</para>

<para>
<programlisting><![CDATA[
{- This is the same as inserting the contents of fold.inc here -}
include "fold.inc"

def sum(L) = foldl(lambda(a,b) = a+b, L, 0)

sum([1,2,3])
]]></programlisting>
</para>

<para>
Note that these declarations still obey the rules of lexical scope. Also, Orc 
does not detect shared declarations; if the same file is included twice, its 
declarations occur twice.
</para>

</section>


</section>


</section>

<!-- 
<section><title>Simplified Orc</title>

Discuss Cor as syntactic sugar for a simpler Orc calculus.

</section>
 -->

</chapter>


<chapter id="chapter.methodology"><title>Programming Methodology</title>

<para>
In <link linkend="chapter.language">Chapter 1</link>, we described the syntax and semantics of the Orc language. 
Now, we turn our attention to how the language is used in practice, with guidelines on style and programming 
methodology, including a number of common concurrency patterns.
</para>

<section><title>Syntactic and Stylistic Conventions</title>

<para>
In this section we suggest some syntactic conventions for writing Orc programs. None of these 
conventions are required by the parser; newlines are used only to disambiguate certain corner
cases in parsing, and other whitespace is ignored. However, following programming convention 
helps to improve the readability of programs, so that the programmer's intent is more readily apparent.
</para>

<!--
<section><title>Identifiers</title>

By convention, identifiers bound to sites should begin with a capital letter (e.g. <code>Rtimer</code>,
<code>Google</code>). Similarly, identifiers bound to functions which are strict and publish at 
most one value should also begin with a capital letter. Identifiers bound to functions which are not
strict, or may publish multiple values, should begin with a lowercase letter. Variable names
are typically lowercase but may be made uppercase if it seems stylistically appropriate.

</section>
 -->
 
<section><title>Parallel combinator</title> 
 
<para>
When the combined expressions are small, write them all on one line.

<programlisting>
<emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> | <emphasis role="bold">H</emphasis>
</programlisting>

Note that we do not need parentheses here, since <code>|</code> is fully associative and commutative.
</para>

<para>
When the combined expressions are large enough to take up a full line, write one expression
per line, with each subsequent expression aligned with the first and preceded by <code>|</code>. 
Indent the first expression to improve readability.

<programlisting>
  <emphasis role="bold">long expression</emphasis> 
| <emphasis role="bold">long expression</emphasis>
| <emphasis role="bold">long expression</emphasis>
</programlisting>
 
</para>

<para>
A sequence of parallel expressions often form the left hand side of a sequential combinator. 
Since the sequential combinator has higher precedence, use parentheses to group the
combined parallel expressions together. 


<programlisting>
( <emphasis role="bold">expression</emphasis> 
| <emphasis role="bold">expression</emphasis>
) <![CDATA[>x>]]>
<emphasis role="bold">another expression</emphasis>
</programlisting>
</para>

</section>

<section><title>Sequential combinator</title>

<para>
When the combined expressions are small, write a cascade of sequential combinators
all on the same line.
</para> 

<programlisting>
<emphasis role="bold">F</emphasis> <![CDATA[>x>]]> <emphasis role="bold">G</emphasis> <![CDATA[>y>]]> <emphasis role="bold">H</emphasis>
</programlisting>

<para>
Remember that sequential is right associative; in this example, <code>x</code> is bound in both G and H, and <code>y</code> is
bound in H.
</para>

<para>
When the combined expressions are large enough to take up a full line, write one expression
per line; each line ends with the combinator which binds the publications
produced by that line.

<programlisting>
<emphasis role="bold">long expression</emphasis> <![CDATA[>x>]]> 
<emphasis role="bold">long expression</emphasis> <![CDATA[>y>]]>
<emphasis role="bold">long expression</emphasis>
</programlisting>
 
</para>

<para>
For very long-running expressions, or expressions that span multiple lines, write
the combinators on separate lines, indented, between each expression. 

<programlisting>
<emphasis role="bold">very long expression</emphasis> 
  <![CDATA[>x>]]> 
<emphasis role="bold">very long expression</emphasis> 
  <![CDATA[>y>]]>
<emphasis role="bold">very long expression</emphasis>
</programlisting>
 
</para>

</section>

<section><title>Pruning combinator</title>

<para>
When the combined expressions are small, write them on the same line:

<programlisting>
<emphasis role="bold">F</emphasis> <![CDATA[<x<]]> <emphasis role="bold">G</emphasis>
</programlisting>

When multiple pruning combinators are used to bind multiple variables
(especially when the scoped expression is long), start each line with a 
combinator, aligned and indented, and continue with the expression.

<programlisting>
<emphasis role="bold">long expression</emphasis> 
  <![CDATA[<x<]]> <emphasis role="bold">G</emphasis>
  <![CDATA[<y<]]> <emphasis role="bold">H</emphasis>
</programlisting>

</para>

<para>
The pruning combinator is not often written in its explicit form
in Orc programs. Instead, the <code>val</code> declaration is often more
convenient, since it is semantically equivalent and mentions the variable
<code>x</code> before its use in scope, rather than after.

<programlisting>
val x = <emphasis role="bold">G</emphasis>
val y = <emphasis role="bold">H</emphasis>
<emphasis role="bold">long expression</emphasis> 
</programlisting>

</para>

<para>
Additionally, when the variable is used in only one place, and the
expression is small, it is often easier to use a nested expression.
For example,

<programlisting>
val x = <emphasis role="bold">G</emphasis>
val y = <emphasis role="bold">H</emphasis>
M(x,y)
</programlisting>

is equivalent to

<programlisting>
M(<emphasis role="bold">G</emphasis>,<emphasis role="bold">H</emphasis>)
</programlisting>

</para>

<para>
Sometimes, we use the pruning combinator simply for its capability to terminate
expressions and get a single publication; binding a variable is irrelevant. This
is a special case of nested expressions. We use the identity site <code>let</code>
to put the expression in the context of a function call.
</para>

<para>
For example,

<programlisting>
x <![CDATA[<x<]]> <emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> | <emphasis role="bold">H</emphasis>
</programlisting>

is equivalent to

<programlisting>
let(<emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> | <emphasis role="bold">H</emphasis>)
</programlisting>
</para>

<para>
The translation uses a pruning combinator, but we don't need to write the combinator, 
name an irrelevant variable, or worry about precedence (since the expression is enclosed
in parentheses as part of the call).
</para>

</section>

<section><title>Declarations</title>

<para>
Declarations should always end with a newline. 

<programlisting>
def add(x,y) = x + y
val z = 7
add(z,z)
</programlisting>

While the parser does not require a newline to end a declaration, it uses the 
newline to disambiguate certain corner cases in parsing, such as function application.
</para>

<para>
When the body of a declaration spans multiple lines, start the body on a new line
after the <code>=</code> symbol, and indent the entire body.

<programlisting>
def f(x,y) =
    <emphasis role="bold">declaration</emphasis>
    <emphasis role="bold">declaration</emphasis>
    <emphasis role="bold">body expression</emphasis>
</programlisting>

</para>

<para>
Apply this style recursively; if a def appears within a def, indent its contents even further.

<programlisting>
def f(x,y) =
    <emphasis role="bold">declaration</emphasis>
    def helper(z) =
    	<emphasis role="bold">declaration in helper</emphasis>
    	<emphasis role="bold">declaration in helper</emphasis>
    	<emphasis role="bold">body of helper</emphasis>
    <emphasis role="bold">declaration</emphasis>
    <emphasis role="bold">body expression</emphasis>
</programlisting>


</para>

</section>

</section>



<section><title>Programming Idioms</title>

In this section we look at some common idioms used in the design of Orc programs. Many of these idioms will
be familiar to programmers using concurrency, and they are very simple to express in Orc.

<section><title>Fork-join</title>

One of the most common concurrent idioms is a <firstterm>fork-join</firstterm>: run two processes concurrently,
and wait for a result from each one. This is very easy to express in Orc. Whenever we write a <code>val</code>
declaration, the process computing that value runs in parallel with the rest of the program. So if we write
two <code>val</code> declarations, and then form a tuple of their results, this performs a fork-join.


<para>
<programlisting>
val x = <emphasis role="bold">F</emphasis>
val y = <emphasis role="bold">G</emphasis>
(x,y)
</programlisting>
</para>


Fork-joins are a fundamental part of all Orc programs, since they are created by all nested expression
translations. In fact, the fork-join we wrote above could be expressed even more simply as just:

<para>
<programlisting>
(<emphasis role="bold">F</emphasis>,<emphasis role="bold">G</emphasis>)
</programlisting>
</para>


<section><title>Example: Machine initialization</title>

<para>
In Orc programs, we often use fork-join and recursion together to dispatch many tasks in parallel and wait
for all of them to complete. Suppose that given a machine <code>m</code>, calling <code>m.init()</code> 
initializes <code>m</code> and then publishes a signal when initialization is complete. The function 
<code>initAll</code> initializes a list of machines.
</para>

<programlisting><![CDATA[
def initAll([]) = signal
def initAll(m:ms) = ( m.init() , initAll(ms) ) >> signal
]]></programlisting>

<para>
For each machine, we fork-join the initialization of that machine (<code>m.init()</code>) with the initialization
of the remaining machines (<code>initAll(ms)</code>). Thus, all of the initializations proceed in parallel, and
the function returns a signal only when every machine in the list has completed its initialization. 
</para>

<para>
Note that if some machine fails to initialize, and does not return a signal, then the initialization procedure
will never complete. 
</para> 

</section>

<section id="example.auction"><title>Example: Simple parallel auction</title>

<para>
We can also use a recursive fork-join to obtain a value, rather than just signaling completion. Suppose we
have a list of bidders in a sealed-bid, single-round auction. Calling <code>b.ask()</code> requests a bid
from the bidder <code>b</code>. We want to ask for one bid from each bidder, and then return the highest
bid. The function <code>auction</code> performs such an auction for a list of bidders (<code>max</code> 
finds the maximum of its arguments):
</para>

<programlisting><![CDATA[
def auction([]) = 0
def auction(b:bs) = max(b.ask(), auction(bs))
]]></programlisting>

</section>

<section><title>Example: Barrier synchronization</title>

<para>
Suppose we have an expression of the following form, where F and G are expressions and M and N are sites:

<programlisting>
M() <![CDATA[>x>]]> <emphasis role="bold">F</emphasis> | N() <![CDATA[>y>]]> <emphasis role="bold">G</emphasis>
</programlisting>

</para>

<para>
However, we would also like to <emphasis>synchronize</emphasis> the completion of M and N, so that
neither F nor G starts executing until both M and N have published. This is a particular example
of a fork-join:

<programlisting>
( M() , N() ) <![CDATA[>(x,y)>]]> ( <emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> )
</programlisting>

We assume that x does not occur free in G, nor y in F.

</para>

</section>

</section>


<section><title>Parallel Or</title>

<para>
Next we consider a classic example of parallel programming which builds up from fork-join: a parallel-or program. Given two
expressions F and G which may publish boolean values (or might stay silent forever), we want to find the disjunction of their
results as soon as possible. If one of the expressions publishes <code>true</code>, then the disjunction is <code>true</code>; 
hence, it is not necessary to wait for the other expression to publish a value.
</para>

<para>
Here is the code:

<programlisting>
val r = 
    val a = <emphasis role="bold">F</emphasis>
    val b = <emphasis role="bold">G</emphasis>
      if(a) <![CDATA[>>]]> true 
    | if(b) <![CDATA[>>]]> true 
    | (a || b)
r
</programlisting>
</para>

<para>
Recall that the <code>||</code> operator is strict; if one of <code>a</code> or <code>b</code> is not bound, it cannot
compute a result. So, we have added <code>if(a) <![CDATA[>>]]> true</code> and <code>if(b) <![CDATA[>>]]> true</code>, 
which wait in parallel for either variable to become <code>true</code> and then publish the result <code>true</code>. 
That way, the parallel-or can evaluate to <code>true</code> based on only one of the results, even if the other result 
is not forthcoming.
</para>

<para>
Also note that the entire computation is within <code>val r =</code>, to prevent <code>true</code> from being published
multiple times.
</para>

</section>


<section><title>Finite Sequential Composition</title>

<para>
F <code><![CDATA[>x>]]></code> G instantiates a copy of G for each published value of F. Suppose we know 
that <emphasis role="bold">F</emphasis> will publish only a finite number of values, and then complete; for 
example, <emphasis role="bold">F</emphasis> publishes the contents of a text file, one line at a time, and
G prints each line to the console. After all of the lines have been printed, we want to start executing a new
expression <emphasis role="bold">H</emphasis>.
</para>

<para>
Sequential composition alone is not sufficient, because we have no way to detect when all of the lines have been published. Fork-join is
also not suitable, since the values to be printed are not stored in some traversable data structure like a list; instead, they
are streaming as publications out of an expression. Instead, we use the <code>;</code> combinator, which waits for all of the
lines to be printed, then the left side completes and the right side can run. Note that we must suppress the publications on
the left side using <code>stop</code>; if the left side published, the right side would not run.
</para>

<programlisting>
<emphasis role="bold">F</emphasis> <![CDATA[>x>]]> println(x) <![CDATA[>>]]> stop ; <emphasis role="bold">H</emphasis>
</programlisting>

</section>


<section><title>Timeout</title>

<para>
One of the most powerful idioms available in Orc is a <firstterm>timeout</firstterm>: execute an expression for at
most a specified amount of time. We accomplish this using <code>val</code> and a timer. The following program runs
F for at most one second to get a value from it. If it does not publish within one second, the value defaults to 0.
</para>

<programlisting>
let( <emphasis role="bold">F</emphasis> | Rtimer(1000) <![CDATA[>>]]> 0 )
</programlisting>


<section><title>Auction with timeout</title>

<para>
In the <link linkend="example.auction">auction example</link> in Section 2.2.1.2, the auction may never complete if 
one of the bidders does not respond. We can add a timeout so that a bidder has at most 8 seconds to provide a bid:
</para>

<programlisting><![CDATA[
def auction([]) = 0
def auction(b:bs) = 
  val bid = b.ask() | Rtimer(8000) >> 0
  Max(bid, auction(bs))
]]></programlisting>

<para>
Now, the auction is guaranteed to complete in at most 8 seconds.
</para>

</section>


<section><title>Detecting timeout</title>

<para>
Sometimes, rather than just yielding a default value, we would like to determine
whether an expression has timed out, and if so, perform some other computation.
To detect the timeout, we pair the original expression with <code>true</code> and the timer
with <code>false</code>, so if the expression does time out, then we can detect
it using the truth value. We then test the truth value, performing the usual
computation if no timeout occurred, or some error-correcting computation if 
the expression did time out.
</para>

<para>
Here, we run the expression F with a time limit t. If it publishes within the time
limit, we execute G (the result of F is bound to r). Otherwise, we execute H.

<programlisting>
val (r,b) = (<emphasis role="bold">F</emphasis>,true) | (Rtimer(t),false)
if b then <emphasis role="bold">G</emphasis> else <emphasis role="bold">H</emphasis>
</programlisting>

</para>
 
</section>

</section>

<section><title>Priority</title>

<para>
We can also use a timer to give a window of priority to one computation over another.
In this example, we run expressions F and G concurrently. F has priority for the first
second: if F publishes, its value is used immediately, but if G publishes, that publication 
is suspended for the first second and may be superseded by a publication from F
during that time. If neither F nor G publishes within a second, then whichever publishes
first after that point is the winner. 

<programlisting>
val x = <emphasis role="bold">F</emphasis>
val y = <emphasis role="bold">G</emphasis>
let( y | Rtimer(1000) >> x )
</programlisting>

</para>

</section>


<section><title>Repeat</title>

<para>
Recall the definition of <code>metronome</code> from the previous chapter:

<programlisting><![CDATA[
def metronome() = signal | Rtimer(1000) >> metronome()
]]></programlisting>
</para>

<para>
We can use <code>metronome</code> and the sequential combinator to repeat 
an expression, so that copies of that expression will execute at
regular intervals.
</para>

<para>
<programlisting><![CDATA[
{-
   Publish "tick" once every second.
   Publish "tock" once every second, with an initial 500ms delay.
   The publications alternate: tick tock tick tock ...
-}   
  metronome() >> "tick"
| Rtimer(500) >> metronome() >> "tock"
]]></programlisting>
</para>

</section>


<section><title>Priority Poll</title>

<para>
Suppose we have a list of buffers. We would like to poll these buffers periodically to see if they have
any available data. Furthermore, this list of buffers is ordered by priority; the first buffer in the
list has the highest priority, so it should be polled first, and if it has no data, then the next buffer
should be polled, and so on.
</para>

<para>
Here is a function which polls a prioritized list of buffers in this way. It publishes the first item 
that it finds, removing it from the originating buffer. If all buffers are empty, it remains silent.
We use the <code>getnb</code> ("get non-blocking") method of the buffer, which retrieves the first
available item if there is one, or else remains silent and completes immediately if the buffer is empty
(it does not wait for an item to become available).
</para>

<programlisting>
def PriorityPoll([]) = stop
def PriorityPoll(b:bs) = b.getnb() ; PriorityPoll(bs)
</programlisting>

</section>

<!-- 

( more idiomatic to use x.getAll() )

<section><title>Buffer Transfer</title>

<para>
Suppose we have two buffers, and would like to empty one buffer and put its contents 
into the other buffer. We use the following function to do so.

<programlisting>
def Transfer(x,y) = 
    def loop() = x.getnb() >v> y.put(v) >> loop()
    loop() ; signal
</programlisting>

<code>loop</code> takes the elements from <code>x</code> one at a time
(using <code>getnb</code>) and recurses. When <code>x</code> is empty, <code>getnb</code> 
completes and is silent, so the call to <code>loop</code> becomes silent,
allowing the right side of the <code>;</code> to run, publishing a signal
to indicate that the transfer is finished.
</para>

</section>
 -->


<section><title>Parallel Matching</title>

<para>
Matching a value against multiple patterns, as we have seen it so far, is a linear
process, and requires a <code>def</code> whose clauses have patterns in their
argument lists. Such a match is linear; each pattern is tried in order until
one succeeds.
</para>

<para>
What if we want to match a value against multiple patterns in parallel, executing
every clause that succeeds? Fortunately, this is very easy to do in Orc. Suppose
we have an expression F which publishes pairs of integers, and we want to publish
a signal for each 3 that occurs. We write:

<programlisting>
<emphasis role="bold">F</emphasis> <![CDATA[>x>
  ( x >(3,_)> signal
  | x >(_,3)> signal ) 
]]>
</programlisting>

The interesting case is the pair <code>(3,3)</code>, which is counted twice
because both patterns match it in parallel.
</para>

<para>
This is a useful idiom even if the patterns are mutually exclusive, to avoid
creating a helper function just to handle the pattern match.
</para>

</section>


<section><title>Arrays</title>

<para>
While lists are a very useful data structure, they are not indexed; it is not possible to get the nth element of
a list in constant time. However, this capability is often needed in practice, so the Orc standard library
provides a function <code>IArray</code> to create immutable arrays. Once initialized, an immutable array cannot
be rewritten; it can only be read. 
</para>

<para>
<code>IArray</code> takes two arguments: an array size, and a function to initialize the array. The function
takes the index being initialized as an argument (indices start at 0), and publishes the value to be stored
at that array position. Here are a few examples:

<programlisting language="orc-demo">
{- Create an array of 10 elements; element i is the ith power of 2 -}
IArray(10, lambda(i) = 2 ** i)
</programlisting>

<programlisting language="orc-demo">
{- Create an array of 5 elements; each element is a newly created buffer -}
IArray(5, lambda(_) = Buffer())
</programlisting>
</para>

<para>
The array is used like a function; the call <code>A(i)</code> returns the <code>i</code>th element of the
array <code>A</code>. A call with an out-of-bounds index halts. 

<programlisting language="orc-demo">
{- Create an array of 3 buffers -}
val A = IArray(10, lambda(_) = Buffer())

{- Send true on the 0th channel, and listen for a value on the 0th channel. -}
A(0).put(true) | A(0).get()
</programlisting>
</para>

</section>


<!-- To add: Channel and routing techniques (internal/external interrupt, old semicolon semantics, condenser) -->

</section>


<section><title>Larger Examples</title>

<section><title>Dining Philosophers</title>

<para>
The dining philosophers problem is a well known and intensely studied problem in
concurrent programming. For a detailed description, see 
<ulink link="http://en.wikipedia.org/wiki/Dining_philosophers">the Wikipedia entry</ulink>
on the problem. Here, we present an Orc solution to the dining philosophers problem,
based on a probabilistic solution by Rabin.  
</para>

<programlisting language="orc-demo"><![CDATA[
def shuffle(a,b) = if (random(2) = 1) then (a,b) else (b,a)

def take((a,b)) =    
  a.acquire() >> b.acquirenb() ;
  a.release() >> take(shuffle(a,b))
    
def drop(a,b) = (a.release(), b.release()) >> signal

def phil(a,b,name) =
  def thinking() = 
    if (urandom() < 0.9)
      then Rtimer(random(1000))
      else println(name + " is thinking forever.") >> stop
  def hungry() = take((a,b))
  def eating() = 
    println(name + " is eating.") >> 
    Rtimer(random(1000)) >> 
    println(name + " has finished eating.") >>
    drop(a,b)
  thinking() >> hungry() >> eating() >> phil(a,b,name)

def dining(n) =
  if (n < 2) 
    then println("Can't simulate fewer than two philosophers.")
    else 
    ( 
      val forks = IArray(n, lambda(_) = Semaphore(1))
      def phils(0) = stop
      def phils(i) = phil(forks(i%n), forks(i-1), "Philosopher " + i) 
                   | phils(i-1)
      phils(n) 
    )
dining(5) ; println("Done.") >> stop
]]></programlisting>

<para>
The program calls <code>dining(5)</code> to simulate the dining philosophers
problem with size 5. It waits for the simulation to complete, then prints a message
and stops.
</para>

<para>
The <code>dining</code> function takes the number <code>n</code> of philosophers 
to simulate. It creates an array of <code>n</code> binary semaphores to
represent the forks. Then, it starts <code>n</code> philosopher processes in
parallel using the function <code>phil</code>, giving each philosopher an
identifier, and references to its left and right forks. 
</para>

<para>
The <code>phil</code> function describes the behavior of an individual philosopher.
It calls the <code>thinking</code>, <code>hungry</code>, and <code>eating</code>
functions in a continuous loop. A <code>thinking</code> philosopher waits for a random
amount of time, and also has a 10% chance of thinking forever. A <code>hungry</code>
philosopher uses the <code>take</code> function to acquire two forks. An <code>eating</code>
philosopher waits for a random time interval and then uses the <code>drop</code> function
to yield ownership of its forks. 
</para>

<para>
The <code>take</code> and <code>drop</code> functions are the key to the algorithm.
Calling <code>take</code> attempts to acquire a pair of forks in two steps:
wait for one fork to become available, then immediately attempt to acquire the second
fork. If the second fork is acquired, signal success; otherwise, release the first
fork, and then try again, randomly changing the order in which the forks are
acquired using the <code>shuffle</code> helper function. This reordering ensures
that the algorithm will probabilistically avoid livelock. The <code>drop</code> function
simply releases both of the forks. 
</para> 

</section>

<section id="methodology.examples.hygenic"><title>Hygienic Dining Philosophers</title>

<para>
Here we implement a different solution to the Dining Philosophers problem,
described in "The Drinking Philosophers Problem", by K. M. Chandy and J. Misra.
Briefly, this algorithm efficiently and fairly solves the dining philosophers
problem for philosophers connected in an arbitrary graph (as opposed to a
simple ring).  The algorithm works by augmenting each fork with a clean/dirty
state.  Initially, all forks are dirty.  A philosopher is only obliged to
relinquish a fork to its neighbor if the fork is dirty. On receiving a fork,
the philosopher cleans it. On eating, the philosopher dirties all forks.  For
full details of the algorithm, consult the original paper.
</para>

<programlisting language="orc-demo"><![CDATA[
{-
Start a philosopher actor; never publishes.
Messages sent between philosophers include:
- ("fork", p): philosopher p relinquishes the fork
- ("request", p): philosopher p requests the fork
- ("rumble", p): sent by a philosopher to itself when it should
  become hungry

name: identify this process in status messages
mbox: our mailbox; the "address" of this philosopher is mbox.put
missing: set of neighboring philosophers holding our forks
-}
def philosopher(name, mbox, missing) =
  {- deferred requests for forks -}
  val deferred = Buffer()
  {- forks we hold which are clean -}
  val clean = Set()

  def sendFork(p) =
    {- remember that we no longer hold the fork -}
    missing.add(p) >>
    p(("fork", mbox.put))
 
  def requestFork(p) =
    p(("request", mbox.put))
  
  {- Start a timer which will tell us when we're hungry. -}
  def digesting() =
      println(name + " thinking") >>
      thinking()
    | Rtimer(random(1000)) >>
      mbox.put(("rumble", mbox.put)) >>
      stop

  {- Wait to become hungry -}
  def thinking() =
    def on(("rumble", _)) =
      println(name + " hungry") >>
      map(requestFork, missing) >>
      hungry()
    def on(("request", p)) =
      sendFork(p) >> thinking()
    on(mbox.get())

  {- Eat once we receive all forks -}
  def hungry() =
    def on(("fork", p)) =
      missing.remove(p) >>
      clean.add(p) >>
      if missing.isEmpty()
      then println(name + " eating") >> eating()
      else hungry()
    def on(("request", p)) =
      if clean.contains(p)
      then deferred.put(p) >> hungry()
      else sendFork(p) >> requestFork(p) >> hungry()
    on(mbox.get())

  {- Dirty forks, process deferred requests, then digest -}
  def eating() =
    clean.clear() >>
    Rtimer(random(1000)) >>
    map(sendFork, deferred.getAll()) >>
    digesting()

  {- All philosophers start out digesting -}
  digesting()

{-
Create an NxN 4-connected grid of philosophers.  Each philosopher
holds the fork for the connections below and to the right (so the
top left philosopher holds both its forks).
-}
def philosophers(n) =
  {- A set with 1 item -}
  def Set1(item) = Set() >s> s.add(item) >> s
  {- A set with 2 items -}
  def Set2(i1, i2) = Set() >s> s.add(i1) >> s.add(i2) >> s

  {- create an NxN matrix of mailboxes -}
  val cs = uncurry(IArray(n, lambda (_) = IArray(n, ignore(Buffer))))

  {- create the first row of philosophers -}
  philosopher((0,0), cs(0,0), Set())
  | for(1, n) >j>
    philosopher((0,j), cs(0,j), Set1(cs(0,j-1).put))

  {- create remaining rows -}
  | for(1, n) >i> (
      philosopher((i,0), cs(i,0), Set1(cs(i-1,0).put))
      | for(1, n) >j>
        philosopher((i,j), cs(i,j), Set2(cs(i-1,j).put, cs(i,j-1).put))
    )

{- Simulate a 3x3 grid of philosophers for 10 seconds -}
let(
  philosophers(3)
  | Rtimer(10000)
) >> "HALTED"]]></programlisting>

<para>
Our implementation is based on the <ulink
link="http://en.wikipedia.org/wiki/Actor_model">actor model</ulink> of
concurrency.  An actor is a state machine which reacts to messages.  On
receiving a message, an actor can send asynchronous messages to other actors,
change its state, or create new actors.  Each actor is single-threaded and
processes messages sequentially, which makes some concurrent programs easier to
reason about and avoids explicit locking. <ulink
link="http://www.erlang.org/">Erlang</ulink> is one popular language based
on the actor model.
</para>

<para>
Orc emulates the actor model very naturally.  In Orc, an actor is an Orc thread
of execution, together with a <code>Buffer</code> which serves as a mailbox.  To send a
message to an actor, you place it in the actor's mailbox, and to receive a
message, the actor gets the next item from the mailbox.  The internal states of
the actor are represented by functions: while an actor's thread of execution is
evaluating a function, it is considered to be in the corresponding state.
Because Orc implements <ulink
link="http://en.wikipedia.org/wiki/Tail_call">tail-call optimization</ulink>,
state transitions can be encoded as function calls without running out of stack
space.
</para>

<para>
In this program, a philosopher is implemented by an actor with three primary
states: <code>eating</code>, <code>thinking</code>, and <code>hungry</code>.
An additional transient state, <code>digesting</code>, is used to start a timer
which will trigger the state change from <code>thinking</code> to
<code>hungry</code>.  Each state is implemented by a function which reads a
message from the mailbox, selects the appropriate action using pattern
matching, performs the action, and finally transitions to the next state
(possibly the same as the current state) by calling the corresponding function.
</para>

<para>
Forks are never represented explicitly.  Instead each philosopher identifies a
fork with the "address" (sending end of a mailbox) of the neighbor who shares
the fork.  Every message sent includes the sender's address.  Therefore when a
philosopher receives a request for a fork, it knows who requested it and
therefore which fork to relinquish.  Likewise when a philosopher receives a
fork, it knows who sent it and therefore which fork was received.
</para>
</section>

<section><title>Readers/Writers</title>

<para>
Here we present an Orc solution to the <ulink
link="http://en.wikipedia.org/wiki/Readers-writers_problem">readers-writers
problem</ulink>.  Briefly, the readers-writers problem involves concurrent
access to a mutable resource.  Multiple readers can access the resource
concurrently, but writers must have exclusive access.  When readers and writers
conflict, different solutions may resolve the conflict in favor of one or the
other, or fairly.  In the following solution, when a writer tries to acquire
the lock, current readers are allowed to finish but new readers are postponed
until after the writer finishes.  Lock requests are granted in the order
received, guaranteeing fairness.  Normally, such a service would be provided to
Orc programs by a site, but it is educational to see how it can be implemented
directly in Orc.
</para>

<programlisting language="orc-demo"><![CDATA[
{-
Create a reader/writer lock and return the sites used
to acquire and release the lock.
-}
def ReadWriteLock() =
  {- Message Queue. Message types:
  Left(Semaphore)  -- acquire read
  Right(Semaphore) -- acquire write
  -}
  val m = Buffer()
  {- Count of active readers/writers -}
  val c = Counter()

  {- Grant read request -}
  def grant(Left(s)) = c.inc() >> s.release()
  {- Grant write request -}
  def grant(Right(s)) =
    c.onZero() >> c.inc() >> s.release() >> c.onZero()

  {- Make a request -}
  def request(tag) = 
    Semaphore(0) >s> m.put(tag(s)) >> s.acquire()

  def acquireR() = request(Left)
  def releaseR() = c.dec()
  def acquireW() = request(Right)
  def releaseW() = c.dec()

  {- Start the actor and return lock functions -}
  repeat(lambda () = m.get() >r> grant(r)) >> stop
  | (acquireR, releaseR, acquireW, releaseW)

{- Test the lock -}
let(
  ReadWriteLock() >(acquireR, releaseR, acquireW, releaseW)> (
    def testR() =
      acquireR() >> println("START READ") >>
      Rtimer(1000) >> println("END READ") >>
      releaseR()
    def testW() =
      acquireW() >> println("START WRITE") >>
      Rtimer(1000) >> println("END WRITE") >>
      releaseW()
    ( Rtimer(10) >> testR() | Rtimer(20) >> testR()
    | Rtimer(30) >> testW()
    | Rtimer(40) >> testR() | Rtimer(50) >> testR()
    ) >> stop
    ; signal
  )
) >> stop]]></programlisting>

<para>
The lock receives requests over the channel <code>m</code> and processes them
sequentially with the function <code>grant</code>. Each request includes a
<code>Semaphore</code> which the requester blocks on.  The lock grants access
by releasing the semaphore, unblocking the requester.
</para>

<para>
The counter <code>c</code> tracks the number of readers or writers currently
holding the lock.  Whenever the lock is granted, <code>grant</code> increments
<code>c</code>, and when the lock is released, <code>c</code> is decremented.
To ensure that a writer has exclusive access, <code>grant</code> waits for the
<code>c</code> to become zero before granting the lock to the writer, and then
waits for <code>c</code> to become zero again before granting any more requests.
</para>
</section>

<!--
Procedural implementation of graphs is terrible for readability. 
Also, introducing this example would require an extended discussion of logical time.

<section><title>Shortest Path</title>


<programlisting><![CDATA[
def path(source, sink, cell, succ) =
  val timer = MakeTimer()
  def run(n,p) =
    cell(n).write(p) >>
    succ(n) >(m,d)>
    timer(d) >>
    run(m,m:p)
  run(source, [source])
  ; reverse(cell(sink).read())

{- A small test graph -}
val source = 0
val sink = 3

val cell0 = Cell()
val cell1 = Cell()
val cell2 = Cell()
val cell3 = Cell()

def cell(0) = cell0
def cell(1) = cell1
def cell(2) = cell2
def cell(3) = cell3

def succ(0) = (1,2) | (2,6) | (3,9)
def succ(1) = (3,7)
def succ(2) = (3,2)
def succ(3) = stop

{-
OUTPUT:
[0, 2, 3]
-}
path(source, sink, cell, succ)
]]></programlisting>

</section>
 -->
 
<!-- 
<section><title>Spellchecker</title>
</section>
-->

<!-- 
<section><title>Meeting Scheduler</title>
</section>
 -->


</section>
 
 
</chapter>



<chapter id="chapter.services"><title>Accessing and Creating External Services</title>

<section id="section.services.java"><title>Java Integration</title>

<para>
The Orc implementation integrates closely with Java.  Java methods and
constructors can be called from Orc as sites, and values can be passed back and
forth seamlessly between Orc and Java.  The following sections will describe
the details of this interaction, and how to implement sites in Java so that
they can be used in Orc.
</para>

<section><title>Values</title>

<para>
Java objects may be used as values anywhere in an Orc program.
Primitive Java values cannot be used directly in an Orc program, they must be
boxed. This boxing (and unboxing, when necessary) is automatic.  Therefore the
main effect of this rule is that it is impossible to distinguish, at runtime,
between a primitive value and an instance of the corresponding wrapper class
with the same value.
</para>

<para>
Orc literals have the following Java types:
<variablelist>
<varlistentry><term>string</term><listitem><code language="java">java.lang.String</code></listitem></varlistentry>
<varlistentry><term>boolean</term><listitem><code language="java">java.lang.Boolean</code></listitem></varlistentry>
<varlistentry><term>integer</term><listitem><code language="java">java.math.BigInteger</code></listitem></varlistentry>
<varlistentry><term>float</term><listitem><code language="java">java.math.BigDecimal</code></listitem></varlistentry>
<varlistentry><term>tuple</term><listitem><code language="java">orc.runtime.values.TupleValue</code></listitem></varlistentry>
<varlistentry><term>function</term><listitem><code language="java">orc.runtime.values.Closure</code></listitem></varlistentry>
<varlistentry><term>list</term><listitem><code language="java">orc.runtime.values.ListValue</code></listitem></varlistentry>
</variablelist>
</para>

<para>
When both arguments of an arithmetic or comparison operator are numeric, the
arguments are implicitly coerced to the widest of the two argument types.
"Widest" is defined by the following relation, where ">" means "is wider than":
BigDecimal > double > float > BigInteger > long > int > short > byte
</para>

</section>

<section id="section.services.java.dot"><title>Dot Operator</title>

<para>
Java classes (as defined by a <code>class</code> declaration) and Java objects (which
are not instances of <code language="java">orc.runtime.values.Callable</code>) behave specially when
treated as sites (i.e. appearing as the target of a call or dot operator).
</para>

<para>
<code>x.member</code>, where <code>x</code> is a Java object or class, is evaluated as follows:
<itemizedlist>
<listitem>If <code>x</code> has one or more methods named <code>member</code>,
a "method handle" is returned which may be called like an Orc site or function.
When such a method handle is called, the appropriate Java method is selected
and called depending on the number and type of arguments, as described in <link
linkend="section.services.java.method">Method Resolution</link>
below.</listitem>
<listitem>Otherwise, if <code>x</code> has a field named <code>member</code>,
the value of the field is returned.</listitem>
</itemizedlist>
</para>

<para>
Note that no distinction is made between static and non-static members; it is
an error to evaluate a non-static member through a class, but this does not
change how members are resolved.  Note also that if a field shares a name with
one or more methods, there is no way to access the field directly.
</para>

</section>

<section><title>Direct Calls</title>

<para>
When <code>x</code> is a Java object (but not a Java class), the syntax
<code>x(...)</code> is treated as equivalent to <code>x.apply(...)</code>,
whose behavior is described in <link linkend="section.services.java.dot">Dot Operator</link>.
</para>

</section>

<section><title>Constructors</title>

When <code>x</code> is a Java class, the syntax <code>x(...)</code> is treated as equivalent to
<code>x.&lt;init&gt;(...)</code> (ignoring the fact that the latter is syntactically invalid).
In other words, the constructor for the object is called. In case of overloaded
constructors, the appropriate constructor is chosen based on the number and
types of arguments as described in <link
linkend="section.services.java.method">Method Resolution</link>.

</section>

<section id="section.services.java.method"><title>Method Resolution</title>

<para>
When an overloaded method is called, the actual method called is based on the runtime types of the arguments, as follows:
<orderedlist>
<listitem>If only one method has the appropriate number of arguments, that method is called.</listitem>
<listitem>Otherwise, each method taking the appropriate number of arguments is tested for type compatibility as follows, and the first matching method is called.
	<orderedlist>
	<listitem>For each argument in turn:
		<orderedlist>
		<listitem>If the argument is null, then the argument matches</listitem>
		<listitem>If the formal parameter is a primitive type, then the argument must be an instance of a wrapper class. The argument is unboxed (unwrapped) and may be coerced to the type of the formal parameter according to Java's standard rules for implicit widening coercions.</listitem>
		<listitem>Otherwise, the argument must be a subtype of the formal parameter type.</listitem>
		</orderedlist>
	</listitem>
	</orderedlist>
</listitem>
</orderedlist>
</para>

<para>
Currently we do not implement specificity rules for choosing the best matching
method; the first matching method (according to some unspecified order) is
chosen.  Note also that we do not support varargs methods explicitly, but
instead varargs may be passed as an array of the appropriate type.
</para>

</section>

<section><title>Cooperative Scheduling</title>

<section><title>Overview</title>
<para>
In order to support massive concurrency efficiently in Java, Orc uses
cooperative threading.  Orc programs are broken into discrete steps which
are executed by a fixed-size thread pool.  This approach works for Orc
expressions, but the internals of an Orc site written in Java cannot be easily
broken down.  So Orc has two choices when it needs to call a local Java site:
</para>

<itemizedlist>
<listitem>Run the site call in a new thread.  This means site calls never
unnecessarily block the Orc engine, but it also limits the number of concurrent
site calls an Orc program can make.</listitem>
<listitem>Run the site call in the same thread as the Orc engine, which
conserves thread resources but may block the engine from making further
progress until the site call finishes.</listitem>
</itemizedlist>

<para>
Fortunately, in practice most Orc site calls take a short, deterministic amount
of time to complete. Of those that don't, it's usually only because they are
blocked waiting for some external event, like another site call.  In this case,
instead of blocking the site can return control to the Orc engine, asking to
be run again when the external event occurs.  In typical Java applications this
kind of non-blocking behavior is implemented using callbacks (or in its most
general form, continuation passing).  Unfortunately this creates convoluted and
verbose code: what if you need to block in the middle of a <code
	language="java">for</code> loop, for example?
</para>

<para>
<ulink url="http://kilim.malhar.net/">Kilim</ulink> resolves this issue by
allowing programmers to write code in a natural blocking style and then
manipulating the bytecode to perform a form of CPS conversion, so that instead
of blocking the code actually returns control to a scheduler. Orc incorporates
Kilim to allow site authors to write sites with internal concurrency and
blocking behavior which don't use Java threads and cooperate with the Orc
engine.
</para>
</section>

<section><title>Kilim Tutorial</title>

<para>
For a full introduction to Kilim, see <ulink
url="http://www.malhar.net/sriram/kilim/thread_of_ones_own.pdf">A Thread of
One's Own</ulink>, by Sriram Srinivasan. In the following, we will cover just
enough to get you started writing Orc sites using Kilim.
</para>

<para>
Kilim introduces three key primitives:
<variablelist>
<varlistentry>
<term>
<code language="java">Pausable</code>
</term>
<listitem>
This checked exception marks methods which may block
<footnote>Originally Kilim used annotations to mark pausable methods. It turned
out that javac would sometimes manipulate code in ways which violate the
invariants regarding use of the annotation. Annotations also have the
disadvantage that the invariants on their use are not checked automatically by
tools like Eclipse.</footnote>. You should never catch
this exception, and you should always declare it even if you have already
declared <code language="java">throws Exception</code> or <code
language="java">throws Throwable</code>.  In all other respects it follows the
normal rules for checked exceptions: an override can only throw it if the
superclass method throws it, and you must throw it if you call any method which
throws it.
</listitem>
</varlistentry>
<varlistentry>
<term>
<code language="java">Mailbox</code>
</term>
<listitem>
A multiple-producer, single-consumer blocking queue used to communicate with tasks.
</listitem>
</varlistentry>
<varlistentry>
<term>
<code language="java">Task</code>
</term>
<listitem>
Cooperative analogue of a Thread. Creating and running a task looks like this:

<programlisting language="java">
new Task() {
    public void execute() throws Pausable {
        // do some stuff
    }
}.start();
</programlisting>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
When writing Orc sites you rarely need to use tasks explicitly because every Orc
site call is implicitly run inside a Kilim task. So all you need to do is mark
<code language="java">Pausable</code> methods. Here's a short example of a
buffer site written using Kilim <code language="java">Mailbox</code>es:

<programlisting language="java"><![CDATA[
public class KilimBuffer<V> {
	private LinkedList<Mailbox<V>> waiters =
		new LinkedList<Mailbox<V>>();
	private LinkedList<V> buffer = new LinkedList<V>();
	public synchronized void put(V o) throws Pausable {
		Mailbox<V> waiter = waiters.poll();
		if (waiter != null) waiter.put(o);
		else buffer.add(o);
	}
	public synchronized V get() throws Pausable {
		V out = buffer.poll();
		if (out != null) return out;
		else {
			Mailbox<V> waiter = new Mailbox<V>();
			waiters.add(waiter);
			return waiter.get();
		}
	}
}]]></programlisting>
</para>
</section>

<section><title>Using Kilim in Orc</title>

<para>Classes using Kilim can be imported like other Java classes using the Orc
<code>class</code> declaration.  For example, we can use the
<code>KilimBuffer</code> class defined above:
<programlisting><![CDATA[
class Buffer = orc.lib.state.KilimBuffer
val b = Buffer()
  Rtimer(1000) >> b.put("1 second later") >> null
| b.get()]]></programlisting>
</para>

<para>
Any Orc site can also run <code language="java">Task</code>s directly or use
the utility method <code language="java">orc.runtime.Kilim#runPausable(Token,
Pausable)</code> to run a task which produces a value for a token.
</para>
</section>

<section><title>When you must block</title>

<para>
Sometimes blocking is unavoidable, for example if a site must perform blocking
IO.  For such cases, Orc provides a utility method <code
language="java">orc.runtime.Kilim#runThreaded(Callable)</code> which farms work
out to a thread pool.  The advantage of doing this over spawning your own
thread is that there is no chance of using too many threads; if no thread is
available, the method pauses until one becomes available.  The disadvantage is
that if you have too many Java methods which must communicate with each other
concurrently and can't use Mailboxes, there won't be enough threads for them
all and execution will deadlock.  This situation is sufficiently rare that
<code language="java">runThreaded</code> is usually the correct approach.
</para>

</section>

<section><title>Compiling Kilim Sites</title>

<para>
Code which uses Kilim annotations must be processed after compiling and before
running, with the Kilim "weaver".  If your <filename>.class</filename> files
are in <filename>./build</filename>, you would run the weaver like this:
</para>
<programlisting language="sh"><![CDATA[
java -cp orc-0.9.3.jar:lib/kilimex.jar:./build kilim.tools.Weaver -d ./build ./build]]></programlisting>

<para>
The Orc source distribution includes an ant <command>kilim</command> task in
<filename>build.xml</filename> to do exactly this.
</para>
</section>

</section>

</section>

</chapter>


<!-- 
<chapter><title>Execution Environment</title>
</chapter>
-->

<!-- 
<chapter><title>Debugging</title>
</chapter>
 -->
 
<!-- 
<chapter><title>The Implementation</title>
</chapter>
-->


<appendix><title>Complete Syntax of Orc</title>

<para>

<table id="full-ebnf-grammar" frame="none" rowsep="0" colsep="0">
<title>Complete Syntax of Orc</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="100%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="5*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>operator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E G+</entry>

<entry></entry>
<entry><emphasis>call</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>FATBAR</code> E</entry>

<entry></entry>
<entry><emphasis>parallel combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ <]]></code>P<code><![CDATA[< ]]></code>E</entry>

<entry></entry>
<entry><emphasis>pruning combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>otherwise combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>


<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>



<row>
<entry>C</entry>
<entry>::=</entry>
<entry><code>true</code> | <code>false</code> | <emphasis>integer</emphasis> | <emphasis>string</emphasis> | <code>signal</code></entry>
<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>identifier</emphasis></entry>

<entry><emphasis>Variable</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>address</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>




<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>!</code>P</entry>

<entry></entry>
<entry><emphasis>publish pattern</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>


<!-- 
<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>site pattern</emphasis></entry>
</row>
 -->

</tbody>
</tgroup>
</table>
</para>


</appendix>


<appendix id="appendix.library"><title>Standard Library</title>
<section><title>Overview</title>
<para>
The standard library is a set of declarations implicitly available to all Orc
programs.  In this section we give an informal description of the standard library,
including the type of each declaration and a short explanation of its use.
</para>

<para>
Orc programs are expected to rely on the host language and environment for
all but the most essential sites.  For example, in the Java implementation of
Orc, the entire Java standard library is available to Orc programs via
<code>class</code> declarations. Therefore the Orc standard library aims only
to provide convenience for the most common Orc idioms, not the complete set of
features needed for general-purpose programming.
</para>
</section>

<section><title>Notation</title>

<para>
Each declaration in the standard library includes a type signature as part of
its documentation. The notation for type signatures, summarized here, is based
on a formal type system for Orc currently under preparation.
</para>

<para>
A type signature consists of: a declaration keyword, a declaration name, argument
types, the return type, and finally any subtyping constraints. For
example <code>def min(A, A) :: A, A &lt;: Comparable</code> gives the type
of the <code>def</code> declaration for <code>min</code>. According to this
signature, <code>min</code> is a function which takes two arguments of type
<code>A</code> and returns a value of the same type, where <code>A</code> is
any subtype of <code>Comparable</code>.
</para>

<para>
Declaration keywords include
<link linkend="orc-declaring-a-site"><code>site</code></link>,
<link linkend="cor.functions"><code>def</code></link>,
<link linkend="cor.variables"><code>val</code></link>, and <code>pattern</code>. The first three keywords
are described in previous chapters. The last, <code>pattern</code>, declares
the inverse of a site which can be used in a pattern. Given <code>pattern M(A) :: (B,C)</code>,
evaluation of <code>x &gt;M(y,z)&gt; (y,z)</code> publishes a tuple <code>(y,z)</code>
such that <code>M(y,z)=x</code>. Suppose <code>Interleave</code> is a <code>site</code>
such that <code>Interleave(y,z)</code>, given two lists of equal length
<code>y</code> and <code>z</code>, returns the lists interleaved starting with
<code>y</code>. Then, given <code>pattern Interleave</code>,

<programlisting><![CDATA[
[0,1,2,3] >Interleave(y,z)> (y,z)]]></programlisting>

publishes <code>([0,2], [1,3])</code>.</para>

<para>
Object members (methods and fields) are each declared separately.  The binding
name of a member is written in the form Type.member, e.g.  <code>Foo.get</code>
refers to the <code>get</code> member of an object of type <code>Foo</code>.
The object type can include type variables which are referenced by the member
type, so for example <code>site Buffer&lt;A&gt;.get() :: A</code> means that
when the <code>get</code> method is called on a <code>Buffer</code> holding an
arbitrary element type <code>A</code>, it will return a value of the same type.
</para>

<para>
Argument and return types are written as follows:
<itemizedlist>
<listitem>Primitive types are given descriptive names based on the names of the
	corresponding Java classes. For example, <code>Number</code> is any
	number, and <code>Comparable</code> is any value which supports a total
	order.</listitem> 
<listitem>Type variables in polymorphic declarations are written using the
	letters <code>A</code> ... <code>Z</code>. For example, the signature
	<code>site let(A) :: A</code> means that <code>let</code> takes one
	argument of any type, and returns a value of the same type.</listitem>
<listitem>The Top type (of which all types are subtypes) is written
	<code>Top</code>. The Bottom type (which is a subtype of all types) is
	written <code>Bot</code>.</listitem>
<listitem>A list with element type <code>A</code> is written <code>[A]</code>.</listitem>
<listitem>A tuple with element types <code>A, B, ...</code> is written <code>(A, B, ...)</code>.</listitem>
<listitem>Any other parameterized type is written as a type name followed by
	type parameters in angle brackets. For example,
	<code>Array&lt;Integer&gt;</code> is the type of arrays of integers.</listitem>
<listitem>A function type (when given as an argument or return type) is written with the keyword
	<code>lambda</code> followed by the argument types and return type as
	in a declaration type signature. For example, <code>lambda (Integer) ::
	Integer</code> is the type of functions mapping integers to
	integers.</listitem>
</itemizedlist>
</para>

<para>
Multiple sets of argument types are syntactic sugar for currying. For
example, <code>site Foo()() :: Signal</code> is equivalent to
<code>site Foo() :: lambda () :: Signal</code>.
</para>

<para>
Subtyping constraints are used to constrain the types of polymorphic type
variables, and are written <code>A &lt;: X</code>, meaning <code>A</code> must
be a subtype of <code>X</code>.
</para>
 
</section>

<xi:include href="stdlib.xml"/>

</appendix>

 
<!-- 
<appendix><title>FAQ</title>
Under construction.
</appendix>
 -->

</book>
