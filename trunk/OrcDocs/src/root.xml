<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC " -//OASIS//DTD DocBook XML V5.0//EN" "../docbook-xml/dtd/docbook.dtd" >

<book>

<chapter><title>The Orc Programming Language</title>

<section><title>Introduction</title>

<para>
Orc is a programming language designed to make distributed and
concurrent programs simple and intuitive to write. Orc expresses
orchestration, a type of structured concurrency. It emphasizes the
flow of control and gives a global view of a concurrent system. Orc
is well-suited for task orchestration, a form of
concurrent programming with applications in workflow, business process
management, and web service orchestration. Orc provides constructs to
orchestrate the concurrent invocation of services while managing
time-outs, priorities, and failures of services or communication.  To
learn more about Orc and run your own Orc programs, visit the website:
<ulink url="http://orc.csres.utexas.edu/"><code>http://orc.csres.utexas.edu/</code></ulink>.
</para>

<para>
This chapter describes the Orc programming language in three steps. In Section 1.2, we
discuss a small subset of Orc called Cor. Cor is a pure functional language,
which has no features for concurrency, has no state, and does not communicate 
with external services. Cor introduces us to the parts of Orc that are most familiar 
from existing programming languages, such as arithmetic operations, variables,
conditionals, and functions.
</para>

<para>
Next, in Section 1.3, we consider Orc itself, which in addition to Cor, comprises 
external services and combinators for concurrent orchestration of those services. 
We show how Orc interacts with these external services, how the combinators can be
used to build up complex orchestrations from simple base expressions, and how the 
functional constructs of Cor take on new, subtler behaviors in the concurrent 
context of Orc.
</para>

<para>
Finally, in Section 1.4, we discuss some additional features of Orc that extend 
the basic syntax. These are useful for creating large-scale Orc programs, but 
they are not essential to the understanding of the language.
</para>
 
</section> 


<section><title>Cor: A Functional Subset</title>



 
<para>
In this section we introduce Cor, a pure functional subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</para>

<para>
A Cor program is called an <firstterm>expression</firstterm>. Cor expressions are built
up recursively from smaller expressions. Cor <firstterm>evaluates</firstterm> an expression
to reduce it to some simple <firstterm>value</firstterm> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <firstterm>
result</firstterm> of the expression.
</para>

<para>
In the following subsections we introduce the concepts of Cor. First, we talk about
simple constants, such as numbers and truth values, and the operations that we can perform
on those values. Then we introduce conditionals (<code>if then else</code>). Then we 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we talk about constructing data structures, and examining those structures
using patterns. Lastly, we introduce functions.
</para> 

<para>
The following figure describes the syntax of Cor. Each part of the syntax is explained 
in a subsequent section.
</para>

<para>

<informaltable id="cor-ebnf-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="4*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>operator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>function call</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>


<row>
<entry>C</entry>
<entry>::=</entry>

<entry><code>true</code> | <code>false</code> | <emphasis>integer</emphasis> | <emphasis>string</emphasis></entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>identifier</emphasis></entry>

<entry><emphasis>Variable</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>


<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>

</tbody>
</tgroup>
</informaltable>
</para>



<section><title>Constants</title>
<para>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</para>

<para>

Cor has three types of constants, and thus for the moment three types of values:

<itemizedlist>

<listitem>
Integers: <code> ... -1, 0, 1 ... </code>
</listitem> 

<listitem>
Booleans: <code>true</code> and <code>false</code>
</listitem>

<listitem>
Strings: <code>"orc"</code>, <code>"ceci n'est pas une |"</code>
</listitem>

</itemizedlist>
</para>

</section>

<section id="language.base.oeprators"><title>Operators</title>
<para>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>1+2</code> evaluates to <code>3</code>.</listitem>
<listitem><code>(98+2)*17</code> evaluates to <code>1700</code>.</listitem>
<listitem><code>4 = 20 / 5</code> evaluates to <code>true</code>.</listitem>
<listitem><code>3-5 >= 5-3 </code> evaluates to <code>false</code>.</listitem>
<listitem><code><![CDATA[true && (false || true)]]></code> evaluates to <code>true</code>.</listitem>
<listitem><code>"leap" + "frog"</code> evaluates to <code>"leapfrog"</code>.</listitem>
</itemizedlist>
</para>

<para>
Here is the full set of operators that Cor supports:

<informaltable id="ops-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="95%" ?>
<tgroup cols="8" >
<colspec colnum="1" colname="arith-names" colwidth="1*" align="left"/>
<colspec colnum="2" colname="arith-ops" colwidth="4*" align="left"/>
<colspec colnum="3" colname="comp-names" colwidth="1*" align="left"/>
<colspec colnum="4" colname="comp-ops" colwidth="6*" align="left"/>
<colspec colnum="5" colname="logic-names" colwidth="1*" align="left"/>
<colspec colnum="6" colname="logic-ops" colwidth="3*" align="left"/>
<colspec colnum="7" colname="string-names" colwidth="1*" align="left"/>
<colspec colnum="8" colname="string-ops" colwidth="4*" align="left"/>

<thead>
<row>
<entry namest="arith-names" nameend="arith-ops" align="left">Arithmetic</entry>
<entry namest="comp-names" nameend="comp-ops" align="left">Comparison</entry>
<entry namest="logic-names" nameend="logic-ops" align="left">Logical</entry>
<entry namest="string-names" nameend="string-ops" align="left">String</entry>
</row>
</thead>
<tbody>

<row>
<entry><code><![CDATA[+]]></code></entry>
<entry>addition</entry>

<entry><code><![CDATA[=]]></code></entry>
<entry>equality</entry>

<entry><code><![CDATA[&&]]></code></entry>
<entry>logical and</entry>

<entry><code><![CDATA[+]]></code></entry>
<entry>concatenation</entry>

</row>

<row>
<entry><code><![CDATA[-]]></code></entry>
<entry>subtraction</entry>

<entry><code><![CDATA[/=]]></code></entry>
<entry>inequality</entry>

<entry><code><![CDATA[||]]></code></entry>
<entry>logical or</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>


<row>
<entry><code><![CDATA[*]]></code></entry>
<entry>multiplication</entry>

<entry><code><![CDATA[<]]></code></entry>
<entry>less than</entry>

<entry><code><![CDATA[~]]></code></entry>
<entry>logical not</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>

<row>
<entry><code><![CDATA[/]]></code></entry>
<entry>division</entry>

<entry><code><![CDATA[>]]></code></entry>
<entry>greater than</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry><code><![CDATA[%]]></code></entry>
<entry>modulus</entry>

<entry><code><![CDATA[<=]]></code></entry>
<entry>less than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry namest="arith-names" nameend="arith-ops"/>

<entry><code><![CDATA[>=]]></code></entry>
<entry>greater than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

</tbody>
</tgroup>
</informaltable>

</para>


<para>
The <code>=</code> operator can compare values of any type.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>10 = true</code> evaluates to <code>false</code>.</listitem>
</itemizedlist>
</para>

<para>
Sometimes, there are situations where an expression is stuck, because it is attempting to perform 
some impossible operation and cannot reach a value. If this is the case, we say that the expression
is <firstterm>silent</firstterm>. An expression is also silent if it depends on the result of a silent 
subexpression.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>10 / 0</code> is silent.</listitem>
<listitem><code>6 + false</code> is silent.</listitem>
<listitem><code>3 + 1/0</code> is silent.</listitem>
<listitem><code>4 + true = 5</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
Note that Cor is a dynamically typed language. It does not statically check the type correctness
of an expression; instead, an expression with a type error is simply silent when evaluated.
</para>

</section>


<section><title>Conditionals</title>

<para>
A conditional expression in Cor is of the form 
<code>if</code> E <code>then</code> F <code>else</code> G. 
Its meaning is similar to that in other languages: the value
of the expression is the value of F if and only if E evaluates to true, 
or the value of G if and only if E evaluates to false. Note that G is not
evaluated at all if E evaluates to true, and similarly F is not evaluated
at all of E evaluates to false. Thus, for example, evaluation of 
<code>if 3 = 3 then 5 else 1/0</code> does not cause any error. 
</para>

<para>
Unlike other languages, expressions in Cor may be silent. If E is
silent, then the entire expression is silent. And if E evaluates to true 
but F is silent (or if E evaluates to false and G is silent) then the 
expression is silent.
</para>

<para>
The behavior of conditionals is summarized by the following table
(<emphasis>v</emphasis> denotes a value).

<informaltable id="cond-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="60%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="4" >
<colspec colnum="1" colname="E" colwidth="1*" align="center"/>
<colspec colnum="2" colname="F" colwidth="1*" align="center"/>
<colspec colnum="3" colname="G" colwidth="1*" align="center"/>
<colspec colnum="4" colname="result" colwidth="3*" align="center"/>
<thead>
<row>
<entry>E</entry>
<entry>F</entry>
<entry>G</entry>
<entry><code>if</code> E <code>then</code> F <code>else</code> G</entry>
</row>
</thead>
<tbody>

<row>
<entry><code>true</code></entry>
<entry><emphasis>v</emphasis></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>true</code></entry>
<entry>silent</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry>silent</entry>
<entry>silent</entry>
</row>

<row>
<entry>silent</entry>
<entry>-</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

</tbody>
</tgroup>
</informaltable>

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>if true then 4 else 5</code> evaluates to <code>5</code>.</listitem>
<listitem><code><![CDATA[if  2 < 3 && 5 < 4  then "blue" else "green"]]></code> evaluates to "green".</listitem>
<listitem><code>if  true || "fish"  then "yes" else "no"</code> is silent.</listitem>
<listitem><code>if  false || false  then 4+true else 4+5</code> is silent.</listitem>
<listitem><code><![CDATA[if 0 < 5 then 0/5 else 5/0]]></code> evaluates to 0.</listitem>
</itemizedlist>
</para>


</section>


<section><title>Variables</title>

<para>
A <firstterm>variable</firstterm> names the value of some expression so that we can use it later.
Expression <code>x</code>, where x is some variable name, evaluates to the result <firstterm>bound</firstterm>
to the variable x.
</para>

<para>
Variables are bound using a <firstterm>declaration</firstterm>. A declaration is a statement that has no value 
of its own but instead binds one or more variables. The simplest form of declaration is <code>val</code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<ulink url="http://en.wikipedia.org/wiki/Lexical_scope">lexical scoping</ulink>.
</para>

<para>
<programlisting><![CDATA[
val x = 1 + 2 + 3 + 4 + 5
val y = x + x
]]></programlisting>

These declarations bind variable <code>x</code> to 15 and variable <code>y</code> to 30.
</para>


<para>
If the expression on the right side of a <code>val</code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions can continue. If an evaluated expression depends on that
variable, that expression is silent.

<programlisting language="orc-demo"><![CDATA[
val x = 1/0
val y = 4+5
if false then x else y
]]></programlisting>

Evaluation of the declaration and <code>val y = 4+5</code> and the expression <code>if false then x else y</code>
may continue even though <code>x</code> is not bound. The expression evaluates to 9.

</para>

<!-- 
<note>
<code>val</code> expresses a limited form of concurrency called <emphasis>declarative concurrency</emphasis> (add
biblio reference to CTMCP). A declaration may be evaluated in parallel with the declarations and expressions that
follow it; any expression which uses a variable introduced by a declaration that is still evaluating will wait for
that evaluation to complete. However, since Cor is a purely declarative language, and cannot express state changes
or the progress of time, it is impossible to distinguish a parallel evaluation from a sequential evaluation within
Cor.
</note>
 -->

</section>


<section><title>Data Structures</title>

<para>
Cor supports two basic data structures, <firstterm>tuples</firstterm> and <firstterm>lists</firstterm>.
</para>

<para>
A <firstterm>tuple expression</firstterm> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple value containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+2, 7)</code> evaluates to <code>(3,7)</code>.</listitem>
<listitem><code><![CDATA[ ("true" + "false", true || false, true && false) ]]></code> evaluates to <code>("truefalse", true, false)</code>.</listitem>
<listitem><code>(2/2, 2/1, 2/0)</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
A <firstterm>list expression</firstterm> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list value containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>[1,2+3] </code> evaluates to <code>[1,5]</code>.</listitem>
<listitem><code><![CDATA[ [true && true] ]]> </code> evaluates to <code>[true]</code>.</listitem>
<listitem><code>[]</code> evaluates trivially to <code>[]</code>, the empty list.</listitem>
<listitem><code>[5, 5 + true, 5]</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
There is also a concatenation (<firstterm>cons</firstterm>) operation on lists,
written <emphasis>h</emphasis><code>:</code><emphasis>t</emphasis>, where <emphasis>h</emphasis>
and <emphasis>t</emphasis> are expressions. Its result is a new list whose first element is the 
result of <emphasis>h</emphasis> and whose remaining elements are the list result of
<emphasis>t</emphasis>.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+3):[2+5,6]</code> evaluates to <code>[4,7,6]</code>.</listitem>
<listitem><code>2:2:5:[] </code> evaluates to <code>[2,2,5]</code>.</listitem>
<listitem>Suppose <code>t</code> is bound to [3,5]. Then <code>1:t</code> evaluates to <code>[1,3,5]</code>.</listitem>
<listitem><code>2:3</code> is silent, because <code>3</code> is not a list.</listitem>
</itemizedlist>
</para>


</section>

<section><title>Patterns</title>

<para>
We have seen how to construct data structures. But how do we examine them, and use them? We use <firstterm>patterns</firstterm>.
</para>

<para>
A pattern is a powerful way to bind variables. When writing <code>val</code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <firstterm>shape</firstterm>; a
pattern may take the shape of any structured value. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,y) = (2+3,2*3)</code> binds <code>x</code> to 5 and <code>y</code> to 6.</listitem>
<listitem>
<code>val [a,b,c] = ["one", "two", "three"]</code> binds <code>a</code> to "one", 
<code>b</code> to "two", and <code>c</code> to "three".
</listitem>
<listitem>
<code>val ((a,b),c) = ((1, true), (2, false))</code> binds <code>a</code> to 1, <code>b</code> to <code>true</code>,
and <code>c</code> to <code>(2,false)</code>.
</listitem>
</itemizedlist>
</para>

<para>
Patterns are <firstterm>linear</firstterm>; that is, a pattern may mention a variable name at most once. 
For example, <code>(x,y,x)</code> is not a valid pattern.
</para>

<para>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code>val</code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evaluated, it is silent.
</para>

<para>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code>_</code>, to do this; it matches any shape and binds no
variables.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,_,_) = (1,(2,2),[3,3,3])</code> binds <code>x</code> to 1.</listitem>
<listitem><code>val [[_,x],[_,y]] = [[1,3],[2,4]]</code> binds <code>x</code> to 3 and <code>y</code> to 4.</listitem>
</itemizedlist>
</para>

</section>

<section><title>Functions</title>

<para>
Like most other programming languages, Cor has the capability to define <firstterm>functions</firstterm>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code>def</code>, in the following way.

<programlisting><![CDATA[
def add(x,y) = x+y
]]></programlisting>

The expression on the right of the <code>=</code> is called the <firstterm>body</firstterm> of the function.
</para>

<para>
After defining the function, we can <firstterm>call</firstterm> it. A call looks just like the left side of
the declaration except that the variable names (the <firstterm>formal parameters</firstterm>) have been 
replaced by expressions (the <firstterm>actual parameters</firstterm>). 
</para>

<para>
To evaluate a call, we treat it as a sequence of <code>val</code> declarations associating the formal
parameters with the actual parameters, followed by the body of the function. 

<programlisting><![CDATA[
{- Evaluation of add(1+2,3+4) -}
val x = 1+2
val y = 3+4
x+y
]]></programlisting>
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>add(10,10*10)</code> evaluates to <code>110</code>.</listitem>
<listitem><code>add(add(5,3),5)</code> evaluates to <code>13</code>.</listitem>
</itemizedlist>
</para>

<para>
Notice that the evaluation strategy of functions allows to call to proceed even if some of the actual
parameters to be silent, so long as the values of those actual parameters are not used in the evaluation
of the body.

<programlisting><![CDATA[
def cond(b,x,y) = if b then x else y
cond(true, 3, 5/0)
]]></programlisting>

This evaluates to <code>3</code> even though <code>5/0</code> is silent, because <code>y</code> is not
needed.

</para>


<para>
A definition or a call may have zero arguments, in which case we write <code>()</code> for the arguments.

<programlisting><![CDATA[
def zero() = 0
]]></programlisting>
</para>


<section><title>Recursion</title>

<para>
Definitions can be recursive; that is, the name of a definition may be used in its own body.

<programlisting><![CDATA[
def sumto(n) = if n < 1 then 0 else n + sumto(n-1)
]]></programlisting>

Then, <code>sumto(5)</code> evaluates to 15.
</para>  

<para>
Mutual recursion is also supported.

<programlisting><![CDATA[
def even(n) = 
  if (n > 0) then odd(n-1)
  else if (n < 0) then odd(n+1)
  else true
def odd(n) = 
  if (n > 0) then even(n-1)
  else if (n < 0) then even(n+1)
  else false
]]></programlisting>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.
</para>

</section>

<section><title>Closure</title>

<para>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<firstterm>closure</firstterm>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

<programlisting><![CDATA[
def a(x) = x-3
def b(y) = y*4
val funs = (a,b)
]]></programlisting>
</para>

<para>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
supports <emphasis>higher-order</emphasis> functions.

<programlisting><![CDATA[
def onetwosum(f) = f(1) + f(2)
def triple(x) = x * 3
]]></programlisting>

Then, <code>onetwosum(triple)</code> is <code>triple(1) + triple(2)</code>, which is <code>1 * 3 + 2 * 3</code>, which evaluates to <code>9</code>.

</para>

<para>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<emphasis>lexical closures</emphasis>. This means that when a closure is created, if the body of the
function contains any variables other than the formal parameters, the bindings for those variables are
stored in the closure. Then, when the closure is called, the evaluation of the function body uses those 
stored variable bindings.  
</para>


</section>

<section><title>Lambda</title>

<para>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code>lambda</code> for this purpose. By writing a function
definition with the keyword <code>lambda</code> instead of a function name, that definition
becomes an expression which evaluates to a closure. 

<programlisting language="orc-demo"><![CDATA[
def onetwosum(f) = f(1) + f(2)

onetwosum( lambda(x) = x * 3 )
{- 
  identical to:
  def triple(x) = x * 3
  onetwosum(triple)
-}
]]></programlisting>

Then, <code>onetwosum( lambda(x) = x * 3 )</code> evaluates to 9. 

</para>

</section>


<section><title>Clauses</title>

<para>
The combination of functions and pattern matching offers a powerful capability: 
<firstterm>clausal</firstterm> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</para>


<para>
Here's an example.

<programlisting><![CDATA[
def sum([]) = 0
def sum(h:t) = h + sum(t)
]]></programlisting>

<code>sum(L)</code> publishes the sum of the numbers in the list <code>L</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</para>

<para>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</para>

<para>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</para>

<para>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

<programlisting><![CDATA[
{- Fibonacci numbers -}
def fib(0) = 1
def fib(1) = 1
def fib(n) = if (n < 0) then 0 else fib(n-1) + fib(n-2)
]]></programlisting>

<programlisting><![CDATA[
{- Take up to the first n elements from a list -}
def take(0,_) = []
def take(_,[]) = []
def take(n,h:t) = h:(take(n-1,t))
]]></programlisting>
</para>

<para>
Mutual recursion and clausal definitions are allowed to occur together.
For example, this function takes a list and evaluates to a new list with every other element repeated:

<programlisting><![CDATA[
def stutter([]) = []
def stutter(h:t) = h:h:mutter(t)
def mutter([]) = []
def mutter(h:t) = h:stutter(t)
]]></programlisting>

<code>stutter([1,2,3])</code> evaluates to <code>[1,1,2,3,3]</code>.
</para>

<para>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

<programlisting><![CDATA[
def even(0) = true
def odd(0) = false
def even(n) = odd(if n > 0 then n-1 else n+1)
def odd(n) = even(if n > 0 then n-1 else n+1)
]]></programlisting>

</para>

</section>

</section>

<section><title>Comments</title>
<para>
Cor has two kinds of comments.   

</para>

<para>
A line which begins with two dashes (<code>--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<programlisting><![CDATA[
-- This is a single line comment.
	 -- This is also a single line comment.
]]></programlisting>
</para>

<para>
Multiline comments are enclosed by matching braces of the form <code><![CDATA[{- -}]]></code>. 
Multiline comments may be nested. They may appear anywhere, even in the middle of an expression.

<programlisting><![CDATA[
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

{- They may appear anywhere, -} 
1 + {- even in the middle of an expression. -} 2 + 3
]]></programlisting>

</para>

</section>

</section>



<section><title>Orc: Orchestrating services</title>


<para>
In this section we present the full Orc language. As in Cor, an Orc program is an 
<firstterm>expression</firstterm>; Orc expressions are built up recursively from smaller 
expressions. All Cor expressions are also Orc expressions.
</para>

<para>
Orc expressions are <firstterm>executed</firstterm>, rather than evaluated; an execution 
communicates with external services and <firstterm>publishes</firstterm> some number of 
values (possibly zero). If an execution publishes no value, it is called <firstterm>silent</firstterm>.
However, unlike silent expressions in Cor, a silent expression in Orc might perform some meaningful 
computation or communication; silence does not necessarily indicate an error.
</para>

<para>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <firstterm>combinators</firstterm>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</para>

<para>
The following figure summarizes the new syntax that Orc introduces, as an extension
of the syntax of Cor.
</para>

<para>
<informaltable id="orc-ebnf-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="4*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>URL</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry>C</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>signal</code></entry>

<entry></entry>
<entry><emphasis>signal value</emphasis></entry>
</row>


<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>|</code> E</entry>

<entry></entry>
<entry><emphasis>bar combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code><![CDATA[>]]></code>P<code><![CDATA[>]]></code> E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code><![CDATA[<]]></code>P<code><![CDATA[<]]></code> E</entry>

<entry></entry>
<entry><emphasis>asymmetric combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>






</tbody>
</tgroup>
</informaltable>
</para>

<section><title>Communicating with external services</title>

<para>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. Clearly, the full 
Orc language must transcend these limitations, because the orchestration of external services 
is critical to Orc's purpose.
</para>

<para>
We introduce <firstterm>sites</firstterm>: Orc's interface to external services.
Sites are called using the same syntax as a function call, but with a slightly different 
meaning. Sites are values, introduced and bound to variables by a special declaration.
</para>

<section><title>Calling a site</title>

<para>
Suppose that the variable <code>Google</code> is bound to a site which sends a 
string to the Google search engine and returns the URL of the top result. A call to
<code>Google</code> looks just like a function call.

<programlisting><![CDATA[
{- Get the top search result for "computation orchestration" -}
Google("computation orchestration")
]]></programlisting>

When the Google search engine determines the top result for this search, it responds with
some URL. The site call then publishes that response. Note that the service might
never respond: Google's servers might be down, the network might be down, or the search 
might yield no result URL. If the service fails to respond, the site call remains
silent.
</para>


<para>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</para>


<para>
A site is sometimes called purely for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <firstterm>signal</firstterm>: a special value which carries no 
information (analogous to the unit value <code>()</code> in ML). The signal value
can be written as <code>signal</code> within Orc programs.


<programlisting language="orc-demo"><![CDATA[
-- Use the 'print' site to print a string to an output console
-- The return value of this site call is a signal
println("Hello, World!")
]]></programlisting>
</para>


</section>


<section><title>Declaring sites</title>

<para>
A <code>site</code> declaration makes some service available as a site and
binds it to a variable. The service might be an object in the host language, 
an external service on the web accessed through some protocol like SOAP or REST, 
or even a primitive operation like addition. We will discuss the particulars of 
these declarations, and the guidelines for accessing web-based services or creating 
one's own services, in <link linkend="chapter.services">Chapter 3</link>. Also,
many useful sites are already defined in the Orc standard library, documented
in <link linkend="appendix.library">Appendix B</link>. For now, we present a simple 
type of site declaration: using an object in the host language as a site.  
</para>

<para>
The following example instantiates a Java object to be used as a site in an Orc program, specifically
a Java object which provides an asynchronous buffer service. The declaration uses a
fully qualified Java class name to find and load a class, and creates an instance of that
class to provide the service. 

<programlisting><![CDATA[
{-  Define the Buffer site  -}
site Buffer = orc.lib.state.Buffer
]]></programlisting>  
</para>

<para>

</para>
  
</section>

</section>


<section><title>The concurrency combinators of Orc</title>

<para>
Orc has three concurrency <firstterm>combinators</firstterm>: ways of connecting expressions together so that they can
be executed concurrently.
</para>

<section><title>The parallel combinator</title>

<para>
Orc's simplest combinator is <code>|</code>, the parallel combinator. Orc executes
the expression F <code>|</code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
the whole execution does so as well.
</para>   


<para>
<programlisting><![CDATA[
-- Publish 1, 2, and 3 in parallel  
1 | 2 | 1+2
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
{- 
  Access two search sites, Google and Yahoo, in parallel.

  Publish any results they return.
  
  Since each call may publish a value, the expression
  may publish up to two values.
-}  
Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
</para>  

</section>

<section><title>The sequential combinator</title>

<para>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F <code><![CDATA[>x>]]></code> G, 
combines the expression F, which publishes some values, with another expression G 
which will use those values as they are published, using <code>x</code> to transmit
the values from from F to G.
</para>

<para>
The execution of F <code><![CDATA[>x>]]></code> G executes F. Whenever F publishes a value, 
a new copy of G is executed in parallel with F (and with any previous copies of G); in that
copy of G, <code>x</code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</para>

<para>
<programlisting><![CDATA[
-- Publish 1 and 2 in parallel  
(0 | 1) >n> n+1
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
-- Publish 3 and 4 in parallel  
2 >n> (n+1 | n+2)
]]></programlisting>
</para>  


<para>
<programlisting><![CDATA[
-- Publish 1, 2, 3 and 4 in parallel  
(0 | 2) >n> (n+1 | n+2)
]]></programlisting>
</para>  


<para>
<programlisting><![CDATA[
-- Prepend the string "Result: " to each published search result
-- The cat site concatenates any number of arguments into one string  
(Google("cupcake") | Yahoo("cupcake")) >s> cat("Result: ", s)
]]></programlisting>
</para>  




<para>
The sequential combinator may be written as F <code><![CDATA[>]]></code>P<code><![CDATA[>]]></code> G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new copy of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new copy of G is executed.
</para>

<para>
<programlisting><![CDATA[
-- Publish the elements of a triple in unspecified order
-- Publishes 3, 6, and 9
(3,6,9)  >(x,y,z)>  ( x | y | z )
]]></programlisting>
</para>


<para>
<programlisting><![CDATA[
-- Publish x from any tuple of the form (1,x)
-- Publishes 4 and 6  
( (1,4) | (2,5) | (1,6) )  >(1,x)> x
]]></programlisting>
</para>
 


<para>
We may also omit the variable entirely, writing <code><![CDATA[>>]]></code>. This
is equivalent to using a wildcard pattern: <code><![CDATA[>_>]]></code>
</para>

<para>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code><![CDATA[>>]]></code> together with the special expression 
<code>stop</code>, which is always silent.  
</para>

<para>
<programlisting><![CDATA[
{- 
  Print two strings to the console,
  but don't publish the return values of the print calls.
-}
( print("goodbye") | print("world") ) >> stop
]]></programlisting>
</para>


</section>


<section><title>The asymmetric combinator</title>

<para>
The asymmetric combinator, written F <code><![CDATA[<x<]]></code> G, allows us to block 
a computation waiting for a result, or terminate a computation.
</para> 

<para>
As with the sequential combinator, we consider the simple, one-variable case first. 
The execution of F <code><![CDATA[<x<]]></code> G starts executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then G is immediately <firstterm>terminated</firstterm>.
</para>

<para>
A terminated expression cannot perform any more execution; if it is in the process of communicating
with an external service, that communication is allowed to complete but the response is ignored.
</para>

<para>
<programlisting><![CDATA[
-- Publish either 5 or 6, but not both
x+2 <x< 3 | 4
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
-- Query Google and Yahoo for a search result
-- Print out the result that arrives first; ignore the other result
print(result) <result< Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
</para>  

<para>
If an execution in F encounters the variable <code>x</code>, but G has not yet published
a value, that execution <firstterm>blocks</firstterm> until G publishes a value and <code>x</code>
becomes bound.
</para>

<para>
The asymmetric combinator may include a full pattern P instead of just a variable name. Any
value published by G is matched against the pattern P. If this match is successful, then G
terminates and all of the bindings of the pattern P are made in F. Otherwise, the published 
value is simply ignored and G continues to execute.
</para>

<para>
<programlisting><![CDATA[
-- Publish either 9 or 25, but not 16.
x*x <(x,0)< (3,0) | (4,1) | (5,0)
]]></programlisting>
</para>  

<para>
Note that even if <code>(4,1)</code> is published before <code>(3,0)</code> or <code>(5,0)</code>, 
it is ignored. The right side continues to execute and will publish one of <code>(3,0)</code> or 
<code>(5,0)</code>.
</para> 

<para>
The pattern is optional; without a variable the combinator is written <code><![CDATA[<<]]></code>. It
is equivalent to using a wildcard: <code><![CDATA[<_<]]></code>
</para>

<para>
<programlisting><![CDATA[
-- Print only one of "true" or "false" to the console.
-- Publish no values.
stop << print("true") | print("false")
]]></programlisting>
</para>


</section>



</section>



<section><title>Changes to functional expressions</title>

<para>
Now that we have introduced concurrency and state, some of the assumptions we
made when describing the behavior of functional expressions in Cor no longer hold.
</para>

<section><title><code>val</code></title>

<para>
It turns out that <code>val x = g</code> followed by expression <code>f</code> is 
actually just a prefix form of the asymmetric combinator <code><![CDATA[f <x< g]]></code>.
Thus, <code>val</code> shares all of the behavior of the asymmetric combinator,
which we have already described. This is also true when a pattern is used instead
of a variable name.
</para>

</section>


<section><title>Nested expressions</title>

<para>
Orc expressions with concurrency combinators may occur as subexpressions of Cor expressions, 
such as arithmetic operations or function call arguments. Such expressions may publish many 
values and perform many communications, as in <code>(1 | 2) + 3</code>. What do these
expressions mean in a purely functional context?
</para>

<para>
The specific syntactic contexts we are interested in are as follows (E is any Orc expression):

<informaltable id="value-context-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="40%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" align="left"/>
<colspec colnum="2" colwidth="1*" align="right"/>
<tbody>

<row>
<entry>E <emphasis>op</emphasis> E</entry>
<entry><emphasis>operators</emphasis></entry>
</row>

<row>
<entry><code>if</code> E <code>then</code> ...</entry>
<entry><emphasis>conditionals</emphasis></entry>
</row>

<row>
<entry>X<code>(</code> ... <code>,</code> E <code>,</code> ... <code>)</code></entry>
<entry><emphasis>calls</emphasis></entry>
</row>

<row>
<entry><code>(</code> ... <code>,</code> E <code>,</code> ... <code>)</code></entry>
<entry><emphasis>tuples</emphasis></entry>
</row>

<row>
<entry><code>[</code> ... <code>,</code> E <code>,</code> ... <code>]</code></entry>
<entry><emphasis>lists</emphasis></entry>
</row>

</tbody>
</tgroup>
</informaltable>
</para>

<para>
Roughly speaking, these are contexts where only one value is expected.
</para>

<para>
Whenever an Orc expression F appears in such a Cor context E[], it is 
treated as if it was on the right side of an asymmetric combinator,
using a fresh variable name to fill in the hole. Thus, E[F] (where F
is an Orc expression and E is a Cor context) translates to 
E[<code>x</code>] <code><![CDATA[<x<]]></code> F.
</para>

<para>
In other words, the expression executes until it publishes its first
value, and then it is terminated. That value is used in the context
as if it were the result of evaluation a Cor expression.
</para>

</section>


<section><title>Functions</title>

<para>
In the context of Orc, function calls are not strict. When a function
is called, the function body and the arguments are actually evaluated
in parallel. Whenever an execution in the function body reaches one of 
the argument variables, it blocks until the corresponding argument 
expression publishes a value.
</para>

</section>



</section>


<section><title>Time</title>


</section>


</section>



<section><title>Advanced Features of Orc</title>

<para>
In this section we introduce some advanced features of Orc. 
</para>

<para>
The following figure details the new syntactic constructs discussed
in this section.
</para>

<para>
<informaltable id="advanced-ebnf-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="6*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X G+</entry>

<entry></entry>
<entry><emphasis>generalized call</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>after combinator</emphasis></entry>
</row>

<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>curried arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>


<row>
<entry>P</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>!</code>P</entry>

<entry></entry>
<entry><emphasis>bang pattern</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>call pattern</emphasis></entry>
</row>

<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>


</tbody>
</tgroup>
</informaltable>
</para>


<section><title>Special call forms</title>

<section><title>The <code>.</code> notation</title>

<para>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code>obj.m()</code> calls the method
<code>m</code> of the object <code>obj</code>. 
</para>

<para>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code>x.msg</code>, for any identifiers <code>x</code> and <code>msg</code>. This attempts
to treat the value bound to <code>x</code> as a site, and call it with a special 
<firstterm>message</firstterm> value. If the value cannot be interpreted as a site, no call is made. 
If that site understands the message <code>msg</code> (for example, if <code>x</code> is 
bound to a Java object with a field called <code>msg</code>), the site interprets the message 
and responds with some appropriate value. If the value is a site, but it does not 
understand the message sent to it, it does not respond, and no publication occurs. 
</para>

<para>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code>c</code> might understand the messages
<code>get</code> and <code>put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code>c.get()</code>, or <code>c.put(6)</code>.
</para>

<para>
Such calls actually occur in two steps: first <code>c.put</code> sends the message
<code>put</code> to the value <code>c</code>; this publishes a site whose only purpose
is to put values to that channel. Then, that 'put site' is called on the argument
<code>6</code>, sending 6 on that channel. Readers familiar with functional programming
will recognize this technique as <emphasis>currying</emphasis>.
</para>
</section>


<section><title>Currying</title>

<para>
It is sometimes useful to <emphasis>stage</emphasis> the arguments to a function; that is,
rather than writing a function on two arguments, one instead writes a function on one
argument which returns a function taking the second argument and performing the remainder
of the evaluation. 
</para>

<para>
This technique is known as <emphasis>currying</emphasis> and it is common in functional
programming languages. It is obviously supported in Orc since it is possible to define
closures. However, there is additional support for making curried function calls, and
for defining functions directly in a curried way.
</para>

<para>
Suppose we want to define a curried addition function on two arguments, and later 
apply that function to the arguments 3 and 4. The verbose way to write such 
a program is as follows:

<programlisting><![CDATA[
def add(a) = ( lambda(b) = a+b )  
val f = add(3)
f(4)
]]></programlisting>

</para>

<para>
When defining a curried function, we have abstracted it in two steps, and when
applying it we have written two separate calls. However, Orc has a special syntax
for curried definitions and curried applications that will simplify both of
these steps.

<programlisting><![CDATA[
def add(a)(b) = a+b
add(3)(4)
]]></programlisting>

Definitions may have multiple argument sequences; they are enclosed in parentheses
and concatenated. Curried function calls chain together multiple applications in
a similar way.
</para>

</section>


</section>

<section><title>Special patterns</title>

<section><title>Bang pattern</title>

<para>
A bang pattern, written <code>!p</code>, will publish the value that matches the pattern 
<code>p</code> if the match is successful.

<programlisting language="orc-demo"><![CDATA[
(1,2,3)  >(x,!y,!z)> stop
]]></programlisting>

This publishes <code>2</code> and <code>3</code>. 
</para>

<para>
Note that a bang pattern will not publish if the overall match fails, even if its particular match succeeds:

<programlisting language="orc-demo"><![CDATA[
( (1,2,3) | (4,5,6) )  >(1,!x,y)>  stop
]]></programlisting>

This publishes only <code>2</code>. Even though the pattern <code>x</code> matches the value <code>5</code>, 
the overall pattern <code>(1,!x,y)</code> does not match the value <code>(4,5,6)</code>, so <code>5</code> 
is not published.
</para>

</section>

<section><title>As pattern</title>

<para>
In taking apart a value with a pattern, it is often useful to capture intermediate results.

<programlisting><![CDATA[
val (a,b) = ((1,2),(3,4))
val (ax,ay) = a
val (bx,by) = b
]]></programlisting>

We can use the <code>as</code> keyword to simplify this process, giving a name to an entire
subpattern. Here is an equivalent version of the above code.

<programlisting><![CDATA[
val ((ax,ay) as a, (bx,by) as b) = ((1,2),(3,4))
]]></programlisting>
</para>

</section>

<section><title>Site patterns</title>

<para>
A site pattern, written <code>M(p,...,p)</code>, matches any value which was published by a call to the
site <code>M</code> with arguments that match the tuple <code>(p,...,p)</code>. 
</para>

<para>
Site patterns provide a generalized version of datatype matching, as seen in the <code>case .. of</code>
 or <code>match .. with </code> constructs provided by Haskell and ML.
</para> 

</section>


<section><title>Patterns as views</title>

<para>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <firstterm>view</firstterm> of that data.
</para>

<para>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</para>

<para>
The concept of views and view patterns is not new in programming languages; it has been demonstrated
in other languages, most notably <ulink url="http://www.scala-lang.org/">Scala</ulink>. In fact, the 
underlying implementation strategy for using sites as view patterns is very similar to the use of
extractor objects and the <code>unapply</code> method in Scala.
</para>

</section>

</section>

<section><title>Special declarations</title>

<section><title>Class declarations</title>

<para>
When Orc is run on top of an object-oriented programming language, classes
from that language may be used as sites in Orc itself, via the <code>class</code>
declaration. 
</para>

<para>
<programlisting><![CDATA[
{- Use the String class from Java's standard library as a site -}
class String = java.lang.String
val s = String("foo")
s.concat("bar")
]]></programlisting>
</para>

<para>
This program binds the variable <code>String</code> to the constructor of Java's
String class. When it is called, it constructs a new instance of String, passing
the given arguments to the constructor.
</para>

<para>
This instance of String is a Java object; its methods are called and its fields
are accessed using the <code>.</code> notation, just as one would expect in Java.
</para>
</section>


<section><title>Included declarations</title>

<para>
It is often convenient to group related declarations into units that can be
shared between programs. The <code>include</code> declaration offers a simple
way to do this. It names a source file containing a sequence of Orc declarations;
those declarations are incorporated into the program as if they had textually
replaced the include declaration.
</para>

<para>
<programlisting><![CDATA[
{- Contents of fold.inc -}
def foldl(f,[],s) = s
def foldl(f,h:t,s) = foldl(f,t,f(h,s))

def foldr(f,l,s) = foldl(f,rev(l),s)
]]></programlisting>
</para>

<para>
<programlisting><![CDATA[
{- This is the same as inserting the contents of fold.inc here -}
include "fold.inc"

def sum(L) = foldl(lambda(a,b) = a+b, L, 0)

sum([1,2,3])
]]></programlisting>
</para>

<para>
Note that these declarations still obey the rules of lexical scope. Also,
Orc does not detect shared declarations; if the same file is included twice,
its declarations occur twice.
</para>

</section>


</section>

<section><title>The after combinator</title>

<para>
Orc has a fourth concurrency combinator: the <firstterm>after</firstterm> combinator,
written <code>f ; g</code>. The after combinator executes its left side, publishing 
each of its publications as they occur. When the left side is done executing, then 
the right side executes.
</para>

<para>
We determine when an expression is done executing using the following rules.

<itemizedlist>
<listitem>Any Cor expression is done when it is fully evaluated.</listitem>
<listitem>A site call is done when it has published a value or it is known 
that the request will never receive a response.</listitem>
<listitem>F <code>|</code> G is done when its subexpressions F and G are done.</listitem>
<listitem>F <code><![CDATA[>x>]]></code> G when F is done and all created copies of G are done.</listitem>
<listitem>F <code><![CDATA[<x<]]></code> G is done when F is done, and G is either 
done or has been terminated after publishing a value.</listitem>
<listitem>F <code>;</code> G is done when its subexpressions F and G are done.</listitem>
<listitem><code>stop</code> is done.</listitem>
</itemizedlist>

</para>

<para>
The after combinator is intended to capture as closely as possible the notion of sequential
processing, as denoted by <code>;</code> in other languages. It was not present in the
original formulation of the Orc concurrency calculus; it has been added to support computation
and iteration over strictly finite data. Sequential programs conflate the concept of
producing a value with the concept of completion. Orc separates these two concepts; variable
binding combinators like <code><![CDATA[>x>]]></code> and <code><![CDATA[<x<]]></code> handle
values, whereas <code>;</code> detects the completion of an execution.
</para>

</section>


</section>



</chapter>

 
<chapter><title>Programming Methodology</title>

Under construction.

<!-- 
- forkjoin, delay, parallel or
- dining philosophers
- shortest path
- meeting scheduler
 -->

</chapter>


<chapter id="chapter.services"><title>Accessing and Creating External Services</title>

Under construction.

</chapter>



<appendix><title>Complete Syntax of Orc</title>

<para>

<informaltable id="full-ebnf-grammar" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="4*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>operator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X G+</entry>

<entry></entry>
<entry><emphasis>call</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>|</code> E</entry>

<entry></entry>
<entry><emphasis>bar combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code><![CDATA[>]]></code>P<code><![CDATA[>]]></code> E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code><![CDATA[<]]></code>P<code><![CDATA[<]]></code> E</entry>

<entry></entry>
<entry><emphasis>asymmetric combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>after combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>


<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>



<row>
<entry>C</entry>
<entry>::=</entry>
<entry><code>true</code> | <code>false</code> | <emphasis>integer</emphasis> | <emphasis>string</emphasis> | <code>signal</code></entry>
<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>identifier</emphasis></entry>

<entry><emphasis>Variable</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>URL</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>




<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>!</code>P</entry>

<entry></entry>
<entry><emphasis>bang pattern</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>call pattern</emphasis></entry>
</row>


</tbody>
</tgroup>
</informaltable>
</para>


</appendix>


<appendix id="appendix.library"><title>Standard Library</title>
Under construction.
</appendix>

 
<appendix><title>FAQ</title>

Under construction.

<!-- 
<para>

val x = def E() = 5  E

E is different from E() !

</para>
 -->
</appendix>

 
<!-- 
<chapter><title>Execution Environment</title>
<para></para>
</chapter>

<chapter><title>Debugging</title>
<para></para>
</chapter>

<chapter><title>The Implementation</title>
<para></para>

To answer: why don't nested expressions decode into >x> instead of <x<?

</chapter>
 -->
 
</book>