<?xml version="1.0" encoding="UTF-8"?>

<!--
<!DOCTYPE chapter PUBLIC " -//OASIS//DTD DocBook XML V5.0//EN" "../docbook-xml/dtd/docbook.dtd" >
-->

<book
	id="root"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Orc User Guide v<xi:include href="../VERSION" parse="text"/></title>
 
<preface><title>Introduction</title>
	
<para>
Orc is a programming language designed to make distributed and
concurrent programs simple and intuitive to write. Orc expresses
orchestration, a type of structured concurrency. It emphasizes the
flow of control and gives a global view of a concurrent system. Orc
is well-suited for task orchestration, a form of
concurrent programming with applications in workflow, business process
management, and web service orchestration. Orc provides constructs to
orchestrate the concurrent invocation of services while managing
time-outs, priorities, and failures of services or communication.  To
learn more about Orc and run your own Orc programs, visit the website:
<link xlink:href="http://orc.csres.utexas.edu/"><code>http://orc.csres.utexas.edu/</code></link>.
</para>

<para>
Unless otherwise noted, all material in this document pertains to the
Orc language implementation version
<xi:include href="../VERSION" parse="text"/>.
</para>


</preface>

 
<chapter id="chapter.language"><title>The Orc Programming Language</title>

<section><title>Introduction</title>


<para>
This chapter describes the Orc programming language in three steps. In Section 1.2, we
discuss a small subset of Orc called Cor. Cor is a pure functional language,
which has no features for concurrency, has no state, and does not communicate 
with external services. Cor introduces us to the parts of Orc that are most familiar 
from existing programming languages, such as arithmetic operations, variables,
conditionals, and functions.
</para>

<para>
In Section 1.3, we consider Orc itself, which in addition to Cor, comprises 
external services and combinators for concurrent orchestration of those services. 
We show how Orc interacts with these external services, how the combinators can be
used to build up complex orchestrations from simple base expressions, and how the 
functional constructs of Cor take on new, subtler behaviors in the concurrent 
context of Orc.
</para>

<para>
In Section 1.4, we discuss some additional features of Orc that extend 
the basic syntax. These are useful for creating large-scale Orc programs, but 
they are not essential to the understanding of the language.
</para>
 
</section> 


<section id="cor"><title>Cor: A Functional Subset</title>

 
<para>
In this section we introduce Cor, a pure functional subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</para>

<para>
A Cor program is an <firstterm id="terms.expression">expression</firstterm>. Cor expressions are built
up recursively from smaller expressions. Cor <firstterm>evaluates</firstterm> an expression
to reduce it to some simple <firstterm>value</firstterm> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <firstterm>
result</firstterm> of the expression.
</para>

<para>
In the following subsections we introduce the concepts of Cor. First, we talk about
simple <firstterm id="terms.constant">constants</firstterm>, such as numbers and truth values, and the operations that we can perform
on those values. Then we introduce conditionals (<code>if then else</code>). Then we 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we talk about constructing data structures, and examining those structures
using patterns. Lastly, we introduce functions.
</para> 

<para>
Table 1.1 describes the syntax of Cor. Each part of the syntax is explained 
in a subsequent section.
</para>

<para>
<table id="cor-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Syntax of the Functional Subset of Orc (Cor)</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="4*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>



<row>
<entry></entry>
<entry>|</entry>

<entry><code>{. </code> X<code> = </code> E <code>,</code> ... <code>,</code> X<code> = </code> E <code> .}</code></entry>

<entry></entry>
<entry><emphasis>record</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>function call</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>operator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda (</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>closure</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>

<!--
<row>
<entry></entry>
<entry>|</entry>
	
<entry>D <code>within</code> E</entry>
	
<entry></entry>
<entry><emphasis>goal expression w/declarations</emphasis></entry>
</row>
	-->
	
<row>
<entry>C</entry>
<entry>::=</entry>

<entry><emphasis>Boolean</emphasis> | <emphasis>Number</emphasis> | <emphasis>String</emphasis></entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>Identifier</emphasis></entry>

<entry><emphasis>Identifier</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>


<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>

</tbody>
</tgroup>
</table>
</para>

<para>
Where relevant, syntactic constructs are ordered by precedence, from highest to lowest. For example, among expressions, calls have higher precedence than
operators, which in turn have higher precedence than conditionals.
</para>


<section id="cor.constants"><title>Constants</title>
<para>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</para>

<para>

Cor has three types of constants, and thus for the moment three types of values:

<itemizedlist>

<listitem>
Boolean: <code>true</code> and <code>false</code>
</listitem>

<listitem>
Number: <code> 5, -1, 2.71828, ... </code>
</listitem> 

<listitem>
String: <code>"orc"</code>, <code>"ceci n'est pas une |"</code>
</listitem>

</itemizedlist>
</para>

</section>

<section id="language.base.operators"><title>Operators</title>
<para>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>1+2</code> evaluates to <code>3</code>.</listitem>
<listitem><code>(98+2)*17</code> evaluates to <code>1700</code>.</listitem>
<listitem><code>4 = 20 / 5</code> evaluates to <code>true</code>.</listitem>
<listitem><code>3-5 >= 5-3 </code> evaluates to <code>false</code>.</listitem>
<listitem><code><![CDATA[true && (false || true)]]></code> evaluates to <code>true</code>.</listitem>
<listitem><code>"leap" + "frog"</code> evaluates to <code>"leapfrog"</code>.</listitem>
</itemizedlist>
</para>

<para>
Here is the full set of operators that Cor supports:

<table id="ops-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="95%" ?>
<?dbfo keep-together="always" ?>
<title>Operators of Cor</title>
<tgroup cols="8" >
<colspec colnum="1" colname="arith-names" colwidth="1*" align="left"/>
<colspec colnum="2" colname="arith-ops" colwidth="4*" align="left"/>
<colspec colnum="3" colname="comp-names" colwidth="1*" align="left"/>
<colspec colnum="4" colname="comp-ops" colwidth="6*" align="left"/>
<colspec colnum="5" colname="logic-names" colwidth="1*" align="left"/>
<colspec colnum="6" colname="logic-ops" colwidth="3*" align="left"/>
<colspec colnum="7" colname="string-names" colwidth="1*" align="left"/>
<colspec colnum="8" colname="string-ops" colwidth="4*" align="left"/>

<thead>
<row>
<entry namest="arith-names" nameend="arith-ops" align="left">Arithmetic</entry>
<entry namest="comp-names" nameend="comp-ops" align="left">Comparison</entry>
<entry namest="logic-names" nameend="logic-ops" align="left">Logical</entry>
<entry namest="string-names" nameend="string-ops" align="left">String</entry>
</row>
</thead>
<tbody>

<row>
<entry><code><![CDATA[+]]></code></entry>
<entry>addition</entry>

<entry><code><![CDATA[=]]></code></entry>
<entry>equality</entry>

<entry><code><![CDATA[&&]]></code></entry>
<entry>logical and</entry>

<entry><code><![CDATA[+]]></code></entry>
<entry>concatenation</entry>

</row>

<row>
<entry><code><![CDATA[-]]></code></entry>
<entry>subtraction</entry>

<entry><code><![CDATA[/=]]></code></entry>
<entry>inequality</entry>

<entry><code><![CDATA[||]]></code></entry>
<entry>logical or</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>


<row>
<entry><code><![CDATA[*]]></code></entry>
<entry>multiplication</entry>

<entry><code><![CDATA[<]]></code></entry>
<entry>less than</entry>

<entry><code><![CDATA[~]]></code></entry>
<entry>logical not</entry>

<entry namest="string-names" nameend="string-ops"/>

</row>

<row>
<entry><code><![CDATA[/]]></code></entry>
<entry>division</entry>

<entry><code><![CDATA[>]]></code></entry>
<entry>greater than</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry><code><![CDATA[%]]></code></entry>
<entry>modulus</entry>

<entry><code><![CDATA[<=]]></code></entry>
<entry>less than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

<row>
<entry><code><![CDATA[**]]></code></entry>
<entry>exponent</entry>

<entry><code><![CDATA[>=]]></code></entry>
<entry>greater than or equal</entry>

<entry namest="logic-names" nameend="logic-ops"/>
<entry namest="string-names" nameend="string-ops"/>
</row>

</tbody>
</tgroup>
</table>

</para>

<para>
There is also a unary negation operator, written <code>-</code>, for example <code>-(2 ** 5)</code>.
</para>

<para>
The <code>=</code> operator can compare values of any type. Values of different type are always unequal; for example,
<code>10 = true</code> evaluates to <code>false</code>.
</para>

<para>
Numbers with no decimal part, such as <code>3</code>, are treated as integers. Arithmetic operators with two integer arguments will perform
an integer operation and return an integer result; for example, <code>5 / 2</code> performs integer division and evaluates to <code>2</code>.
However, if either argument to an operator has a decimal part (even if it is trivial, as in <code>3.0</code>), the other argument will
be promoted, and a decimal operation will be peformed. For example, <code>5 / 2.0</code> and <code>5.0 / 2</code> both perform decimal
division and evaluate to <code>2.5</code>.
</para>

<section><title>Silent Expression</title>
<para>
There are situations where an expression evaluation is stuck, because it is attempting to perform 
some impossible operation and cannot compute a value. In that case, the expression is <firstterm>silent</firstterm>. 
An expression is also silent if it depends on the result of a silent subexpression. For example, the following
expressions are silent: <code>10/0</code>, <code>6 + false</code>, <code>3 + 1/0</code>, <code>4 + true = 5</code>.
</para>

<para>
Cor is a dynamically typed language. A Cor implementation does not statically
check the type correctness of an expression; instead, an expression with a type
error is simply silent when it is evaluated.
</para>

<warning>
Silent expressions can produce side effects.  For example, on encountering a
type error, Orc will print an error message to the console.  However the
expression containing the type error will not publish a value, and in this
respect it is silent.
</warning>

</section>

</section>


<section id="cor.conditionals"><title>Conditionals</title>

<para>
A conditional expression in Cor is of the form 
<code>if</code> E <code>then</code> F <code>else</code> G. 
Its meaning is similar to that in other languages: the value
of the expression is the value of F if and only if E evaluates to true, 
or the value of G if and only if E evaluates to false. Note that G is not
evaluated at all if E evaluates to true, and similarly F is not evaluated
at all if E evaluates to false. Thus, for example, evaluation of 
<code>if true then 2+3 else 1/0</code> does not evaluate <code>1/0</code>;
it only evaluates <code>2+3</code>.
</para>

<para>
Unlike other languages, expressions in Cor may be silent. If E is
silent, then the entire expression is silent. And if E evaluates to true 
but F is silent (or if E evaluates to false and G is silent) then the 
expression is silent.
</para>

<para>
Note that conditionals have lower precedence than any of the operators.
For example, <code>if false then 1 else 2 + 3</code> is equivalent to
<code>if false then 1 else (2 + 3)</code>, not <code>(if false then 1 else 2) + 3</code>.
</para>

<para>
The behavior of conditionals is summarized by the following table
(<emphasis>v</emphasis> denotes a value).

<informaltable id="cond-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="60%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="4" >
<colspec colnum="1" colname="E" colwidth="1*" align="center"/>
<colspec colnum="2" colname="F" colwidth="1*" align="center"/>
<colspec colnum="3" colname="G" colwidth="1*" align="center"/>
<colspec colnum="4" colname="result" colwidth="3*" align="center"/>
<thead>
<row>
<entry>E</entry>
<entry>F</entry>
<entry>G</entry>
<entry><code>if</code> E <code>then</code> F <code>else</code> G</entry>
</row>
</thead>
<tbody>

<row>
<entry><code>true</code></entry>
<entry><emphasis>v</emphasis></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>true</code></entry>
<entry>silent</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry><emphasis>v</emphasis></entry>
<entry><emphasis>v</emphasis></entry>
</row>

<row>
<entry><code>false</code></entry>
<entry>-</entry>
<entry>silent</entry>
<entry>silent</entry>
</row>

<row>
<entry>silent</entry>
<entry>-</entry>
<entry>-</entry>
<entry>silent</entry>
</row>

</tbody>
</tgroup>
</informaltable>

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>if true then 4 else 5</code> evaluates to <code>4</code>.</listitem>
<listitem><code><![CDATA[if  2 < 3 && 5 < 4  then "blue" else "green"]]></code> evaluates to "green".</listitem>
<listitem><code>if  true || "fish"  then "yes" else "no"</code> is silent.</listitem>
<listitem><code>if  false || false  then 4+5 else 4+true</code> is silent.</listitem>
<listitem><code><![CDATA[if 0 < 5 then 0/5 else 5/0]]></code> evaluates to 0.</listitem>
</itemizedlist>
</para>


</section>


<section id="cor.variables"><title>Variables</title>

<para>
A <firstterm>variable</firstterm> can be bound to a value. A <firstterm>declaration</firstterm> binds one or
more variables to values. The simplest form of declaration is <code>val</code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<link xlink:href="http://en.wikipedia.org/wiki/Lexical_scope">lexical scoping</link>.
</para>

<para>
<programlisting><![CDATA[
val x = 1 + 2
val y = x + x
]]></programlisting>

These declarations bind variable <code>x</code> to 3 and variable <code>y</code> to 6.
</para>


<para>
If the expression on the right side of a <code>val</code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions continues. If an evaluated expression depends on that
variable, that expression is silent.

<programlisting language="orc-demo"><![CDATA[
val x = 1/0
val y = 4+5
if false then x else y]]></programlisting>

Evaluation of the declaration <code>val y = 4+5</code> and the expression <code>if false then x else y</code>
may continue even though <code>x</code> is not bound. The expression evaluates to 9.

</para>

<!-- 
<note>
<code>val</code> expresses a limited form of concurrency called <emphasis>declarative concurrency</emphasis> (add
biblio reference to CTMCP). A declaration may be evaluated in parallel with the declarations and expressions that
follow it; any expression which uses a variable introduced by a declaration that is still evaluating will wait for
that evaluation to complete. However, since Cor is a purely declarative language, and cannot express state changes
or the progress of time, it is impossible to distinguish a parallel evaluation from a sequential evaluation within
Cor.
</note>
 -->

</section>


<section id="cor.data"><title>Data Structures</title>

<para>
Cor supports three basic data structures, <firstterm>tuples</firstterm>, <firstterm>lists</firstterm>, and <firstterm>records</firstterm>.
</para>

<section><title>Tuples</title>
<para>
A <firstterm>tuple expression</firstterm> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+2, 7)</code> evaluates to <code>(3,7)</code>.</listitem>
<listitem><code><![CDATA[ ("true" + "false", true || false, true && false) ]]></code> evaluates to <code>("truefalse", true, false)</code>.</listitem>
<listitem><code>(2/2, 2/1, 2/0)</code> is silent.</listitem>
</itemizedlist>
</para>

</section>
 
<section><title>Lists</title>

<para>
A <firstterm>list expression</firstterm> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>[1,2+3] </code> evaluates to <code>[1,5]</code>.</listitem>
<listitem><code><![CDATA[ [true && true] ]]> </code> evaluates to <code>[true]</code>.</listitem>
<listitem><code>[]</code> evaluates vacuously to <code>[]</code>, the empty list.</listitem>
<listitem><code>[5, 5 + true, 5]</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
There is also a concatenation (<firstterm>cons</firstterm>) operation on lists,
written F<code>:</code>G, where F and G are expressions. Its result is a new list whose first element is the 
value of F and whose remaining elements are the list value of G. The <code>:</code> operator is right associative,
so F<code>:</code>G<code>:</code>H is F<code>:(</code>G<code>:</code>H<code>)</code>.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+3):[2+5,6]</code> evaluates to <code>[4,7,6]</code>.</listitem>
<listitem><code>2:2:5:[] </code> evaluates to <code>[2,2,5]</code>.</listitem>
<listitem>Suppose <code>t</code> is bound to [3,5]. Then <code>1:t</code> evaluates to <code>[1,3,5]</code>.</listitem>
<listitem><code>2:3</code> is silent, because <code>3</code> is not a list.</listitem>
</itemizedlist>
</para>

</section>



<section><title>Records</title>

<para>
A <firstterm>record expression</firstterm> is a comma-separated sequence of elements of the form 
<emphasis>f</emphasis><code> = </code> E, enclosed by
record braces <code>{.</code> and <code>.}</code>, where each f is a field name and each E is an expression. 
Records may have any number of fields, including zero. Each expression is evaluated; the value 
of the whole record expression is a record containing an element for each field with its associated value. 
Order is irrelevant. If any of the expressions is silent, then the whole record expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>{. zero = 3 - 3, one = 0 + 1 .}</code> evaluates to <code>{. zero = 0, one = 1 .}</code>.</listitem>
<listitem><code>{. .}</code> evaluates to <code>{. .}</code>, the empty record.</listitem>
</itemizedlist>
</para>

Elements of records are accessed using a dot (<code>.</code>) syntax, as in most object oriented languages.
The expression <code>r.f</code> evaluates to the value associated with field <code>f</code> in record <code>r</code>.
If <code>f</code> is not present in <code>r</code>, the expression is silent.

<para>
Suppose <code>r = {. x = 0, y = 1 .}</code>
<itemizedlist><title>Examples</title>
<listitem><code>r.x</code> evaluates to <code>0</code>.</listitem>
<listitem><code>r.y</code> evaluates to <code>1</code>.</listitem>
<listitem><code>r.z</code> is silent.</listitem>
</itemizedlist>
</para>


<para>
Records can also be extended using the + operator. An expression <code>r + s</code>, where r and s are records, 
creates a new record which has all of the elements of <code>r</code> whose field names do not appear in <code>s</code>, and all
of the elements of <code>s</code>. In other words, <code>s</code> overrides <code>r</code>.
This use of <code>+</code> is left-associative and does not commute.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>{. x = 0 .} + {. y = 1 .}</code> evaluates to <code>{. x = 0, y = 1 .}</code></listitem>
<listitem><code>{. x = 0, y = 1 .} + {. y = 2, z = 3 .}</code> evaluates to <code>{. x = 0, y = 2, z = 3 .}</code></listitem>
</itemizedlist>
</para>

</section>
 
</section>


<section id="section.orc.patterns"><title>Patterns</title>

<para>
We have seen how to construct data structures. But how do we examine them, and use them? We use <firstterm>patterns</firstterm>.
</para>

<para>
A pattern is a powerful way to bind variables. When writing <code>val</code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <firstterm>shape</firstterm>; a
pattern may take the shape of any structured value except a record. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,y) = (2+3,2*3)</code> binds <code>x</code> to 5 and <code>y</code> to 6.</listitem>
<listitem>
<code>val [a,b,c] = ["one", "two", "three"]</code> binds <code>a</code> to "one", 
<code>b</code> to "two", and <code>c</code> to "three".
</listitem>
<listitem>
<code>val ((a,b),c) = ((1, true), (2, false))</code> binds <code>a</code> to 1, <code>b</code> to <code>true</code>,
and <code>c</code> to <code>(2,false)</code>.
</listitem>
</itemizedlist>
</para>

<para>
Patterns are <firstterm>linear</firstterm>; that is, a pattern may mention a variable name at most once. 
For example, <code>(x,y,x)</code> is not a valid pattern.
</para>

<para>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code>val</code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evaluated, it is silent.
</para>

<para>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code>_</code>, to do this; it matches any shape and binds no
variables.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,_,_) = (1,(2,2),[3,3,3])</code> binds <code>x</code> to 1.</listitem>
<listitem><code>val [[_,x],[_,y]] = [[1,3],[2,4]]</code> binds <code>x</code> to 3 and <code>y</code> to 4.</listitem>
</itemizedlist>
</para>

</section>

<section id="cor.functions"><title>Functions</title>

<para>
Like most other programming languages, Cor provides the capability to define <firstterm>functions</firstterm>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code>def</code>, in the following way.

<programlisting><![CDATA[
def add(x,y) = x+y
]]></programlisting>

The expression on the right of the <code>=</code> is called the <firstterm>body</firstterm> of the function.
</para>

<para>
After defining the function, we can <firstterm>call</firstterm> it. A call looks just like the left side of
the declaration except that the variable names (the <firstterm>formal parameters</firstterm>) have been 
replaced by expressions (the <firstterm>actual parameters</firstterm>). 
</para>

<para>
To evaluate a call, we treat it as a sequence of <code>val</code> declarations associating the formal
parameters with the actual parameters, followed by the body of the function. 

<programlisting><![CDATA[
{- Evaluation of add(1+2,3+4) -}
val x = 1+2
val y = 3+4
x+y
]]></programlisting>
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>add(10,10*10)</code> evaluates to <code>110</code>.</listitem>
<listitem><code>add(add(5,3),5)</code> evaluates to <code>13</code>.</listitem>
</itemizedlist>
</para>

<para>
Notice that the evaluation strategy of functions allows a call to proceed even if some of the actual
parameters are silent, so long as the values of those actual parameters are not used in the evaluation
of the body.

<programlisting language="orc-demo"><![CDATA[
def cond(b,x,y) = if b then x else y
cond(true, 3, 5/0)
]]></programlisting>

This evaluates to <code>3</code> even though <code>5/0</code> is silent, because <code>y</code> is not
needed.

</para>


<para>
A function definition or call may have zero arguments, in which case we write <code>()</code> for the arguments.

<programlisting><![CDATA[
def Zero() = 0
]]></programlisting>
</para>


<section id="section.orc.recursion"><title>Recursion</title>

<para>
Functions can be recursive; that is, the name of a function may be used in its own body.

<programlisting><![CDATA[
def sumto(n) = if n < 1 then 0 else n + sumto(n-1)
]]></programlisting>

Then, <code>sumto(5)</code> evaluates to 15.
</para>  

<para>
Mutual recursion is also supported.

<programlisting><![CDATA[
def even(n) = 
  if (n > 0) then odd(n-1)
  else if (n < 0) then odd(n+1)
  else true
def odd(n) = 
  if (n > 0) then even(n-1)
  else if (n < 0) then even(n+1)
  else false
]]></programlisting>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.
</para>

</section>

<section id="cor.closures"><title>Closures</title>

<para>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<firstterm>closure</firstterm>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

<programlisting><![CDATA[
def a(x) = x-3
def b(y) = y*4
val funs = (a,b)
]]></programlisting>
</para>

<para>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
supports <emphasis>higher-order</emphasis> functions.

<programlisting><![CDATA[
def onetwosum(f) = f(1) + f(2)
def triple(x) = x * 3
]]></programlisting>

Then, <code>onetwosum(triple)</code> is <code>triple(1) + triple(2)</code>, which is <code>1 * 3 + 2 * 3</code> which evaluates to <code>9</code>.

</para>

<para>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<emphasis>lexical closures</emphasis>. This means that when a closure is created, if the body of the
function contains any variables other than the formal parameters, the bindings for those variables are
stored in the closure. Then, when the closure is called, the evaluation of the function body uses those 
stored variable bindings.  
</para>


</section>

<section id="section.orc.lambda"><title>Lambda</title>

<para>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code>lambda</code> for this purpose. By writing a function
definition without the keyword <code>def</code> and replacing the function name with
the keyword <code>lambda</code>, that definition becomes an expression which evaluates to a closure. 

<programlisting language="orc-demo"><![CDATA[
def onetwosum(f) = f(1) + f(2)

onetwosum( lambda(x) = x * 3 )
{- 
  identical to:
  def triple(x) = x * 3
  onetwosum(triple)
-}]]></programlisting>

Then, <code>onetwosum( lambda(x) = x * 3 )</code> evaluates to 9. 

</para>

<para>
Since a function defined using <code>lambda</code> has no name, it is not possible to define 
a recursive function in this way. Only <code>def</code> can create a recursive function.
</para>

</section>


<section id="section.orc.clauses"><title>Clauses</title>

<para>
The combination of functions and pattern matching offers a powerful capability: 
<firstterm>clausal</firstterm> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</para>


<para>
Here's an example.

<programlisting><![CDATA[
def sum([]) = 0
def sum(h:t) = h + sum(t)
]]></programlisting>

<code>sum(l)</code> publishes the sum of the numbers in the list <code>l</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</para>

<para>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</para>

<para>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</para>

<para>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

<programlisting><![CDATA[
{- Fibonacci numbers -}
def fib(0) = 1
def fib(1) = 1
def fib(n) = if (n < 0) then 0 else fib(n-1) + fib(n-2)
]]></programlisting>

This definition of the Fibonacci function is straightforward, but slow, due to the repeated work in recursive
calls to <code>fib</code>. We can define a linear-time version, again with the help of pattern matching:

<programlisting><![CDATA[
{- Alternate definition of the Fibonacci function -}

{- A helper function: find the pair (Fibonacci(n-1), Fibonacci(n)) -}
def H(0) = (1,1)
def H(n) = 
  val (x,y) = H(n-1)
  (y,x+y)

def fib(n) = 
  if (n < 0) then 0 
  else (
    val (x,_) = H(n) 
    x
  )
     
    
]]></programlisting>
</para>

<para>
As a more complex example of matching, consider the following function which takes
a list argument and returns a new list containing only the first <code>n</code> 
elements of the argument list. 

<programlisting><![CDATA[
def take(0,_) = []
def take(n,h:t) = if (n > 0) then h:(take(n-1,t)) else []
]]></programlisting>
</para>


<para>
Mutual recursion and clausal definitions are allowed to occur together. Here are two functions,
<code>stutter</code> and <code>mutter</code>, which are each mutually recursive, and each have
multiple clauses. <code>stutter(l)</code> returns <code>l</code> with every odd element repeated.
<code>mutter(l)</code> returns <code>l</code> with every even element repeated.

<programlisting><![CDATA[
def stutter([]) = []
def stutter(h:t) = h:h:mutter(t)
def mutter([]) = []
def mutter(h:t) = h:stutter(t)
]]></programlisting>

<code>stutter([1,2,3])</code> evaluates to <code>[1,1,2,3,3]</code>.
</para>

<para>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

<programlisting><![CDATA[
def even(0) = true
def odd(0) = false
def even(n) = odd(if n > 0 then n-1 else n+1)
def odd(n) = even(if n > 0 then n-1 else n+1)
]]></programlisting>

</para>

</section>

</section>

<section><title>Comments</title>
<para>
Cor has two kinds of comments.   

</para>

<para>
A line which begins with two dashes (<code>--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<programlisting><![CDATA[
-- This is a single line comment.
	 -- This is also a single line comment.
]]></programlisting>
</para>

<para>
Multi-line comments are enclosed by matching braces of the form <code><![CDATA[{- -}]]></code>. 
Multi-line comments may be nested. They may appear anywhere, even in the middle of an expression.

<programlisting><![CDATA[
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

{- They may appear anywhere, -} 
1 + {- even in the middle of an expression. -} 2 + 3
]]></programlisting>

</para>

</section>

</section>



<section><title>Orc: Orchestrating services</title>

<para>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. The full 
Orc language transcends these limitations by incorporating the orchestration of external services.
We introduce the term <firstterm>site</firstterm> to denote an external service which can be
called from an Orc program.
</para>

<para>
As in Cor, an Orc program is an  <firstterm>expression</firstterm>; Orc expressions are built 
up recursively from smaller expressions. Orc is a superset of Cor, i.e., all Cor expressions are 
also Orc expressions. Orc expressions are <firstterm>executed</firstterm>, rather than evaluated; 
an execution may call external services and <firstterm id="terms.publish">publish</firstterm> some number of 
values (possibly zero). Different executions of the same expression may have completely different
behaviors; they may call different services, may receive different responses from the same site,
and may publish different values. Expressions in the functional subset, though, will display
the same behavior in all executions.
</para>

<para>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <firstterm>combinators</firstterm>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</para>

<para>
The following figure summarizes the syntax of Orc as an extension of the syntax of Cor. 
The original Cor grammar rules are abbreviated by ellipses (...). 
</para>

<para>
<table id="orc-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Basic Syntax of Orc</title>  
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="4*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>address</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry>C</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>signal</code></entry>

<entry></entry>
<entry><emphasis>signal value</emphasis></entry>
</row>


<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>FATBAR</code> E</entry>

<entry></entry>
<entry><emphasis>parallel combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ <]]></code>P<code><![CDATA[< ]]></code>E</entry>

<entry></entry>
<entry><emphasis>pruning combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>otherwise combinator</emphasis></entry>
</row>


</tbody>
</tgroup>
</table>
</para>
	
<para>
<table id="orc-keyword-table" frame="none" rowsep="0" colsep="0">
<title>Orc Keywords</title>  
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="7" >
	<!--
<colspec colnum="1" colname="word1" colwidth="1*" align="right"/>
<colspec colnum="2" colname="word2" colwidth="1*" align="center"/>
<colspec colnum="3" colname="word3" colwidth="10*" align="left"/>
		-->
<colspec colnum="1" colname="word1" colwidth="1*" align="left"/>
<colspec colnum="2" colname="word2" colwidth="1*" align="left"/>
<colspec colnum="3" colname="word3" colwidth="1*" align="left"/>
<colspec colnum="4" colname="word4" colwidth="1*" align="left"/>
<colspec colnum="5" colname="word5" colwidth="1*" align="left"/>
<colspec colnum="6" colname="word6" colwidth="1*" align="left"/>
<colspec colnum="7" colname="word7" colwidth="1*" align="left"/>
<tbody>
	
<row>
		<entry><code>true</code></entry>
		<entry><code>false</code></entry>
		<entry><code>signal</code></entry>
		<entry><code>stop</code></entry>
		<entry><code>null</code></entry>
		<entry><code>lambda</code></entry>
		<entry><code>_</code></entry>
</row>
	
<row>
		<entry><code>if</code></entry>
		<entry><code>then</code></entry>
		<entry><code>else</code></entry>
		<entry><code>as</code></entry>
		<entry><code>val</code></entry>
		<entry><code>def</code></entry>
</row>
	
<row>
		<entry><code>class</code></entry>
		<entry><code>type</code></entry>
		<entry><code>site</code></entry>
		<entry><code>include</code></entry>
<!--		<entry><code>within</code></entry> -->
		<entry><code>Top</code></entry>
		<entry><code>Bot</code></entry>
</row>
	
</tbody>
</tgroup>
</table>
</para>

		
<section id="orc.sites"><title>Communicating with external services</title>

<para>
An Orc expression may be a site call. Sites are called using the same syntax as a 
function call, but with a slightly different meaning. Sites are introduced and bound 
to variables by a special declaration.  
</para>

<section><title>Calling a site</title>

<para>
Suppose that the variable <code>Google</code> is bound to a site which invokes the
Google search engine service in "I'm Feeling Lucky" mode. A call to <code>Google</code> 
looks just like a function call. Calling <code>Google</code> requests the URL of the top 
result for the given search term.

<programlisting><![CDATA[
{- Get the top search result for "computation orchestration" -}
Google("computation orchestration")
]]></programlisting>

Once the Google search service determines the top result, it sends a response. The site 
call then publishes that response. Note that the service might not respond: Google's 
servers might be down, the network might be down, or the search might yield no result URL.  
</para>

<para>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</para>

<para>
A call to a site has exactly one of the following effects: 

<orderedlist>
<listitem>The site returns a value, called its <firstterm>response</firstterm>.</listitem>
<listitem>The site communicates that it will never respond to the call; we say that the call has <firstterm>halted</firstterm></listitem>
<listitem>The site neither returns a value nor indicates that the call has halted; we say that the call is <firstterm>pending</firstterm>.</listitem>
</orderedlist>
</para>

<para>
In the last two cases, the site call is said to be silent. However, unlike a silent expression in Cor, 
a silent site call in Orc might perform some meaningful computation or communication; silence does 
not necessarily indicate an error. Since halted site calls and pending site calls are both silent,
they cannot usually be distinguished from each other; only the <link linkend="combinators.otherwise">
otherwise combinator</link> can tell the difference. 
</para>


<para>
A site is a value, just like an integer or a list. It may be bound to a variable, passed 
as an argument, or published by an execution, just like any other value.
</para> 

<para>
<programlisting><![CDATA[
{-
  Create a search site from a search engine URL,
  bind the variable Search to that site,
  then use that site to search for a term.
-}
val Search = SearchEngine("http://www.google.com/")
Search("first class value")
]]></programlisting>
</para>

<para>
A site is sometimes called only for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <firstterm>signal</firstterm>: a special value which carries no 
information (analogous to the unit value <code>()</code> in ML). The signal value
can be written as <code>signal</code> within Orc programs.


<programlisting language="orc-demo"><![CDATA[
{- 
  Use the 'println' site to print a string, followed by
  a newline, to an output console.
  The return value of this site call is a signal.
-}
println("Hello, World!")
]]></programlisting>
</para>


</section>


<section id="orc-declaring-a-site"><title>Declaring a site</title>

<para>
A <code>site</code> declaration makes some service available as a site and
binds it to a variable. The service might be an object in the host language 
(e.g. a class instance in Scala or Java), or an external service on the web which is accessed 
through some protocol like SOAP or REST, or even a primitive operation like addition. 


We will discuss the particulars of these declarations, and the guidelines for accessing 
web-based services or creating one's own services, in <link linkend="chapter.services">Chapter 3</link>.
Also, Many useful sites are already defined in the Orc standard library, documented
in <link linkend="appendix.library">Appendix B</link>. For now, we present a simple 
type of site declaration: using an object in the host language as a site.  
</para>

<para>
The following example instantiates a Java object to be used as a site in an Orc program, specifically
a Java object which provides an asynchronous buffer service. The declaration uses a
fully qualified Java class name to find and load a class, and creates an instance of that
class to provide the service. 

<programlisting><![CDATA[
{-  Define the Buffer site  -}
site Buffer = orc.lib.state.Buffer
]]></programlisting>  
</para>

<para>

</para>
  
</section>

</section>


<section><title>The concurrency combinators of Orc</title>

<para>
Orc has four <firstterm>combinators</firstterm>: parallel, sequential, pruning, and otherwise. 
A combinator forms an expression from two component expressions. Each combinator captures a 
different aspect of concurrency. Syntactically, the combinators are written infix, and have
lower precedence than operators, but higher precedence than conditionals or declarations.
</para>

<section id="combinators.parallel"><title>The parallel combinator</title>

<para>
Orc's simplest combinator is <code>|</code>, the parallel combinator. Orc executes
the expression F <code>|</code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
F <code>|</code> G does so as well.  The resulting publications of F <code>|</code> G
may be published in arbitrary order.
</para>   

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
1 | 1+1

-- Note the publication order may be either 1 then 2
-- or 2 then 1
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
{- 
  Access two search sites, Google and Yahoo, in parallel.

  Publish any results they return.
  
  Since each call may publish a value, the expression
  may publish up to two values.
-}  
Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
</para>  

<para>
The parallel combinator is fully associative: (F <code>|</code> G) <code>|</code> H and
F <code>|</code> (G <code>|</code> H) and F <code>|</code> G <code>|</code> H are all
equivalent.
</para> 

<para>
It is also commutative: F <code>|</code> G is equivalent to G <code>|</code> F.  
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1, 2, and 3 in parallel  
1+0 | 1+1 | 1+2
]]></programlisting>
</para>  

</section>

<section id="combinators.sequential"><title>The sequential combinator</title>

<para>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F<code><![CDATA[ >x> ]]></code>G, 
combines the expression F, which may publish some values, with another expression G, 
which will use the values as they are published; <code>x</code> transmits the values
from F to G.
</para>

<para>
The execution of F<code><![CDATA[ >x> ]]></code>G starts by executing F. Whenever F publishes a value, 
a new copy of G is executed in parallel with F (and with any previous copies of G); in that
copy of G, variable <code>x</code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
(0 | 1) >n> n+1
]]></programlisting>
</para>  

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 3 and 4 in parallel  
2 >n> (n+1 | n+2)
]]></programlisting>
</para>  


<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 0, 1, 2 and 3 in parallel  
(0 | 2) >n> (n | n+1)
]]></programlisting>
</para>  


<para>
<programlisting><![CDATA[
-- Prepend the site name to each published search result
-- The cat site concatenates any number of arguments into one string  
  Google("cupcake") >s> cat("Google: ", s)
| Yahoo("cupcake") >s> cat("Yahoo: ", s)
]]></programlisting>
</para>  




<para>
The sequential combinator may be written as F<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new copy of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new copy of G is executed.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 3, 6, and 9 in arbitrary order.
(3,6,9)  >(x,y,z)>  ( x | y | z )
]]></programlisting>
</para>


<para>
<programlisting language="orc-demo"><![CDATA[
-- Filter out values of the form (_,false)
( (4,true) | (5,false) | (6,true) )  >(x,true)> x
-- Publishes 4 and 6 
]]></programlisting>
</para>
 


<para>
We may also omit the variable entirely, writing <code><![CDATA[ >> ]]></code>. This
is equivalent to using a wildcard pattern: <code><![CDATA[ >_> ]]></code>
</para>

<para>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code><![CDATA[ >> ]]></code> together with the special expression 
<code>stop</code>, which is always silent.  
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- 
  Print two strings to the console,
  but don't publish the return values of the calls.
-}
( println("goodbye") | println("world") ) >> stop
]]></programlisting>
</para>

<para>
The sequential combinator is right associative: F<code><![CDATA[ >x> ]]></code>G<code><![CDATA[ >y> ]]></code>H
is equivalent to F<code><![CDATA[ >x> (]]></code>G<code><![CDATA[ >y> ]]></code>H<code>)</code>. It has higher
precedence than the parallel combinator: F<code><![CDATA[ >x> ]]></code>G <code>|</code> H is equivalent to
<code>(</code>F<code><![CDATA[ >x> ]]></code>G <code>) |</code> H.
</para>

<para>
The right associativity of the sequential combinator makes it easy to bind variables in sequence and use
them together.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- 
  Publish the cross product of {1,2} and {3,4}:
  (1,3), (1,4), (2,3), and (2,4).
-}
(1 | 2) >x> (3 | 4) >y> (x,y)
]]></programlisting>
</para>


</section>


<section id="combinators.pruning"><title>The pruning combinator</title>

<para>
The pruning combinator, written F<code><![CDATA[ <x< ]]></code>G, allows us to block 
a computation waiting for a result, or terminate a computation. The execution of 
F<code><![CDATA[ <x< ]]></code>G starts by executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then the execution of G is immediately 
<firstterm>terminated</firstterm>. A terminated expression cannot call any sites or 
publish any values.
</para>

<para>
During the execution of F, any part of the execution that depends on <code>x</code> 
will be suspended until <code>x</code> is bound (to the first value published by G). If G
never publishes a value, that part of the execution is suspended forever. 
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 5 or 6, but not both
x+2 <x< (3 | 4)
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
-- Query Google and Yahoo for a search result
-- Print out the result that arrives first; ignore the other result
println(result) <result< ( Google("cupcake") | Yahoo("cupcake") )
]]></programlisting>
</para>  

<para>
Though a terminated execution may not make any new calls, the calls
that it has already made will continue normally; their responses are simply
ignored. This may have surprising consequences when a call has side effects,
as in the following example.

<programlisting language="orc-demo"><![CDATA[
{- 
  This example actually prints both "true" and "false" to the
  console, regardless of which call responds first.
-}
stop <x< println("true") | println("false")
]]></programlisting>

Both of the <code>println</code> calls are initiated before either one of
them publishes a value and terminates the expression. Once the expression
is terminated, no new calls occur, but the other <code>println</code> call
still proceeds and still has the effect of printing its message to the
console.
</para>


<para>
The pruning combinator may include a full pattern P instead of just a variable name. Any
value published by G is matched against the pattern P. If this match is successful, then G
terminates and all of the bindings of the pattern P are made in F. Otherwise, the published 
value is simply ignored and G continues to execute.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 9 or 25, but not 16.
x*x <(x,true)< ( (3,true) | (4,false) | (5,true) )
]]></programlisting>
</para>  

<para>
Note that even if <code>(4,false)</code> is published before <code>(3,true)</code> or <code>(5,true)</code>, 
it is ignored. The right side continues to execute and will publish one of <code>(3,true)</code> or 
<code>(5,true)</code>.
</para>


<para>
The pruning combinator is left associative: F<code><![CDATA[ <x< ]]></code>G<code><![CDATA[ <y< ]]></code>H
is equivalent to <code>(</code>F<code><![CDATA[ <x< ]]></code>G<code><![CDATA[) <y< ]]></code>H. It has lower
precedence than the parallel combinator: F<code><![CDATA[ <x< ]]></code>G <code>|</code> H is equivalent to
F<code><![CDATA[ <x< (]]></code>G <code>|</code> H<code>)</code>.
</para>


</section>


<section id="combinators.otherwise"><title>The otherwise combinator</title>

<para>
Orc has a fourth concurrency combinator: the <firstterm>otherwise</firstterm> combinator,
written F<code> ; </code>G. The execution of F<code> ; </code> G proceeds as follows.
First, F is executed. If F <firstterm>completes</firstterm>, and has not published any values, 
then G executes. If F did publish one or more values, then G is ignored. The publications of 
F <code>;</code> G are those of F if F publishes, or those of G otherwise.
</para>

<para>
We determine when an expression completes using the following rules.

<itemizedlist>
<listitem>A Cor expression completes when it is fully evaluated; if it is silent, it completes immediately.</listitem>
<listitem>A site call completes when it has published a value or halted.</listitem>
<listitem>F <code>|</code> G completes when its subexpressions F and G have both completed.</listitem>
<listitem>F<code><![CDATA[ >x> ]]></code>G completes when F has completed and all instantiated copies of G have completed.</listitem>
<listitem>F<code><![CDATA[ <x< ]]></code>G completes when F has completed, and G has either completed or
published a value. Also, if G completes without publishing a value, then all expressions in F which
use <code>x</code> also complete, since they will never be able to proceed.</listitem>
<listitem>F <code>;</code> G completes either when F has published a value and subsequently completed,
or when F and G have both completed.</listitem>
<listitem><code>stop</code> completes immediately.</listitem>
</itemizedlist>

</para>

<para>
The otherwise combinator is fully associative, so F <code>;</code> G <code>;</code> H and
(F <code>;</code> G) <code>;</code> H and F <code>;</code> (G <code>;</code> H) are
all equivalent. It has lower precedence than the other three combinators. 
</para>

<para>
The otherwise combinator was not present in the original formulation of the Orc concurrency 
calculus; it has been added to support computation and iteration over strictly finite data. 
Sequential programs conflate the concept of producing a value with the concept of completion. 
Orc separates these two concepts; variable binding combinators like <code><![CDATA[ >x> ]]></code> 
and <code><![CDATA[ <x< ]]></code> handle values, whereas <code>;</code> detects the completion 
of an execution.
</para>

</section>



</section>



<section id="cor.revisiting"><title>Revisiting Cor expressions</title>

<para>
Some Cor expressions have new behaviors in the context of Orc, due to the introduction
of concurrency and of sites.
</para>

<section><title>Operators</title>

<para>
The arithmetic, logical, and comparison operators are actually calls to sites, simply
written in infix style with the expected operator symbols. For example, <code>2+3</code>
is actually <code>(+)(2,3)</code>, where <code>(+)</code> is a primitive site provided
by the language itself. All of the operators can be used directly as sites in this way;
the name of the site is the operator enclosed by parentheses, e.g. <code>(**)</code>,
<code>(>=)</code>, etc. Negation (unary minus) is named <code>(0-)</code>.
</para>

</section>


<section><title>Conditionals</title>

<para>
The conditional expression <code>if</code> E <code>then</code> F <code>else</code> G
is actually a derived form based on two different sites named <code>If</code> and <code>Unless</code>. 
The sites take a boolean argument.  <code>If</code> returns a signal if that argument is <code>true</code>,
or remains silent if the argument is <code>false</code>.  <code>Unless</code> returns a signal if that argument
is <code>false</code> or remains silent if the argument is <code>true</code>.
</para>

<para>
<code>if</code> E <code>then</code> F <code>else</code> G is equivalent 
to <code>(<![CDATA[ If(b) >> ]]></code>F<code><![CDATA[ | Unless(b) >> ]]></code>G<code>)<![CDATA[ <b< ]]></code>E.
</para>

<!--
<para>
 When the <code>else</code> branch of a conditional is unneeded, we can write <code>if</code> F <code>then</code> G,
 with no <code>else</code> branch. This is equivalent to <code>IfT(</code>E<code>) >> </code>F.
</para>
-->
	
</section>


<section><title><code>val</code></title>

<para>
The declaration <code>val x = </code>G, followed by expression F, is 
actually just a different way of writing the expression F<code><![CDATA[ <x< ]]></code>G.
Thus, <code>val</code> shares all of the behavior of the pruning combinator,
which we have already described. (This is also true when a pattern is used instead
of variable name <code>x</code>).
</para>

</section>


<section><title>Nesting Orc expressions</title>

<para>
The execution of an Orc expression may publish many values. What does such an expression 
mean in a context where only one value is expected? For example, what does <code>2 + (3 | 4)</code> 
publish? 
</para>

<para>
The specific contexts in which we are interested are as follows (where E is any Orc expression):

<informaltable id="value-context-table" frame="none" rowsep="0" colsep="0"> 
<?dbhtml table-width="40%" ?>
<?dbfo table-width="80%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" align="left"/>
<colspec colnum="2" colwidth="1*" align="right"/>
<tbody>

<row>
<entry>E <emphasis>op</emphasis> E</entry>
<entry><emphasis>operand</emphasis></entry>
</row>

<row>
<entry><code>if</code> E <code>then</code> ...</entry>
<entry><emphasis>conditional test</emphasis></entry>
</row>

<row>
<entry>X<code>(</code> ... <code>,</code> E <code>,</code> ... <code>)</code></entry>
<entry><emphasis>call argument</emphasis></entry>
</row>

<row>
<entry><code>(</code> ... <code>,</code> E <code>,</code> ... <code>)</code></entry>
<entry><emphasis>tuple element</emphasis></entry>
</row>

<row>
<entry><code>[</code> ... <code>,</code> E <code>,</code> ... <code>]</code></entry>
<entry><emphasis>list element</emphasis></entry>
</row>

</tbody>
</tgroup>
</informaltable>
</para>

<para>
Whenever an Orc expression appears in such a context, it executes until it publishes its first value, 
and then it is terminated. The published value is used in the context as if it were the result of evaluating
the expression.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 5 or 6
2 + (3 | 4)
]]></programlisting>
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish exactly one of 0, 1, 2 or 3
(0 | 2) + (0 | 1)
]]></programlisting>
</para>

<para>
To be precise, whenever an Orc expression appears in such a context, it is treated as if it was 
on the right side of a pruning combinator, using a fresh variable name to fill in the hole. 
Thus, C[E] (where E is the Orc expression and C is the context) is equivalent to the expression 
C[<code>x</code>] <code><![CDATA[ <x< ]]></code> E. 
</para>

</section>


<section><title>Functions</title>

<para>
The body of a function in Orc may be any Orc expression; thus, function
bodies in Orc are executed rather than evaluated, and may engage in communication
and publish multiple values.
</para>

<para>
A function call in Orc, as in Cor, binds the values of its actual parameters
to its formal parameters, and then executes the function body with those bindings.
Whenever the function body publishes a value, the function call publishes that
value. Thus, unlike a site call, or a pure functional Cor call, an Orc function
call may publish many values.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish all integers in the interval 1..n, in arbitrary order. 
def range(n) = if (n > 0) then (n | range(n-1)) else stop 

-- Publish 1, 2, and 3 in arbitrary order.
range(3)
]]></programlisting>
</para>

<para>
In the context of Orc, function calls are not strict. When a function call executes,
it begins to execute the function body immediately, and also executes the argument
expressions in parallel. When an argument expression publishes a value, it is terminated,
and the corresponding formal parameter is bound to that value in the execution of
the function body. Any part of the function body which uses a formal parameter
that has not yet been bound suspends until that parameter is bound to a value.
</para>

</section>



</section>


<section><title>Time</title>

<para>
Orc is designed to communicate with the external world, and one of the
most important characteristics of the external world is the passage of
time. Orc implicitly interacts with the passage of time by calling external
services which take time to respond. However, Orc can also explicitly
wait for some amount of time, using the special site <code>Rtimer</code>. 
</para>

<para>
The site <code>Rtimer</code> is a relative timer. It takes as an argument
a number of milliseconds to wait. It waits for exactly that amount of time,
and then responds with a signal.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Print "red", wait for 3 seconds (3000 ms), and then print "green" 
println("red") >> Rtimer(3000) >> println("green") >> stop
]]></programlisting>
</para>

<para>
The following example defines a metronome, which publishes a signal once 
every <code>t</code> milliseconds, indefinitely.
</para>

<para>
<programlisting><![CDATA[
def metronome(t) = signal | Rtimer(t) >> metronome(t)
]]></programlisting>
</para>

<para>
We can also use <code>Rtimer</code> together with the pruning combinator 
to enforce a timeout.
</para>

<para>
<programlisting><![CDATA[
{-
  Publish the result of a Google search.
  If it takes more than 5 seconds, time out.
-}
result 
  <result< ( Google("impatience") 
           | Rtimer(5000) >> "Search timed out.")
]]></programlisting>
</para>



We present many more examples of programming techniques using real time in <link linkend="chapter.methodology">Chapter 2</link>.

</section>


</section>



<section><title>Advanced Features of Orc</title>

<para>
In this section we introduce some advanced features of Orc. These include curried
function definitions and curried calls, writing an arbitrary expression as the
target of a call, a special syntax for writing calls in an object-oriented style, 
extensions to pattern matching, and new forms of declarations, and ML-style
datatypes.
</para>


<para>
<table id="advanced-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Advanced Syntax of Orc</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="100%" ?>
<?dbfo keep-together="always" ?>
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="5*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E G+</entry>

<entry></entry>
<entry><emphasis>generalized call</emphasis></entry>
</row>

<!-- 
<row>
<entry></entry>
<entry>|</entry>

<entry>T</entry>

<entry></entry>
<entry><emphasis>throw expression</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>TC</entry>

<entry></entry>
<entry><emphasis>try/catch block</emphasis></entry>
</row>

 -->

<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>curried arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>


<row>
<entry>P</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>=</code>X</entry>

<entry></entry>
<entry><emphasis>equality pattern</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>datatype pattern</emphasis></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X <code>=</code> DT <code>|</code> ... <code>|</code> DT</entry>

<entry></entry>
<entry><emphasis>datatype declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>

<row>
<entry>DT</entry>
<entry>::=</entry>

<entry> X<code>(_,</code> ... <code>,_)</code> </entry>

<entry><emphasis>Datatype</emphasis></entry>
<entry></entry>
</row>

<!-- 
<row>
<entry>T</entry>
<entry>::=</entry>

<entry> <code>throw </code> E</entry>

<entry><emphasis>Throw</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>TC</entry>
<entry>::=</entry>

<entry> <code>try ( </code> E <code> ) </code> C+</entry>

<entry><emphasis>Try/Catch</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>C</entry>
<entry>::=</entry>

<entry> <code>catch ( </code> P <code> ) </code> E</entry>

<entry><emphasis>Exception Handler</emphasis></entry>
<entry></entry>
</row>
 -->

</tbody>
</tgroup>
</table>
</para>


<section><title>Special call forms</title>

<section id="special.dot"><title>The <code>.</code> notation</title>

<para>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code>obj.m()</code> calls the method
<code>m</code> of the object <code>obj</code>. 
</para>

<para>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code>x.msg</code>, for any identifiers <code>x</code> and <code>msg</code>. This treats
 the value bound to <code>x</code> as a site, and calls it with a special 
<firstterm>message</firstterm> value <code>msg</code>. 
If the site understands the message <code>msg</code> (for example, if <code>x</code> is 
bound to a Java object with a field called <code>msg</code>), the site interprets the message 
and responds with some appropriate value. If the site does not 
understand the message sent to it, it does not respond, and no publication occurs. 
If <code>x</code> cannot be interpreted as a site, no call is made. 
</para>

<para>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code>c</code> might understand the messages
<code>get</code> and <code>put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code>c.get()</code>, or <code>c.put(6)</code>.
</para>

<para>
A call such as <code>c.put(6)</code> actually occurs in two steps. First <code>c.put</code> sends the message
<code>put</code> to the site <code>c</code>; this publishes a site whose only purpose
is to put values on the channel. Next, that site is called on the argument
<code>6</code>, sending 6 on the channel. Readers familiar with functional programming
will recognize this technique as <emphasis>currying</emphasis>.
</para>
</section>


<section id="section.orc.currying"><title>Currying</title>

<para>
It is sometimes useful to <emphasis>stage</emphasis> the arguments to a function; that is,
rather than writing a function on two arguments, one instead writes a function on one
argument which returns a function taking the second argument and performing the remainder
of the evaluation. 
</para>

<para>
This technique is known as <emphasis>currying</emphasis> and it is common in functional
programming languages. We can write curried functions using <link linkend="cor.closures">closures</link>. Suppose we want to 
define a curried addition function on two arguments, and later apply that function to the 
arguments 3 and 4. We could write such a program in the following way:

<programlisting language="orc-demo"><![CDATA[
def Sum(a) = ( lambda(b) = a+b )  
val f = Sum(3)
f(4)
]]></programlisting>

This defines a function <code>Sum</code> which, given an argument <code>a</code>, creates a function
which will take an argument <code>b</code> and add <code>a</code> to <code>b</code>. It then creates the
function which adds <code>3</code> to its argument, binds that to <code>f</code>, and then invokes
<code>f</code> on <code>4</code> to yield <code>3+4</code>.

</para>

<para>
When defining a curried function, we have abstracted it in two steps, and when
applying it we have written two separate calls. However, this is verbose and
not very clear. Orc has a special syntax for curried function definitions and curried 
applications that will simplify both of these steps. Function definitions may have multiple 
argument sequences; they are enclosed in parentheses and concatenated. Curried function calls 
chain together multiple applications in a similar way. Here is the previous program, written 
in this simplified syntax:

<programlisting language="orc-demo"><![CDATA[
def Sum(a)(b) = a+b
Sum(3)(4)
]]></programlisting>

Naturally, this syntax is backwards compatible; e.g. both of the following programs are also
equivalent:  

<programlisting language="orc-demo"><![CDATA[
def Sum(a) = ( lambda(b) = a+b )  
Sum(3)(4)
]]></programlisting>

<programlisting language="orc-demo"><![CDATA[
def Sum(a)(b) = a+b  
val f = Sum(3)
f(4)
]]></programlisting>

</para>

<warning>
<para>
Clauses of a function may be defined with both curried arguments and patterns in arguments.
However, the combination of these two features can produce unintuitive behavior. Consider
the following clausal, curried function definition:

<programlisting language="orc-demo"><![CDATA[
def sum(x)(0) = x
def sum(x)(y) = x + y
sum(2)(3)
]]></programlisting>

One might expect <code>sum(2)(3)</code> to evaluate to <code>5</code>. However, this is not
the case; instead <code>sum(2)(3)</code> remains silent due to a pattern matching failure.
This is because the compiler always expands curried definitions before considering patterns,
so the above program is in fact equivalent to:

<programlisting language="orc-demo"><![CDATA[
def sum(x) = ( lambda(0) = x )
def sum(x) = ( lambda(y) = x + y )
sum(2)(3)
]]></programlisting>

Now the problem becomes apparent. The first clause will always match when the function is
applied to its first argument, and then only one clause is available when the second
argument is available: the clause with succeeds only on <code>0</code>.
</para>

<para>
Therefore, use caution when writing function definitions that use both currying and clauses.
</para>
</warning>

</section>

<!-- 
Can't find a compelling example for the use of this feature, so this section is commented for now.
However, it is still evident from the grammar that this capability exists.
 -->
<!-- 
<section><title>Expressions as call targets</title>

As a further generalization of calls, we can also write any expression as the target of a call.
In other words, rather than writing an identifier followed by some arguments, a call can even
be a whole expression, whose first publication is used as the site or function to be called.

<programlisting><![CDATA[
 
]]></programlisting>

If the arguments are also expressions, they are executed in parallel with the call target
expression. If the call target expression never publishes, no call occurs.

</section>
 -->

</section>

<section id="patterns.extensions"><title>Extensions to pattern matching</title>

<section><title>As pattern</title>

<para>
In taking apart a value with a pattern, it is often useful to capture intermediate results.

<programlisting><![CDATA[
val (a,b) = ((1,2),(3,4))
val (ax,ay) = a
val (bx,by) = b
]]></programlisting>

We can use the <code>as</code> keyword to simplify this program fragment, giving a name to an entire
sub-pattern. Here is an equivalent version of the above code.

<programlisting><![CDATA[
val ((ax,ay) as a, (bx,by) as b) = ((1,2),(3,4))
]]></programlisting>
</para>

</section>

<section><title>Equality pattern</title>

<para>
When a variable occurs in a pattern, it is bound to the value being matched against that pattern. What
if instead we would like to use the value of a bound variable as a test pattern, in a way similar to
a literal value like <code>0</code>? 
</para>

<para>
We can use an equality pattern to do this. An equality pattern is a variable name preceded by <code>=</code>.
Consider the following definition, which compares its argument to the value bound to variable <code>x</code>,
returning <code>true</code> if they are equal and <code>false</code> otherwise.

<programlisting><![CDATA[
def isx(=x) = true
def isx(_) = false
]]></programlisting>

</para>

<para>
The equality pattern becomes much more useful when it is embedded within other patterns. For example, consider
this definition <code>withz</code>. If one of the arguments passed to it is equal to <code>z</code>, then the function
returns its other argument. Otherwise it remains silent.

<programlisting><![CDATA[
def withz(=z,y) = y
def withz(x,=z) = x
]]></programlisting>

</para>

</section>

<!-- 
<section><title>Site pattern</title>

<para>
A site pattern, written <code>M(p,...,p)</code>, matches any value which was published by a call to the
site <code>M</code> with arguments that match the tuple <code>(p,...,p)</code>. Site patterns only work
for sites which have unique inverses; datatype patterns are a special case of site patterns.
</para>

<para>
Site patterns provide a generalized version of datatype matching, as seen in the <code>case .. of</code>
 or <code>match .. with </code> constructs provided by Haskell and ML.
</para> 

</section>


<section><title>Patterns as views</title>

<para>
In addition to matching data structures constructed within Orc, patterns can also be used to match
external data structures and values. In this setting, a pattern does not necessarily observe the
true structure of the data, but instead provides a <firstterm>view</firstterm> of that data.
</para>

<para>
For example, a list pattern can be used to view some sequentially structured data (such as lines
in a file) as if it were a list. The views allowed on a value are determined by the value itself;
for example, a value which does not support a list view will be refused by any list pattern it
is matched against.
</para>

<para>
The concept of views and view patterns is not new in programming languages; it has been demonstrated
in other languages, most notably <link xlink:href="http://www.scala-lang.org/">Scala</link>. In fact, the 
underlying implementation strategy for using sites as view patterns is very similar to the use of
extractor objects and the <code>unapply</code> method in Scala.
</para>

</section>
 -->

</section>



<section id="section.orc.datatypes"><title>Datatypes</title>

<para>
We have seen Orc's predefined data structures: tuples and lists. Orc also provides the capability
for programmers to define their own data structures, using a feature adopted from the ML/Haskell
language family called <firstterm>datatypes</firstterm> (also called variants or tagged sums).
</para>

<para>
Datatypes are defined using the <code>type</code> declaration:

<programlisting><![CDATA[
type Tree = Node(_,_,_) | Empty()
]]></programlisting>

</para>

<para>
This declaration defines two new sites named <code>Node</code> and <code>Empty</code>.
<code>Node</code> takes three arguments, and publishes a <emphasis>tagged value</emphasis>
wrapping those arguments. <code>Empty</code> takes no arguments and does the same.
</para>

<para>
Once we have created these tagged values, we use a new pattern called a datatype pattern
to match them and unwrap the arguments:

<programlisting><![CDATA[
type Tree = Node(_,_,_) | Empty()
{- Build up a small binary tree -}
val l = Node(Empty(), 0, Empty())
val r = Node(Empty(), 2, Empty())
val t = Node(l,1,r)

{- And then match it to extract its contents -}
t >Node(l,j,r)>
l >Node(_,i,_)>
r >Node(_,k,_)>
( i | j | k )
]]></programlisting>
</para>

<para>
One pair of datatypes is so commonly used that it is already predefined in the standard library:
<code>Some(_)</code> and <code>None()</code>. These are used as return values for calls that
need to distinguish between successfully returning a value (<code>Some(v)</code>), and successfully
completing but having no meaningful value to return (<code>None()</code>). For example, a lookup
function might return <code>Some(result)</code> if it found a result, or return <code>None()</code>
if it successfully performed the lookup but found no suitable result.
</para>

</section>


<section id="section.language.class"><title>Classes</title>

<para>
A <code>class</code> is an abstraction mechanism in Orc, much like the
<code>def</code> construct. It extends the <code>def</code> construct, by allowing
us to convert an Orc program fragment into a site. Specifically, a
class can be used to: (1) Define object classes with methods,
(2) Create new sites and extend behaviors of existing sites, (3) Allow
concurrent method invocation on objects, and (4) Create active
objects, whose executions may be based on time or other external
stimulus, not necessarily explicitly called methods. 
</para>
	
<para>
A class has the following properties:
<orderedlist>
<listitem>Encapsulation: Just like objects in an object-oriented language, classes 
	also provide the encapsulation facility for the programmer. The data defined inside 
	the class can only be accessed and modified through methods defined in class. Therefore, 
	it hides the representation of the data and implementation of functions and methods 
	which work on the data and manage the state. </listitem>
<listitem>Methods instead of functions: These are the gateways to access and manipulate the 
	data represented by class. They also enable the user of the class to access the service 
	provided by that. Unlike functions in Orc, methods defined in a class can only publish 
	one value. </listitem>
<listitem>Termination protection: The execution of a class and its methods are protected from 
	termination of the rest of the program. In other words, the execution of class cannot be 
	interrupted. In the pruning combinator as soon as the right hand side expression publishes a 
	value, all the on going executions in the right hand side will be terminated. However, if there 
	is any call to a class in the right hand side, that call will proceed until completion. For 
	example, in the following Orc expression, suppose that c is a class.
	<programlisting><![CDATA[
	 y <y< g() | c() 
]]></programlisting>
	If g() publishes a value before c() does, the execution of c() will continue. Although, the published 
	value of c() (if any) will never be used. On the other hand, if c() publishes a value first, then the 
	execution of g() will be interrupted since its execution is not protected. This property of classes is 
	very important to prevent the data corruption and invalid state of an object. We will see using an 
	example the significance of this property later on in the guide. 
</listitem>
	<listitem>Strict calls: unlike calls to ordinary function definitions in Orc, calls to class methods 
		are strict. This means that the call will not happen unless all the parameters are bound. </listitem>
</orderedlist>
</para>

<para>
A class definition can be translated to pure Orc calculus, making
use of the site <code>makesite</code>. (See <xref linkend="appendix.library"/> for details of <code>makesite</code>.)
</para>

<section><title>Object Definition</title>

<para>
To motivate the notion of class, we start with a simple example, 
defining a stack with methods <code>push</code> and <code>pop</code>. Below, parameter <code>n</code>
defines the maximum length of each instance of stack. We store the
stack elements in an array. Our implementation blocks an illegal
operation (a <code>push</code> on a full stack or a <code>pop</code> on an empty stack).  
</para>

<programlisting><![CDATA[
def class Stack(n) =
  val store = Table(n, Ref)
  val len = Ref (0) -- len is the current stack length

  def push(x) = ift(len? <: n) >> store(len?) := x >> len := len? + 1

  def pop() = ift(len? :> 0) >> len := len? - 1 >> store(len?)?

  {- class goal -} stop

----------- Test
val st = Stack(5)
st.push(3) >> st.push(5) >> st.pop() >> st.pop()
]]></programlisting>

</section>


<section><title>Class Syntax and Semantics</title>

<para>
A class is defined much like a a function. The keyword <code>class</code>
is used after <code>def</code>. A class may have parameters (including
other classes), as in a function definition. The body of a class
may include function and class definitions. The name of every definition
in the body of a class is exported. 
<!--
(a later version of Orc implementation will allow the programmer to specify the names to be
exported through an export list).
-->
</para>

<para>
A class definition obeys all the rules of function definition
except:

<orderedlist>
<listitem>A class definition must include at least one
definition (which could be a class definition),</listitem>

<listitem>A class's goal expression must not publish,</listitem>

<listitem>Each function defined within a class publishes at most once.</listitem>
</orderedlist>
</para>

<para>
A class call creates and publishes a site (recall that the goal
expression of a class must not publish). Thus, 

<programlisting><![CDATA[
val st = Stack(5)
]]></programlisting>

instantiates site <code>st</code>. Multiple instances of a
class may be created by calling the class multiple times. The
functions (and classes) defined in the body of the class are
externally accessed as dot methods.
</para>
</section>

<section><title>Notes</title>

<itemizedlist>
<listitem><para>
Clausal definition: A class may be defined as a set of
  clauses, exactly as a function definition. In this case all clauses
  must define the same names to be exported.
</para></listitem>

<listitem><para>
Concurrent calls to methods: Methods of a class instance may
  be invoked concurrently, as in functions. It is the obligation of
  the programmer to ensure that concurrent calls do not
  interfere. Calling the methods of stack <code>st</code> concurrently may
  result in unintended outcomes. For example, in  
<programlisting><![CDATA[
  st.push(3) >> st.pop() >> Rtimer(1000) >> st.pop()
| st.push(4) >> stop
]]></programlisting>
  the last <code>st.pop()</code> (in the first line) often does not succeed,
  because just one value was stored in the stack though there
  were two concurrent <code>st.push()</code> operations. 
</para></listitem>

<listitem><para>
Prune on class call: Like site calls, running class method invocations 
  are not terminated by the pruning combinator. In the following program,
  <code>x</code> is assigned value 3 because execution of <code>testprune().run()</code> never
  publishes. However,
  <code>testprune().run()</code> is treated as a site call which continues
  execution even after x is assigned a value. Eventually, the line
  <computeroutput>done</computeroutput> is printed.
<programlisting><![CDATA[
def class testprune() =
  def run() =  Rtimer(1000) >> println("done") >> stop
  stop

  val x =  Rtimer(50) >> 3 |  testprune().run()
  x
]]></programlisting>
</para></listitem>
</itemizedlist>
</section>

<section><title>Class Example</title>
	<para>
		The following shows the code for this sequence number generator in Orc: 
	</para>
	
	<programlisting><![CDATA[
-- the mutable integer defined with seed zero
val seq_num = Ref(0)
-- gen_seq will increase the seq_num and return the new value
def gen_seq() =
  seq_num := seq_num?+1 >> seq_num?
  
gen_seq() >s> println(s) >> gen_seq() >s> println(s) >> stop
]]></programlisting>
	
	<para>
		What is the problem with the above code? The first problem is that the seq_num is 
		exposed to all the expressions which come after it. This means that all those 
		expressions can possibly read and write the value of seq_num. This is not always 
		desirable and makes the reasoning about the program more difficult. The second issue 
		with this code is that it is not flexible enough. What if we want to have different 
		sequence number generator with a different initial seed? For example, we may want a 
		sequence number starting at 0 and another one starting at 1000.
	</para>

	<para>
		There is another issue associated with the above code from a concurrent programming 
		viewpoint. It is not thread safe. This means that if we make two parallel calls to 
		gen_seq(), we may get the same result. For example, the following piece of code: 
	</para>
	
		<programlisting><![CDATA[
gen_seq() | gen_seq()
]]></programlisting>
	
	<para> The above code can generate "1" as the publication for both expressions, and in most of the runs
		it will.  This is a famous phenomenon in parallel programming known as a race condition. 
		In fact, access to the shared variable seq_num is subject to race condition between 
		the two threads running the two calls to gen_seq(). To solve the race issue we need 
		to add a semaphore to the above code in order to regulate the access to the shared 
		variable, seq_num. Therefore, every call to gen_seq needs to acquire the semaphore in 
		order to update the variable and release the semaphore at the end. The new safe code 
		is as follows:  </para>
	
		<programlisting><![CDATA[
-- the mutable integer defined with seed zero
val seq_num = Ref(0)
-- a semaphore to regulate access to shared variable seq_num
val seq_num_sem = Semaphore(1)
-- gen_seq will increase the seq_num and return the new value
def gen_seq() =
  seq_num_sem.acquire() >> seq_num := seq_num?+1 >> 
  seq_num? >x> seq_num_sem.release() >> x
  
gen_seq() | gen_seq()
]]></programlisting>
	
	<para>
		The above code, besides the issue of encapsulation and the complexity of having more than 
		one sequence number generator, looks fine. However, there is a subtle problem with this code. 
		The problem is data corruption and invalid state which can be caused by abrupt termination 
		of the call to gen_seq(). Consider the following piece of code and corresponding execution order: 
	</para>
	
		<programlisting><![CDATA[
y <y< 1+1 | gen_seq()
		]]></programlisting>
	
		<programlisting><![CDATA[
1- 1+1
2- seq_num_sem.acquire()
3- y is bound to 2
4- terminate gen_seq()
		]]></programlisting>
	
	<para>
		As illustrated in the above execution sequence, the semaphore seq_num_sem got acquired but never 
		released because of abrupt termination. Therefore consecutive calls to gen_seq will never proceed 
		because they cannot acquire the semaphore. So, we need to somehow protect the execution of gen_seq. 
		Classes address all the above issues in a succinct way.
	</para>
	
	<para>
		The class solution to the sequence number generator is the following code:
	</para>
	
			<programlisting><![CDATA[
def class gen_seq(init) =
	-- the mutable integer defined with seed init
	val seq_num = Ref(init)
	-- the next function will increase the seq_num and return the new value
	def next() =
		seq_num := seq_num?+1 >> seq_num?
	signal

	val g = gen_seq(1000)

	g.next() >y> println(y) >> g.next() >y> println(y) >> stop
		]]></programlisting>
	
	<para>
		It is very easy to instantiate a new sequence number that starts with a different seed. We just need 
		to create a new instance of gen_seq with a different seed. The following code shows an example of creating 
		two sequence number generator with two different seeds. 
	</para>
	
		<programlisting><![CDATA[
val g0 = gen_seq(0)
val g1 = gen_seq(1000)

g0.next() >y> println(y) >> g1.next() >y> println(y) >> stop
		]]></programlisting>
	
	<para>
		Notice how easy it is to have a new sequence number generator. Comparatively, in a pure functional language where 
		we just have functions, we need to declare new declarations of seq_num to accomplish the job.
	</para>
	
	<para>
		Now, in order to solve the issue of thread safety, we want to add a semaphore to the class. Note that since 
		the execution of the class is protected we will not run into the problem of invalid state or data corruption 
		caused by abrupt termination. The following code shows the thread safe version of the sequence number generator. 
	</para>
	
	<programlisting><![CDATA[
def class gen_seq(init) =
	-- the mutable integer defined with seed init
	val seq_num = Ref(init)
	-- a semaphore to regulate access to shared variable seq_num
	val seq_num_sem = Semaphore(1)
	-- gen_seq will increase the seq_num and return the new value
	def next() =
		seq_num_sem.acquire() >> seq_num := seq_num?+1 >>
		seq_num? >x> seq_num_sem.release() >> x
	signal
		]]></programlisting>
	
</section>
	
<section id="section.language.class.examples"><title>More Class Examples</title>

<para>
Here we show a few more examples of class usage.
</para>
	
<section><title>Active Classes</title></section>
	<para>
		Class is an active entity. Active objects, unlike passive ones, have 
		their own thread of control. They can initiate a computation without receiving 
		a method call (in procedural languages) or a message (in languages with message 
		passing model). Note that this definition of active objects subsumes reactive 
		objects and actors. We said that the execution of class is protected from the 
		rest of the program. Here we want to clarify what do we mean by creation of the 
		class and when the class actually exists.
	</para>
	
	<para>
		A class exists as soon as all the parameters and free variables in the class 
		are bound to their values. Thereafter, any method on the class can be called. This 
		means that the creation process would not wait for goal expression of the class to 
		finish. Therefore, the creation of the class would return immediately. But the goal 
		expression continues to execute. The goal expression will not publish anything. However, 
		it can have side effects. For example, it could print something on the screen or it 
		can initiate some other processes and send and receive data to and/or from buffers. 
	</para>
	
	<para>
		The following example explains the notion of activeness of classes. We want to design a 
		clock that ticks every n (user specified) milliseconds. We want to be able to get the 
		number of ticks passed since the process started. The following example shows a class 
		implementation of this clock.
	</para>
	
		<programlisting><![CDATA[
def class nclock(n) = -- tick every n milliseconds
	-- tick_cnt counts the number of ticks
	val tick_cnt = Ref(0)
	-- getTick returns the number of ticks passed so far
	def getTick() = tick_cnt?
	metronome(n) >> tick_cnt:=tick_cnt?+1

	val ticker = nclock(250)
	-- prints a mutiple of 4 every one second
	Rtimer(1000) >> metronome(1000) >> ticker.getTick()
		]]></programlisting>
	
	<para>
		In this example, the class nclock has a tick counter tick_cnt that records the number of 
		ticks passed so far. The method getTick returns the number of ticks. The interesting point 
		about this class is its goal expression. The goal expression is a metronome that publish 
		a signal every n milliseconds. Each time a signal is issued it causes the tick_cnt to increase 
		by one. As can be seen, the goal expression would never stop. It keeps increasing the tick 
		counter for ever and a thread is always active in the nclock class instance. This program 
		keeps publishing the multiples of 4 starting from 4 upward. 
	</para>

<section><title>Multi-dimensional Matrix</title>

<para>
We declare a two dimensional matrix whose index ranges may span any
finite interval of integers. The same technique can be used to declare
any multi-dimensional matrix.
</para>

<programlisting><![CDATA[
def class Matrix((lo1, up1), (lo2, up2)) =
  val mat = Array((up1 - lo1 + 1) * (up2 - lo2 + 1))
  def access(i, j) = mat((i - lo1) * (up2 - lo2 + 1) + j)
  stop

----------------- Test
val A = Matrix((-2, 0), (-1, 3)).access
A(-1,2) := 5 >> A(-1, 2) := 3 >> A(-1, 2)?
]]></programlisting>

<para>
Note that we define matrix <code>A</code> to be the sole method, <code>access</code>, of the
class; this enables us to refer to matrix elements in the
traditional style.
</para>
</section>

<section><title>Create a new site</title>

<para>
We create a new site, bounded buffer, using <code>Buffer</code> and
<code>Semaphore</code> sites. The buffer stores the data items and the
semaphores are used to ensure proper blocking. Below, <code>n</code> is the
maximum buffer size, and <code>p</code> and <code>g</code> are semaphores whose values are the
number of empty and full positions, respectively. A <code>put</code> operation is
allowed only if <code>p > 0</code> and a <code>get</code> if <code>g > 0</code>.
</para>

<programlisting><![CDATA[
def class BBuffer(n) =
  val b = Buffer()
  val (p, g) = (Semaphore(n), Semaphore(0))
  def put(x) = p.acquire() >> b.put(x) >> g.release()
  def get() = g.acquire() >> b.get() >x> p.release() >> x
  stop
]]></programlisting>

<para>
Note that setting <code>n = 1</code> lets us define a 1-place buffer in which the
executions of 
<code>put</code> and <code>get</code> operations have to alternate.
</para>
</section>

<section><title>Extend functionality of existing site</title>

<para>
We add a <code>length</code> function to the <code>Buffer</code> site, that returns
its current length. 
</para>

<programlisting><![CDATA[
def class Channel() =
  val ch = Buffer()
  val chlen = Counter(0)

  def put(x) = ch.put(x) >> chlen.inc()
  def get() = ch.get() >x> chlen.dec() >> x
  def length() = chlen.value()
  stop
]]></programlisting>
</section>

<section><title>A Communication protocol; Rendezvous</title>

<para>
A set of senders and receivers communicate in the following manner. A
sender executes <code>send(v)</code> and a receiver <code>recv()</code>. The <code>send(v)</code> remains
blocked until some <code>recv()</code> operation is executed; similarly a
<code>recv()</code> is blocked until there is a corresponding <code>send(v)</code>. When both
<code>send(v)</code> and <code>recv()</code> operations are ready for execution,
the <code>recv()</code> operation receives data <code>v</code>, <code>send</code> receives a signal,
and both can then proceed.
</para>

<para>
We employ semaphore <code>s</code> on which the send operation blocks; <code>s</code> is released by
the receive operation. The sender then puts its data in a buffer and
the receiver reads from the buffer. 
</para>

<programlisting><![CDATA[
def class Rendezvous() =
  val (s,data) = (Semaphore(0), Buffer())
  def send(x) = s.acquire() >> data.put(x)
  def recv() = s.release() >> data.get()
  stop
]]></programlisting>

<para>
The following code fragment shows three threads that are forced to
execute their codes in a nearly sequential manner due to the restrictions
imposed by rendezvous.
</para>

<programlisting><![CDATA[
val group1 = Rendezvous()
val group2 = Rendezvous()

  group1.send(3)
| Rtimer(1000) >> group2.recv()
| group2.send(5) >> group1.recv()
]]></programlisting>
</section>

<section><title>A class operating in real time</title>

<para>
We create a class to mimic a stopwatch. A stopwatch allows the
following operations: 
<itemizedlist>
<listitem><code>start()</code>: (re)starts the stopwatch and publishes a signal</listitem>
<listitem><code>halt()</code>: stops and publishes current value on the stopwatch</listitem>
</itemizedlist>
</para>

<para>
We implement an instance of a stopwatch by assigning a new clock to it
(created by calling site <code>Clock()</code> that returns a new clock
with value 0). Additionally, two mutable variables are used with
the following meaning.
<itemizedlist>
<listitem><code>timeshown</code>: clock value when the stopwatch was last stopped,</listitem>
<listitem><code>laststart</code>: clock value when the stopwatch was last started.</listitem>
</itemizedlist>
Initially, both variable values are 0.
</para>

<programlisting><![CDATA[
def class Stopwatch() =
  val clk = Clock()
  val (timeshown, laststart) = (Ref(0), Ref(0))

  def start() = laststart := clk()

  def halt() = timeshown := timeshown? + (clk() - laststart?) >> timeshown?
  stop
]]></programlisting>

<para>
A useable implementation of stopwatch requires a more general
interface. It should allow <code>start</code> operation in the state where
the stopwatch is already running, and <code>halt</code> in a state where the
stopwatch is already halted. Additionally, an operation to determine
the staus of the stopwatch (running or not) should be provided. Such
an implementation is given for the library site, <code>Stopwatch</code>; see
 the <code>Stopwatch</code> site in <xref linkend="appendix.library"/>.  
</para>
</section>

</section>

</section>


<section><title>New forms of declarations</title>

<section id="section.orc.class"><title><code>class</code> declaration</title>

<para>
When Orc is run on top of an object-oriented programming language, classes
from that language may be used as sites in Orc itself, via the <code>class</code>
declaration. 
</para>

<para>
<programlisting><![CDATA[
{- Use the String class from Java's standard library as a site -}
class String = java.lang.String
val s = String("foo")
s.concat("bar")
]]></programlisting>
</para>

<para>
This program binds the variable <code>String</code> to Java's String class.
When it is called as a site, it constructs a new instance of String, passing
the given arguments to the constructor.
</para>

<para>
This instance of String is a Java object; its methods are called and its fields
are accessed using the dot (<code>.</code>) notation, just as one would expect
in Java.  For complete details of how Orc interacts with Java and Scala, see
<xref linkend="section.services.java"/>.
</para>
</section>


<section id="section.orc.include"><title><code>include</code> declaration</title>

<para>
It is often convenient to group related declarations into units that can be
shared between programs. The <code>include</code> declaration offers a simple
way to do this. It names a source file containing a sequence of Orc declarations;
those declarations are incorporated into the program as if they had textually
replaced the include declaration. An included file may itself contain 
<code>include</code> declarations.  Included files may come from local files, any
URI recognized by the Java library (http, https, ftp, etc.), and include resources
found in the Orc JAR files.
</para>

<para>
<programlisting><![CDATA[
{- Contents of fold.inc -}
def foldl(f,[],s) = s
def foldl(f,h:t,s) = foldl(f,t,f(h,s))

def foldr(f,l,s) = foldl(f,rev(l),s)
]]></programlisting>
</para>

<para>
<programlisting><![CDATA[
{- This is the same as inserting the contents of fold.inc here -}
include "fold.inc"

def sum(L) = foldl(lambda(a,b) = a+b, L, 0)

sum([1,2,3])
]]></programlisting>
</para>

<para>
Note that these declarations still obey the rules of lexical scope. Also, Orc 
does not detect shared declarations; if the same file is included twice, its 
declarations occur twice.
</para>

</section>

</section>

</section>


</chapter>


<chapter id="chapter.methodology"><title>Programming Methodology</title>

<para>
In <link linkend="chapter.language">Chapter 1</link>, we described the syntax and semantics of the Orc language. 
Now, we turn our attention to how the language is used in practice, with guidelines on style and programming 
methodology, including a number of common concurrency patterns.
</para>

<section><title>Syntactic and Stylistic Conventions</title>

<para>
In this section we suggest some syntactic conventions for writing Orc programs. None of these 
conventions are required by the parser; newlines are used only to disambiguate certain corner
cases in parsing, and other whitespace is ignored. However, following programming convention 
helps to improve the readability of programs, so that the programmer's intent is more readily apparent.
</para>

<!--
<section><title>Identifiers</title>

By convention, identifiers bound to sites should begin with a capital letter (e.g. <code>Rtimer</code>,
<code>Google</code>). Similarly, identifiers bound to functions which are strict and publish at 
most one value should also begin with a capital letter. Identifiers bound to functions which are not
strict, or may publish multiple values, should begin with a lowercase letter. Variable names
are typically lowercase but may be made uppercase if it seems stylistically appropriate.

</section>
 -->
 
<section><title>Parallel combinator</title> 
 
<para>
When the combined expressions are small, write them all on one line.

<programlisting>
<emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> | <emphasis role="bold">H</emphasis>
</programlisting>

Note that we do not need parentheses here, since <code>|</code> is fully associative and commutative.
</para>

<para>
When the combined expressions are large enough to take up a full line, write one expression
per line, with each subsequent expression aligned with the first and preceded by <code>|</code>. 
Indent the first expression to improve readability.

<programlisting>
  <emphasis role="bold">long expression</emphasis> 
| <emphasis role="bold">long expression</emphasis>
| <emphasis role="bold">long expression</emphasis>
</programlisting>
 
</para>

<para>
A sequence of parallel expressions often form the left hand side of a sequential combinator. 
Since the sequential combinator has higher precedence, use parentheses to group the
combined parallel expressions together. 


<programlisting>
( <emphasis role="bold">expression</emphasis> 
| <emphasis role="bold">expression</emphasis>
)<![CDATA[ >x> ]]>
<emphasis role="bold">another expression</emphasis>
</programlisting>
</para>

</section>

<section><title>Sequential combinator</title>

<para>
When the combined expressions are small, write a cascade of sequential combinators
all on the same line.
</para> 

<programlisting>
<emphasis role="bold">F</emphasis><![CDATA[ >x> ]]><emphasis role="bold">G</emphasis><![CDATA[ >y> ]]><emphasis role="bold">H</emphasis>
</programlisting>

<para>
Remember that sequential is right associative; in this example, <code>x</code> is bound in both G and H, and <code>y</code> is
bound in H.
</para>

<para>
When the combined expressions are large enough to take up a full line, write one expression
per line; each line ends with the combinator which binds the publications
produced by that line.

<programlisting>
<emphasis role="bold">long expression</emphasis> <![CDATA[ >x> ]]> 
<emphasis role="bold">long expression</emphasis> <![CDATA[ >y> ]]>
<emphasis role="bold">long expression</emphasis>
</programlisting>
 
</para>

<para>
For very long-running expressions, or expressions that span multiple lines, write
the combinators on separate lines, indented, between each expression. 

<programlisting>
<emphasis role="bold">very long expression</emphasis> 
 <![CDATA[ >x> ]]> 
<emphasis role="bold">very long expression</emphasis> 
 <![CDATA[ >y> ]]>
<emphasis role="bold">very long expression</emphasis>
</programlisting>
 
</para>

</section>

<section id="style.pruning"><title>Pruning combinator</title>

<para>
When the combined expressions are small, write them on the same line:

<programlisting>
<emphasis role="bold">F</emphasis><![CDATA[ <x< ]]><emphasis role="bold">G</emphasis>
</programlisting>

When multiple pruning combinators are used to bind multiple variables
(especially when the scoped expression is long), start each line with a 
combinator, aligned and indented, and continue with the expression.

<programlisting>
<emphasis role="bold">long expression</emphasis> 
 <![CDATA[ <x< ]]><emphasis role="bold">G</emphasis>
 <![CDATA[ <y< ]]><emphasis role="bold">H</emphasis>
</programlisting>

</para>

<para>
The pruning combinator is not often written in its explicit form
in Orc programs. Instead, the <code>val</code> declaration is often more
convenient, since it is semantically equivalent and mentions the variable
<code>x</code> before its use in scope, rather than after.

<programlisting>
val x = <emphasis role="bold">G</emphasis>
val y = <emphasis role="bold">H</emphasis>
<emphasis role="bold">long expression</emphasis> 
</programlisting>

</para>

<para>
Additionally, when the variable is used in only one place, and the
expression is small, it is often easier to use a nested expression.
For example,

<programlisting>
val x = <emphasis role="bold">G</emphasis>
val y = <emphasis role="bold">H</emphasis>
M(x,y)
</programlisting>

is equivalent to

<programlisting>
M(<emphasis role="bold">G</emphasis>,<emphasis role="bold">H</emphasis>)
</programlisting>

</para>

<para>
Sometimes, we use the pruning combinator simply for its capability to terminate
expressions and get a single publication; binding a variable is irrelevant. This
is a special case of nested expressions. We use the identity site <code>let</code>
to put the expression in the context of a function call.
</para>

<para>
For example,

<programlisting>
x<![CDATA[ <x< ]]><emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> | <emphasis role="bold">H</emphasis>
</programlisting>

is equivalent to

<programlisting>
let(<emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> | <emphasis role="bold">H</emphasis>)
</programlisting>
</para>

<para>
The translation uses a pruning combinator, but we don't need to write the combinator, 
name an irrelevant variable, or worry about precedence (since the expression is enclosed
in parentheses as part of the call).
</para>

</section>

<section><title>Declarations</title>

<!--
<para>
Declarations should always end with a newline. 

<programlisting>
def add(x,y) = x + y
val z = 7
add(z,z)
</programlisting>

While the parser does not require a newline to end a declaration, it uses the 
newline to disambiguate certain corner cases in parsing, such as function application.
</para>
-->
	
<para>
When the body of a declaration spans multiple lines, start the body on a new line
after the <code>=</code> symbol, and indent the entire body.

<programlisting>
def f(x,y) =
    <emphasis role="bold">declaration</emphasis>
    <emphasis role="bold">declaration</emphasis>
    <emphasis role="bold">body expression</emphasis>
</programlisting>

</para>

<para>
Apply this style recursively; if a def appears within a def, indent its contents even further.

<programlisting>
def f(x,y) =
    <emphasis role="bold">declaration</emphasis>
    def helper(z) =
    	<emphasis role="bold">declaration in helper</emphasis>
    	<emphasis role="bold">declaration in helper</emphasis>
    	<emphasis role="bold">body of helper</emphasis>
    <emphasis role="bold">declaration</emphasis>
    <emphasis role="bold">body expression</emphasis>
</programlisting>


</para>

	<section><title>Ambiguous Declarations</title>

<para> The following situation could introduce syntactic ambiguity: the end
of a declaration (def or val) is followed by an expression that starts with a
non-alphanumeric symbol. Consider these example programs:
</para>

<para>
<programlisting><![CDATA[
def f() =       -- example 1
  def g() = h
  (x,y)
]]></programlisting>
</para>
		
<para>
<programlisting><![CDATA[
def f() =       -- example 2
  val t = h
  (x,y)
]]></programlisting>
</para>
		
<para>
<programlisting><![CDATA[
def f() =       -- example 3
  val t = u
  -3
]]></programlisting>
</para>
		
<para>  <code>(x,y)</code> may be interpreted as the parameter list of <code>h</code>, and <code>-3</code> as
continuation of <code>u</code>, or they may be regarded as completely
separate expressions (in this case, the goal expression of <code>def f</code>). To avoid this ambiguity, 
Orc imposes the following syntactic constraint:
</para>
		
<para><code>An expression that follows a declaration begins with an alphanumeric symbol</code></para>
	
<para>To circumvent this restriction, if (x,y) is an expression that follows a declaration, 
write it as <code>signal >> (x,y)</code>. Similarly, write <code>signal >> -3</code>, in case <code>-3</code> is
the goal expression in the above example.  Note that there are many solutions to this problem; for example
using <code>stop | (x,y)</code> is also valid.</para>

</section>
	
</section>

</section>



<section><title>Programming Idioms</title>

<para>
In this section we give Orc implementations of some standard idioms from
concurrent and functional programming. Despite the austerity of Orc's four
combinators, we are able to encode a variety of idioms straightforwardly.
</para>

<section><title>Channels</title>

<para>
Orc has no communication primitives like pi-calculus
channels<footnote><para>R. Milner. <emphasis>Communicating and Mobile Systems:
the &#960;-Calculus</emphasis>. Cambridge University Press, May
1999.</para></footnote> or Erlang mailboxes<footnote><para>J. Armstrong, R.
Virding, C. Wikstr¨om, and M. Williams. <emphasis>Concurrent programming in
ERLANG (2nd ed.)</emphasis>. Prentice Hall International (UK) Ltd.,
Hertfordshire, UK, UK, 1996.</para></footnote>. Instead, it makes use of sites
to create channels of communication. 
</para>

<para>
The most frequently used of these sites is <code>Buffer</code>. When called, it
publishes a new asynchronous FIFO channel. That channel is a site with two
methods: <code>get</code> and <code>put</code>.  The call <code>c.get()</code>
takes the first value from channel <code>c</code> and publishes it, or blocks
waiting for a value if none is available. The call <code>c.put(v)</code> puts
<code>v</code> as the last item of <code>c</code> and publishes a signal.
</para>

<para>
A channel may be closed to indicate that it will not be sent any more values.
If the channel <code>c</code> is closed, <code>c.put(v)</code> always halts
(without modifying the state of the channel), and <code>c.get()</code> halts
once <code>c</code> becomes empty. The channel <code>c</code> may be closed by
calling either <code>c.close()</code>, which returns a signal once
<code>c</code> becomes empty, or <code>c.closenb()</code>, which returns a
signal immediately.
</para>

</section>

<section><title>Lists</title>

<para>
In the section on Cor, we were introduced to lists: how to construct them,
and how to match them against patterns. While it is certainly feasible to
write a specific function with an appropriate pattern match every time we
want to access a list, it is helpful to have a handful of common operations
on lists and reuse them.
</para>

<para>
One of the most common uses for a list is to send each of its elements through
a sequential combinator. Since the list itself is a single value, we want
to walk through the list and publish each one of its elements in parallel
as a value. The library function <code>each</code> does exactly that.
</para>

<para>
Suppose we want to send the message <code>invite</code> to each email
address in the list <code>inviteList</code>:

<programlisting><![CDATA[
each(inviteList) >address> Email(address, invite)
]]></programlisting>

</para>


<para>
Orc also adopts many of the list idioms of functional programming. The Orc library contains definitions
for most of the standard list functions, such as <code>map</code> and <code>fold</code>. Many of the
list functions internally take advantage of concurrency to make use of any available parallelism; for
example, the <code>map</code> function dispatches all of the mapped calls concurrently, and assembles
the result list once they all return using a fork-join.
</para>

</section>

<section id="methodology.streams"><title>Streams</title>

<para>
Sometimes a source of data is not explicitly represented by a list or other data structure. Instead,
it is made available through a site, which returns the values one at a time, each time it is called.
We call such a site a <firstterm>stream</firstterm>. It is analogous to an iterator in a language 
like Java. Functions can also be used as streams, though typically they will not be pure functions,
and should only return one value. A call to a stream may halt, to indicate that the end of the data
has been reached, and no more values will become available. It is often useful to detect the
end of a stream using the otherwise combinator. 
</para>

<para>
Streams are common enough in Orc programming that there is a library function to take all of the
available publications from a stream; it is called <code>repeat</code>, and it is analogous to
<code>each</code> for lists.
</para>

<programlisting><![CDATA[
def repeat(f) = f() >x> (x | repeat(f))
]]></programlisting>

<para>
The <code>repeat</code> function calls the site or function <code>f</code> with no arguments,
publishes its return value, and recurses to query for more values. <code>repeat</code> should
be used with sites or functions that block until a value is available. Notice that if any
call to <code>f</code> halts, then <code>repeat(f)</code> consequently halts. 
</para>

<para>
For example, it is very easy to treat a channel <code>c</code> as a stream, reading any 
values put on the channel as they become available:

<programlisting><![CDATA[
repeat(c.get)
]]></programlisting>

</para>

<!-- An example of a site that creates streams would be great; file I/O maybe? -->

</section>


<section><title>Mutable References</title>

<para>
Variables in Orc are immutable. There is no assignment operator, and there is no way to
change the value of a bound variable. However, it is often useful to have mutable state
when writing certain algorithms. The Orc library contains two sites that offer simple 
mutable storage: <code>Ref</code> and <code>Cell</code>. It also provides the site <code>Array</code>
to create mutable arrays.
</para>

<para>
A word of caution: References, cells, and other mutable objects may be accessed concurrently
by many different parts of an Orc program, so race conditions may arise. 
</para> 


<section><title>Rewritable references</title>
<para>
The <code>Ref</code> site creates rewritable reference cells.

<programlisting language="orc-demo"><![CDATA[
val r = Ref(0)
println(r.read()) >>
r.write(2) >> 
println(r.read()) >>
stop
]]></programlisting>

</para>

<para>
These are very similar to ML's <code>ref</code> cells. <code>r.write(v)</code> stores
the value <code>v</code> in the reference <code>r</code>, overwriting any previous
value, and publishes a signal. <code>r.read()</code> publishes the current value stored
in <code>r</code>.
</para>

<para>
However, unlike in ML, a reference cell can be left initially empty by calling <code>Ref</code>
with no arguments. A read operation on an empty cell blocks until the cell is written.

<programlisting language="orc-demo"><![CDATA[
{- Create a cell, and wait 1 second before initializing it. -}
{- The read operation blocks until the write occurs. -}
val r = Ref()
r.read() | Rtimer(1000) >> r.write(1) >> stop
]]></programlisting>

</para>

</section>

<section><title>Write-once references</title>

<para>
The Orc library also offers write-once reference cells, using the <code>Cell</code> site.
A write-once cell has no initial value. Read operations block until the cell has been
written. A write operation succeeds only if the cell is empty; subsequent write operations
simply halt.

<programlisting language="orc-demo"><![CDATA[
{- Create a cell, try to write to it twice, and read it -}
{- The read will block until a write occurs
   and only one write will succeed. -}
val r = Cell()
  Rtimer(1000) >> r.write(2) >> println("Wrote 2") >> stop
| Rtimer(1000) >> r.write(3) >> println("Wrote 3") >> stop
| r.read()
]]></programlisting>

Write-once cells are very useful for concurrent programming, and they are often safer
than rewritable reference cells, since the value cannot be changed once it has been
written. The use of write-once cells for concurrent programming is not a new idea;
they have been studied extensively in the context of the 
<link xlink:href="http://en.wikipedia.org/wiki/Oz_programming_language">Oz programming language</link>.
</para>

</section>


<section><title>Reference syntax</title>

<para>Orc provides syntactic sugar for reading and writing mutable storage:</para>

<itemizedlist>
<listitem><code>x?</code> is equivalent to <code>x.read()</code>. This operator
is of equal precedence with the dot operator and function application, so
you can write things like <code>x.y?.v?</code>. This operator is very similar
to the C languages's <code>*</code> operator, but is postfix instead of prefix.
	</listitem>
<listitem><code>x := y</code> is equivalent to <code>x.write(y)</code>.
This operator has higher precedence than the concurrency combinators and if/then/else,
but lower precedence than any of the other operators.</listitem>
</itemizedlist>

<para>Here is a previous example rewritten using this syntactic sugar:</para>

<programlisting language="orc-demo"><![CDATA[
{- Create a cell, try to write to it twice, and read it -}
{- The read will block until a write occurs
   and only one write will succeed. -}
val r = Cell()
  Rtimer(1000) >> r := 2 >> println("Wrote 2") >> stop
| Rtimer(1000) >> r := 3 >> println("Wrote 3") >> stop
| r?
]]></programlisting>

</section>

<section><title>Arrays</title>

<para>
While lists are a very useful data structure, they are not mutable, and they are not indexed. However, 
these properties are often needed in practice, so the Orc standard library provides a function 
<code>Array</code> to create mutable arrays. 
</para>

<para>
<code>Array(n)</code> creates an array of size <code>n</code> whose elements are all initially <code>null</code>. 
The array is used like a function; the call <code>A(i)</code> returns the <code>i</code>th element of the array 
<code>A</code>, which is then treated as a reference, just like the references created by <code>Ref</code>. A call 
with an out-of-bounds index halts, possibly reporting an error. 
</para>

<para>

The following program creates an array of size 10, and initializes each index i with the
ith power of 2. It then reads the array values at indices 3, 6, and 10. The read at index 10
halts because it is out of bounds (arrays are indexed from 0).

<programlisting language="orc-demo"><![CDATA[
val a = Array(10)
def initialize(i) = 
  if (i < 10) 
    then a(i) := 2 ** i  >>  initialize(i+1)
    else signal
initialize(0) >> (a(3)? | a(6)? | a(10)?)
]]>
</programlisting>

</para>

<para>

The standard library also provides a helper function <code>fillArray</code> which makes array initialization
easier. <code>fillArray(a, f)</code> initializes array <code>a</code> using function <code>f</code> by setting
element <code>a(i)</code> to the first value published by <code>f(i)</code>. When the array is fully
initialized, <code>fillArray</code> returns the array <code>a</code> that was passed (which makes it easier to
simultaneously create and initialize an array). Here are a few examples:

<programlisting language="orc-demo">
{- Create an array of 10 elements; element i is the ith power of 2 -}
fillArray(Array(10), lambda(i) = 2 ** i)
</programlisting>

<programlisting language="orc-demo">
{- Create an array of 5 elements; each element is a newly created buffer -}
fillArray(Array(5), lambda(_) = Buffer())
</programlisting>

<programlisting language="orc-demo">
{- Create an array of 2 channels -}
val A = fillArray(Array(2), lambda(_) = Buffer())

{- 
   Send true on channel 0,
   listen for a value on channel 0 and forward it to channel 1, 
   and listen for a value on channel 1 and publish it. 
-}
  A(0)?.put(true) >> stop
| A(0)?.get() >x> A(1)?.put(x) >> stop
| A(1)?.get()
</programlisting>
</para>


<para>
Since arrays are accessed by index, there is a library function specifically
designed to make programming with indices easier. The function <code>upto(n)</code> 
publishes all of the numbers from <code>0</code> to
<code>n-1</code> simultaneously; thus, it is very easy to access all of the elements of
an array simultaneously. Suppose we have an array <code>A</code> of <code>n</code> email 
addresses and would like to send the message <code>m</code> to each one.

<programlisting><![CDATA[
upto(n) >i> A(i)? >address> Email(address, m)
]]></programlisting>

</para>

</section>

</section>

<section><title>Loops</title>

<para>
Orc does not have any explicit looping constructs. Most of the time, where a loop
might be used in other languages, Orc programs use one of two strategies: 
</para>

<orderedlist>

<listitem>When the iterations of the loops can occur in parallel, write an expression
that expands the data into a sequence of publications, and
use a sequential operator to do something for each publication. This is the strategy
that uses functions like <code>each</code>, <code>repeat</code>, and <code>upto</code>.
</listitem>
<listitem>When the iterations of the loops must occur in sequence, write a tail
recursive function that iterates over the data. Any loop can be rewritten as a 
tail recursion. Typically the data of interest is in a list, so one of the standard
list functions, such as <code>foldl</code>, applies. The library also defines a
function <code>while</code>, which handles many of the common use cases of
while loops.
</listitem>
</orderedlist>

</section>

<section><title>Parallel Matching</title>

<para>
Matching a value against multiple patterns, as we have seen it so far, is a linear
process, and requires a <code>def</code> whose clauses have patterns in their
argument lists. Such a match is linear; each pattern is tried in order until
one succeeds.
</para>

<para>
What if we want to match a value against multiple patterns in parallel, executing
every clause that succeeds? Fortunately, this is very easy to do in Orc. Suppose
we have an expression F which publishes pairs of integers, and we want to publish
a signal for each 3 that occurs. 
</para>

<para>
We could write:

<programlisting>
<emphasis role="bold">F</emphasis><![CDATA[ >(x,y)>
  ( if(x=3) >> signal
  | if(y=3) >> signal ) 
]]>
</programlisting>

But there is a more general alternative:

<programlisting>
<emphasis role="bold">F</emphasis><![CDATA[ >x>
  ( x >(3,_)> signal
  | x >(_,3)> signal ) 
]]>
</programlisting>

The interesting case is the pair <code>(3,3)</code>, which is counted twice
because both patterns match it in parallel.
</para>

<para>
This parallel matching technique is sometimes used as an alternative to pattern matching using function
clauses, but only when the patterns are mutually exclusive.
</para>

<para>

For example,

<programlisting  language="orc-demo">
def helper([]) = 0
def helper([_]) = 1
def helper(_:_:_) = 2
helper([4,6])
</programlisting>

is equivalent to

<programlisting  language="orc-demo"><![CDATA[
[4,6] >x>
  x >[]> 0
| x >[_]> 1
| x >_:_:_> 2
]]></programlisting>

whereas

<programlisting  language="orc-demo">
def helper([]) = 0
def helper([_]) = 1
def helper(_) = 2
helper([5])
</programlisting>

is <emphasis>not</emphasis> equivalent to

<programlisting language="orc-demo"><![CDATA[
[5] >x>
  x >[]> 0
| x >[_]> 1
| x >_> 2
]]></programlisting>

because the clauses are not mutually exclusive. Function clauses must attempt to match in linear order, whereas
this expression matches all of the patterns in parallel. Here, it will match <code>[5]</code> two different ways,
publishing both <code>1</code> and <code>2</code>.
</para>

</section>

<section><title>Fork-join</title>

<para>
One of the most common concurrent idioms is a <firstterm>fork-join</firstterm>: run two processes concurrently,
and wait for a result from each one. This is very easy to express in Orc. Whenever we write a <code>val</code>
declaration, the process computing that value runs in parallel with the rest of the program. So if we write
two <code>val</code> declarations, and then form a tuple of their results, this performs a fork-join.
</para>

<para>
<programlisting>
val x = <emphasis role="bold">F</emphasis>
val y = <emphasis role="bold">G</emphasis>
   signal >> (x,y)
</programlisting>
</para>

<para>
Fork-joins are a fundamental part of all Orc programs, since they are created by all nested expression
translations. In fact, the fork-join we wrote above could be expressed even more simply as just:
</para>

<para>
<programlisting>
(<emphasis role="bold">F</emphasis>,<emphasis role="bold">G</emphasis>)
</programlisting>
</para>


<section><title>Example: Machine initialization</title>

<para>
In Orc programs, we often use fork-join and recursion together to dispatch many tasks in parallel and wait
for all of them to complete. Suppose that given a machine <code>m</code>, calling <code>m.init()</code> 
initializes <code>m</code> and then publishes a signal when initialization is complete. The function 
<code>initAll</code> initializes a list of machines.
</para>

<programlisting><![CDATA[
def initAll([]) = signal
def initAll(m:ms) = ( m.init() , initAll(ms) ) >> signal
]]></programlisting>

<para>
For each machine, we fork-join the initialization of that machine (<code>m.init()</code>) with the initialization
of the remaining machines (<code>initAll(ms)</code>). Thus, all of the initializations proceed in parallel, and
the function returns a signal only when every machine in the list has completed its initialization. 
</para>

<para>
Note that if some machine fails to initialize, and does not return a signal, then the initialization procedure
will never complete. 
</para> 

</section>

<section id="example.auction"><title>Example: Simple parallel auction</title>

<para>
We can also use a recursive fork-join to obtain a value, rather than just signaling completion. Suppose we
have a list of bidders in a sealed-bid, single-round auction. Calling <code>b.ask()</code> requests a bid
from the bidder <code>b</code>. We want to ask for one bid from each bidder, and then return the highest
bid. The function <code>auction</code> performs such an auction for a list of bidders (<code>max</code> 
finds the maximum of its arguments):
</para>

<programlisting><![CDATA[
def auction([]) = 0
def auction(b:bs) = max(b.ask(), auction(bs))
]]></programlisting>

</section>

<para>
Note that all bidders are called simultaneously. Also note that if some bidder fails 
to return a bid, then the auction will never complete.  Later we will see
a <link linkend="example.auction-with-timeout">different solution</link> that addresses the issue of non-termination.
</para>

<section><title>Example: Barrier synchronization</title>

<para>
Consider an expression of the following form, where F and G are expressions and M and N are sites:

<programlisting>
M() <![CDATA[ >x> ]]> <emphasis role="bold">F</emphasis> | N() <![CDATA[ >y> ]]> <emphasis role="bold">G</emphasis>
</programlisting>

</para>

<para>
Suppose we would like to <emphasis>synchronize</emphasis> F and G, so that both start
executing at the same time, after both <code>M()</code> and <code>N()</code> respond.  This is easily done
using the fork-join idiom. In the following, we assume that <code>x</code> does not occur
free in G, nor <code>y</code> in F.

<programlisting>
( M() , N() ) <![CDATA[ >(x,y)> ]]> ( <emphasis role="bold">F</emphasis> | <emphasis role="bold">G</emphasis> )
</programlisting>

</para>

</section>

</section>

<section><title>Sequential Fork-Join</title>

<para>
Previous sections illustrate how Orc can use the fork-join idiom to process a
fixed set of expressions or a list of values.  Suppose that instead we wish to
process all the publications of an expression F, and once this processing is
complete, execute some expression G.  For example, F publishes the contents
of a text file, one line at a time, and we wish to print each line to the
console using the site <code>println</code>, then publish a signal after all lines
have been printed.
</para>

<para>
Sequential composition alone is not sufficient, because we have no way to
detect when all of the lines have been processed.  A recursive fork-join
solution would require that the lines be stored in a traversable data structure
like a list, rather than streamed as publications from F.  A better solution
uses the <code>;</code> combinator to detect when processing is complete:
</para>

<programlisting>
<emphasis role="bold">F</emphasis> >x> println(x) >> stop ; signal
</programlisting>

<para>
Since <code>;</code> only evaluates its right side if the left side does not publish,
we suppress the publications on the left side using <code>stop</code>. Here, we
assume that we can detect when F halts. If, for example,
F is publishing the lines of the file as it receives them over a socket,
and the sending party never closes the socket, then F never halts and no
signal is published.
</para>
</section>

<section><title>Priority Poll</title>

<para>
The otherwise combinator is also useful for trying alternatives in sequence. Consider an expression of
the form <code>F<subscript>0</subscript> ; F<subscript>1</subscript> ; F<subscript>2</subscript> ; ...</code>. If F<subscript>i</subscript> does not publish 
and halts, then F<subscript>i+1</subscript> is executed. We can think of the F<subscript>i</subscript>'s as a series of 
alternatives that are explored until a publication occurs.
</para>

<para>
Suppose that we would like to poll a list of buffers for available data.  The
list of buffers is ordered by priority. The first buffer in the list has the
highest priority, so it is polled first.  If it has no data, then the
next buffer is polled, and so on.
</para>

<para>
Here is a function which polls a prioritized list of buffers in this way. It
publishes the first item that it finds, removing it from the originating
buffer. If all buffers are empty, the function halts.  We use the <code>getnb</code> ("get non-blocking") method of the buffer, which retrieves the first
available item if there is one, and halts otherwise.
</para>

<programlisting>
def priorityPoll([]) = stop
def priorityPoll(b:bs) = b.getnb() ; priorityPoll(bs)
</programlisting>
</section>

<section><title>Parallel Or</title>

<para>
``Parallel or'' is a classic idiom of parallel programming.  The ``parallel or'' operation executes two
expressions F and G in parallel, each of which may publish a single boolean,
and returns the disjunction of their publications as soon as possible. 
If one of the expressions publishes <code>true</code>, then the disjunction is <code>true</code>, 
so it is not necessary to wait for the other expression to publish a value. 
This holds even if one of the expressions is silent.
</para>

<para>
The ``parallel or'' of expressions F and G may be expressed in Orc as
follows:
</para>

<programlisting>
let(
    val a = <emphasis role="bold">F</emphasis>
    val b = <emphasis role="bold">G</emphasis>
      signal >> (a || b)
       | if(a)<![CDATA[ >> ]]>true 
       | if(b)<![CDATA[ >> ]]>true 
)
</programlisting>

<para>
The expression <code>(a || b)</code> waits for both <code>a</code> and <code>b</code> to become
available and then publishes their disjunction.  However if either <code>a</code> or
<code>b</code> is true we can publish <code>true</code> immediately regardless of whether the
other variable is available.  Therefore we run <code>if(a) >> true</code> and <code>if(b) >> true</code>
in parallel to wait for either variable to become <code>true</code> and immediately
publish the result <code>true</code>.  Since more than one of these expressions may
publish <code>true</code>, the surrounding <code>let(...)</code> is necessary to select and
publish only the first result.
</para>

</section>


<section><title>Timeout</title>

<para>
<firstterm>Timeout</firstterm>, the ability to execute an expression for at most a specified
amount of time, is an essential ingredient of fault-tolerant and distributed
programming.  Orc accomplishes timeout using pruning and the <code>Rtimer</code> site.
The following program runs F for at most one second, publishing its result if
available and the value <code>0</code> otherwise.
</para>

<programlisting>
let( <emphasis role="bold">F</emphasis> | Rtimer(1000)<![CDATA[ >> ]]>0 )
</programlisting>


<section id="example.auction-with-timeout"><title>Auction with timeout</title>

<para>
In the <link linkend="example.auction">auction example</link> given previously, the auction may never complete if 
one of the bidders does not respond. We can add a timeout so that a bidder has at most 8 seconds to provide a bid:
</para>

<programlisting><![CDATA[
def auction([]) = 0
def auction(b:bs) = 
  val bid = b.ask() | Rtimer(8000) >> 0
  max(bid, auction(bs))
]]></programlisting>

<para>
This version of the auction is guaranteed to complete within 8 seconds.
</para>

</section>


<section><title>Detecting timeout</title>

<para>
Sometimes, rather than just yielding a default value, we would like to
determine whether an expression has timed out, and if so, perform some other
computation.  To detect the timeout, we pair the result of the original
expression with <code>true</code> and the result of the timer with <code>false</code>.
Thus, if the expression does time out, then we can distinguish that case
using the boolean value.
</para>

<para>
Here, we run expression F with a time limit <code>t</code>. If it publishes
within the time limit, we bind its result to <code>r</code> and execute G.
Otherwise, we execute H.

<programlisting>
val (r, b) = (<emphasis role="bold">F</emphasis>, true) | (Rtimer(t), false)
if b then <emphasis role="bold">G</emphasis> else <emphasis role="bold">H</emphasis>
</programlisting>

Instead of using a boolean and conditional, we could use pattern matching:

<programlisting><![CDATA[
val s = Some(]]><emphasis role="bold">F</emphasis><![CDATA[) | Rtimer(t) >> None()
  s >Some(r)> ]]><emphasis role="bold">G</emphasis><![CDATA[
| s >None()>  ]]><emphasis role="bold">H</emphasis>
</programlisting>

</para>

<para>

It is even possible to encapsulate timeout as a function.

<programlisting><![CDATA[
def timeout(x, t) = let(Some(x) | Rtimer(t) >> None())
]]></programlisting>

<code><![CDATA[timeout(]]><emphasis role="bold">F</emphasis><![CDATA[, t)]]></code> waits 
<code>t</code> milliseconds for F to publish a value. If F publishes <code>v</code> within
the time limit, <code>timeout</code> returns <code>Some(v)</code>. Otherwise, it returns
<code>None()</code> when the time limit is reached.

</para>

<section><title>Timeout streams</title>

<para>
We can also apply timeout to <link linkend="methodology.streams">streams</link>. Let's
define a modified version of the <code>repeat</code> function as follows:

<programlisting><![CDATA[
def repeatWithTimeout(f, t) = 
  timeout(f(), t) 
    >Some(x)> 
  (x | repeatWithTimeout(f, t))

]]></programlisting>
</para>

<para>
We call <code>f()</code> as before, but apply a timeout of <code>t</code> to the call.
If a value becomes available from <code>f</code> before the timeout, then the call to
<code>timeout</code> publishes <code>Some(x)</code>, which we match, and then publish
<code>x</code> and recursively wait for further values from the stream.
</para>

<para>
However, if no value is available from <code>f</code> within the timeout, the call 
to <code>timeout</code> publishes <code>None()</code>. Since <code>None()</code> does 
not match the pattern, the entire expression halts, indicating that the end of the
stream has been reached.
</para>

<para>
It is also possible to achieve this behavior with the existing <code>repeat</code> function,
simply by changing the function passed to <code>repeat</code>:

<programlisting><![CDATA[
def f'() = timeout(f(), t) >Some(x)> x
repeat(f')
]]></programlisting>

</para>


</section>
 
</section>

</section>

<section><title>Priority</title>

<para>
We can use a timer to give a window of priority to one computation over
another.  In this example, we run expressions F and G concurrently.  For
one second, F has priority; F's result is published immediately,
but G's result is held until the time interval has elapsed.  If neither F nor
G publishes a result within one second, then the first result from either
is published.

<programlisting>
val x = <emphasis role="bold">F</emphasis>
val y = <emphasis role="bold">G</emphasis>
let( y | Rtimer(1000) >> x )
</programlisting>

</para>

</section>


<section><title>Metronome</title>

<para>
A timer can be used to execute an expression repeatedly at regular
intervals, for example to poll a service.
Recall the definition of <code>metronome</code> from the previous chapter:

<programlisting><![CDATA[
def metronome(t) = signal | Rtimer(t) >> metronome()
]]></programlisting>
</para>

<para>
The following example publishes "tick" once per second and "tock" once per
second after an initial half-second delay.  The publications alternate: "tick
tock tick tock ...". Note that this program is not defined recursively;
the recursion is entirely contained within <code>metronome</code>.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
  metronome(1000) >> "tick"
| Rtimer(500) >> metronome(1000) >> "tock"
]]></programlisting>
</para>

</section>





<section><title>Routing</title>

<para>
The Orc combinators restrict the passing of values among their component
expressions. However, some programs will require greater
flexibility.  For example, <code>F &lt;x&lt; G</code> provides F with the first 
publication of G, but what if F needs the first n publications of G?  
In cases like this we use channels or other stateful sites to redirect or 
store publications.  We call this technique <firstterm>routing</firstterm>
because it involves routing values from one execution to another.
</para>

<section><title>Generalizing Termination</title>

<para>
The pruning combinator terminates an expression after it publishes its first
value. We have <link linkend="style.pruning">already seen</link> how to use 
pruning just for its termination capability, without binding a variable, using 
the <code>let</code> site. Now, we use routing to terminate an expression
under different conditions, not just when it publishes a value; it may
publish many values, or none, before being terminated.
</para>

<para>
Our implementation strategy is to route the publications of the expression
through a channel, so that we can put the expression inside a pruning combinator
and still see its publications without those publications terminating the
expression. 
</para>

<section><title>Enhanced Timeout</title>

<para>
As a simple demonstration of this concept, we construct a more powerful form 
of timeout: allow an expression to execute, publishing arbitrarily many values 
(not just one), until a time limit is reached.
</para>

<programlisting>
val c = Buffer()
repeat(c.get)<![CDATA[ << ]]>
    <emphasis role="bold">F</emphasis><![CDATA[ >x> c.put(x) >> stop 
  | Rtimer(1000) >> c.closenb()]]></programlisting>

<para>
This program allows F to execute for one second and then terminates it. Each
value published by F is routed through channel <code>c</code> so that it does
not terminate F. After one second, <code>Rtimer(1000)</code> responds,
triggering the call <code>c.closenb()</code>.  The call
<code>c.closenb()</code> closes <code>c</code> and publishes a signal,
terminating F.  The library function <code>repeat</code> is used to repeatedly
take and publish values from <code>c</code> until it is closed.
</para>

</section>


<section><title>Test Pruning</title>

<para>
We can also decide to terminate based on the values published. This expression
executes F until it publishes a negative number, and then terminates it:
</para>

<programlisting>
val c = Buffer()
repeat(c.get)<![CDATA[ << ]]>
  <emphasis role="bold">F</emphasis><![CDATA[ >x> 
    (if x >= 0 
        then c.put(x) >> stop
        else c.closenb())]]>
</programlisting>

<para>
Each value published by F is tested. If it is non-negative, it is placed on
channel <code>c</code> (silently) and read by <code>repeat(c.get)</code>. 
If it is negative, the channel is closed, publishing a signal and causing
the termination of F.
</para>

</section>

<section><title>Interrupt</title>

<para>
We can use routing to interrupt an expression based on a signal from
elsewhere in the program.  We set up the expression like a timeout, but instead
of waiting for a timer, we wait for the semaphore <code>done</code> to be released. Any
call to <code>done.release</code> will terminate the expression (because it will
cause <code>done.acquire()</code> to publish), but otherwise F executes as normal and
may publish any number of values.
</para>

<programlisting><![CDATA[
val c = Buffer()
val done = Semaphore(0)
repeat(c.get) <<
    ]]><emphasis role="bold">F</emphasis><![CDATA[ >x> c.put(x) >> stop
  | done.acquire() >> c.closenb()]]></programlisting>

</section>

<section><title>Publication Limit</title>

<para>
We can limit an expression to <emphasis>n</emphasis> publications,
rather than just one. Here is an expression which executes F until
it publishes 5 values, and then terminates it.
</para>

<programlisting><![CDATA[
val c = Buffer()
val done = Semaphore(0)
def allow(0) = done.release() >> stop
def allow(n) = c.get() >x> (x | allow(n-1))
allow(5) << ]]>
    <emphasis role="bold">F</emphasis><![CDATA[ >x> c.put(x) >> stop 
  | done.acquire() >> c.closenb()
]]>
</programlisting>

<para>
We use the auxiliary function <code>allow</code> to get only the first 5
publications from the channel <code>c</code>.  When no more publications are allowed,
<code>allow</code> uses the interrupt idiom to halt F and close <code>c</code>.
</para>

</section>


</section>


<section><title>Non-Terminating Pruning</title>

<para>
We can use routing to create a modified version of the pruning combinator.
As in <code>F &lt;x&lt; G</code>, we'll run F and G in parallel and make the first
value published by G available to F.  However instead of terminating G after
it publishes a value, we will continue running it, ignoring its remaining
publications.
</para>

<programlisting><![CDATA[
val r = Cell()
signal >>
   (]]><emphasis role="bold">F</emphasis><![CDATA[ <x< c.read()) | (]]><emphasis role="bold">G</emphasis><![CDATA[ >x> c.write(x))
]]>
</programlisting>

</section>

<section><title>Publication-Agnostic Otherwise</title>

<para>
We can also use routing to create a modified version of the otherwise combinator. We'll
run F until it halts, and then run G, regardless of whether F published any values
or not.
</para>

<programlisting><![CDATA[
val c = Buffer()
repeat(c.get) | (]]><emphasis role="bold">F</emphasis><![CDATA[ >x> c.put(x) >> stop ; c.close() >> ]]><emphasis role="bold">G</emphasis>)  
</programlisting>

We use <code>c.close()</code> instead of the more common <code>c.closenb()</code>
to ensure that G does not execute until all the publications of F have been
routed. Recall that <code>c.close()</code> does not return until <code>c</code> is
empty.

</section>

</section>

<section><title>Interruption</title>

<para>
We can write a function <code>interruptible</code> that implements the interrupt idiom
to execute any function in an interruptible way.  <code>interruptible(g)</code>
calls the function <code>g</code>, which is assumed to take no arguments, and
silences its publications. It immediately publishes another function, which we
can call at any time to terminate the execution of <code>g</code>. For simplicity,
we assume that <code>g</code> itself publishes no values.
</para>

<para>
Here is a naive implementation that doesn't quite work:
</para>

<programlisting><![CDATA[
def interruptible(f) =
  val done = Semaphore(0)
  done.release
    << f() >> stop 
     | done.acquire() >> c.closenb()

{- wrong! -}
val stopper = interruptible(g)
...
]]>
</programlisting>

<para>
The function <code>interruptible</code> is correct, but the way it is used causes a strange error.
The function <code>g</code> executes, but is always immediately terminated! This happens because the
<code>val</code> declaration which binds <code>stopper</code> also kills all of the remaining
computation in <code>interruptible(g)</code>, including the execution of <code>g</code> itself.
</para>

<para>
The solution is to bind the variable differently:
</para>

<programlisting><![CDATA[
def interruptible(f) =
  val done = Semaphore(0)
  done.release
    << f() >> stop 
     | done.acquire() >> c.closenb()

interruptible(g) >stopper>
...
]]>
</programlisting>

<para>
This idiom, wherein a function publishes some value that can be used to monitor or control its 
execution, arises occasionally in Orc programming. When using this idiom, always remember to
avoid terminating that execution accidentally. Since Orc is a structured concurrent language,
every process is contained with some other process; kill the containing process, and the
contained processes die too.
</para>

</section>

<section><title>Lifting</title>

It is often useful to explicitly lift an execution, so that it is in some sense protected from
being terminated. We can do this by running a "lifter" process, to which we can send functions
that will be executed by the lifter and thus will not be terminated unless the lifter itself
is terminated.

Such a lifter is written by creating a channel, and running a loop which listens for functions to
be sent on the channel and executes those functions as they arrive. The lifter publishes only
the put method for the channel; the loop itself publishes no values, since the values published by the 
lifted functions are silenced.

Here, we write such a lifter, and then use it to protect a function call from a timeout.

<programlisting language="orc-demo"><![CDATA[
def lifter() =
  val c = Buffer()
  def loop() = c.get() >f> ( f() >> stop | loop() )
  c.put | loop()

def delayedPrint() = Rtimer(1500) >> println("Delayed 1.5 seconds")

lifter() >lift>
(
println("Running...") 
  << Rtimer(1000) | delayedPrint() | lift(delayedPrint)
)
]]>
</programlisting>

The timeout stops the execution of <code>delayedPrint()</code>, so it does not print a result.
However, the lifted execution of <code>delayedPrint</code> does succeed, since it is executing
within the loop of <code>lifter()</code>, unaffected by the timeout.

</section>

<section><title>Fold</title>

<para>
We consider various concurrent implementations of the classic "list fold"
function from functional programming:
</para>

<programlisting><![CDATA[
def fold(_, [x])  = x
def fold(f, x:xs) = f(x, fold(xs))]]></programlisting>

<para>
This is a seedless fold (sometimes called <code>fold1</code>) which requires that the
list be nonempty and uses its first element as a seed.  This implementation is
short-circuiting --- it may finish early if the reduction operator <code>f</code> does
not use its second argument --- but it is not concurrent; no two calls to <code>f</code>
can proceed in parallel.  However, if <code>f</code> is associative, we can overcome this restriction 
and implement fold concurrently. If <code>f</code> is also commutative, we can further increase concurrency.
</para>

<section><title>Associative Fold</title>

<para>
We first consider the case when the reduction operator is associative.  We
define <code>afold(f,xs)</code> where <code>f</code> is a binary associative function and
<code>xs</code> is a non-empty list.  The implementation iteratively reduces <code>xs</code>
to a single value.  Each step of the iteration applies the auxiliary function
<code>step</code>, which halves the size of <code>xs</code> by reducing disjoint pairs of
adjacent items. 
</para>

<programlisting><![CDATA[
def afold(_, [x]) = x
def afold(f, xs) =
  def step([]) = []
  def step([x]) = [x]
  def step(x:y:xs) = f(x,y):step(xs)
  afold(f, step(xs))]]>
</programlisting>

<para>
Notice that <code>f(x,y):step(xs)</code> is an implicit
fork-join. Thus, the call <code>f(x,y)</code>
executes in parallel with the recursive call <code>step(xs)</code>. 
As a result, all calls to <code>f</code> execute concurrently within
each iteration of <code>afold</code>.   
</para>
  
</section>

<section><title>Associative, Commutative Fold</title>

<para>
We can make the implementation even more concurrent when the fold operator 
is both associative and commutative. We define <code>cfold(f,xs)</code>, where 
<code>f</code> is a associative and commutative binary function and <code>xs</code> is a non-empty list. 
The implementation initially copies all list items into a buffer in arbitrary
order using the auxiliary function <code>xfer</code>, counting the total
number of items copied. The auxiliary function <code>combine</code> repeatedly 
pulls pairs of items from the buffer, reduces
them, and places the result back in the buffer. Each pair of items is reduced
in parallel as they become available. The last item in the buffer is the
result of the overall fold.
</para>

<programlisting><![CDATA[
def cfold(f, xs) =
  val c = Buffer()
  
  def xfer([])    = 0
  def xfer(x:xs)  = c.put(x) >> stop | xfer(xs)+1

  def combine(0) = stop
  def combine(1) =  c.get()
  def combine(m) =  c.get() >x> c.get() >y> 
                    ( c.put(f(x,y)) >> stop | combine(m-1))

  xfer(xs) >n> combine(n)]]>
</programlisting>

</section>
</section>

</section>


<section><title>Larger Examples</title>

In this section we show a few larger Orc programs to demonstrate programming techniques. 
There are many more such examples available at the Orc website, on the
<link xlink:href="http://orc.csres.utexas.edu/wiki/Wiki.jsp?page=WikiLab">community wiki</link>.


<section><title>Dining Philosophers</title>

<para>
The dining philosophers problem is a well known and intensely studied problem
in concurrent programming. Five philosophers sit around a circular table. Each
philosopher has two forks that she shares with her neighbors (giving five forks
in total).  Philosophers think until they become hungry.  A hungry philosopher
picks up both forks, one at a time, eats, puts down both forks, and then
resumes thinking.  Without further refinement, this scenario allows deadlock;
if all philosophers become hungry and pick up their left-hand forks
simultaneously, no philosopher will be able to pick up her right-hand fork to
eat.  Lehmann and Rabin's solution<footnote><para>D. J. Lehmann and M. O. Rabin. On the advantages of free choice: A symmetric
and fully distributed solution to the dining philosophers problem. In <emphasis>POPL</emphasis>, pages
133–138, 1981.</para></footnote>, which we implement,
requires that each philosopher pick up her forks in a random order.  If the
second fork is not immediately available, the philosopher must set down both
forks and try again.  While livelock is still possible if all philosophers
take forks in the same order, randomization makes this possibility vanishingly
unlikely.
</para>

<programlisting language="orc-demo"><![CDATA[
def shuffle(a,b) = if (random(2) = 1) then (a,b) else (b,a)

def take((a,b)) =    
  a.acquire() >> b.acquirenb() ;
  a.release() >> take(shuffle(a,b))
    
def drop(a,b) = (a.release(), b.release()) >> signal

def phil(n,a,b) =
  def thinking() = 
    println(n + " thinking") >> 
    if (random(10) < 9)
      then Rtimer(random(1000))
      else stop
  def hungry() = take((a,b))
  def eating() = 
    println(n + " eating") >> 
    Rtimer(random(1000)) >> 
    println(n + " done eating") >> 
    drop(a,b)
  thinking() >> hungry() >> eating() >> phil(n,a,b)

def philosophers(1,a,b) = phil(1,a,b)
def philosophers(n,a,b) =
  val c = Semaphore(1)
  philosophers(n-1,a,c) | phil(n,c,b)

val fork = Semaphore(1)
philosophers(5,fork,fork)]]></programlisting>

<para>
The <code>phil</code> function simulates a single philosopher.  It takes as arguments
two binary semaphores representing the philosopher's forks, and calls
the <code>thinking</code>, <code>hungry</code>, and <code>eating</code> functions in a continuous
loop. A <code>thinking</code> philosopher waits for a random amount of time, with a
10% chance of thinking forever. A <code>hungry</code> philosopher uses the <code>take</code>
function to acquire two forks. An <code>eating</code> philosopher waits for a random
time interval and then uses the <code>drop</code> function to relinquish ownership of
her forks.
</para>

<para>
Calling <code>take(a,b)</code> attempts to acquire a pair of forks <code>(a,b)</code> in two steps:
wait for fork <code>a</code> to become available, then immediately attempt to acquire fork <code>b</code>.
The call <code>b.acquirenb()</code> either acquires <code>b</code> and responds immediately, or halts if <code>b</code> is not available.
If <code>b</code> is acquired, signal success; otherwise, release <code>a</code>, and
then try again, randomly changing the order in which the forks are acquired
using the auxiliary function <code>shuffle</code>.
</para>

<para>
The function call <code>philosophers(n,a,b)</code> recursively creates a chain of <code>n</code>
philosophers, bounded by fork <code>a</code> on the left and <code>b</code> on the right. The
goal expression of the program calls <code>philosophers</code> to create a chain of
five philosophers bounded on the left and right by the same fork; hence, a
ring.
</para>

<para>
This Orc solution has several nice properties.  The overall structure of the
program is functional, with each behavior encapsulated in its own function,
making the program easy to understand and modify.  Mutable state is isolated to
the "fork" semaphores and associated <code>take</code> and <code>get</code> functions,
simplifying the implementation of the philosophers.  The program never
manipulates threads explicitly, but instead expresses relationships between
activities using Orc's combinators.
</para>

</section>

<section id="methodology.examples.hygenic"><title>Hygienic Dining Philosophers</title>

<para>
Here we implement a different solution to the Dining Philosophers problem,
described in "The Drinking Philosophers Problem", by K. M. Chandy and J. Misra.
Briefly, this algorithm efficiently and fairly solves the dining philosophers
problem for philosophers connected in an arbitrary graph (as opposed to a
simple ring).  The algorithm works by augmenting each fork with a clean/dirty
state.  Initially, all forks are dirty.  A philosopher is only obliged to
relinquish a fork to its neighbor if the fork is dirty. On receiving a fork,
the philosopher cleans it. On eating, the philosopher dirties all forks.  For
full details of the algorithm, consult the original paper.
</para>

<programlisting language="orc-demo"><![CDATA[
{-
Start a philosopher actor; never publishes.
Messages sent between philosophers include:
- ("fork", p): philosopher p relinquishes the fork
- ("request", p): philosopher p requests the fork
- ("rumble", p): sent by a philosopher to itself when it should
  become hungry

name: identify this process in status messages
mbox: our mailbox; the "address" of this philosopher is mbox.put
missing: set of neighboring philosophers holding our forks
-}
def philosopher(name, mbox, missing) =
  {- deferred requests for forks -}
  val deferred = Buffer()
  {- forks we hold which are clean -}
  val clean = Set()

  def sendFork(p) =
    {- remember that we no longer hold the fork -}
    missing.add(p) >>
    p(("fork", mbox.put))
 
  def requestFork(p) =
    p(("request", mbox.put))
  
  {- Start a timer which will tell us when we're hungry. -}
  def digesting() =
      println(name + " thinking") >>
      thinking()
    | Rtimer(random(1000)) >>
      mbox.put(("rumble", mbox.put)) >>
      stop

  {- Wait to become hungry -}
  def thinking() =
    def on(("rumble", _)) =
      println(name + " hungry") >>
      map(requestFork, missing) >>
      hungry()
    def on(("request", p)) =
      sendFork(p) >> thinking()
    on(mbox.get())

  {- Eat once we receive all forks -}
  def hungry() =
    def on(("fork", p)) =
      missing.remove(p) >>
      clean.add(p) >>
      if missing.isEmpty()
      then println(name + " eating") >> eating()
      else hungry()
    def on(("request", p)) =
      if clean.contains(p)
      then deferred.put(p) >> hungry()
      else sendFork(p) >> requestFork(p) >> hungry()
    on(mbox.get())

  {- Dirty forks, process deferred requests, then digest -}
  def eating() =
    clean.clear() >>
    Rtimer(random(1000)) >>
    map(sendFork, deferred.getAll()) >>
    digesting()

  {- All philosophers start out digesting -}
  digesting()

{-
Create an NxN 4-connected grid of philosophers.  Each philosopher
holds the fork for the connections below and to the right (so the
top left philosopher holds both its forks).
-}
def philosophers(n) =
  {- A set with 1 item -}
  def Set1(item) = Set() >s> s.add(item) >> s
  {- A set with 2 items -}
  def Set2(i1, i2) = Set() >s> s.add(i1) >> s.add(i2) >> s

  {- create an NxN matrix of mailboxes -}
  val cs = uncurry(Table(n, lambda (_) = Table(n, ignore(Buffer))))

  {- create the first row of philosophers -}
  philosopher((0,0), cs(0,0), Set())
  | for(1, n) >j>
    philosopher((0,j), cs(0,j), Set1(cs(0,j-1).put))

  {- create remaining rows -}
  | for(1, n) >i> (
      philosopher((i,0), cs(i,0), Set1(cs(i-1,0).put))
      | for(1, n) >j>
        philosopher((i,j), cs(i,j), Set2(cs(i-1,j).put, cs(i,j-1).put))
    )

{- Simulate a 3x3 grid of philosophers for 10 seconds -}
let(
  philosophers(3)
  | Rtimer(10000)
) >> "HALTED"]]></programlisting>

<para>
Our implementation is based on the <link
xlink:href="http://en.wikipedia.org/wiki/Actor_model">actor model</link> of
concurrency.  An actor is a state machine which reacts to messages.  On
receiving a message, an actor can send asynchronous messages to other actors,
change its state, or create new actors.  Each actor is single-threaded and
processes messages sequentially, which makes some concurrent programs easier to
reason about and avoids explicit locking. <link
	xlink:href="http://www.erlang.org/">Erlang</link> is one popular
language based on the actor model.
</para>

<para>
Orc emulates the actor model very naturally.  In Orc, an actor is an Orc thread
of execution, together with a <code>Buffer</code> which serves as a mailbox.  To send a
message to an actor, you place it in the actor's mailbox, and to receive a
message, the actor gets the next item from the mailbox.  The internal states of
the actor are represented by functions: while an actor's thread of execution is
evaluating a function, it is considered to be in the corresponding state.
Because Orc implements <link
xlink:href="http://en.wikipedia.org/wiki/Tail_call">tail-call optimization</link>,
state transitions can be encoded as function calls without running out of stack
space.
</para>

<para>
In this program, a philosopher is implemented by an actor with three primary
states: <code>eating</code>, <code>thinking</code>, and <code>hungry</code>.
An additional transient state, <code>digesting</code>, is used to start a timer
which will trigger the state change from <code>thinking</code> to
<code>hungry</code>.  Each state is implemented by a function which reads a
message from the mailbox, selects the appropriate action using pattern
matching, performs the action, and finally transitions to the next state
(possibly the same as the current state) by calling the corresponding function.
</para>

<para>
Forks are never represented explicitly.  Instead each philosopher identifies a
fork with the "address" (sending end of a mailbox) of the neighbor who shares
the fork.  Every message sent includes the sender's address.  Therefore when a
philosopher receives a request for a fork, it knows who requested it and
therefore which fork to relinquish.  Likewise when a philosopher receives a
fork, it knows who sent it and therefore which fork was received.
</para>
</section>

<section><title>Readers-Writers</title>

<para>
Here we present an Orc solution to the <link
xlink:href="http://en.wikipedia.org/wiki/Readers-writers_problem">readers-writers
problem</link>.  Briefly, the readers-writers problem involves concurrent
access to a mutable resource.  Multiple readers can access the resource
concurrently, but writers must have exclusive access.  When readers and writers
conflict, different solutions may resolve the conflict in favor of one or the
other, or fairly.  In the following solution, when a writer tries to acquire
the lock, current readers are allowed to finish but new readers are postponed
until after the writer finishes.  Lock requests are granted in the order
received, guaranteeing fairness.  Normally, such a service would be provided to
Orc programs by a site, but it is educational to see how it can be implemented
directly in Orc.
</para>

<programlisting language="orc-demo"><![CDATA[
-- Queue of lock requests
val m = Buffer()
-- Count of active readers/writers
val c = Counter()

{-- Process requests in sequence --}
def process() =
  -- Grant read request
  def grant((false,s)) = c.inc() >> s.release()
  -- Grant write request
  def grant((true,s)) =
    c.onZero() >> c.inc() >> s.release() >> c.onZero()
  -- Goal expression of process()
  m.get() >r> grant(r) >> process()

{-- Acquire the lock: argument is "true" if writing --}
def acquire(write) =
  val s = Semaphore(0)
  m.put((write, s)) >> s.acquire()

{-- Release the lock --}
def release() = c.dec()

-------------------------------------------------

{-- These definitions are for testing only --}
def reader(start) = Rtimer(start) >>
  acquire(false) >> println("START READ") >>
  Rtimer(1000) >> println("END READ") >>
  release() >> stop
def writer(start) = Rtimer(start) >>
  acquire(true) >> println("START WRITE") >>
  Rtimer(1000) >> println("END WRITE") >>
  release() >> stop

let(
    process()  {- Output:     -}
  | reader(10) {- START READ  -}
  | reader(20) {- START READ  -}
               {- END READ    -}
               {- END READ    -}
  | writer(30) {- START WRITE -}
               {- END WRITE   -}
  | reader(40) {- START READ  -}
  | reader(50) {- START READ  -}
               {- END READ    -}
               {- END READ    -}
  -- halt after the last reader finishes
  | Rtimer(60) >> acquire(true)
)]]></programlisting>

<para>
The lock receives requests over the channel <code>m</code> and processes them
sequentially with the function <code>grant</code>. Each request includes a
boolean flag which is true for write requests and false for read requests, and a
<code>Semaphore</code> which the requester blocks on.  The lock grants access
by releasing the semaphore, unblocking the requester.
</para>

<para>
The counter <code>c</code> tracks the number of readers or writers currently
holding the lock.  Whenever the lock is granted, <code>grant</code> increments
<code>c</code>, and when the lock is released, <code>c</code> is decremented.
To ensure that a writer has exclusive access, <code>grant</code> waits for the
<code>c</code> to become zero before granting the lock to the writer, and then
waits for <code>c</code> to become zero again before granting any more requests.
</para>
</section>

<section><title>Quicksort</title>

<para>
The original quicksort algorithm
<footnote><para>C. A. R. Hoare. Partition: Algorithm 63, Quicksort: Algorithm 64, and
Find: Algorithm 65. <emphasis>Communications of the ACM</emphasis>,
4(7):321–322, 1961.</para></footnote>
was designed for efficient execution on a uniprocessor.
Encoding it as a functional program typically ignores its efficient
rearrangement of the elements of an array.
Further, no known implementation highlights its concurrent aspects.
The following program attempts to overcome these two limitations.
The program is mostly functional in its structure, though it manipulates the
array elements in place.
We encode parts of the algorithm as concurrent activities where sequentiality
is unneeded.
</para>

<para>
The following listing gives the implementation of the <code>quicksort</code>
function which sorts the array <code>a</code> in place.
The auxiliary function <code>sort</code> sorts the subarray given by indices
<code>s</code> through <code>t</code> by calling <code>part</code> to partition
the subarray and then recursively sorting the partitions.
</para>

<programlisting><![CDATA[
def quicksort(a) =

  def swap(x, y) = a(x)? >z> a(x) := a(y)? >> a(y) := z

  def part(p, s, t) =
    def lr(i) = if i < t && a(i)? <= p then lr(i+1) else i
    def rl(i) = if a(i)? > p then rl(i-1) else i

    signal >>
      (lr(s), rl(t)) >(s', t')>
      ( if (s' + 1 < t') >> swap(s', t') >> part(p, s'+1, t'-1)
      | if (s' + 1 = t') >> swap(s', t') >> s'
      | if (s' + 1 > t') >> t'
      )

  def sort(s, t) =
     if s >= t then signal
     else part(a(s)?, s+1, t) >m>
          swap(m, s) >>
          (sort(s, m-1), sort(m+1, t)) >>
          signal

  sort(0, a.length()-1)]]></programlisting>

<para>
The function <code>part</code> partitions the subarray given by indices
<code>s</code> through <code>t</code> into two partitions, one containing values
less than or equal to <code>p</code> and the other containing values &gt; <code>p</code>.  The last index of the lower partition is returned.
The value at <code>a(s-1)</code> is assumed to be less than or equal to <code>p</code> --- this is satisfied
by choosing <code>p = a(s-1)?</code> initially.  To create the partitions, <code>part</code>
calls two auxiliary functions <code>lr</code> and <code>rl</code> concurrently.  These
functions scan from the left and right of the subarray respectively, looking
for out-of-place elements.  Once two such elements have been found, they are
swapped using the auxiliary function <code>swap</code>, and then the unscanned portion
of the subarray is partitioned further.  Partitioning is complete when the
entire subarray has been scanned.
</para>

<para>
This program uses the syntactic sugar <code>x?</code> for <code>x.read()</code>
and <code>x := y</code> for <code>x.write(y)</code>.  Also note that the expression
<code>a(i)</code> returns a reference to the element of array <code>a</code> at index
<code>i</code>, counting from 0.
</para>
</section>

<section><title>Meeting Scheduler</title>

<para>
Orc makes very few assumptions about the behaviors of services it uses. Therefore
it is straightforward to write programs which interact with human agents and
network services.  This makes Orc especially suitable for encoding
<firstterm>workflows</firstterm>, the coordination of multiple activities
involving multiple participants.  The following program illustrates a simple
workflow for scheduling a business meeting.  Given a list of people and a date
range, the program asks each person when they are available for a meeting.  It
then combines all the responses, selects a meeting time which is acceptable to
everyone, and notifies everyone of the selected time.
</para>

<programlisting><![CDATA[
include "net.inc"
val during = Interval(LocalDate(2009, 9, 10),
                      LocalDate(2009, 10, 17))
val invitees = ["john@example.com", "jane@example.com"]

def invite(invitee) =
  Form() >f>
  f.addPart(DateTimeRangesField("times",
    "When are you available for a meeting?", during, 9, 17)) >>
  f.addPart(Button("submit", "Submit")) >>
  SendForm(f) >receiver>
  SendMail(invitee, "Meeting Request", receiver.getURL()) >>
  receiver.get() >response>
  response.get("times")

def notify([]) =
  each(invitees) >invitee>
  SendMail(invitee, "Meeting Request Failed",
                    "No meeting time found.")
def notify(first:_) =
  each(invitees) >invitee>
  SendMail(invitee, "Meeting Request Succeeded",
                    first.getStart())

map(invite, invitees) >responses>
afold(lambda (a,b) = a.intersect(b), responses) >times>
notify(times)]]></programlisting>

<para>
This program begins with declarations of <code>during</code> (the date range for the
proposed meeting) and <code>invitees</code> (the list of people to invite represented
by email addresses).
</para>

<para>
The <code>invite</code> function obtains possible meeting times from a given invitee, as
follows.  First it uses library sites (<code>Form</code>, <code>DateTimeRangesField</code>,
<code>Button</code>, and <code>SendForm</code>) to construct a web form which may be used to
submit possible meeting times.  Then it emails the URL of this form to the
invitee and blocks waiting for a response.  When the invitee receives the
email, he or she will use a web browser to visit the URL, complete the form,
and submit it.  The corresponding execution of <code>invite</code> receives the
response in the variable <code>response</code> and extracts the chosen meeting times.
</para>

<para>
The <code>notify</code> function takes a list of possible meeting times, selects the
first meeting time in the list, and emails everyone with this time.  If the
list of possible meeting times is empty, it emails everyone indicating that no
meeting time was found.
</para>

<para>
The goal expression of the program uses the library function <code>map</code> to
apply <code>notify</code> to each invitee and collect the responses in a list. It
then uses the library function <code>afold</code> to intersect all of the responses.
The result is a set of meeting times which are acceptable to everyone. Finally,
<code>notify</code> is called to select one of these times and notify everyone of the result.
</para>

<para>
This program may be extended to add more sophisticated features, such as a
quorum (to select a meeting as soon as some subset of invitees responds) or
timeouts (to remind invitees if they don't respond in a timely manner).  These
modifications are local and do not affect the overall structure of the program.
For complete details, see <link xlink:href="http://orc.csres.utexas.edu/tryorc.shtml">examples on our website</link>.
</para>
</section>

<!--
Procedural implementation of graphs is terrible for readability. 
Also, introducing this example would require an extended discussion of logical time.

<section><title>Shortest Path</title>


<programlisting><![CDATA[
def path(source, sink, cell, succ) =
  val timer = MakeTimer()
  def run(n,p) =
    cell(n).write(p) >>
    succ(n) >(m,d)>
    timer(d) >>
    run(m,m:p)
  run(source, [source])
  ; reverse(cell(sink).read())

{- A small test graph -}
val source = 0
val sink = 3

val cell0 = Cell()
val cell1 = Cell()
val cell2 = Cell()
val cell3 = Cell()

def cell(0) = cell0
def cell(1) = cell1
def cell(2) = cell2
def cell(3) = cell3

def succ(0) = (1,2) | (2,6) | (3,9)
def succ(1) = (3,7)
def succ(2) = (3,2)
def succ(3) = stop

{-
OUTPUT:
[0, 2, 3]
-}
path(source, sink, cell, succ)
]]></programlisting>

</section>
 -->
 
<!-- 
<section><title>Spellchecker</title>
</section>
-->

<!-- 
<section><title>Meeting Scheduler</title>
</section>
 -->


</section>
  
</chapter>
 
 
  
<chapter id="chapter.services"><title>Accessing and Creating External Services</title>

<section id="section.services.intro"><title>Introduction</title>

<para>
There are two primary ways to create sites which can be used in Orc:
</para>

<orderedlist>
<listitem>Implement sites as regular Scala or Java classes.
	Orc programs can import and use these classes directly with the
	<code>class</code> declaration. This approach is easy for anyone
	already familiar with Scala/Java, and such sites are straightforward to share
	between Orc and the Java Virtual Machine.  However such sites are limited in how they
	can interact with the Orc engine.
</listitem>
<listitem>Implement sites using Orc's low-level site API.  Orc programs can
	import and use these sites with the <code>site</code> declaration.
	This approach provides full access to the features of the Orc engine.
	However such sites are difficult to use from Scala or Java code.
</listitem>
</orderedlist>

<para>
External services (including web services) are handled using the <link
	xlink:href="http://en.wikipedia.org/wiki/Proxy_pattern">Proxy
	pattern</link>.  A site implemented in the base language (using one of the two
techniques above) must act as the local proxy for the service, translating Orc
site calls into the appropriate requests and translating responses into site
return values, halts, or errors.
</para>
</section>

<section id="section.services.java"><title><code>class</code> Sites</title>

<para>
Scala and Java classes can be imported into Orc as sites using the <link
	linkend="section.orc.class"><code>class</code> declaration</link>.
Imported classes must be in the classpath of the JVM running the Orc
interpreter.  The following sections describe in detail how such imported
classes behave in Orc programs.
</para>

<section id="section.services.java.dot"><title>Dot Operator</title>

<para>
<code>x.member</code>, where <code>x</code> evaluates to a Scala/Java class or object, 
is evaluated as follows:
<itemizedlist>
<listitem>If <code>x</code> has one or more methods named <code>member</code>,
a "method handle" site is returned which may be called like any other Orc site.
When a method handle is actually called with arguments, the appropriate Scala/Java
method is selected and called depending on the number and type of arguments, as
<!-- CHANGE ME (the method resolution section) -->
described in <link linkend="section.services.java.method">Method Resolution</link>
below.</listitem>
<listitem>Otherwise, if <code>x</code> has a field named <code>member</code>,
the object's field is returned, encapsulated in a <link
	linkend="orc.lib.state.Ref"><code>Ref</code> object</link>. The
<code>Ref</code> object has <code>read</code> and <code>write</code> methods
which are used to get and set the value of the field.</listitem>
</itemizedlist>
</para>

<para>
Note that no distinction is made between static and non-static members; it is
an error to reference a non-static member through a class, but this does not
change how members are resolved.  Note also that if a field shares a name with
one or more methods, there is no way to access the field directly.
</para>

<para>
The following (rather useless) example illustrates how the dot operator can be
used to access both static and non-static methods and fields:
<programlisting>
{- bind Integer to a Java class -}
class Integer = java.lang.Integer

{- call a static method -}
val i = Integer.decode("5")
{- read a field -}
val m = Integer.MIN_VALUE.read()
{- write a field -}
Integer.MIN_VALUE.write(5) >>
{- call a non-static method -}
i.toString()
</programlisting>
</para>

</section>

<section><title>Direct Calls</title>

<para>
When <code>x</code> evaluates to a Scala/Java object (but not a Scala/Java class), the syntax
<code>x(...)</code> is equivalent to <code>x.apply(...)</code>.
</para>

<para>
When <code>x</code> evaluates to a Scala/Java class, the syntax <code>x(...)</code>
calls the class's constructor.  In case of overloaded constructors, the
appropriate constructor is chosen based on the number and types of arguments as
described in <link linkend="section.services.java.method">Method Resolution</link>.
</para>

</section>

<section><title>Pattern Matching</title>

<para>
If <code>C</code> is bound to a Scala/Java class, it can be used as a pattern.
A pattern <code>C(x)</code> matches any Scala/Java object of that class or
any of its subclasses. The variable <code>x</code> is simply bound
to the object again; thus the matcher is just a partial identity function.
</para>

<!-- 

<para>
This is most often used to match <link linkend="exceptions">exceptions</link>
against specific Java exception types in a <code>catch</code>.
</para>

 -->

</section>

<!-- CHANGE ME (method resolution) -->
<section id="section.services.java.method"><title>Method Resolution</title>

<para>
When a method handle is called, the actual Scala/Java method called is chosen based
on the runtime types of the arguments, as follows:
<orderedlist>
<listitem>If only one method has the appropriate number of arguments, that method is called.</listitem>
<listitem>Otherwise, each method taking the appropriate number of arguments is
	tested for type compatibility as follows, and the first matching method
	is called.
	<orderedlist>
	<listitem>Every argument is compared to the corresponding formal
		parameter type as follows. All arguments must match for the
		method to match.
		<orderedlist>
		<listitem>If the argument is null, then the argument matches</listitem>
		<listitem>If the formal parameter type is primitive (int, char,
			float, ...) and the argument is an instance of a
			wrapper class, then the argument is unboxed (unwrapped)
			and coerced to the type of the formal parameter
			according to Java's standard rules for implicit
			widening coercions.</listitem>
		<listitem>If the formal parameter type is a primitive numeric type
			and the argument is an instance of <code language="java">BigDecimal</code>,
			the argument is implicitly narrowed to the formal parameter type.</listitem>
		<listitem>If the formal parameter type is a primitive integral type
			and the argument is an instance of <code language="java">BigInt</code>,
			the argument is implicitly narrowed to the formal parameter type.</listitem>
		<listitem>Otherwise, the argument must be a subtype of the formal parameter type.</listitem>
		</orderedlist>
	</listitem>
	</orderedlist>
</listitem>
</orderedlist>
</para>

<para>
The reason for the unusual implicit narrowing of <code language="java">BigDecimal</code> and
<code language="java">BigInt</code> is that Orc numeric literals have these types, and it
would be awkward to have to perform an explicit conversion every time such a
value is passed to a Java method expecting a primitive.
</para>

<para>
Currently we do not implement specificity rules for choosing the best matching
method; the first matching method (according to some unspecified order) is
chosen.  Note also that we do not support varargs methods explicitly, but
instead varargs may be passed as an array of the appropriate type.
</para>

</section>

<section id="section.values.scala"><title>Orc values in Scala</title>

<para>
Orc values are implemented by Scala objects, so in general any Orc value may be
passed to a site implemented in Scala.  Standard Orc values have the following
Scala types:
</para>

<variablelist>
<?dbfo list-presentation="list" term-width="6em"?>
<varlistentry><term>string</term><listitem><code language="java">java.lang.String</code></listitem></varlistentry>
<varlistentry><term>boolean</term><listitem><code language="java">java.lang.Boolean</code></listitem></varlistentry>
<varlistentry><term>number</term><listitem><code language="java">scala.math.BigDecimal and scala.math.BigInt</code></listitem></varlistentry>
<varlistentry><term>tuple</term><listitem><code language="java">orc.values.OrcTuple</code></listitem></varlistentry>
<varlistentry><term>list</term><listitem><code language="java">scala.collection.immutable.List</code></listitem></varlistentry>
<varlistentry><term>function</term><listitem><code language="java">orc.run.Closure</code>
		<para>Currently it is not possible to call Orc functions from Java code.</para></listitem></varlistentry>
<varlistentry><term>site</term><listitem><code language="java">orc.value.sites.Sites</code>
		<para>Currently it is not possible to directly call Orc sites from Java
code.  However if you are implementing a site yourself, you may provide methods
which can be called from Scala/Java code to invoke the behavior of the site.</para></listitem></varlistentry>
</variablelist>
</section>

<section><title>Scala Values in Orc</title>

<para>
Scala objects may be used directly as values anywhere in an Orc program.
Primitive Scala values cannot be used directly in an Orc program, but are
automatically boxed (and unboxed) as necessary.
</para>

<para>
When both arguments of an arithmetic or comparison operator are Java or Scala numeric
types, the arguments are implicitly coerced to the widest of the two argument
types.  "Widest" is defined by the following relation, where ">" means "is
wider than": BigDecimal > Double > Float > BigInt > Long > Integer > Short
> Byte
</para>

</section>

</section>

<section id="section.services.coopsched"><title>Cooperative Scheduling and Concurrency</title>

<section><title>Overview</title>
<para>
In order to support massive concurrency efficiently in Scala, Orc uses
the Scala actor library.  Orc programs are broken into discrete steps which
are executed by a pool of actors.  This approach works for Orc
expressions, but the internals of an Orc site written in Scala/Java cannot be easily
broken down.  So Orc uses the following method to call a local Scala/Java site:
</para>

<itemizedlist>
<listitem>Run the site call within a new actor.  This means site calls never
	unnecessarily block the Orc engine.  Orc manages the actor pool.
    The Orc engine never blocks, it only creates new actors or reuses actors
    from the pool.</listitem>
</itemizedlist>

	<!--
<para>
Fortunately, in practice most Orc site calls take a short, deterministic amount
of time to complete. Of those that don't, it's usually only because they are
blocked waiting for some external event, like another site call.  In this case,
instead of blocking the site can return control to the Orc engine, asking to
be run again when the external event occurs.
</para>
		-->

</section>
</section>

<section id="section.services.site"><title><code>site</code> Sites</title>

<section><title>Fundamentals</title>

<para>
Orc sites imported with the <code>site</code> declaration are implemented as
Scala classes which extend <code language="java">orc.values.sites.Sites</code>.
Here we will summarize the most important features of this and related classes;
<!--
for a detailed description, refer to the <link
xlink:href="http://orc.csres.utexas.edu/javadoc/STABLE/index.html">Javadoc</link>.
-->
</para>

	
<para>
Sites must implement a single method: <code language="java">callSite(Args args,
Token token)</code>.  The Orc engine calls this method whenever the site is
called by the Orc program.
</para>

<para>
The <code language="java">args</code> argument (of type <code
language="java">Args</code>) is used to get the arguments which were passed to
the site call by the Orc program. It has the following important methods:
</para>

<variablelist>
<varlistentry><term><code language="java">getArg(int
n)</code></term><listitem>returns the value of the (n+1)th argument, as an
<code language="java">Object</code>.  For example, to get the value of the
first argument, call <code
language="java">args.getArg(0)</code>.</listitem></varlistentry>

<varlistentry><term><code language="java">intArg(int n)</code>, <code
language="java">stringArg(int n)</code>, <code language="java">boolArg(int
n)</code>, etc.</term><listitem>returns the value of the (n+1)th argument cast
to the appropriate type. If the argument is not the appropriate type, throws an
<code
language="java">ArgumentTypeMismatchException</code>.</listitem></varlistentry>
</variablelist>

<para>
The <code language="java">token</code> argument (of type <code
language="java">Token</code>) is a sort of callback which is used by the site
to return a value or signal that it has halted. It has the following important
methods:
</para>

<variablelist>
<varlistentry><term><code language="java">resume(Object
value)</code></term><listitem>return the value <code
language="java">value</code> from the site call. For example, to return the
number 5, call <code language="java">token.resume(5)</code>.  To publish a
signal without returning any specific value, call <code
language="java">token.resume()</code>.</listitem></varlistentry>

<varlistentry><term><code language="java">error(TokenException
problem)</code></term><listitem>halt without publishing a value and report an
error.  This method is an appropriate way to report Scala or Java exceptions encountered
during a site call.  Alternatively, a site can simply throw a checked exception
from the <code language="java">callSite</code> method; the engine will call
<code language="java">token.error</code> on its behalf. To convert a Java
exception to the necessary <code language="java">TokenException</code> type,
wrap it in an instance of <code
language="java">orc.error.runtime.JavaException</code>.</listitem></varlistentry>

<varlistentry><term><code language="java">die()</code></term><listitem>halt,
without publishing a value or reporting an error. For example, the built-in
site <code>If</code> uses this method to halt when called with a
<code>false</code> argument.</listitem></varlistentry>
</variablelist>

<para>
The <code language="java">callSite</code> method must return control to its
caller within a short, deterministic amount of time.  To implement a site which
blocks or waits for some condition, <code language="java">callSite</code> must
save the <code language="java">token</code> and return without calling any of
the above methods.  Then when it is time for the site call to return, call the
appropriate method on the <code language="java">token</code>.
</para>

</section>

<section><title>More Site Classes</title>

<section><title>EvalSite</title>

<para>
Many sites are deterministic, always returning a value immediately when called.
Such sites can be implemented easily by extending <code
language="java">orc.values.sites.compatability.EvalSite</code> and implementing the method
<code language="java">evaluate(Args args)</code>.  This method should read the
arguments from <code language="java">args</code> as usual, and then return the
value to be returned from the site call, or throw a checked exception to
indicate an error.
</para>
</section>

<section id="section.services.sites.ThreadedSite"><title>ThreadedSite</title>

<para>
Some sites need to perform blocking IO or use other Scala/Java blocking methods like
<code language="java">Object#wait()</code>.  This cannot be done directly in
the <code language="java">callSite</code> or <code
language="java">EvalSite#evaluate</code>  methods because that might block the
Orc engine. Instead, extend <code
language="java">orc.values.sites.compatability.ThreadedSite</code> and implement the method
<code language="java">evaluate(Args args)</code>.  This method should read the
arguments from <code language="java">args</code> as usual, and then return the
value to be returned from the site call, or throw a checked exception to
indicate an error.  Your <code language="java">evaluate</code> method will be
automatically run asynchronously in a new thread so that it does not interfere
with the Orc engine.
</para>

<para>
Beware that the Orc engine may be configured to only allow a fixed number of
site threads. If too many sites need to use threads simultaneously, some will
block until threads become available.
</para>
</section>

<section><title>DotSite</title>

<para>
Recall that the notation <code>x.msg</code> corresponds to calling the site
<code>x</code> with the special message value <code>msg</code>.  To implement a
site which responds to such messages, extend <code
language="java">orc.values.sites.compatability.DotSite</code>.
</para>

<para>
In the site's constructor, call the method <code
language="java">addMember(String message, Object value)</code> once for each
message you wish the site to respond to. The call <code
language="java">addMember(m, v)</code> instructs the site to return the value
<code language="java">v</code> when it is called with the message <code
language="java">m</code>.
</para>

<para>
Any object can be used as a member value, even another site.  Anonymous inner
classes extending <code language="java">Site</code> are often used as member
values which behave like  methods of the enclosing <code
language="java">DotSite</code>.
</para>
</section>
</section>

<section><title>Tutorial Example</title>

<para>
We will implement a simplified version of Orc's <code>Buffer</code> site,
called <code language="java">ExampleBuffer</code>. The goal will be to be able
to run this Orc program:
</para>

<programlisting><![CDATA[
-- Import the site definition
site ExampleBuffer = ExampleBuffer
-- Create a new buffer site
val b = ExampleBuffer()
-- wait for a value in the buffer
b.get()
-- put a value in the buffer
| b.put(3) >> stop
-- Publishes: 3]]></programlisting>

<para>
The first step is to create <filename>ExampleBuffer.java</filename>. The <code
language="java">ExampleBuffer</code> site is actually a <firstterm>discovery site</firstterm>: all
it does when called is create and return a reference to a new site (the buffer
instance).
</para>

<programlisting language="java"><![CDATA[
public class ExampleBuffer extends EvalSite {
  public Object evaluate(Args args) {
    return new ExampleBufferInstance();
  }
}]]></programlisting>

<para>
Next we must implement <code language="java">ExampleBufferInstance</code>,
which defines the behavior of an individual buffer. We can put this class
either in its own file or in <filename>ExampleBuffer.java</filename>, since
that is the only class which refers to it directly. How does an instance
behave? If we write <code>b.get()</code>, that means that <code>b</code>
responds to the message <code>get</code> with a site which we call to get a
value from the buffer. So we'll extend <code language="java">DotSite</code>,
telling it to respond to the message "get" with a <code
language="java">GetMethod</code> site, and likewise for "put". We'll use a
linked list to store the actual contents of the buffer.
</para>

<programlisting language="java"><![CDATA[
class ExampleBufferInstance extends DotSite {
  private LinkedList<Object> contents = new LinkedList<Object>();
  public ExampleBufferInstance() {
    addMember("get", new GetMethod());
    addMember("put", new PutMethod());
  }
}]]></programlisting>

<para>
The <code language="java">GetMethod</code> site is implemented as an inner
class so it has easy access to the contents of the buffer. In the
implementation we first check if there is an item in the buffer. If so, we
return it. Otherwise, we must store the token in a queue to be notified when
the next item is put in the buffer. We synchronize on the outer object to
protect against concurrent modification.
</para>

<programlisting language="java"><![CDATA[
private LinkedList<Token> waiters = new LinkedList<Token>();
private class GetMethod extends Site {
  public void callSite(Args args, Token token) {
    synchronized (ExampleBufferInstance.this) {
      if (!contents.isEmpty()) {
        token.resume(contents.removeFirst());
      } else {
        waiters.add(token);
      } 
    }
  }
}]]></programlisting>

<para>
<code language="java">PutMethod</code> is even simpler since it doesn't need to
block. If there is a token waiting for an item, we give it the item. Otherwise
we put the item in the buffer. We synchronize on the outer object to protect
against concurrent modification. When done we return a dummy "signal" value.
</para>

<programlisting language="java"><![CDATA[
private class PutMethod extends EvalSite {
  public Object evaluate(Args args) {
    Object item = args.getArg(0);
    synchronized (ExampleBufferInstance.this) { 
      if (!waiters.isEmpty()) {
        waiters.removeFirst().resume(item);
      } else {
        contents.add(item);
      } 
    }
    return signal();
  }
}]]></programlisting>

<para>
Putting it all together, here is the entire implementation:
</para>

<programlisting language="java"><![CDATA[
import java.util.LinkedList;

import orc.values.sites.compatability.EvalSite;
import orc.values.sites.compatability.DotSite;
import orc.values.sites.Sites;
import orc.runtime.Token;

public class ExampleBuffer extends EvalSite {
  public Object evaluate(Args args) {
    return new ExampleBufferInstance();
  }
}

class ExampleBufferInstance extends DotSite {
  private LinkedList<Object> contents = new LinkedList<Object>();
  private LinkedList<Token> waiters = new LinkedList<Token>();
    
  private class GetMethod extends Site {
    public void callSite(Args args, Token token) {
      synchronized (ExampleBufferInstance.this) {
        if (!contents.isEmpty()) {
          token.resume(contents.removeFirst());
        } else {
          waiters.add(token);
        } 
      }
    }
  }

  private class PutMethod extends EvalSite {
    public Object evaluate(Args args) {
      Object item = args.getArg(0);
      synchronized (ExampleBufferInstance.this) { 
        if (!waiters.isEmpty()) {
          waiters.removeFirst().resume(item);
        } else {
          contents.add(item);
        } 
      }
      return signal();
    }
  }

  public ExampleBufferInstance() {
    addMember("get", new GetMethod());
    addMember("put", new PutMethod());
  }
}]]></programlisting>
</section>

</section>

<section><title>Web Services</title>

<section><title>Introduction</title>

<para>
While we believe Orc is an excellent language for web service scripting,
currently the library support for such tasks is at a proof-of-concept level.
The web service libraries are not bundled with the core Orc distribution, do
not have stable APIs, and are not officially documented.  However this section
should provide you with enough information to get started.
</para>

</section>

<section><title>Downloading and Running Examples</title>

<para>All Orc sites related to web services are bundled in a separate
"OrcSites" library.  As with the core Orc distribution, you can either
download this library as a prepackaged JAR or check out the
source code from the "OrcSites" module in version control.  We generally recommend the latter
approach, since the source code provides several examples which can be used as
a basis for creating your own web service sites.
</para>

<para>
Within the OrcSites source code you will find:
</para>
<itemizedlist>
<listitem>Java source code for web service sites: <filename>src/orc/lib/net/</filename></listitem>
<listitem>Orc source code for programs using web services: <filename>examples/</filename></listitem>
</itemizedlist>

<para>Several of the examples require you to create
	<filename>.properties</filename> files and place them in your
	classpath. The simplest way to do this is to make sure the
	<filename>examples/</filename> directory is in your classpath, and
	place the necessary <filename>.properties</filename> files there.
</para>

</section>

<section><title>Protocols Supported</title>

<para>
Web services use a variety of protocols, so there are a variety of ways to
contact them. All of them boil down to creating a Scala or Java proxy site for the
service and calling that.  Previous sections explain how to implement such
sites which can be called in Orc. Because web services tend to use blocking
I/O, Java wrappers make frequent use of <link linkend="section.services.sites.ThreadedSite">ThreadedSite</link> 
	to ensure that web service calls don't block the Orc engine.
</para>

<section><title>Java APIs</title>

<para>
Some web services provide Java APIs specifically for the service. For example,
Google Calendar. In these cases we just use the Java API from Orc, either
directly or via a small Java wrapper which simplifies the interface.
</para>

<para>OrcSites includes <code>class orc.lib.net.GoogleCalendar</code> as an
	example of this type of web service.</para>

</section>

<section><title>SOAP RPC</title></section>

<para>
OrcSites includes a generic <code>site orc.lib.net.Webservice</code> which allows you to connect to any SOAP RPC (specifically
rpc/encoded) service, without writing Java wrappers.  Instead <link
	xlink:href="http://ws.apache.org/axis/">Apache Axis</link> is used to
generate Java wrappers on-demand.
</para>

<para>
<link xlink:href="http://www.xmethods.net" /> is a good place to find examples
of SOAP RPC services:
</para>

<orderedlist>
<listitem>Find the RPC "Style" service which does what you want.</listitem>
<listitem>Click on the name of the service.</listitem>
<listitem>Click on "View RPC Profile" for a summary of the methods available.</listitem>
<listitem>Construct instances of the service by passing the WSDL URL to the
	<code>Webservice</code> site. E.g. <code>Webservice("http://site.com/wsdl")</code>.</listitem>
<listitem>Call methods on the service as you would with any Java object. The
	<link xlink:href="http://jcp.org/en/jsr/detail?id=101">JAX-RPC
		specification</link> has complete details on how SOAP
	operations and data types are represented in Java.  Beware: method
	names always begin with a lower-case letter, even if the corresponding
	operation does not.</listitem>
</orderedlist>

<para>
Example:
</para>
<programlisting language="orc-demo">
site orc.lib.net.Webservice
{-
Find documentation of this service at:
http://www.xmethods.net/ve2/WSDLRPCView.po?
key=uuid:BF3EFCDD-FCD4-8867-3AAC-068985E7CB89
-}
val service = Webservice(
  "http://www.ebob42.com/cgi-bin/"
  + "Romulan.exe/wsdl/IRoman")
service.intToRoman(451)
</programlisting>

</section>

<section><title>REST</title>

<para>
Many services use ad-hoc REST/XML protocols. Unfortunately, there is no REST
equivalent to WSDL, so there's no way to automatically generate an API for REST
services. We're not trying to solve this problem with Orc, but when the web
services community reaches some kind of consensus, Orc will support it.
</para>

<para>
For now you must write a Java wrapper for each service which handles
marshalling and unmarshalling the data. There's no reason such marshalling code
couldn't be written in Orc, calling low-level HTTP and XML libraries directly,
but there would be no advantage to doing so, so we let each language play to
its strengths. OrcSites includes utility classes to assist with submitting
requests and parsing responses.</para>

<para>OrcSites includes the following examples of this type of service:</para>
<itemizedlist>
<listitem><code>class orc.lib.net.Upcoming</code></listitem>
<listitem><code>site orc.lib.net.TrueRandom</code></listitem>
<listitem><code>site orc.lib.net.YahooSpellFactory</code></listitem>
</itemizedlist>

</section>

</section>

</chapter>

<!--
<chapter id="chapter.typechecker"><title>Type Checking</title> 

<para>
The Orc language, as it is described in <link linkend="chapter.language">Chapter 1</link>, is
dynamically typed. If an operation occurs at runtime which is not type-correct, the call
which attempted that operation becomes silent, and produces a type error that is reported
on the console. 
</para>

<para>
Orc also has an optional static typechecker, which will guarantee that a program is
free of type errors before the program is run. For every expression in the program,
the typechecker tries to find the types of values that the expression could publish, 
and then checks that all such types are consistent. The typechecker performs a limited form of
<emphasis>type inference</emphasis>, so it can discover many types automatically;
however, the programmer must provide additional type information for defined functions 
and for a few other specific cases.
</para>

<para>
The typechecker is disabled by default, though typed syntax is still permitted (and types are still
checked for syntax errors) even when the typechecker is not used. It may be enabled as a project
property in the Eclipse plugin, or by using the <code>-typecheck</code> switch on the command line. 
</para>


<para>
If the typechecker can verify that a program is correctly typed, it will display the message
</para>

<para>
<code>... :: </code>T
</para>

<para>
on the console. The symbol <code>::</code> means "has type", and T is the type of any value that
the program might publish.
</para>

<para>
The typechecker uses the local type inference algorithm described by Pierce and Turner in the paper 
<link xlink:href="http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf">Local Type Inference</link>.
It extends this algorithm with polymorphic type constructors (e.g. <code>List</code> and
<code>Buffer</code>), user-defined datatypes (which may also be polymorphic),
and a typing discipline for external services. The typechecker supports both 
<emphasis>parametric polymorphism</emphasis> (generics) and 
<emphasis>inclusion polymorphism</emphasis> (subtyping), 
though it does not currently implement <emphasis>bounded polymorphism</emphasis>, which combines the two. 
</para>

<para>
While almost all of the features of the Orc language are compatible with the typechecker, there are
still a few limitations, as of version 1.1:
</para>

<para>
The <code>capsule</code> declaration is not fully compatible with the typechecker, in that it is not 
currently possible to write the type of a capsule explicitly. This means that a capsule cannot be 
used in a position that requires an explicit annotation, for example as a function argument, or as 
the return value of a recursive function. In particular, this means that it is not currently possible 
to typecheck recursive or mutually recursive capsule definitions.
</para>

<para>
The Orc typechecker interacts with the Java type system in a relatively sophisticated way. However, since
the Orc typechecker cannot currently express bounded polymorphism, it cannot interface with some Java
types that make use of Java's own bounded polymorphism. Orc's typechecker also does not handle
many cases related to Java intefaces. Lastly, Orc's type join operation on Java types does not currently
compute the full join of Java classes (i.e. the least common ancestor); it will handle limited cases,
such as when one class is a subtype of the other, but it does not compute the least upper bound.
</para>

<section><title>Simple Typing</title>

In this section we will see how Orc programs are typechecked, starting with
simple expressions like constants and arithmetic operations, and working up to more interesting
cases such as defined functions, the concurrency combinators, and calls to external services.

<section><title>Values and Operators</title>

<para>
Each of the Orc constants has the expected type:

<itemizedlist>
<listitem><code>true , false</code> <code> :: </code> <code>Boolean</code></listitem>
<listitem> ... <code> -1, 0, 1 </code> ... <code> :: </code> <code>Integer</code></listitem>
<listitem> ... <code> "orc" , "ceci n'est pas une |"</code> ... <code> :: </code> <code>String</code></listitem>
<listitem> ... <code> 0.001, -1.5, 2.71828 </code> ... <code> :: </code> <code>Number</code></listitem>
</itemizedlist>

The expression <code>signal</code> has its own unique type, <code>Signal</code>.
</para>

<para>
Orc allows <emphasis>subtyping</emphasis>: some types are included in other types. For example,
Integer is a subtype of Number, because all Integers are also Numbers. 
</para>

<para>
Each of the primitive operators typechecks in the obvious way; for example <code><![CDATA[&&]]></code> requires
two Boolean operands and returns a Boolean result. Some of the arithmetic operators also support
<emphasis>ad-hoc polymorphism</emphasis>; for example, a <code>+</code> expression with two Integer 
operands has type Integer, but with one or more Number operands it instead has type Number. 

 
This kind of polymorphism is not unique to the primitive operators; operators are simply sites,
and any site call can exhibit such polymorphism. However, functions defined in Orc cannot have
ad-hoc polymorphism; only external services can.

</para>

</section>

<section><title><code>Top</code> and <code>Bot</code></title>

<para>
There are two other important types: <code>Top</code> and <code>Bot</code>. 
</para>

<para>
<code>Top</code> is the universal type; it is the type of any value, and all other types are subtypes 
of it. 
</para>

<para>
<code>Bot</code> is the empty type; no value has type <code>Bot</code>. It is a subtype of all other
types. Expressions with type <code>Bot</code> are expressions that the typechecker can verify will
never publish any values. In particular, <code>stop</code> will never publish, so it has type <code>Bot</code>.
</para>

<para>
<code>Bot</code> has an interesting status in Orc. In other typed languages, if an expression
has type <code>Bot</code>, this usually indicates a guaranteed error, infinite loop, or other failure
to return a value. Since sequential programming rarely involves subexpressions that are guaranteed
never to return, <code>Bot</code> is usually just a curiosity or a formal artifact of the type system,
and indeed many static type systems do not have a <code>Bot</code> type at all. 
In Orc, however, <code>Bot</code> is very useful, since it is frequently the case that Orc expressions 
are written to carry out ongoing concurrent activities but never publish any values, and the type system 
can use the type <code>Bot</code> to indicate that no publications will ever be seen from such
expressions.
</para>

</section>

<section><title>Tuples</title>

<para>
The type of a tuple is a tuple of the types of each of its elements.

<itemizedlist>
<listitem><code>(3+3, true) :: (Integer, Boolean)</code></listitem>
<listitem><code>("orc", (2, "orc")) :: (String, (Integer, String))</code></listitem>
</itemizedlist>

</para>

</section>


<section><title>Combinators</title>

<section><title>Parallel</title>
<para>
The type of F <code>|</code> G is the <emphasis>join</emphasis> of the types of F and G.
</para>

<para>
A <emphasis>common supertype</emphasis> of two types S and T is any type U such that 
S and T are both subtypes of U. The join J is the <emphasis>least</emphasis> common 
supertype of S and T, that is, J is a common supertype, and J is also a subtype of every other 
common supertype.
</para>

<para>
The most common case is the join of a type T with itself. Then the join is just T.
This happens when both parallel branches publish the same type of values.

<itemizedlist>
<listitem><code>3+4 | 5  ::  Integer</code></listitem>
</itemizedlist>
</para>

<para>
If S is a subtype of T, the join of S and T is T. This happens when one branch
is publishing a less specific type of value. To be safe, the whole expression
then has that less specific type.

<itemizedlist>
<listitem><code>3 | 3.1  ::  Number</code></listitem>
</itemizedlist>

</para>

<para>
As a special case, the join of any type T with <code>Bot</code> is T. This occurs
when one branch publishes values and the other one never publishes. Thus, it is
safe to use the type of values from the first branch, since the second branch
contributes no values at all.

<itemizedlist>
<listitem><code>"all quiet on the western front" | EasternFront() >> stop  ::  String</code></listitem>
</itemizedlist>
 
</para>

<para>
In any other case, the typechecker will try to infer the join. However, it
may not always find the least supertype, and in some cases there may not
even be a useful common supertype. In these cases it will default to
the <code>Top</code> type, which is a supertype of all other types, and is
therefore always a common supertype, if not a very useful one.

<itemizedlist>
<listitem><code>3 | "three"  ::  Top</code></listitem>
</itemizedlist>

</para>

</section>

<section><title>Sequential</title>
<para>
The type of F <code><![CDATA[>x>]]></code> G is the type of G using the assumption x :: T, where T is the type of F.
</para>

<para>
If a pattern is used instead of a variable, the structure of the pattern must match the structure
of the type of F, and the types for each variable bound in G are taken from the corresponding
pieces of the type of F. For example, in the expression F <code><![CDATA[>(x,b)>]]></code> G,
where F <code>:: (Integer, Boolean)</code>, G is typechecked with the assumptions <code>x :: Integer</code>
and <code>b :: Boolean</code>.
</para>

</section>

<section><title>Pruning</title>
<para>
The type of F <code><![CDATA[<x<]]></code> G is the type of F using the assumption x :: T, where T is the type of G.
</para>

<para>
When a declaration <code>val x = </code> F occurs, the expression in scope for the declaration
is typechecked using the assumption x :: T, where T is the type of F.
</para>

<para>
Patterns in the pruning combinator and in <code>val</code> declarations are typechecked in the same way as in the sequential combinator.
</para>


</section>

<section><title>Otherwise</title>
<para>
The type of F <code>;</code> G is the <emphasis>join</emphasis> of the types of F and G, as described for the parallel combinator.
</para>
</section>


</section>

<section><title>Conditionals</title>

<para>
In the conditional expression <code>if</code> E <code>then</code> F <code>else</code> G, the expression E must have type
<code>Boolean</code>, and the type of the whole expression is the join of the types of F and G, as described for the
parallel combinator.
</para>

</section>


<section><title>Defined Functions</title>

<para>
Though the typechecker can infer the types of many expressions without additional information from the programmer, there are some
cases where the algorithm does need assistance. In particular, whenever a function is defined (using the <code>def</code> keyword),
the programmer must also include a <emphasis>signature</emphasis> for that function, supplying its argument types and return type.
</para>

<para>
A signature immediately precedes a function definition, and is written as follows:

<programlisting language="orc"><![CDATA[
def magsq(Number, Number) :: Number
def magsq(x,y) = x*x + y*y
]]></programlisting>

Argument types replace the arguments, <code>::</code> replaces <code>=</code>, and the return type (the type of the body expression)
replaces the body expression. If the function is not recursive, then the return type is optional, because the typechecker can infer it from
the body expression without additional information. So, in this case, we could have just written:

<programlisting language="orc"><![CDATA[
def magsq(Number, Number)
def magsq(x,y) = x*x + y*y
]]></programlisting>
</para>

<para>
It is also possible to include the argument types and return type directly in a definition, rather than as a separate signature. 
The signature and definition above could be written together as:

<programlisting language="orc"><![CDATA[
def magsq(x :: Number, y :: Number) :: Number = x*x + y*y
]]></programlisting>

An argument <code>x</code> with type <code>T</code> is replaced by <code>x :: T</code> in the argument list. The return type is inserted
between the argument list and the <code>=</code> sign. This form is not typically used for functions with multiple clauses or pattern
matches, though it is allowed in those cases so long as only one clause has the type information.
</para>

<para>
<code>lambda</code> expressions are a special case: the type information must be included directly in this way,
since there is no way to declare the signature separately. Specifying the return type of a lambda is always optional,
since it is not possible for an anonymous function to make a recursive call. Written as a typed lambda function, the <code>magsq</code>
definition looks like:

<programlisting language="orc"><![CDATA[
lambda (x :: Number, y :: Number) = x*x + y*y
]]></programlisting>

When the typechecker has enough information to check the type of a lambda against a given function type, rather than needing to infer it, 
the argument types of the lambda are also optional. This occurs, for example, when a lambda is given as an argument to a defined higher-order function.
</para>

<para>
Once defined, functions are values, and thus have a special type of their own. The type of a function is written
very much like a signature, but using the <code>lambda</code> keyword instead of <code>def</code> and the function
name.

<itemizedlist>
<listitem><code>magsq</code>, defined earlier, has type <code>lambda (Number, Number) :: Number</code></listitem>.
<listitem><code>lambda (x :: Integer) = x+1</code>  has type  <code>lambda (Integer) :: Integer</code></listitem>
<listitem><code>lambda () = signal</code> has type <code>lambda () :: Top</code></listitem>
<listitem><code>lambda (a :: Boolean, b :: Boolean) = (b,a)</code> has type <code>lambda (Boolean,Boolean) :: (Boolean,Boolean)</code></listitem>
</itemizedlist>
</para>

</section>

<section><title>Ascriptions</title>

<para>
In addition to annotation defined functions with a signature, the typechecker can also accept programmer-supplied type
information for any expression. An <emphasis>ascription</emphasis>, written E <code>::</code> T, asks the typechecker 
to verify that expression E has type T.
</para>

<para>
Normally, the typechecker would simply find the type of E by inference, but in certain situations it is easier to check
a given type. For example, the typechecker may not be able to infer the correct join type for a parallel combinator,
but it is always able to check that both branches are subtypes of an already provided type. Furthermore, adding extra
type information makes it easier to pinpoint the source of a typechecking failure.
</para>

<para>
Ascriptions are also allowed in patterns; P <code>::</code> T is a valid pattern, instructing the typechecker to verify
that the value fragment bound by the pattern P will always be of type T.
</para>

</section>

<section><title>Aliasing</title>

When adding function signatures and ascriptions, it is often helpful to have simpler names for
complex types that frequently occur. In the same way that variable binding can be used to give
a name to a complex value, there is a type declaration that binds a complex type to a type variable.
This is called <emphasis>aliasing</emphasis>, and it is accomplished using the <code>type</code>
definition. 

<programlisting language="orc"><![CDATA[
 A rectangle is defined by its lower left and upper right coordinates.
type Rect = ((Number, Number), (Number, Number))

 Transpose such a rectangle, rotating it around an x=y axis
def flip(Rect) :: Rect
def flip( ((a, b), (c, d)) ) = ((a, b), (d, c))
]]></programlisting>

While it does not change the behavior of the typing algorithm, aliasing can substantially improve
readability and make the intention of one's code much clearer.

</section>


<section><title>Datatypes</title>

We have already seen user-defined datatypes in the untyped Orc language. In the typed language, they are
declared in the same way, except that the slots in the datatype, which previously were always <code>_</code>,
now contain the actual types that go in those slots. As an example, here is a datatype for geometric
shapes.

<programlisting language="orc"><![CDATA[
{- 
  Rect(w,h): A rectangle with width w and height h. 
  Circle(r): A circle with radius r.
  RegularPolygon(n,l): A regular polygon with n sides, each of length l.
-}
type Shape = Rect(Number, Number) | Circle(Number) | RegularPolygon(Integer, Number)
]]></programlisting>

We will see how to declare generic datatypes, like <code>Tree</code> or <code>Option</code>, in the next section.

</section>


<section><title>Interacting with External Services</title>

In addition to verifying the correctness of code written within Orc itself, the typechecker must also ensure that
external services are used correctly in the context of the Orc program. 

<para>
When an external site is made available to Orc with the <code>site</code> declaration, its type is also
made available to the Orc typechecker. The type of a site is itself treated like a service; it is passed
the types of its arguments, and responds with a return type for those arguments. Thus, a site call can typecheck
in ways not possible for function calls or other expressions. For example, sites can support ad-hoc polymorphism.
Also, sites can respond to messages sent using the dot operator. In fact, Orc has no native record type, because
the dot operator only applies to sites, so the type of the site can interpret the message internally
and determine the correct type to return, if any. 
</para>

<para>
Additionally, a site can introduce new types into Orc. For example, the <code>Semaphore</code> site responds with
new instances of semaphores. And just as sites can be declared using <code>site</code>, these types can be
declared using <code>type</code>. Typically they are represented as Java classes, just as sites are. As an example,
here is a program which declares the <code>Semaphore</code> type, and then defines a function which "toggles" a pair 
of semaphores by acquiring the first and releasing the second.

<programlisting language="orc"><![CDATA[
type Semaphore = orc.lib.state.types.SemaphoreType

def toggle(Semaphore, Semaphore) :: Top
def toggle(s, t) = s.acquire() >> t.release()
]]></programlisting>

Notice that it is not possible to typecheck <code>toggle</code> without first giving a name to the Semaphore type,
because it is used in the signature of <code>toggle</code>.
</para>

<para>
<code>type</code> definitions occur alongside <code>site</code> definitions in the standard library, so the
types returned by many of the library functions are already available.
</para>

</section>


<section><title>Assertions</title>
<para>
While the typechecker can be helpful, it will not accept programs that are not safe according to
its algorithm, which can be burdensome when the programmer knows that an expression will have a
certain type but the typechecker cannot verify it.
</para>

<para>
Since the typechecker is optional, it can always be turned off in these cases. But this is often
too drastic a solution: typechecking difficulties often arise from small segments of a much larger
program, and the rest of the program still benefits from typechecking. 
</para>

<para>
Fortunately, the typechecker can be selectively disabled for parts of a program. For this purpose,
the typechecker supports a special operation called an <emphasis>assertion</emphasis>, written 
E <code> :!: </code> T, where E is an expression and T is its asserted type. An assertion 
is used like an ascription, but rather than verifying that E has type T, the typechecker instead
assumes that E has type T, without inspecting E at all. Thus, the programmer can supply the correct
type T without being restricted by the typechecking algorithm.
</para>

<para>
This feature should be used sparingly, with the knowledge that it does compromise the integrity
of the typechecking algorithm. If the supplied type is wrong, runtime type errors could propagate to any
part of the program that depends on that type. Assertions are useful for rapid prototyping, but
they are not recommended for production code.
</para>

</section>

</section>


<section><title>Polymorphism</title>

In this section we examine a powerful feature of Orc's typechecker: <emphasis>parametric polymorphism</emphasis>.
This allows us to define types that take other types as parameters; the same theory underlies Java's generics.


We will start by considering simple parametric types, like Orc's lists, and demonstrate how to write
and invoke typed functions that operate on these parametric types, no matter what the parameter is. Then
we'll talk about how to define parametric types, such as a generic datatype or an external generic type.

 
<section><title>Parametric types</title>

<para>
What is the type of <code>[1,2,3]</code>? It is a list, containing Integers. What about <code>[true, true]</code>?
Again a list, but it contains Booleans instead. It would be very cumbersome to have separate types such
as <code>IntegerList</code> and <code>BooleanList</code> for each of these possibilities, and in fact
infinitely many such types are possible. What we would like instead is one <code>List</code> type, with
a parameter which gives us the types contained in the list.
</para>

<para>
Such a type is called a parametric, or generic, type. It contains two parts: a type operator, such as
<code>List</code>, followed by a sequence of paramemters enclosed in brackets <code>[...]</code>. 
For example, <code>[1,2,3] :: List[Integer]</code>, and <code>[true,true] :: List[Boolean]</code>.
</para>

<para>
Lists are not the only parametric type. The standard library includes other parametric types, such as
<code>Option</code>, <code>Buffer</code>, and <code>Cell</code>. Type operators, such as <code>List</code>,
are declared using the same <code>type</code> declarations as any other type. For example, the
declaration

<programlisting language="orc"><![CDATA[
type Buffer = orc.lib.state.types.BufferType
]]></programlisting>

is part of the standard library; it declares the <code>Buffer</code> type operator. 
 
</para>

</section>


<section><title>Parametric functions</title>

<para>
How do we write functions that use parametric types? Consider the following definition
of the <code>append</code> function, which appends two lists:

<programlisting language="orc"><![CDATA[
def append[T](List[T], List[T]) :: List[T]
def append([], l) = l
def append(h::t, l) = h::append(t,l)
]]></programlisting>

The function <code>append</code> has a <emphasis>type argument</emphasis>, T, in its
signature. The type T is the type of elements in the lists that we are appending. Notice that both argument
lists must contain the same type of elements. The resulting list contains elements of that same type.
</para>

 
<para>
Functions defined using <code>lambda</code> can also have type parameters, such as the following
anonymous function, which returns the first element of a list, or is silent if the list is empty:

<programlisting language="orc"><![CDATA[
lambda[T](h:_ :: List[T]) = h
]]></programlisting>
</para>

 
</section>


<section><title>Generic calls</title>

<para>
When calling the <code>append</code> function, in addition to providing its normal arguments, we must
also provide its type argument:

<programlisting language="orc"><![CDATA[
append[Integer]([1,2,3], [4,5])
]]></programlisting>

However, it would be very burdensome and verbose to provide type arguments to all such calls. Fortunately,
in most cases, the type checker can infer the correct type arguments, in the same way that it infers
the correct type for many expressions without any additional information. So in this case, we can
simply write:

<programlisting language="orc"><![CDATA[
append([1,2,3], [4,5])
]]></programlisting>

and the typechecker infers that the parameter T is <code>Integer</code>, since both argument lists are
of type <code>List[Integer]</code>. For a more thorough explanation of how this inference occurs, please
refer to Pierce and Turner's paper.
</para>

<para>
Inference of type arguments will always fail on certain kinds of calls, because the typechecker does
not have enough information to infer the correct type. The most common case is a site call which
constructs a parametric type without taking any arguments. For example:

<programlisting language="orc"><![CDATA[
val b = Buffer()
]]></programlisting>

will never typecheck, since there is no way for the typechecker to know what type of elements the
buffer should contain. In other languages such as ML, the typechecker might be able to infer this information
from the rest of the program, but Orc's typechecker is based on <emphasis>local</emphasis> type inference,
which must find the information locally, such as from the types of the arguments. So, to construct
a buffer that will contain Numbers, a type parameter must be given:

<programlisting language="orc"><![CDATA[
val b = Buffer[Number]()
]]></programlisting>

</para>

</section>

<section><title>Polymorphic aliases</title>

<para>
A type alias may have type parameters. For example, here is a type alias for triples:

<programlisting language="orc"><![CDATA[
type Triple[T] = (T,T,T)
]]></programlisting>

<code>Triple</code> is now a type operator that takes one parameter. Any occurrence of
<code>Triple[T]</code> is equivalent to <code>(T,T,T)</code>.

</para>

</section>

<section><title>Polymorphic datatypes</title>

<para>
Datatypes can also have type parameters. This allows a programmer to
define very useful generic data structures. For example, this is necessary
to define a reasonable datatype for trees:

<programlisting language="orc"><![CDATA[
type Tree[T] = Node(Tree[T], Tree[T], T) | Leaf()
]]></programlisting>

Notice that the datatype is recursive, and the type parameter <code>T</code> is
passed recursively to <code>Tree</code> to define the type of the subtrees. 

</para>

</section>

 
<section><title>Variance: Subtyping for parametric types</title>

type constructors
(immutable type constructors, like List, are _covariant_, so C[A] <: C[B] only if A <: B
(mutable type constructors, like Buffer, are _invariant_, so C[A] <: C[B] only if A = B

</section>

</section>
-->
<!--
<section><title>Interacting with Java</title>

<para>
When a Java class is made accessible to Orc using the <code>class</code> declaration,
the Orc typechecker interacts with the Java type system to make Java types available
in Orc. This feature is experimental and does not allow access to all of Java's typing
features (for example, interfaces are not fully supported), but it does allow
the typechecker to handle many of the common cases.
</para>

<para>
The type returned by the constructor of a class has the same name in Orc as the class.
It is the Orc type of Java objects of that class.

<programlisting language="orc"><![CDATA[
class File = java.io.File
File("test.orc") :: File
]]></programlisting>
</para>

<para>
If a <code>class</code> declaration binds a generic Java class, that type shows up
in Orc as a parametric type, and its constructor takes type arguments. For example:

<programlisting language="orc"><![CDATA[
class TreeSet = java.util.TreeSet
TreeSet[String]() :: TreeSet[String]
]]></programlisting>
</para>

<para>
There is a correspondence between Orc's primitive types and the equivalent classes
in Java; they are interchangeable. For example, a call expecting a <code>java.lang.Integer</code>
can be given an Orc <code>Integer</code>.
</para>

<para>
Subtyping between Java object types is determined by Java's subtyping relation: if
one class is a subclass of the other, then one type will be a subtype of the other.
The typechecker does not implement support a full join operation for Java types; it will
not find the least common ancestor of two classes as the join.
</para>

</section>
-->

<!-- 
<section><title>Exception Handling</title>

<para>
The Orc typechecker currently provides only partial support for the typechecking of the
<code>try</code>/<code>catch</code> <link linkend="exceptions">exception handling mechanism</link>.
</para>

<para>
The expression <code>throw</code> E always has type <code>Bot</code>. E is typechecked
to ensure that it does indeed have some type, but that type is ignored, since a throw expression
will raise exceptions rather than publish values.
</para>

<para>
In the expression <code>try</code> E <code>catch(</code>P<code>)</code> F, the type of the
whole expression is the type of E. The type of the handler body F must be the same as, or
some subtype of, the type of E.
</para>

<para>
The expression F is checked without information about the
type of the exception value bound by <code>P</code>; the typechecker uses the type <code>Bot</code>.
This is a hole in the typechecker; it is possible to write an exception handler which uses
its argument inappropriately and generates a runtime type error. For the moment, it is the
programmer's responsibility to ensure that a handler uses its argument appropriately; we are
currently investigating possible solutions to this problem. 
</para>

<para>
In practice this weakness is rarely a problem, because the common use case for <code>catch</code>
handler arguments is to match against a Java exception class:

<programlisting language="orc"><![CDATA[
class FileNotFoundException = java.io.FileNotFoundException
try
  ...
catch (FileNotFoundException(e))
  ...
]]></programlisting>

Since this effectively performs a cast, the variable <code>e</code> is given the appropriate type
<code>FileNotFoundException</code>, and the typechecker behaves correctly in this case.

</para>

</section>

 -->

<!--
<section><title>Syntax of Typed Orc</title>

<para>
The following figure summarizes the syntax of typed Orc as an extension of untyped Orc. 
The original Orc grammar rules are abbreviated by ellipses (...). 
</para>

<para>
<table id="types-ebnf-table" frame="none" rowsep="0" colsep="0">
<title>Typed Orc</title>  
<?dbhtml table-width="80%" ?>
<?dbfo table-width="100%" ?> -->
<!--  <?dbfo keep-together="always" ?>  -->
	<!--
<tgroup cols="5" >
<colspec colnum="1" colname="bexp" colwidth="1*" align="right"/>
<colspec colnum="2" colname="texp" colwidth="1*" align="center"/>
<colspec colnum="3" colname="fexp" colwidth="10*" align="left"/>
<colspec colnum="4" colname="whole exp" colwidth="4*" align="left"/>
<colspec colnum="5" colname="whole exp" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>T</entry>
<entry>::=</entry>

<entry> </entry>

<entry><emphasis>Type</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>Type variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>Integer</code> | <code>Boolean</code> | <code>String</code> | <code>Number</code> | <code>Signal</code> | <code>Top</code> | <code>Bot</code></entry>

<entry></entry>
<entry><emphasis>Ground type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code></entry>

<entry></entry>
<entry><emphasis>Tuple type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda</code> <code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code> <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>Function type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code></entry>

<entry></entry>
<entry><emphasis>Type application</emphasis></entry>
</row>

<row>
<entry>D</entry>
<entry>::=</entry>

<entry> ... </entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>type import</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>=</code> T</entry>

<entry></entry>
<entry><emphasis>type alias</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>=</code> TC | ... | TC </entry>

<entry></entry>
<entry><emphasis>datatype declaration (typed)</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code> <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>function signature</emphasis></entry>
</row>


<row>
<entry>TC</entry>
<entry>::=</entry>

<entry> X<code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code>  </entry>

<entry><emphasis>Constructor (typed)</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>E</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>type ascription</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>:!:</code> T</entry>

<entry></entry>
<entry><emphasis>type assertion</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda</code><code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code><code>::</code> T <code>=</code> E </entry>

<entry></entry>
<entry><emphasis>closure (typed)</emphasis></entry>
</row>

<row>
<entry>G</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>type parameters plus arguments</emphasis></entry>
</row>

<row>
<entry>P</entry>
<entry>::=</entry>

<entry>...</entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>type ascription</emphasis></entry>
</row>

</tbody>
</tgroup>
</table>
</para>

</section>
-->
<!-- 

raw extra material:

<para>
A type signature consists of: a declaration keyword, a declaration name,
type parameters (with subtyping constraints), formal argument types,
and finally the return type. For example <code>def min[A &lt;: Comparable](A,
	A) :: A</code> gives the type of the <code>def</code> declaration for
<code>min</code>. According to this signature, <code>min</code> is a function
parameterized over any type <code>A</code> which is a subtype of
<code>Comparable</code>. It takes two arguments of type <code>A</code> and
returns a value of the same type.
</para>
<para>
Polymorphic sites and functions are declared with explicit type parameters.
By convention, the type parameters are written using the letters <code>A</code>
... <code>Z</code>. For example, the signature <code>site let[A](A) :: A</code>
means that <code>let</code> takes one argument of any type, and returns a value
of the same type.  Subtyping constraints can be used to constrain the type
parameters. A constrained type parameter has the form <code>A &lt;: X</code>,
meaning the type supplied for <code>A</code> must be a subtype of <code>X</code>.
</para>

<para>
Argument and return types are written as follows:
<itemizedlist>
<listitem>Primitive types are given descriptive names based on the names of the
	corresponding Java classes. For example, <code>Number</code> is any
	number, and <code>Comparable</code> is any value which supports a total
	order.</listitem> 
<listitem>The Top type (the type of <code>signal</code>, of which all types are subtypes) is written
	<code>Top</code>. The Bottom type (the type of <code>halt</code>, and a subtype of all types) is
	written <code>Bot</code>.</listitem>
<listitem>A tuple with element types <code>A, B, ...</code> is written <code>(A, B, ...)</code>.</listitem>
<listitem>Any other parameterized type is written as a type name followed by
	type parameters in square brackets. For example, <code>List[String]</code>
	is the type of a list of strings, and <code>Array[Integer]</code> is the type
	of arrays of integers.</listitem>
<listitem>A function type (when given as an argument or return type) is written with the keyword
	<code>lambda</code> followed by the argument types and return type as
	in a declaration type signature. For example, <code>lambda (Integer) ::
	Integer</code> is the type of functions mapping integers to
	integers.</listitem>
</itemizedlist>
</para>

<para>
Multiple sets of argument types are syntactic sugar for currying. For
example, <code>site Foo()() :: Top</code> is equivalent to
<code>site Foo() :: lambda () :: Top</code>.
</para>



<section>






-->
<!--
 </chapter>
 -->

<!-- 
<chapter><title>Execution Environment</title>
</chapter>
-->

<!-- 
<chapter><title>Debugging</title>
</chapter>
 -->
 
<!-- 
<chapter><title>The Implementation</title>
</chapter>
-->


<appendix><title>Complete Syntax of Orc</title>

<para>

<table id="full-ebnf-grammar" frame="none" rowsep="0" colsep="0">
<title>Complete Syntax of Orc</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="100%" ?>
<!--  <?dbfo keep-together="always" ?>  -->
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="5*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E G+</entry>

<entry></entry>
<entry><emphasis>call</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>prefix operator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>infix operator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>FATBAR</code> E</entry>

<entry></entry>
<entry><emphasis>parallel combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ <]]></code>P<code><![CDATA[< ]]></code>E</entry>

<entry></entry>
<entry><emphasis>pruning combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>otherwise combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda (</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>closure (untyped)</emphasis></entry>

</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda</code><code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code><code>::</code> T <code>=</code> E </entry>

<entry></entry>
<entry><emphasis>closure (typed)</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>type ascription</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>:!:</code> T</entry>

<entry></entry>
<entry><emphasis>type assertion</emphasis></entry>
</row>

<!--
<row>
<entry></entry>
<entry>|</entry>

<entry>D <code>within</code> E</entry>

<entry></entry>
<entry><emphasis>goal expression w/declarations</emphasis></entry>
</row>
-->

<!-- 
<row>
<entry></entry>
<entry>|</entry>

<entry>T</entry>

<entry></entry>
<entry><emphasis>throw expression</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>TC</entry>

<entry></entry>
<entry><emphasis>try/catch block</emphasis></entry>
</row>

-->

<!--  
 
<row>
<entry>T</entry>
<entry>::=</entry>

<entry> <code>throw </code> E</entry>

<entry><emphasis>Throw</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>TC</entry>
<entry>::=</entry>

<entry> <code>try ( </code> E <code> ) </code> C+</entry>

<entry><emphasis>Try/Catch</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>C</entry>
<entry>::=</entry>

<entry> <code>catch ( </code> P <code> ) </code> E</entry>

<entry><emphasis>Exception Handler</emphasis></entry>
<entry></entry>
</row>
 -->


<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>arguments</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry> <code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>type parameters plus arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>?</code> </entry>

<entry></entry>
<entry><emphasis>dereference</emphasis></entry>
</row>


<row>
<entry>C</entry>
<entry>::=</entry>

<entry><emphasis>Boolean</emphasis> | <emphasis>Number</emphasis> | <emphasis>String</emphasis> | <code>signal</code> | <code>null</code></entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>identifier</emphasis></entry>

<entry><emphasis>Variable</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>address</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code>+ <code>::</code> T <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code>+ <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>function signature</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>type import</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>=</code> T</entry>

<entry></entry>
<entry><emphasis>type alias</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X <code>=</code> UC | ... | UC </entry>

<entry></entry>
<entry><emphasis>datatype declaration (untyped)</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>=</code> TC | ... | TC </entry>

<entry></entry>
<entry><emphasis>datatype declaration (typed)</emphasis></entry>
</row>


<row>
<entry>UC</entry>
<entry>::=</entry>

<entry> X<code>(_,</code> ... <code>,_)</code> </entry>

<entry><emphasis>Constructor (untyped)</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>TC</entry>
<entry>::=</entry>

<entry> X<code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code>  </entry>

<entry><emphasis>Constructor (typed)</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X <code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>datatype pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>:</code> P</entry>

<entry></entry>
<entry><emphasis>cons pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>=</code>X</entry>

<entry></entry>
<entry><emphasis>equality pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>type ascription</emphasis></entry>
</row>


<row>
<entry>T</entry>
<entry>::=</entry>

<entry>  </entry>

<entry><emphasis>Type</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>Type variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>Integer</code> | <code>Boolean</code> | <code>String</code> | <code>Number</code> | <code>Signal</code> | <code>Top</code> | <code>Bot</code></entry>

<entry></entry>
<entry><emphasis>Ground type</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code></entry>

<entry></entry>
<entry><emphasis>Tuple type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda</code> <code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code> <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>Function type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code></entry>

<entry></entry>
<entry><emphasis>Type application</emphasis></entry>
</row>


</tbody>
</tgroup>
</table>
</para>


<para>
Where relevant, syntactic constructs are ordered by precedence, from highest to lowest. For example, among expressions, calls have higher precedence than
any of the combinators, which in turn have higher precedence than conditionals.
</para>

</appendix>

<appendix id="appendix.library"><title>Standard Library</title>
<section><title>Overview</title>
<para>
The standard library is a set of declarations implicitly available to all Orc
programs.  In this section we give an informal description of the standard library,
including the type of each declaration and a short explanation of its use.
</para>

<para>
Orc programs are expected to rely on the host language and environment for
all but the most essential sites.  For example, in the Java implementation of
Orc, the entire Java standard library is available to Orc programs via
<code>class</code> declarations. Therefore the Orc standard library aims only
to provide convenience for the most common Orc idioms, not the complete set of
features needed for general-purpose programming.
</para>
</section>

<section><title>Types and Notation</title>

<para>
The standard library is fully compatible with the static type checker; all
library declarations have associated type declarations, which also serve as
helpful documentation. 
</para>

<para>
The documentation of library functions uses special notation for parametric 
types that have dot-accessible members.
Member names are written in the form Type.member, e.g.  <code>Foo.get</code>
refers to the <code>get</code> member of an object of type <code>Foo</code>.
The object type can include type variables which are referenced by the member
type, so for example <code>site Buffer[A].get() :: A</code> means that
when the <code>get</code> method is called on a <code>Buffer</code> holding an
arbitrary element type <code>A</code>, it will return a value of the same type.
</para>
 
</section>

<!--  <xi:include href="stdlib.xml"/> -->

</appendix>

<!-- 
<appendix><title>FAQ</title>
Under construction.
</appendix>
 -->

</book>
