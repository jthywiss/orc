<?xml version="1.0" encoding="UTF-8"?>
<!-- ug.language.orc.xml - DocBook source for the Orc user guide

     $Id: ug.language.orc.xml 2767 2011-04-16 23:54:16Z jthywissen $

     Copyright (c) 2011 The University of Texas at Austin. All rights reserved.

     Use and redistribution of this file is governed by the license terms in
     the LICENSE file found in the project's top-level directory and also found at
     URL: http://orc.csres.utexas.edu/license.shtml .
  -->

<chapter xml:id="ug.language.orc"
		 xmlns="http://docbook.org/ns/docbook" 
		 xmlns:xlink="http://www.w3.org/1999/xlink"
		 xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Orc: Orchestrating services</title>

<para>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. The full 
Orc language transcends these limitations by incorporating the orchestration of external services.
We introduce the term <firstterm>site</firstterm> to denote an external service which can be
called from an Orc program.
</para>

<para>
As in Cor, an Orc program is an  <firstterm>expression</firstterm>; Orc expressions are built 
up recursively from smaller expressions. Orc is a superset of Cor, i.e., all Cor expressions are 
also Orc expressions. Orc expressions are <firstterm>executed</firstterm>, rather than evaluated; 
an execution may call external services and <firstterm xml:id="terms.publish">publish</firstterm> some number of 
values (possibly zero). Different executions of the same expression may have completely different
behaviors; they may call different services, may receive different responses from the same site,
and may publish different values. Expressions in the functional subset, though, will display
the same behavior in all executions.
</para>

<para>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <firstterm>combinators</firstterm>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</para>

		
<section xml:id="orc.sites"><title>Communicating with external services</title>

<para>
An Orc expression may be a site call. Sites are called using the same syntax as a 
function call, but with a slightly different meaning. Sites are introduced and bound 
to variables by a special declaration.  
</para>

<section xml:id="orc.sites.calling"><title>Calling a site</title>

<para>
Suppose that the variable <code>Google</code> is bound to a site which invokes the
Google search engine service in "I'm Feeling Lucky" mode. A call to <code>Google</code> 
looks just like a function call. Calling <code>Google</code> requests the URL of the top 
result for the given search term.

<programlisting><![CDATA[
{- Get the top search result for "computation orchestration" -}
Google("computation orchestration")
]]></programlisting>

Once the Google search service determines the top result, it sends a response. The site 
call then publishes that response. Note that the service might not respond: Google's 
servers might be down, the network might be down, or the search might yield no result URL.  
</para>

<para>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</para>

<!--  maybe cut this -->
<para>
A call to a site has exactly one of the following effects: 

<orderedlist>
<listitem>The site returns a value, called its <firstterm>response</firstterm>.</listitem>
<listitem>The site communicates that it will never respond to the call; we say that the call has <firstterm>halted</firstterm></listitem>
<listitem>The site neither returns a value nor indicates that the call has halted; we say that the call is <firstterm>pending</firstterm>.</listitem>
</orderedlist>
</para>

<para>
In the last two cases, the site call is said to be silent. However, unlike a silent expression in Cor, 
a silent site call in Orc might perform some meaningful computation or communication; silence does 
not necessarily indicate an error. Since halted site calls and pending site calls are both silent,
they cannot usually be distinguished from each other; only the <link linkend="combinators.otherwise">
otherwise combinator</link> can tell the difference. 
</para>


<para>
A site is a value, just like an integer or a list. It may be bound to a variable, passed 
as an argument, or published by an execution, just like any other value.
</para> 

<para>
<programlisting><![CDATA[
{- Create a search site from a search engine URL,
   bind the variable Search to that site,
   then use that site to search for a term.
-}

val Search = SearchEngine("http://www.google.com/")
Search("first class value")
]]></programlisting>
</para>

<para>
A site is sometimes called only for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <firstterm>signal</firstterm>: a special value which carries no 
information (analogous to the unit value <code>()</code> in ML). The signal value
can be written as <code>signal</code> within Orc programs.


<programlisting language="orc-demo"><![CDATA[
{- Use the 'println' site to print a string, followed by
   a newline, to an output console.
   The return value of this site call is a signal.
-}

Println("Hello, World!")
]]></programlisting>
</para>


</section>


</section>


<section xml:id="combinators"><title>The concurrency combinators of Orc</title>

<para>
Orc has four <firstterm>combinators</firstterm>: parallel, sequential, pruning, and otherwise. 
A combinator forms an expression from two component expressions. Each combinator captures a 
different aspect of concurrency. Syntactically, the combinators are written infix, and have
lower precedence than operators, but higher precedence than conditionals or declarations.
</para>

<section xml:id="combinators.parallel"><title>The parallel combinator</title>

<para>
Orc's simplest combinator is <code>|</code>, the parallel combinator. Orc executes
the expression F <code>|</code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
F <code>|</code> G does so as well.  The resulting publications of F <code>|</code> G
may be published in arbitrary order.
</para>   

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish 1 and 2 in parallel -}  

1 | 1+1

{-
OUTPUT:PERMUTABLE
1
2
-}
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
{- Access two search sites, Google and Yahoo, in parallel.

   Publish any results they return.
  
   Since each call may publish a value, the expression
   may publish up to two values.
-}  
Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
</para>  

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish 1, 2, and 3 in parallel -}
  
1+0 | 1+1 | 1+2

{-
OUTPUT:PERMUTABLE
1
2
3
-}
]]></programlisting>
</para>  

<para>For more information, see the 
	<olink targetdoc="refmanual" targetptr="ref.combinators.parallel">
	Reference Manual (Parallel Combinator)	
	</olink>.
</para>

</section>

<section xml:id="combinators.sequential"><title>The sequential combinator</title>

<para>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F<code><![CDATA[ >x> ]]></code>G, 
combines the expression F, which may publish some values, with another expression G, 
which will use the values as they are published; <code>x</code> transmits the values
from F to G.
</para>

<para>
The execution of F<code><![CDATA[ >x> ]]></code>G starts by executing F. Whenever F publishes a value, 
a new instance of G is executed in parallel with F (and with any previous copies of G); in that
instance of G, variable <code>x</code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish 1 and 2 in parallel -}
  
(0 | 1) >n> n+1

{-
OUTPUT:PERMUTABLE
1
2
-}
]]></programlisting>
</para>  

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish 3 and 4 in parallel -}
  
2 >n> (n+1 | n+2)

{-
OUTPUT:PERMUTABLE
3
4
-}
]]></programlisting>
</para>  


<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish 0, 1, 2 and 3 in parallel -}
  
(0 | 2) >n> (n | n+1)

{-
OUTPUT:PERMUTABLE
0
1
2
3
-}
]]></programlisting>
</para>  


<para>
<programlisting><![CDATA[
{- Prepend the site name to each published search result
   The cat site concatenates any number of arguments into one string
-}  
  Google("cupcake") >s> cat("Google: ", s)
| Yahoo("cupcake") >s> cat("Yahoo: ", s)
]]></programlisting>
</para>  




<para>
The sequential combinator may be written as F<code> &gt;</code>P<code>&gt; </code>G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new instance of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new instance of G is executed.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish 3, 6, and 9 in arbitrary order. -}

(3,6,9)  >(x,y,z)>  ( x | y | z )

{-
OUTPUT:PERMUTABLE
3
6
9
-}
]]></programlisting>
</para>


<para>
<programlisting language="orc-demo"><![CDATA[
{- Filter out values of the form (_,false) -}

( (4,true) | (5,false) | (6,true) )  >(x,true)> x

{-
OUTPUT:PERMUTABLE
4
6
-} 
]]></programlisting>
</para>
 


<para>
We may also omit the variable entirely, writing <code><![CDATA[ >> ]]></code>. This
is equivalent to using a wildcard pattern: <code><![CDATA[ >_> ]]></code>
</para>

<para>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code><![CDATA[ >> ]]></code> together with the special expression 
<code>stop</code>, which is always silent.  
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Print two strings to the console,
   but don't publish the return values of the calls.
-}

( Println("goodbye") | Println("world") ) >> stop

{-
OUTPUT:
goodbye
world
-}
]]></programlisting>
</para>

<para>
The sequential combinator makes it easy to bind variables in sequence and use
them together.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish the cross product of {1,2} and {3,4} -}

(1 | 2) >x> (3 | 4) >y> (x,y)

{-
OUTPUT:PERMUTABLE
(1,3)
(1,4)
(2,3)
(2,4)
-}
]]></programlisting>
</para>


</section>


<section xml:id="combinators.pruning"><title>The pruning combinator</title>

<para>
The pruning combinator, written F<code><![CDATA[ <x< ]]></code>G, allows us to block 
a computation waiting for a result, or terminate a computation. The execution of 
F<code><![CDATA[ <x< ]]></code>G starts by executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then the execution of G is immediately 
<firstterm>killed</firstterm>. A killed expression cannot call any sites or 
publish any values.
</para>

<para>
During the execution of F, any part of the execution that depends on <code>x</code> 
will be suspended until <code>x</code> is bound (to the first value published by G). If G
never publishes a value, that part of the execution is suspended forever. 
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish either 5 or 6, but not both -}

x+2 <x< (3 | 4)

{-
OUTPUT:
5
-}
{-
OUTPUT:
6
-}
]]></programlisting>
</para>  

<para>
Though a terminated execution may not make any new calls, the calls
that it has already made will continue normally; their responses are simply
ignored. This may have surprising consequences when a call has side effects,
as in the following example.

<programlisting language="orc-demo"><![CDATA[
{- This example might actually print both "uh" and "oh" to the
   console, regardless of which call responds first. -}

stop <x< Println("uh") | Println("oh")

{-
OUTPUT:PERMUTABLE
uh
oh
-}
{-
OUTPUT:
uh
-}
{-
OUTPUT:
oh
-}
]]></programlisting>

Both of the <code>Println</code> calls could be initiated before either one of
them publishes a value and terminates the expression. Once the expression
is terminated, no new calls occur, but the other <code>Println</code> call
still proceeds and still has the effect of printing its message to the
console.
</para>

</section>


<section xml:id="combinators.otherwise"><title>The otherwise combinator</title>

<para>
Orc has a fourth concurrency combinator: the <firstterm>otherwise</firstterm> combinator,
written F<code> ; </code>G. The execution of F<code> ; </code> G proceeds as follows.
First, F is executed. If F <firstterm>halts</firstterm>, and has not published any values, 
then G executes. If F did publish one or more values, then G is ignored. The publications of 
F <code>;</code> G are those of F if F publishes, or those of G otherwise.
</para>

<!-- TODO: may need a 1 sentence description of 'halts' -->
<!--  TODO: may need an example too -->
</section>



</section>



<section><title>Revisiting Cor expressions</title>

<para>
Some Cor expressions have new behaviors in the context of Orc, due to the introduction
of concurrency and of sites.
</para>


<!--  TODO: Cut -->
<section><title>Operators</title>

<para>
The arithmetic, logical, and comparison operators are actually calls to sites, simply
written in infix style with the expected operator symbols. For example, <code>2+3</code>
is actually <code>(+)(2,3)</code>, where <code>(+)</code> is a primitive site provided
by the language itself. All of the operators can be used directly as sites in this way;
the name of the site is the operator enclosed by parentheses, e.g. <code>(**)</code>,
<code>(>=)</code>, etc. Negation (unary minus) is named <code>(0-)</code>.
</para>

</section>

<!--  TODO: Cut -->
<section xml:id="orc.conditionals"><title>Conditionals</title>

<para>
The conditional expression <code>if</code> E <code>then</code> F <code>else</code> G
is actually a derived form based on two different sites named <code>If</code> and <code>Iff</code>. 
The sites take a boolean argument.  <code>If</code> returns a signal if that argument is <code>true</code>,
or remains silent if the argument is <code>false</code>.  <code>Iff</code> returns a signal if that argument
is <code>false</code> or remains silent if the argument is <code>true</code>.
</para>

<para>
<code>if</code> E <code>then</code> F <code>else</code> G is equivalent 
to <code>(<![CDATA[ Ift(b) >> ]]></code>F<code><![CDATA[ | Iff(b) >> ]]></code>G<code>)<![CDATA[ <b< ]]></code>E.
</para>

	
</section>

<!--  TODO: Move to val (variables) section from Cor, maybe inline with pruning combinator -->
<section><title><code>val</code></title>

<para>
The declaration <code>val x = </code>G, followed by expression F, is 
actually just a different way of writing the expression F<code><![CDATA[ <x< ]]></code>G.
Thus, <code>val</code> shares all of the behavior of the pruning combinator,
which we have already described. (This is also true when a pattern is used instead
of variable name <code>x</code>).
</para>

</section>


<section xml:id="expression.nesting"><title>Nesting Orc expressions</title>

<para>
The execution of an Orc expression may publish many values. What does such an expression 
mean in a context where only one value is expected? For example, what does <code>2 + (3 | 4)</code> 
publish? 
</para>

<para>
Whenever an Orc expression appears in such a context, it executes until it publishes its first value, 
and then it is terminated. The published value is used in the context as if it were the result of evaluating
the expression.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish either 5 or 6 -}

2 + (3 | 4)

{-
OUTPUT:
5
-}
{-
OUTPUT:
6
-}
]]></programlisting>
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish exactly one of 0, 1, 2 or 3 -}

(0 | 2) + (0 | 1)

{-
OUTPUT:
0
-}
{-
OUTPUT:
1
-}
{-
OUTPUT:
2
-}
{-
OUTPUT:
3
-}
]]></programlisting>
</para>

<!--  TODO: Add link to deflation -->
<para>
To be precise, whenever an Orc expression appears in such a context, it is treated as if it was 
on the right side of a pruning combinator, using a fresh variable name to fill in the hole. 
Thus, C[E] (where E is the Orc expression and C is the context) is equivalent to the expression 
C[<code>x</code>] <code><![CDATA[ <x< ]]></code> E. 
</para>

</section>


<section><title>Functions</title>

<para>
The body of a function in Orc may be any Orc expression; thus, function
bodies in Orc are executed rather than evaluated, and may engage in communication
and publish multiple values.
</para>

<para>
A function call in Orc binds the values of its arguments
to the function's parameters, and then executes the function body in parallel with the
computation of the bindings. Whenever the function body publishes a value, the function call publishes that
value. Thus, unlike a site call, a function call may publish many values.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Publish all integers in the interval 1..n, in arbitrary order. -}
def range(n) = if (n > 0) then (n | range(n-1)) else stop 

{- Publish 1, 2, and 3 in arbitrary order. -}
range(3)

{-
OUTPUT:PERMUTABLE
1
2
3
-}
]]></programlisting>
</para>

<!--  TODO: link to deflation -->
<para>
In the context of Orc, function calls are not strict. When a function call executes,
it begins to execute the function body immediately, and also executes the argument
expressions in parallel. When an argument expression publishes a value, it is killed,
and the corresponding parameter is bound to that value in the execution of
the function body. Any part of the function body which uses a parameter
that has not yet been bound blocks until that parameter is bound to a value.
</para>


<!--  TODO: add example about blocking on function parameters -->

</section>



</section>


<section xml:id="orc.language.time"><title>Time</title>

<para>
Orc is designed to communicate with the external world, and one of the
most important characteristics of the external world is the passage of
time. Orc implicitly interacts with the passage of time by calling external
services which take time to respond. However, Orc can also explicitly
wait for some amount of time, using the special site <code>Rwait</code>. 
</para>

<!--  TODO: link approximately to ref manual -->
<para>
The site <code>Rwait</code> is a relative timer. It takes as an argument
a number of milliseconds to wait. It waits for approximately that amount of time,
and then responds with a signal.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- Print "red", wait for 3 seconds (3000 ms), and then print "green" -}
 
Println("red") >> Rwait(3000) >> Println("green") >> stop

{-
OUTPUT:
red
green
-}
]]></programlisting>
</para>

<para>
The following example defines a metronome, which publishes a signal once 
every <code>t</code> milliseconds, indefinitely.
</para>

<para>
<programlisting><![CDATA[
def metronome(t) = signal | Rwait(t) >> metronome(t)
]]></programlisting>
</para>

<para>
We can also use <code>Rwait</code> together with the pruning combinator 
to enforce a timeout.
</para>

<para>
<programlisting><![CDATA[
{- Publish the result of a Google search.
   If it takes more than 5 seconds, time out.
-}
result 
  <result< ( Google("impatience") 
           | Rwait(5000) >> "Search timed out.")
]]></programlisting>
</para>


<!--  TODO: Change name from Chapter 2 to 'methodology' or some such -->
We present many more examples of programming techniques using real time in <link linkend="chapter.methodology">Chapter 2</link>.

</section>


</chapter>


<!-- TODO: keep dot access -->
<!-- TODO: keep datatypes -->
<!-- TODO: keep def class -->
