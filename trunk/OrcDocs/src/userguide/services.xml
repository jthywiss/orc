<?xml version="1.0" encoding="UTF-8"?>

<chapter id="chapter.services" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>Accessing and Creating External Services</title>

<section id="section.services.intro"><title>Introduction</title>

<para>
There are two primary ways to create sites which can be used in Orc:
</para>

<orderedlist>
<listitem>Implement sites as regular Scala or Java classes.
	Orc programs can import and use these classes directly with the
	<code>class</code> declaration. This approach is easy for anyone
	already familiar with Scala/Java, and such sites are straightforward to share
	between Orc and the Java Virtual Machine.  However such sites are limited in how they
	can interact with the Orc engine.
</listitem>
<listitem>Implement sites using Orc's low-level site API.  Orc programs can
	import and use these sites with the <code>site</code> declaration.
	This approach provides full access to the features of the Orc engine.
	However such sites are difficult to use from Scala or Java code.
</listitem>
</orderedlist>

<para>
External services (including web services) are handled using the <link
	xlink:href="http://en.wikipedia.org/wiki/Proxy_pattern">Proxy
	pattern</link>.  A site implemented in the base language (using one of the two
techniques above) must act as the local proxy for the service, translating Orc
site calls into the appropriate requests and translating responses into site
return values, halts, or errors.
</para>
</section>

<section id="section.services.java"><title><code>class</code> Sites</title>

<para>
Scala and Java classes can be imported into Orc as sites using the <link
	linkend="section.orc.class"><code>class</code> declaration</link>.
Imported classes must be in the classpath of the JVM running the Orc
interpreter.  The following sections describe in detail how such imported
classes behave in Orc programs.
</para>

<section id="section.services.java.dot"><title>Dot Operator</title>

<para>
<code>x.member</code>, where <code>x</code> evaluates to a Scala/Java class or object, 
is evaluated as follows:
<itemizedlist>
<listitem>If <code>x</code> has one or more methods named <code>member</code>,
a "method handle" site is returned which may be called like any other Orc site.
When a method handle is actually called with arguments, the appropriate Scala/Java
method is selected and called depending on the number and type of arguments, as
<!-- CHANGE ME (the method resolution section) -->
described in <link linkend="section.services.java.method">Method Resolution</link>
below.</listitem>
<listitem>Otherwise, if <code>x</code> has a field named <code>member</code>,
the object's field is returned, encapsulated in a <link
	linkend="ref.stdlib.state.Ref"><code>Ref</code> object</link>. The
<code>Ref</code> object has <code>read</code> and <code>write</code> methods
which are used to get and set the value of the field.</listitem>
</itemizedlist>
</para>

<para>
Note that no distinction is made between static and non-static members; it is
an error to reference a non-static member through a class, but this does not
change how members are resolved.  Note also that if a field shares a name with
one or more methods, there is no way to access the field directly.
</para>

<para>
The following (rather useless) example illustrates how the dot operator can be
used to access both static and non-static methods and fields:
<programlisting>
{- bind Integer to a Java class -}
class Integer = java.lang.Integer

{- call a static method -}
val i = Integer.decode("5")
{- read a field -}
val m = Integer.MIN_VALUE.read()
{- write a field -}
Integer.MIN_VALUE.write(5) >>
{- call a non-static method -}
i.toString()
</programlisting>
</para>

</section>

<section><title>Direct Calls</title>

<para>
When <code>x</code> evaluates to a Scala/Java object (but not a Scala/Java class), the syntax
<code>x(...)</code> is equivalent to <code>x.apply(...)</code>.
</para>

<para>
When <code>x</code> evaluates to a Scala/Java class, the syntax <code>x(...)</code>
calls the class's constructor.  In case of overloaded constructors, the
appropriate constructor is chosen based on the number and types of arguments as
described in <link linkend="section.services.java.method">Method Resolution</link>.
</para>

</section>

<section><title>Pattern Matching</title>

<para>
If <code>C</code> is bound to a Scala/Java class, it can be used as a pattern.
A pattern <code>C(x)</code> matches any Scala/Java object of that class or
any of its subclasses. The variable <code>x</code> is simply bound
to the object again; thus the matcher is just a partial identity function.
</para>

<!-- 

<para>
This is most often used to match <link linkend="exceptions">exceptions</link>
against specific Java exception types in a <code>catch</code>.
</para>

 -->

</section>

<!-- CHANGE ME (method resolution) -->
<section id="section.services.java.method"><title>Method Resolution</title>

<para>
When a method handle is called, the actual Scala/Java method called is chosen based
on the runtime types of the arguments, as follows:
<orderedlist>
<listitem>If only one method has the appropriate number of arguments, that method is called.</listitem>
<listitem>Otherwise, each method taking the appropriate number of arguments is
	tested for type compatibility as follows, and the first matching method
	is called.
	<orderedlist>
	<listitem>Every argument is compared to the corresponding formal
		parameter type as follows. All arguments must match for the
		method to match.
		<orderedlist>
		<listitem>If the argument is null, then the argument matches</listitem>
		<listitem>If the formal parameter type is primitive (int, char,
			float, ...) and the argument is an instance of a
			wrapper class, then the argument is unboxed (unwrapped)
			and coerced to the type of the formal parameter
			according to Java's standard rules for implicit
			widening coercions.</listitem>
		<listitem>If the formal parameter type is a primitive numeric type
			and the argument is an instance of <code language="java">BigDecimal</code>,
			the argument is implicitly narrowed to the formal parameter type.</listitem>
		<listitem>If the formal parameter type is a primitive integral type
			and the argument is an instance of <code language="java">BigInt</code>,
			the argument is implicitly narrowed to the formal parameter type.</listitem>
		<listitem>Otherwise, the argument must be a subtype of the formal parameter type.</listitem>
		</orderedlist>
	</listitem>
	</orderedlist>
</listitem>
</orderedlist>
</para>

<para>
The reason for the unusual implicit narrowing of <code language="java">BigDecimal</code> and
<code language="java">BigInt</code> is that Orc numeric literals have these types, and it
would be awkward to have to perform an explicit conversion every time such a
value is passed to a Java method expecting a primitive.
</para>

<para>
Currently we do not implement specificity rules for choosing the best matching
method; the first matching method (according to some unspecified order) is
chosen.  Note also that we do not support varargs methods explicitly, but
instead varargs may be passed as an array of the appropriate type.
</para>

</section>

<section xml:id="section.services.orcvalues"><title>Orc values in Scala</title>

<para>
Orc values are implemented by Scala objects, so in general any Orc value may be
passed to a site implemented in Scala.  Standard Orc values have the following
Scala types:
</para>

<variablelist>
<?dbfo list-presentation="list" term-width="6em"?>
<varlistentry><term>string</term><listitem><code language="java">java.lang.String</code></listitem></varlistentry>
<varlistentry><term>boolean</term><listitem><code language="java">java.lang.Boolean</code></listitem></varlistentry>
<varlistentry><term>number</term><listitem><code language="java">scala.math.BigDecimal and scala.math.BigInt</code></listitem></varlistentry>
<varlistentry><term>tuple</term><listitem><code language="java">orc.values.OrcTuple</code></listitem></varlistentry>
<varlistentry><term>list</term><listitem><code language="java">scala.collection.immutable.List</code></listitem></varlistentry>
<varlistentry><term>function</term><listitem><code language="java">orc.run.Closure</code>
		<para>Currently it is not possible to call Orc functions from Java code.</para></listitem></varlistentry>
<varlistentry><term>site</term><listitem><code language="java">orc.value.sites.Sites</code>
		<para>Currently it is not possible to directly call Orc sites from Java
code.  However if you are implementing a site yourself, you may provide methods
which can be called from Scala/Java code to invoke the behavior of the site.</para></listitem></varlistentry>
</variablelist>
</section>

<section xml:id="section.services.scalavalues"><title>Scala values in Orc</title>

<para>
Scala objects may be used directly as values anywhere in an Orc program.
Primitive Scala values cannot be used directly in an Orc program, but are
automatically boxed (and unboxed) as necessary.
</para>

<para>
When both arguments of an arithmetic or comparison operator are Java or Scala numeric
types, the arguments are implicitly coerced to the widest of the two argument
types.  "Widest" is defined by the following relation, where ">" means "is
wider than": BigDecimal > Double > Float > BigInt > Long > Integer > Short
> Byte
</para>

</section>

</section>

<section id="section.services.coopsched"><title>Cooperative Scheduling and Concurrency</title>

<section><title>Overview</title>
<para>
In order to support massive concurrency efficiently in Scala, Orc uses
the Scala actor library.  Orc programs are broken into discrete steps which
are executed by a pool of actors.  This approach works for Orc
expressions, but the internals of an Orc site written in Scala/Java cannot be easily
broken down.  So Orc uses the following method to call a local Scala/Java site:
</para>

<itemizedlist>
<listitem>Run the site call within a new actor.  This means site calls never
	unnecessarily block the Orc engine.  Orc manages the actor pool.
    The Orc engine never blocks, it only creates new actors or reuses actors
    from the pool.</listitem>
</itemizedlist>

	<!--
<para>
Fortunately, in practice most Orc site calls take a short, deterministic amount
of time to complete. Of those that don't, it's usually only because they are
blocked waiting for some external event, like another site call.  In this case,
instead of blocking the site can return control to the Orc engine, asking to
be run again when the external event occurs.
</para>
		-->

</section>
</section>

<section id="section.services.site"><title><code>site</code> Sites</title>

<section><title>Fundamentals</title>

<para>
Orc sites imported with the <code>site</code> declaration are implemented as
Scala classes which extend <code language="java">orc.values.sites.Sites</code>.
Here we will summarize the most important features of this and related classes;
<!--
for a detailed description, refer to the <link
xlink:href="http://orc.csres.utexas.edu/javadoc/STABLE/index.html">Javadoc</link>.
-->
</para>

	
<para>
Sites must implement a single method: <code language="java">callSite(Args args,
Token token)</code>.  The Orc engine calls this method whenever the site is
called by the Orc program.
</para>

<para>
The <code language="java">args</code> argument (of type <code
language="java">Args</code>) is used to get the arguments which were passed to
the site call by the Orc program. It has the following important methods:
</para>

<variablelist>
<varlistentry><term><code language="java">getArg(int
n)</code></term><listitem>returns the value of the (n+1)th argument, as an
<code language="java">Object</code>.  For example, to get the value of the
first argument, call <code
language="java">args.getArg(0)</code>.</listitem></varlistentry>

<varlistentry><term><code language="java">intArg(int n)</code>, <code
language="java">stringArg(int n)</code>, <code language="java">boolArg(int
n)</code>, etc.</term><listitem>returns the value of the (n+1)th argument cast
to the appropriate type. If the argument is not the appropriate type, throws an
<code
language="java">ArgumentTypeMismatchException</code>.</listitem></varlistentry>
</variablelist>

<para>
The <code language="java">token</code> argument (of type <code
language="java">Token</code>) is a sort of callback which is used by the site
to return a value or signal that it has halted. It has the following important
methods:
</para>

<variablelist>
<varlistentry><term><code language="java">resume(Object
value)</code></term><listitem>return the value <code
language="java">value</code> from the site call. For example, to return the
number 5, call <code language="java">token.resume(5)</code>.  To publish a
signal without returning any specific value, call <code
language="java">token.resume()</code>.</listitem></varlistentry>

<varlistentry><term><code language="java">error(TokenException
problem)</code></term><listitem>halt without publishing a value and report an
error.  This method is an appropriate way to report Scala or Java exceptions encountered
during a site call.  Alternatively, a site can simply throw a checked exception
from the <code language="java">callSite</code> method; the engine will call
<code language="java">token.error</code> on its behalf. To convert a Java
exception to the necessary <code language="java">TokenException</code> type,
wrap it in an instance of <code
language="java">orc.error.runtime.JavaException</code>.</listitem></varlistentry>

<varlistentry><term><code language="java">die()</code></term><listitem>halt,
without publishing a value or reporting an error. For example, the built-in
site <code>If</code> uses this method to halt when called with a
<code>false</code> argument.</listitem></varlistentry>
</variablelist>

<para>
The <code language="java">callSite</code> method must return control to its
caller within a short, deterministic amount of time.  To implement a site which
blocks or waits for some condition, <code language="java">callSite</code> must
save the <code language="java">token</code> and return without calling any of
the above methods.  Then when it is time for the site call to return, call the
appropriate method on the <code language="java">token</code>.
</para>

</section>

<section><title>More Site Classes</title>

<section><title>EvalSite</title>

<para>
Many sites are deterministic, always returning a value immediately when called.
Such sites can be implemented easily by extending <code
language="java">orc.values.sites.compatability.EvalSite</code> and implementing the method
<code language="java">evaluate(Args args)</code>.  This method should read the
arguments from <code language="java">args</code> as usual, and then return the
value to be returned from the site call, or throw a checked exception to
indicate an error.
</para>
</section>

<section id="section.services.sites.ThreadedSite"><title>ThreadedSite</title>

<para>
Some sites need to perform blocking IO or use other Scala/Java blocking methods like
<code language="java">Object#wait()</code>.  This cannot be done directly in
the <code language="java">callSite</code> or <code
language="java">EvalSite#evaluate</code>  methods because that might block the
Orc engine. Instead, extend <code
language="java">orc.values.sites.compatability.ThreadedSite</code> and implement the method
<code language="java">evaluate(Args args)</code>.  This method should read the
arguments from <code language="java">args</code> as usual, and then return the
value to be returned from the site call, or throw a checked exception to
indicate an error.  Your <code language="java">evaluate</code> method will be
automatically run asynchronously in a new thread so that it does not interfere
with the Orc engine.
</para>

<para>
Beware that the Orc engine may be configured to only allow a fixed number of
site threads. If too many sites need to use threads simultaneously, some will
block until threads become available.
</para>
</section>

<section><title>DotSite</title>

<para>
Recall that the notation <code>x.msg</code> corresponds to calling the site
<code>x</code> with the special message value <code>msg</code>.  To implement a
site which responds to such messages, extend <code
language="java">orc.values.sites.compatability.DotSite</code>.
</para>

<para>
In the site's constructor, call the method <code
language="java">addMember(String message, Object value)</code> once for each
message you wish the site to respond to. The call <code
language="java">addMember(m, v)</code> instructs the site to return the value
<code language="java">v</code> when it is called with the message <code
language="java">m</code>.
</para>

<para>
Any object can be used as a member value, even another site.  Anonymous inner
classes extending <code language="java">Site</code> are often used as member
values which behave like  methods of the enclosing <code
language="java">DotSite</code>.
</para>
</section>
</section>

<section><title>Tutorial Example</title>

<para>
We will implement a simplified version of Orc's <code>Buffer</code> site,
called <code language="java">ExampleBuffer</code>. The goal will be to be able
to run this Orc program:
</para>

<programlisting><![CDATA[
-- Import the site definition
site ExampleBuffer = ExampleBuffer
-- Create a new buffer site
val b = ExampleBuffer()
-- wait for a value in the buffer
b.get()
-- put a value in the buffer
| b.put(3) >> stop
-- Publishes: 3]]></programlisting>

<para>
The first step is to create <filename>ExampleBuffer.java</filename>. The <code
language="java">ExampleBuffer</code> site is actually a <firstterm>discovery site</firstterm>: all
it does when called is create and return a reference to a new site (the buffer
instance).
</para>

<programlisting language="java"><![CDATA[
public class ExampleBuffer extends EvalSite {
  public Object evaluate(Args args) {
    return new ExampleBufferInstance();
  }
}]]></programlisting>

<para>
Next we must implement <code language="java">ExampleBufferInstance</code>,
which defines the behavior of an individual buffer. We can put this class
either in its own file or in <filename>ExampleBuffer.java</filename>, since
that is the only class which refers to it directly. How does an instance
behave? If we write <code>b.get()</code>, that means that <code>b</code>
responds to the message <code>get</code> with a site which we call to get a
value from the buffer. So we'll extend <code language="java">DotSite</code>,
telling it to respond to the message "get" with a <code
language="java">GetMethod</code> site, and likewise for "put". We'll use a
linked list to store the actual contents of the buffer.
</para>

<programlisting language="java"><![CDATA[
class ExampleBufferInstance extends DotSite {
  private LinkedList<Object> contents = new LinkedList<Object>();
  public ExampleBufferInstance() {
    addMember("get", new GetMethod());
    addMember("put", new PutMethod());
  }
}]]></programlisting>

<para>
The <code language="java">GetMethod</code> site is implemented as an inner
class so it has easy access to the contents of the buffer. In the
implementation we first check if there is an item in the buffer. If so, we
return it. Otherwise, we must store the token in a queue to be notified when
the next item is put in the buffer. We synchronize on the outer object to
protect against concurrent modification.
</para>

<programlisting language="java"><![CDATA[
private LinkedList<Token> waiters = new LinkedList<Token>();
private class GetMethod extends Site {
  public void callSite(Args args, Token token) {
    synchronized (ExampleBufferInstance.this) {
      if (!contents.isEmpty()) {
        token.resume(contents.removeFirst());
      } else {
        waiters.add(token);
      } 
    }
  }
}]]></programlisting>

<para>
<code language="java">PutMethod</code> is even simpler since it doesn't need to
block. If there is a token waiting for an item, we give it the item. Otherwise
we put the item in the buffer. We synchronize on the outer object to protect
against concurrent modification. When done we return a dummy "signal" value.
</para>

<programlisting language="java"><![CDATA[
private class PutMethod extends EvalSite {
  public Object evaluate(Args args) {
    Object item = args.getArg(0);
    synchronized (ExampleBufferInstance.this) { 
      if (!waiters.isEmpty()) {
        waiters.removeFirst().resume(item);
      } else {
        contents.add(item);
      } 
    }
    return signal();
  }
}]]></programlisting>

<para>
Putting it all together, here is the entire implementation:
</para>

<programlisting language="java"><![CDATA[
import java.util.LinkedList;

import orc.values.sites.compatability.EvalSite;
import orc.values.sites.compatability.DotSite;
import orc.values.sites.Sites;
import orc.runtime.Token;

public class ExampleBuffer extends EvalSite {
  public Object evaluate(Args args) {
    return new ExampleBufferInstance();
  }
}

class ExampleBufferInstance extends DotSite {
  private LinkedList<Object> contents = new LinkedList<Object>();
  private LinkedList<Token> waiters = new LinkedList<Token>();
    
  private class GetMethod extends Site {
    public void callSite(Args args, Token token) {
      synchronized (ExampleBufferInstance.this) {
        if (!contents.isEmpty()) {
          token.resume(contents.removeFirst());
        } else {
          waiters.add(token);
        } 
      }
    }
  }

  private class PutMethod extends EvalSite {
    public Object evaluate(Args args) {
      Object item = args.getArg(0);
      synchronized (ExampleBufferInstance.this) { 
        if (!waiters.isEmpty()) {
          waiters.removeFirst().resume(item);
        } else {
          contents.add(item);
        } 
      }
      return signal();
    }
  }

  public ExampleBufferInstance() {
    addMember("get", new GetMethod());
    addMember("put", new PutMethod());
  }
}]]></programlisting>
</section>

</section>

<section><title>Web Services</title>

<section><title>Introduction</title>

<para>
While we believe Orc is an excellent language for web service scripting,
currently the library support for such tasks is at a proof-of-concept level.
The web service libraries are not bundled with the core Orc distribution, do
not have stable APIs, and are not officially documented.  However this section
should provide you with enough information to get started.
</para>

</section>

<section><title>Downloading and Running Examples</title>

<para>All Orc sites related to web services are bundled in a separate
"OrcSites" library.  As with the core Orc distribution, you can either
download this library as a prepackaged JAR or check out the
source code from the "OrcSites" module in version control.  We generally recommend the latter
approach, since the source code provides several examples which can be used as
a basis for creating your own web service sites.
</para>

<para>
Within the OrcSites source code you will find:
</para>
<itemizedlist>
<listitem>Java source code for web service sites: <filename>src/orc/lib/net/</filename></listitem>
<listitem>Orc source code for programs using web services: <filename>examples/</filename></listitem>
</itemizedlist>

<para>Several of the examples require you to create
	<filename>.properties</filename> files and place them in your
	classpath. The simplest way to do this is to make sure the
	<filename>examples/</filename> directory is in your classpath, and
	place the necessary <filename>.properties</filename> files there.
</para>

</section>

<section><title>Protocols Supported</title>

<para>
Web services use a variety of protocols, so there are a variety of ways to
contact them. All of them boil down to creating a Scala or Java proxy site for the
service and calling that.  Previous sections explain how to implement such
sites which can be called in Orc. Because web services tend to use blocking
I/O, Java wrappers make frequent use of <link linkend="section.services.sites.ThreadedSite">ThreadedSite</link> 
	to ensure that web service calls don't block the Orc engine.
</para>

<section><title>Java APIs</title>

<para>
Some web services provide Java APIs specifically for the service. For example,
Google Calendar. In these cases we just use the Java API from Orc, either
directly or via a small Java wrapper which simplifies the interface.
</para>

<para>OrcSites includes <code>class orc.lib.net.GoogleCalendar</code> as an
	example of this type of web service.</para>

</section>

<section><title>SOAP RPC</title></section>

<para>
OrcSites includes a generic <code>site orc.lib.net.Webservice</code> which allows you to connect to any SOAP RPC (specifically
rpc/encoded) service, without writing Java wrappers.  Instead <link
	xlink:href="http://ws.apache.org/axis/">Apache Axis</link> is used to
generate Java wrappers on-demand.
</para>

<para>
<link xlink:href="http://www.xmethods.net" /> is a good place to find examples
of SOAP RPC services:
</para>

<orderedlist>
<listitem>Find the RPC "Style" service which does what you want.</listitem>
<listitem>Click on the name of the service.</listitem>
<listitem>Click on "View RPC Profile" for a summary of the methods available.</listitem>
<listitem>Construct instances of the service by passing the WSDL URL to the
	<code>Webservice</code> site. E.g. <code>Webservice("http://site.com/wsdl")</code>.</listitem>
<listitem>Call methods on the service as you would with any Java object. The
	<link xlink:href="http://jcp.org/en/jsr/detail?id=101">JAX-RPC
		specification</link> has complete details on how SOAP
	operations and data types are represented in Java.  Beware: method
	names always begin with a lower-case letter, even if the corresponding
	operation does not.</listitem>
</orderedlist>

<para>
Example:
</para>
<programlisting language="orc-demo">
site orc.lib.net.Webservice
{-
Find documentation of this service at:
http://www.xmethods.net/ve2/WSDLRPCView.po?
key=uuid:BF3EFCDD-FCD4-8867-3AAC-068985E7CB89
-}
val service = Webservice(
  "http://www.ebob42.com/cgi-bin/"
  + "Romulan.exe/wsdl/IRoman")
service.intToRoman(451)
</programlisting>

</section>

<section><title>REST</title>

<para>
Many services use ad-hoc REST/XML protocols. Unfortunately, there is no REST
equivalent to WSDL, so there's no way to automatically generate an API for REST
services. We're not trying to solve this problem with Orc, but when the web
services community reaches some kind of consensus, Orc will support it.
</para>

<para>
For now you must write a Java wrapper for each service which handles
marshalling and unmarshalling the data. There's no reason such marshalling code
couldn't be written in Orc, calling low-level HTTP and XML libraries directly,
but there would be no advantage to doing so, so we let each language play to
its strengths. OrcSites includes utility classes to assist with submitting
requests and parsing responses.</para>

<para>OrcSites includes the following examples of this type of service:</para>
<itemizedlist>
<listitem><code>class orc.lib.net.Upcoming</code></listitem>
<listitem><code>site orc.lib.net.TrueRandom</code></listitem>
<listitem><code>site orc.lib.net.YahooSpellFactory</code></listitem>
</itemizedlist>

</section>

</section>

</chapter>
