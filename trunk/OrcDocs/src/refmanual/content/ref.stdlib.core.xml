<?xml version='1.0' encoding='UTF-8'?>
<section xml:id="ref.stdlib.core"> 
        <!--Generated by OrcDocgen from core.inc on Feb 2, 2011 6:07:56 PM-->
        <title>core</title>
        <para>Fundamental sites and operators.
</para><para>These declarations include both prefix and infix sites (operators).  For
consistency, all declarations are written in prefix form, with the site name
followed by the operands.  When the site name is surrounded in parentheses, as
in <code>(+)</code>, it denotes an infix operator.
</para><para>For a more complete description of the built-in operators and their syntax, see
the <olink targetdoc="root" targetptr="language.base.operators">Operators</olink> section of the
User Guide.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.let">
  		  <term><code>let</code></term>
        <listitem>
  		 	  <para><code>site let() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>When applied to no arguments, return a signal.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>let</code></term>
        <listitem>
  		 	  <para><code>site let(A) :: A</code></para>
  			  <para>When applied to a single argument, return that argument (behaving as the identity function).
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>let</code></term>
        <listitem>
  		 	  <para><code>site let(A, ...) :: (A, ...)</code></para>
  			  <para>When applied to two or more arguments, return the arguments as a tuple.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.If">
  		  <term><code>If</code></term>
        <listitem>
  		 	  <para><code>site If(Boolean) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Fail silently if the argument is false. Otherwise return a signal.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Always publishes"
  If(false) >> "Never publishes"
| If(true) >> "Always publishes"]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.Unless">
  		  <term><code>Unless</code></term>
        <listitem>
  		 	  <para><code>site Unless(Boolean) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Fail silently if the argument is true. Otherwise return a signal.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Always publishes"
  Unless(false) >> "Always publishes"
| Unless(true) >> "Never publishes"]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.error">
  		  <term><code>error</code></term>
        <listitem>
  		 	  <para><code>site error(String) :: Bot</code></para>
  			  <para><sitepropset>   
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Halt with the given error message.
</para><para>Example, using <code>error</code> to implement assertions:
<programlisting language="orc-demo"><![CDATA[
def assert(b) =
  if b then signal else error("assertion failed")
</para><para>-- Fail with the error message: "assertion failed"
assert(false)]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (+)(Number, Number) :: Number</code></para>
  			  <para><code>a+b</code> returns the sum of <code>a</code> and <code>b</code>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (-)(Number, Number) :: Number</code></para>
  			  <para><code>a-b</code> returns the value of <code>a</code> minus the value of <code>b</code>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (0-)(Number) :: Number</code></para>
  			  <para>Return the additive inverse of the argument.
When this site appears as an operator, it is written in prefix form without the
zero, i.e. <code>(-a)</code>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (*)(Number, Number) :: Number</code></para>
  			  <para><code>a*b</code> returns the product of <code>a</code> and <code>b</code>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (**)(Number, Number) :: Number</code></para>
  			  <para><code>a ** b</code> returns
<inlineequation><mathphrase>a<superscript>b</superscript></mathphrase></inlineequation>,
i.e. <code>a</code> raised to the <code>b</code>th power.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (/)(Number, Number) :: Number</code></para>
  			  <para><code>a/b</code> returns <code>a</code> divided by <code>b</code>.
If both arguments have integral types, <code>(/)</code> performs integral
division, rounding towards zero. Otherwise, it performs floating-point
division. If <code>b=0</code>, <code>a/b</code> halts with an error.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
  7/3   -- publishes 2
| 7/3.0 -- publishes 2.333...]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (%)(Number, Number) :: Number</code></para>
  			  <para><code>a%b</code> computes the remainder of <code>a/b</code>. If <code>a</code>
and <code>b</code> have integral types, then the remainder is given by
the expression <code>a - (a/b)*b</code>. For a full description, see the
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.17.3">Java Language Specification, 3rd edition</link>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (&lt;:)(Top, Top) :: Boolean</code></para>
  			  <para><code>a &lt;: b</code> returns true if <code>a</code> is less than <code>b</code>, and false otherwise.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (&lt;=)(Top, Top) :: Boolean</code></para>
  			  <para><code>a &lt;= b</code> returns true if <code>a</code> is less than or equal to <code>b</code>, and false otherwise.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (:&gt;)(Top, Top) :: Boolean</code></para>
  			  <para><code>a :> b</code> returns true if <code>a</code> is greater than <code>b</code>, and false otherwise.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (&gt;=)(Top, Top) :: Boolean</code></para>
  			  <para><code>a >= b</code> returns true if <code>a</code> is greater than or equal to <code>b</code>, and false otherwise.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (=)(Top, Top) :: Boolean</code></para>
  			  <para><code>a = b</code> returns true if <code>a</code> is equal to <code>b</code>,
and false otherwise.  The precise definition of "equal" depends on the values
being compared, but always obeys the rule that if two values are considered
equal, then one may be substituted locally for the other without affecting the
behavior of the program.
</para><para>Two values with the same object identity are always considered equal.
In addition, Cor <olink targetdoc="root" targetptr="cor.constants">constant values</olink> and
<olink targetdoc="root" targetptr="cor.data">data structures</olink> are considered equal if their
contents are equal. Other types are free to implement their own equality
relationship provided it conforms to the rules given here.
</para><para>Note that although values of different types may be compared with
<code>=</code>, the substitutability principle requires that such values are
always considered inequal, i.e. the comparison will return <code>false</code>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (/=)(Top, Top) :: Boolean</code></para>
  			  <para><code>a/=b</code> returns false if <code>a=b</code>, and true otherwise.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (~)(Boolean) :: Boolean</code></para>
  			  <para>Return the logical negation of the argument.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (&amp;&amp;)(Boolean, Boolean) :: Boolean</code></para>
  			  <para>Return the logical conjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (||)(Boolean, Boolean) :: Boolean</code></para>
  			  <para>Return the logical disjunction of the arguments. This is not a short-circuiting
operator; both arguments must be evaluated and available before the result is
computed.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>site (:)[A](A, List[A]) :: List[A]</code></para>
  			  <para>The list <code>a:b</code> is formed by prepending the element <code>a</code> to
the list <code>b</code>.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: (3, [4, 5])
3:4:5:[] >x:xs> (x,xs)]]></programlisting>
</para><para>In patterns, the <code>(:)</code> deconstructor can be applied to a variety of
list-like values such as <code>Array</code>s and Java <code>Iterable</code>s,
in which case it returns the first element of the list-like value, and a new
list-like value (not necessarily of the same type as the original list-like
value) representing the tail.  Modifying the structure of the original
value (e.g. adding an element to an <code>Iterable</code>) may render
old "tail"s unusable, so you should refrain from modifying a value
while you are deconstructing it.  This feature is highly experimental
and will probably change in future versions of the implementation.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.abs">
  		  <term><code>abs</code></term>
        <listitem>
  		 	  <para><code>def abs(Number) :: Number</code></para>
  			  <para>Return the absolute value of the argument.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def abs(Number) :: Number
def abs(x) = if x <: 0 then -x else x

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.signum">
  		  <term><code>signum</code></term>
        <listitem>
  		 	  <para><code>def signum(Number) :: Number</code></para>
  			  <para><code>signum(a)</code> returns <code>-1</code> if <code>a&lt;0</code>,
<code>1</code> if <code>a&gt;0</code>, and <code>0</code> if <code>a=0</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def signum(Number) :: Number
def signum(x) =
  if x <: 0 then -1
  else if x :> 0 then 1
  else 0

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.min">
  		  <term><code>min</code></term>
        <listitem>
  		 	  <para><code>def min[A](A,A) :: A</code></para>
  			  <para>Return the lesser of the arguments. If the arguments
are equal, return the first argument.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def min[A](A,A) :: A
def min(x,y) = if y <: x then y else x

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.max">
  		  <term><code>max</code></term>
        <listitem>
  		 	  <para><code>def max[A](A,A) :: A</code></para>
  			  <para>Return the greater of the arguments. If the arguments
are equal, return the second argument.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def max[A](A,A) :: A
def max(x,y) = if x :> y then x else y


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.floor">
  		  <term><code>floor</code></term>
        <listitem>
  		 	  <para><code>site floor(Number) :: Integer</code></para>
  			  <para>Return the greatest integer less than
or equal to this number.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.core.ceil">
  		  <term><code>ceil</code></term>
        <listitem>
  		 	  <para><code>site ceil(Number) :: Integer</code></para>
  			  <para>Return the least integer greater than
or equal to this number.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
      </section>