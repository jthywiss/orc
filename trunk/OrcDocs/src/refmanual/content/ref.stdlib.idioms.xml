<?xml version='1.0' encoding='UTF-8'?>
<section xml:id="ref.stdlib.idioms"> 
        <!--Generated by OrcDocgen from idioms.inc on Feb 17, 2011 12:41:40 AM-->
        <title>idioms</title>
        <para>Higher-order Orc programming idioms.
Many of these are standard functional-programming
combinators borrowed from Haskell or Scheme.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.curry">
  		  <term><code>curry</code></term>
        <listitem>
  		 	  <para><code>def curry[A,B,C](lambda (A,B) :: C)(A)(B) :: C</code></para>
  			  <para>Curry a function of two arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def curry[A,B,C](lambda (A,B) :: C)(A)(B) :: C
def curry(f)(x)(y) = f(x,y)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.curry3">
  		  <term><code>curry3</code></term>
        <listitem>
  		 	  <para><code>def curry3[A,B,C,D](lambda (A,B,C) :: D)(A)(B)(C) :: D</code></para>
  			  <para>Curry a function of three arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def curry3[A,B,C,D](lambda (A,B,C) :: D)(A)(B)(C) :: D
def curry3(f)(x)(y)(z) = f(x,y,z)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.uncurry">
  		  <term><code>uncurry</code></term>
        <listitem>
  		 	  <para><code>def uncurry[A,B,C](lambda (A)(B) :: C)(A, B) :: C</code></para>
  			  <para>Uncurry a function of two arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def uncurry[A,B,C](lambda (A)(B) :: C)(A, B) :: C
def uncurry(f)(x,y) = f(x)(y)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.uncurry3">
  		  <term><code>uncurry3</code></term>
        <listitem>
  		 	  <para><code>def uncurry3[A,B,C,D](lambda (A)(B)(C) :: D)(A,B,C) :: D</code></para>
  			  <para>Uncurry a function of three arguments.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def uncurry3[A,B,C,D](lambda (A)(B)(C) :: D)(A,B,C) :: D
def uncurry3(f)(x,y,z) = f(x)(y)(z)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.flip">
  		  <term><code>flip</code></term>
        <listitem>
  		 	  <para><code>def flip[A,B,C](lambda (A, B) :: C)(B, A) :: C</code></para>
  			  <para>Flip the order of parameters of a two-argument function.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def flip[A,B,C](lambda (A, B) :: C)(B, A) :: C
def flip(f)(x,y) = f(y,x)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.constant">
  		  <term><code>constant</code></term>
        <listitem>
  		 	  <para><code>def constant[A](A)() :: A</code></para>
  			  <para>Create a function which returns a constant value.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def constant[A](A)() :: A
def constant(x)() = x

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.defer">
  		  <term><code>defer</code></term>
        <listitem>
  		 	  <para><code>def defer[A,B](lambda (A) :: B, A)() :: B</code></para>
  			  <para>Given a function and its argument, return a thunk which applies the function.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def defer[A,B](lambda (A) :: B, A)() :: B
def defer(f, x)() = f(x)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.defer2">
  		  <term><code>defer2</code></term>
        <listitem>
  		 	  <para><code>def defer2[A,B,C](lambda (A,B) :: C, A, B)() :: C</code></para>
  			  <para>Given a function and its arguments, return a thunk which applies the function.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def defer2[A,B,C](lambda (A,B) :: C, A, B)() :: C
def defer2(f, x, y)() = f(x, y)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.ignore">
  		  <term><code>ignore</code></term>
        <listitem>
  		 	  <para><code>def ignore[A,B](lambda () :: B)(A) :: B</code></para>
  			  <para>From a function of no arguments, create a function
of one argument, which is ignored.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def ignore[A,B](lambda () :: B)(A) :: B
def ignore(f)(_) = f()

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.ignore2">
  		  <term><code>ignore2</code></term>
        <listitem>
  		 	  <para><code>def ignore2[A,B,C](lambda () :: C)(A, B) :: C</code></para>
  			  <para>From a function of no arguments, create a function
of two arguments, which are ignored.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def ignore2[A,B,C](lambda () :: C)(A, B) :: C
def ignore2(f)(_, _) = f()

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.compose">
  		  <term><code>compose</code></term>
        <listitem>
  		 	  <para><code>def compose[A,B,C](lambda (B) :: C, lambda (A) :: B)(A) :: C</code></para>
  			  <para>Compose two single-argument functions.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def compose[A,B,C](lambda (B) :: C,
                   lambda (A) :: B)(A) :: C
def compose(f,g)(x) = f(g(x))

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.while">
  		  <term><code>while</code></term>
        <listitem>
  		 	  <para><code>def while[A](lambda (A) :: Boolean, lambda (A) :: A)(A) :: A</code></para>
  			  <para>Iterate a function while a predicate is satisfied, publishing
each value passed to the function. The exact behavior is specified
by the following implementation:
</para><para><programlisting><![CDATA[
def while(p,f) = 
  def loop(x) = Ift(p(x)) >> ( x | loop(f(x)) )
  loop]]></programlisting>
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2 3 4 5
while(
  lambda (n) = (n <= 5),
  lambda (n) = n+1
)(0)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def while[A](lambda (A) :: Boolean,
             lambda (A) :: A)(A) 
  :: A
def while(p,f) = 
  def loop(A) :: A
  def loop(x) = Ift(p(x)) >> ( x | loop(f(x)) )
  loop

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.repeat">
  		  <term><code>repeat</code></term>
        <listitem>
  		 	  <para><code>def repeat[A](lambda () :: A) :: A</code></para>
  			  <para>Call a function sequentially, publishing each value returned by the function.
The expression <code>repeat(f)</code> is equivalent to
the infinite expression <code>f() >x> ( x | f() >x> ( x | f() >x> ... ) )</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def repeat[A](lambda () :: A) :: A
def repeat(f) = f() >x> (x | repeat(f))

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.fork">
  		  <term><code>fork</code></term>
        <listitem>
  		 	  <para><code>def fork[A](List[lambda () :: A]) :: A</code></para>
  			  <para>Call a list of functions in parallel, publishing
all values published by the functions.
</para><para>The expression <code>fork([f,g,h])</code> is equivalent to
the expression <code>f() | g() | h()</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def fork[A](List[lambda () :: A]) :: A
def fork([]) = stop
def fork(p:ps) = p() | fork(ps)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.forkMap">
  		  <term><code>forkMap</code></term>
        <listitem>
  		 	  <para><code>def forkMap[A,B](lambda (A) :: B, List[A]) :: B</code></para>
  			  <para>Apply a function to a list in parallel, publishing all values published
by the applications.
</para><para>The expression <code>forkMap(f, [a,b,c])</code> is equivalent to
the expression <code>f(a) | f(b) | f(c)</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def forkMap[A,B](lambda (A) :: B, List[A]) :: B
def forkMap(f, []) = stop
def forkMap(f, x:xs) = f(x) | forkMap(f, xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.seq">
  		  <term><code>seq</code></term>
        <listitem>
  		 	  <para><code>def seq[A](List[lambda () :: A]) :: Signal</code></para>
  			  <para>Call a list of functions in sequence, publishing
a signal whenever the last function publishes. The
actual publications of the given functions are not
published.
</para><para>The expression <code>seq([f,g,h])</code> is equivalent to
the expression <code>f() >> g() >> h() >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def seq[A](List[lambda () :: A]) :: Signal
def seq([]) = signal
def seq(p:ps) = p() >> seq(ps)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.seqMap">
  		  <term><code>seqMap</code></term>
        <listitem>
  		 	  <para><code>def seqMap[A,B](lambda (A) :: B, List[A]) :: Signal</code></para>
  			  <para>Apply a function to a list in in sequence, publishing
a signal whenever the last application publishes. The
actual publications of the given functions are not
published.
</para><para>The expression <code>seqMap(f, [a,b,c])</code> is equivalent to
the expression <code>f(a) >> f(b) >> f(c) >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def seqMap[A,B](lambda (A) :: B, List[A]) :: Signal
def seqMap(f, []) = signal
def seqMap(f, x:xs) = f(x) >> seqMap(f, xs)
 
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.join">
  		  <term><code>join</code></term>
        <listitem>
  		 	  <para><code>def join[A](List[lambda () :: A]) :: Signal</code></para>
  			  <para>Call a list of functions in parallel and publish
a signal once all functions have completed.
</para><para>The expression <code>join([f,g,h])</code> is equivalent to
the expression <code>(f(), g(), h()) >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def join[A](List[lambda () :: A]) :: Signal
def join([]) = signal
def join(p:ps) = (p(), join(ps)) >> signal
 
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.joinMap">
  		  <term><code>joinMap</code></term>
        <listitem>
  		 	  <para><code>def joinMap[A,B](lambda (A) :: B, List[A]) :: Signal</code></para>
  			  <para>Apply a function to a list in parallel and publish
a signal once all applications have completed.
</para><para>The expression <code>joinMap(f, [a,b,c])</code> is equivalent to
the expression <code>(f(a), f(b), f(c)) >> signal</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def joinMap[A,B](lambda (A) :: B, List[A]) :: Signal
def joinMap(f, []) = signal
def joinMap(f, x:xs) = (f(x), joinMap(f, xs)) >> signal

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.alt">
  		  <term><code>alt</code></term>
        <listitem>
  		 	  <para><code>def alt[A](List[lambda () :: A]) :: A</code></para>
  			  <para>Call each function in the list until one publishes.
</para><para>The expression <code>alt([f,g,h])</code> is equivalent to
the expression <code>f() ; g() ; h()</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def alt[A](List[lambda () :: A]) :: A
def alt([]) = stop
def alt(p:ps) = p() ; alt(ps)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.altMap">
  		  <term><code>altMap</code></term>
        <listitem>
  		 	  <para><code>def altMap[A,B](lambda (A) :: B, List[A]) :: B</code></para>
  			  <para>Apply the function to each element in the list until one publishes.
</para><para>The expression <code>altMap(f, [a,b,c])</code> is equivalent to
the expression <code>f(a) ; f(b) ; f(c)</code>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def altMap[A,B](lambda (A) :: B, List[A]) :: B
def altMap(f, []) = stop
def altMap(f, x:xs) = f(x) ; altMap(f, xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.por">
  		  <term><code>por</code></term>
        <listitem>
  		 	  <para><code>def por(List[lambda () :: Boolean]) :: Boolean</code></para>
  			  <para>Parallel or. Execute a list of boolean functions in parallel, publishing
a value as soon as possible, and <link linkend="ref.concepts.kill">killing</link> any unnecessary ongoing
computation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def por(List[lambda () :: Boolean]) :: Boolean
def por([]) = false
def por(p:ps) =
  Let(
    val b1 = p()
    val b2 = por(ps)
    Ift(b1) >> true | Ift(b2) >> true | (b1 || b2)
  )
  
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.pand">
  		  <term><code>pand</code></term>
        <listitem>
  		 	  <para><code>def pand(List[lambda () :: Boolean]) :: Boolean</code></para>
  			  <para>Parallel and. Execute a list of boolean functions in parallel, publishing
a value as soon as possible, and <link linkend="ref.concepts.kill">killing</link> any unnecessary ongoing
computation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def pand(List[lambda () :: Boolean]) :: Boolean
def pand([]) = true
def pand(p:ps) =
  Let(
    val b1 = p()
    val b2 = pand(ps)
    Iff(b1) >> false | Iff(b2) >> false | (b1 && b2)
  )
 
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.idioms.collect">
  		  <term><code>collect</code></term>
        <listitem>
  		 	  <para><code>def collect[A](lambda () :: A) :: List[A]</code></para>
  			  <para>Run a function, collecting all publications in a list.
Return the list when the function <link linkend="ref.concepts.halt">halts</link>.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [signal, signal, signal, signal, signal]
collect(defer(signals, 5))]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def collect[A](lambda () :: A) :: List[A]
def collect(p) =
  val b = Buffer[A]()
  p() >x> b.put(x) >> stop
  ; b.getAll()
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist>
      </section>