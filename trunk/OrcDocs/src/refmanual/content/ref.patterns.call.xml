<?xml version="1.0" encoding="UTF-8"?>
<!-- ref.patterns.call.xml - DocBook source for an Orc reference manual section

     $Id$

     Copyright (c) 2010 The University of Texas at Austin. All rights reserved.

     Use and redistribution of this file is governed by the license terms in
     the LICENSE file found in the project's top-level directory and also found at
     URL: http://orc.csres.utexas.edu/license.shtml .
  -->

<!-- Call Pattern -->
	<section xml:id="ref.patterns.call">
		<title>Call Pattern</title>
		<section xml:id="ref.patterns.call.body">
			<para>
				A call pattern matches a value produced by a previous call to a site. Each argument pattern
				is matched against the corresponding argument to the original call. 
			</para>
			<para>
			  Call patterns can only be used with values that have an <code>unapply</code> member. All
			  <link linkend="ref.data.datatype">datatype constructors</link> support <code>unapply</code>. 
			  Matching against datatype values is the most common use of the call pattern.
			</para>
		</section>
		
		<section xml:id="ref.patterns.call.syntax">
	  <title>Syntax</title>
	  <para>
	    <productionset>
	    	<productionrecap linkend="ebnf.pattern.call"/>
	    </productionset>
	  </para>
	  </section>
		
		 <section xml:id="ref.patterns.call.examples">
		  <title>Examples</title>

		  <example xml:id="ref.patterns.call.examples.trees"><title>Trees</title>
<programlisting language="orc"><![CDATA[
{- 
   Build up a small binary tree, then use call patterns to deconstruct the tree and extract its contents.   
-}

type Tree = Node(_,_,_) | Empty()

val l = Node(Empty(), 0, Empty())
val r = Node(Empty(), 2, Empty())
val t = Node(l,1,r)

t >Node(l,j,r)>
l >Node(_,i,_)>
r >Node(_,k,_)>
( i | j | k )

{-
OUTPUT:PERMUTABLE
0
1
2
-}

]]></programlisting>
		  </example>
		  
		  <example xml:id="ref.patterns.call.examples.trees"><title>Trees</title>
<programlisting language="orc"><![CDATA[
{- 
   A user-defined call pattern match, using a class with an unapply member.
   Defines a value Square which matches only perfect squares. 
-}

def isqrt(n) =
  val root = Floor(n ** 0.5)
  if (n = root * root) then root else stop

val Square = {. unapply = isqrt .}

signal >> (9 | 12 | 16 | 24 | 25) >Square(n)> n

{-
OUTPUT:PERMUTABLE
3
4
5
-}

]]></programlisting>
		  </example>
		</section>
		
		<section xml:id="ref.patterns.call.links">
		  <title>Related Links</title>
		  
		  <informaltable frame="none">
	  		<tgroup cols="1" align="left">
	    	<thead>
	      		<row>
	        		<entry align="left">Related Reference Topics</entry>
	        	</row>
	    	</thead>
	    	<tbody valign="top">
	     		<row>
	        		<entry><itemizedlist>
	          			<listitem><para><link linkend="ref.patterns">Patterns</link></para></listitem>
	          			<listitem><para><link linkend="ref.expressions.call">Site and Function Calls</link></para></listitem>
	        		</itemizedlist></entry>
	        	</row>
	    	</tbody>
	  		</tgroup>
		  </informaltable>
		  
		  <informaltable frame="none">
	  		<tgroup cols="1" align="left">
	    	<thead>
	      		<row>
	        		<entry align="left">Related Tutorial Sections</entry>
	        	</row>
	    	</thead>
	    	<tbody valign="top">
	     		<row>
	        		<entry><itemizedlist>
          				<listitem><para><olink targetdoc="userguide" targetptr="patterns.extensions">Extensions to Pattern Matching</olink></para></listitem>
        			</itemizedlist></entry>
	        	</row>
	    	</tbody>
	  		</tgroup>
		  </informaltable>
		  
	  </section>
	</section>
