<?xml version='1.0' encoding='UTF-8'?>
<section xml:id="ref.stdlib.text"> 
        <!--Generated by OrcDocgen from text.inc on Feb 2, 2011 6:07:56 PM-->
        <title>text</title>
        <para>Operations on strings.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.String">
  		  <term><code>String</code></term>
        <listitem>
  		 	  <para><code>site String</code></para>
  			  <para>Strings themselves have a set of methods associated with them. These methods can
be invoked on any string literal or any variable bound to a string.
</para><para>The methods documented here are only a subset of those available in the Java
implementation. In practice, strings in the Java implementation support all 
methods provided by Java's <code>String</code> class.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code>String</code></term>
        <listitem>
  		 	  <para><code>site String.length() :: Integer</code></para>
  			  <para>Return the length of the string.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 4
"four".length()]]></programlisting>
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>String</code></term>
        <listitem>
  		 	  <para><code>site String.substring(Integer, Integer) :: String</code></para>
  			  <para>Return the substring of this string covered by the given half-open range.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "orc"
val s = "apple orchard"
s.substring(6,9)]]></programlisting>
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>String</code></term>
        <listitem>
  		 	  <para><code>site String.indexOf(String) :: Integer</code></para>
  			  <para>Return the starting index of the first occurrence of the given string.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 6
"apple orchard".indexOf("orc")]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.print">
  		  <term><code>print</code></term>
        <listitem>
  		 	  <para><code>site print(Top) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Print a value as a string to standard output.
For Java objects, this will call <code>toString()</code> to convert
the object to a String.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.read">
  		  <term><code>read</code></term>
        <listitem>
  		 	  <para><code>site read[A](String) :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Given a string representing an Orc value (using standard
Orc literal syntax), return the corresponding value. If
the argument does not conform to Orc literal syntax,
<link linkend="ref.concepts.halt">halt</link> with an error.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
  read("true") -- publishes the boolean true
| read("1") -- publishes the integer 1
| read("(3.0, [])") -- publishes the tuple (3.0, [])
| read("\"hi\"") -- publishes the string "hi"]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.write">
  		  <term><code>write</code></term>
        <listitem>
  		 	  <para><code>site write(Top) :: String</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Given an Orc value, return its string representation
using standard Orc literal syntax.  If the value is
of a type with no literal syntax,
(for example, it is a site), return an arbitrary string
representation which is intended to be human-readable.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
  write(true) -- publishes "true"
| write(1) -- publishes "1"
| write((3.0, [])) -- publishes "(3.0, [])"
| write("hi") -- publishes "\"hi\""]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.lines">
  		  <term><code>lines</code></term>
        <listitem>
  		 	  <para><code>def lines(String) :: List[String]</code></para>
  			  <para>Split a string into lines, which are substrings
terminated by an endline or the end of the string.
DOS, Mac, and Unix endline conventions are all accepted.
Endline characters are not included in the result.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def lines(String) :: List[String]
def lines(text) =
  (
  val out = text.split("\n|\r\n|\r")
  if out.get(out.length()-1) = "" then
    out.split(0, out.length()-1)
  else out
  )  :!: List[String]

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.unlines">
  		  <term><code>unlines</code></term>
        <listitem>
  		 	  <para><code>def unlines(List[String]) :: String</code></para>
  			  <para>Append a linefeed, "\n", to each string in the sequence
and concatenate the results.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def unlines(List[String]) :: String
def unlines(line:lines) = line + "\n" + unlines(lines)
def unlines([]) = ""
  
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.words">
  		  <term><code>words</code></term>
        <listitem>
  		 	  <para><code>def words(String) :: List[String]</code></para>
  			  <para>Split a string into words, which are sequences of non-whitespace characters separated by whitespace.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[

def words(String) :: List[String]
def words(text) = (text.trim().split("\\s+"))  :!: List[String]


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.text.unwords">
  		  <term><code>unwords</code></term>
        <listitem>
  		 	  <para><code>def unwords(List[String]) :: String</code></para>
  			  <para>Concatenate a sequence of strings with a single space between
each string.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def unwords(List[String]) :: String
def unwords([]) = ""
def unwords([word]) = word
def unwords(word:words) = word + " " + unwords(words)
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist>
      </section>