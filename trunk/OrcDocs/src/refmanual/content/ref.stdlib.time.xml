<?xml version='1.0' encoding='UTF-8'?>
<section xml:id="ref.stdlib.time"> 
        <!--Generated by OrcDocgen from time.inc on Feb 2, 2011 6:07:56 PM-->
        <title>time</title>
        <para>Real and logical time.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.time.Rtimer">
  		  <term><code>Rtimer</code></term>
        <listitem>
  		 	  <para><code>site Rtimer(Integer) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>Publish a signal after the given number of milliseconds.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code>Rtimer</code></term>
        <listitem>
  		 	  <para><code>site Rtimer.time() :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return the current real time in milliseconds, as
measured from midnight January 1, 1970 UTC.
Ranges from 0 to <code>Long.MAX_VALUE</code>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.time.Clock">
  		  <term><code>Clock</code></term>
        <listitem>
  		 	  <para><code>def Clock()() :: Number</code></para>
  			  <para>A call to <code>Clock</code> creates a new relative real-time clock.
Calling a relative clock returns the number
of milliseconds which have elapsed since the
clock was created.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes a value near 1000
val c = Clock()
Rtimer(1000) >> c()]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.time.Ltimer">
  		  <term><code>Ltimer</code></term>
        <listitem>
  		 	  <para><code>site Ltimer(Integer) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>Publish a signal after the given number of logical timesteps,
as measured by the current logical clock.
The logical time advances whenever the computation controlled
by the logical clock is quiescent (i.e. cannot advance on its own).
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry>
  		  <term><code>Ltimer</code></term>
        <listitem>
  		 	  <para><code>site Ltimer.time() :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return the current logical time, as measured by logical
clock which was current when <code>Ltimer.time</code> was evaluated.
Ranges from 0 to <code>Integer.MAX_VALUE</code>.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.time.withLtimer">
  		  <term><code>withLtimer</code></term>
        <listitem>
  		 	  <para><code>def withLtimer[A](lambda () :: A) :: A</code></para>
  			  <para>Run the given thunk in the context of a new inner logical clock.
Within the computation represented by the thunk, calls to
<code>Ltimer</code> refer to the new clock. The
outer clock can only advance when the inner clock becomes
quiescent.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.time.metronome">
  		  <term><code>metronome</code></term>
        <listitem>
  		 	  <para><code>def metronome(Integer) :: Signal</code></para>
  			  <para>Publish a signal at regular intervals, indefinitely. The period is given by the
argument, in milliseconds.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
      </section>