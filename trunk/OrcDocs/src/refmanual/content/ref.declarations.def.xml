<?xml version="1.0" encoding="UTF-8"?>
<!-- ref.declarations.def.xml - DocBook source for an Orc reference manual section

     $Id$

     Copyright (c) 2011 The University of Texas at Austin. All rights reserved.

     Use and redistribution of this file is governed by the license terms in
     the LICENSE file found in the project's top-level directory and also found at
     URL: http://orc.csres.utexas.edu/license.shtml .
  -->

<!-- def -->
	<section xml:id="ref.declarations.def">
		<title><code>def</code>:  Define Function</title>
		
		<!-- Index pointers for unwritten terms -->
		<indexterm><primary>argument type</primary></indexterm>
		
		<para>
			The <code><ind>def</ind></code> declaration defines a function. 
			A function definition consists of an identifier, a sequence of <firstterm baseform="parameter">parameters</firstterm>,
		  and a <firstterm>body</firstterm> expression. 
		</para>
		
		<para>
		  An Orc function behaves much like a function, method, procedure, or subroutine in other programming languages. 
		  However, there are two key differences:
		</para>
		
		<para>
		<itemizedlist>
		<listitem>Orc functions are <ind>lenient</ind>: when a function is called, the argument expressions and the 
		function body are evaluated in parallel. </listitem>
		<listitem>Orc functions may <link linkend="ref.concepts.publish">publish</link> any number of values, including zero,
		during the execution of the function body.</listitem>		  
		</itemizedlist>
		</para>
		
		<para>
		Orc functions also have other features, many of them adopted from typed functional programming languages:
		</para>
		
		<para>
		<itemizedlist>
		  <listitem>Orc functions may be recursive. A group of functions may be mutually recursive.</listitem>
		  <listitem>Patterns may be used as function parameters.</listitem>
		  <listitem>A function may have a guard, which allows the function body to be executed only if a given condition holds.</listitem>
		  <listitem>A function may be defined by multiple clauses.</listitem>
		  <listitem>A function may be defined in a <firstterm baseform="currying">curried</firstterm> form, with multiple argument groups.</listitem>
		</itemizedlist>
		</para>
	
		  
		<section xml:id="ref.declarations.def.syntax">
		  <title>Syntax</title>
		  <para>
		    <productionset>
		    	<productionrecap linkend="ebnf.declaration.definition"/>
		    	<productionrecap linkend="ebnf.parameters"/>
		    	<productionrecap linkend="ebnf.guard"/>
		    </productionset>
		  </para>
    </section>
    
    
		 
		<section xml:id="ref.declarations.def.execution">
		<title>Function Execution</title>
		
		  <para>
		  We first consider the simplest case of argument binding, with only variables and wildcards as parameters.
		  </para>
		
			<para>
		   When a function is <link linkend="ref.expressions.call.function">called</link>, the function body executes,
		   and in parallel the argument expressions of the call are <link linkend="ref.concepts.deflate"><ind>deflate</ind>d</link>.
		   </para>
		   
		   <para>
		   If the execution of the body encounters a use of a parameter whose corresponding argument expression 
		  has not yet published a value, that use <link linkend="ref.concepts.states.block">blocks</link> 
		  until the argument value is available,
			but the rest of the body continues to execute. 
			</para>
			
			<para>
		  Whenever the execution of the body would publish a value, the function call publishes that value.
		  If execution of the body <link linkend="ref.concepts.states.halt">halts</link>, the function call also halts.
		  As a result, a function call might publish any number of times, including zero.
		  </para>
		  
		  <para>
		  If the function call is <link linkend="ref.concepts.states.killed">killed</link>,
		  execution of the body expression is also immediately <link linkend="ref.concepts.states.killed">killed</link>.
		  </para>
		  
		  <para>
		  Because functions are lenient, the following two programs are equivalent:
		  
		  <programlisting language="orc"><![CDATA[
def fn(x,y) = E
fn(G,H)
]]></programlisting>

<programlisting language="orc"><![CDATA[
val x = G
val y = H
E
]]></programlisting>

		</para>
		   
		   <!-- 
		     This is tutorial material, and so it is commented out here. 
		     In the tutorial, at Jay's suggestion, we'll add an example which
		     has three different behaviors in each of the three evaluation modes.
		     - dkitchin
		   -->
		   <!-- 
		  <para>
		 			 We contrast lenient execution with strict and lazy evaluations of
functions, which are common paradigms for function execution. In a
strict execution, the arguments of a function are first evaluated, and
then the function body. In lazy evaluation, the function body starts
executing until the value of an argument is needed; only then is the
argument evaluated. Lenient execution differs from both in that the
body and the arguments are evaluated in parallel.
...
			</para>
			 -->


		</section> 
		
		<section xml:id="ref.declarations.def.recursion">
    <title>Recursion</title>
    
      <para>
        Functions can be <ind>recursive</ind>; that is, the name of a function may be used in its own body.
      </para>
        
        <example xml:id="ref.declarations.def.recursion.examples.factorial">
<programlisting language="orc"><![CDATA[
{- A recursive factorial function -}
def fact(n) = if (n <= 1) then 1 else n * fact(n-1)
]]></programlisting>
      </example>
        
      <para>
        A recursive function might continue executing indefinitely, producing an infinite number of publications.
      </para>  
        
      <example xml:id="ref.declarations.def.recursion.examples.factorial">
<programlisting language="orc"><![CDATA[
{- Publishes a signal every second, forever -}
def metronome() = signal | Rwait(1000) >> metronome()

{- NONRUNNABLE -}
]]></programlisting>
      </example>
        
        
        <para>
        A set of functions may be mutually recursive by naming each other in their bodies.
        There is no special keyword for <ind>mutual recursion</ind>; whenever two or more function
        definitions are adjacent, the compiler detects whether they mutually recurse.
        </para>
<example>       
<programlisting language="orc"><![CDATA[
{- Test if a number is even or odd, using mutual recursion -}
def even(n) = Ift(n = 0) >> true
            | Ift(n <: 0) >> odd(n+1) 
            | Ift(n :> 0) >> odd(n-1)
    
def odd(n) = Ift(n = 0) >> false
           | Ift(n <: 0) >> even(n+1) 
           | Ift(n :> 0) >> even(n-1)

odd(-4)

{- 
OUTPUT:
false
-}
]]></programlisting>
</example>       
    </section>  
		
		<section xml:id="ref.declarations.def.pattern">
		<title>Patterns as Parameters</title>
		
		  <para>
		  A function parameter may be any pattern. 
		  A <firstterm>lenient pattern</firstterm> is either a variable pattern or a wildcard pattern; 
		  such patterns will never fail to match. 
		  Any other pattern is a <firstterm>strict pattern</firstterm>, which could fail to match. 
		  </para>
		  
		  <para>
		  When a function is called, the call blocks until a value is available for each strict pattern. The values are then matched
		  against the strict patterns. If all of these matches succeed, then the function call executes as described earlier. If any 
		  strict pattern match fails, or if any of the argument expressions corresponding to a strict pattern halts, 
		  then the function call halts. 
		  </para>
		  
		  <para>
		  Suppose <code>P</code> is a strict pattern. The following two programs are equivalent:
		  
		  <programlisting language="orc"><![CDATA[
def fn(x,P) = E
fn(G,H)
]]></programlisting>

<programlisting language="orc"><![CDATA[
val x = G
val z = H
z >P> E
]]></programlisting>

		</para>
		
		</section>
		
		<section xml:id="ref.declarations.def.guard">
		<title>Guards</title>
		
		  <para>
		  A function definition may include a guard, of the form <code>if</code> <code>(</code> <replaceable>E</replaceable> <code>)</code>.
		  When a function is called, and each strict pattern matches successfuly as described earlier, then the guard expression
		  <replaceable>E</replaceable> is deflated. If <replaceable>E</replaceable> deflates to <code>true</code>, then the function
		  body is executed. If <replaceable>E</replaceable> deflates to some other value, or halts without publishing a value,
		  then the function call halts silently. 
		  </para>
			
			<para>
		  Suppose <code>P</code> is a strict pattern and <code>Gd</code> is a guard expression.
		  The following two programs are equivalent:
		  
		  <programlisting language="orc"><![CDATA[
def fn(x,P) if (Gd) = E
fn(G,H)
]]></programlisting>

<programlisting language="orc"><![CDATA[
val x = G
val z = H
z >P> Ift(Gd) >> E
]]></programlisting>

			</para>
			
		</section>  
		
		<section xml:id="ref.declarations.def.clauses">
		<title>Clausal Definition</title>
		
		  <para>
			  A function can be defined by a sequence of <firstterm baseform="clause">clauses</firstterm>: repeated
			  function definitions with the same identifier but different parameters. Each clause must have
			  the same number of parameters.  
			</para>
			
			<para>
			  When a function with multiple clauses is called, the argument expressions are deflated, and in
			  parallel the first clause is executed.
			  The clause will <firstterm baseform="clause failure">fail</firstterm> under any of the following conditions:
			  <orderedlist>
			  <listitem>One of the parameters is a strict pattern, and that pattern fails to match.</listitem>
			  <listitem>One of the parameters is a strict pattern, and the corresponding argument expression has halted silently.</listitem>
			  <listitem>There is a guard expression, and it did not deflate to <code>true</code>.</listitem>
			  </orderedlist>
			  
			  If each strict pattern matches successfully, and the guard deflates to <code>true</code>, 
			  then the corresponding function body executes. 
			  If the clause fails, then the next clause is executed.
			  If the last clause fails, then the function call halts silently. 
			</para>

	  </section>
		 
		
		
	  
	  <section xml:id="ref.declarations.def.currying">
		<title>Curried Definition</title>
		
		<para>
		  A function definition may have more than one group of parameters. 
		  If it does, it is a <firstterm baseform="curry">curried</firstterm> definition.
		  When such a function is called, it executes as described earlier,
		  except that rather than executing the function body, it instead immediately
		  publishes a closure of an equivalent function definition, minus the first group of arguments.
		</para>
		
		<para>
		  The following two programs are equivalent:
		  
<programlisting language="orc"><![CDATA[
def fn(x)(y) = E
]]></programlisting>

<programlisting language="orc"><![CDATA[
def fn(x) = ( lambda (y) = E )
]]></programlisting>
    </para>
    
    <para>
		  Combining curried definitions and clausal definitions may result
		  in counterintuitive program behavior.
		  When a function clause has multiple parameter groups, only the first
		  parameter group participates in pattern matching. Subsequent parameter
		  groups are irrelevant until after a clause has been chosen.
		</para>
		
		<para>
		  The following two programs are equivalent:
		  
<programlisting language="orc"><![CDATA[
def fn([x])([y]) = E
def fn(x)(y) = F
]]></programlisting>

<programlisting language="orc"><![CDATA[
def fn([x]) = ( lambda ([y]) = E )
def fn(x) = ( lambda (y) = F )
]]></programlisting>

      Consequently, the call <code>fn([0])([])</code> will halt silently,
      rather than matching the clause <code>fn(x)(y) = F</code>,
      since the clause <code>fn([x])([y]) = E</code> is chosen based on the first argument group
      <code>[0]</code>, even though the subsequent parameter <code>[y]</code> does not match the 
      argument <code>[]</code>.
    </para>
		
		
		</section>
	  
	  

	  <section xml:id="ref.declarations.def.type">
	    <title>Type</title>
	    <para>
	      When a function is defined, the function identifier is bound to a <link linkend="ref.data.closure">closure</link>.
	      A definition must be given <link linkend="ref.types.annotation.function">additional type information</link> so that the typechecker can deduce the correct <link linkend="ref.data.closure.type">function type</link> for the identifier.
	    </para>
	  </section>
	  

    <section xml:id="ref.declarations.def.examples">
			<title>Examples</title>
			
		  <example xml:id="ref.declarations.def.recursive.examples.three"><title>Mutually Recursive Parity v2</title>
<programlisting language="orc"><![CDATA[
{- Return true if parity of 1s in a binary string is even -}

def even([]) = true
def even(1:xs) = odd(xs)
def even(0:xs) = even(xs)

def odd([]) = false
def odd(1:xs) = even(xs)
def odd(0:xs) = odd(xs)

even([1,0,1,0])

{-
OUTPUT:
true
-}
]]></programlisting>
		  </example>
			
			<example xml:id="ref.declarations.def.clausal.examples.sum"><title>Simple example of a clausal function</title>
<programlisting language="orc"><![CDATA[
{- Simple clausal function -}

def sum([]) = 0
def sum(h:t) = h + sum(t)
sum([1,2,3])

{-
OUTPUT:
6
-}

]]></programlisting>
		  </example>

		  <example xml:id="ref.declarations.def.clausal.examples.fib"><title>Clausal function with constant patterns</title>
<programlisting language="orc-demo"><![CDATA[
{- Fibonacci numbers -}

def fib(0) = 1
def fib(1) = 1
def fib(n) = if (n < 0) then 0 else fib(n-1) + fib(n-2)

fib(5)

{-
OUTPUT:
8
-}
]]></programlisting>
		  </example>

		  <example xml:id="ref.declarations.def.clausal.examples.evenodd"><title>Parity</title>
<programlisting language="orc"><![CDATA[
{- Return true if parity of 1s in a binary string is even -}

def even([]) = true
def odd([]) = false
def even(1:xs) = odd(xs)
def odd(1:xs) = even(xs)
def even(_:xs) = even(xs)
def odd(_:xs) = odd(xs)

even([1,1,1,0])

{-
OUTPUT:
false
-}
]]></programlisting>
		  </example>
		  
	  </section>

		<section xml:id="ref.declarations.def.links">
		  <title>Related Links</title>
		  
		  <informaltable frame="none">
	  		<tgroup cols="1" align="left">
	    	<thead>
	      		<row>
	        		<entry align="left">Related Reference Topics</entry>
	        	</row>
	    	</thead>
	    	<tbody valign="top">
	     		<row>
	        		<entry><itemizedlist>
	          			<listitem><para><link linkend="ref.expressions.lambda">Lambda</link></para></listitem>
	          			<listitem><para><link linkend="ref.data.closure">Closures</link></para></listitem>
	        		</itemizedlist></entry>
	        	</row>
	    	</tbody>
	  		</tgroup>
		  </informaltable>
		  
		  <informaltable frame="none">
	  		<tgroup cols="1" align="left">
	    	<thead>
	      		<row>
	        		<entry align="left">Related Tutorial Sections</entry>
	        	</row>
	    	</thead>
	    	<tbody valign="top">
	     		<row>
	        		<entry><itemizedlist>
          				<listitem><para><olink targetdoc="userguide" targetptr="orc.language.clauses">Clauses</olink></para></listitem>
        			</itemizedlist></entry>
	        	</row>
	    	</tbody>
	  		</tgroup>
		  </informaltable>
		  
	  </section>
	</section>
