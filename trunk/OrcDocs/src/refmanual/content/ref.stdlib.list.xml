<?xml version='1.0' encoding='UTF-8'?>
<section xml:id="ref.stdlib.list"> 
        <!--Generated by OrcDocgen from list.inc on Feb 2, 2011 6:07:56 PM-->
        <title>list</title>
        <para>Operations on lists.
Many of these functions are similar to those in the Haskell prelude, but
operate on the elements of a list in parallel.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.each">
  		  <term><code>each</code></term>
        <listitem>
  		 	  <para><code>def each[A](List[A]) :: A</code></para>
  			  <para>Publish every value in a list, simultaneously.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def each[A](List[A]) :: A
def each([]) = stop
def each(h:t) = h | each(t)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.map">
  		  <term><code>map</code></term>
        <listitem>
  		 	  <para><code>def map[A,B](lambda (A) :: B, List[A]) :: List[B]</code></para>
  			  <para>Apply a function to every element of a list (in parallel),
returning a list of the results.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def map[A,B](lambda (A) :: B, List[A]) :: List[B]
def map(f,[]) = []
def map(f,h:t) = f(h):map(f,t)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.reverse">
  		  <term><code>reverse</code></term>
        <listitem>
  		 	  <para><code>def reverse[A](List[A]) :: List[A]</code></para>
  			  <para>Return the reverse of the given list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def reverse[A](List[A]) :: List[A]
def reverse(l) = 
  def tailrev(List[A], List[A]) :: List[A] 
  def tailrev([],x) = x
  def tailrev(h:t,x) = tailrev(t,h:x)
  tailrev(l,[]) 

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.filter">
  		  <term><code>filter</code></term>
        <listitem>
  		 	  <para><code>def filter[A](lambda (A) :: Boolean, List[A]) :: List[A]</code></para>
  			  <para>Return a list containing only those elements which satisfy the predicate.
The filter is applied to all list elements in parallel.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def filter[A](lambda (A) :: Boolean, List[A]) :: List[A]
def filter(p,[]) = []
def filter(p,x:xs) =
  val fxs = filter(p, xs)
  if p(x) then x:fxs else fxs

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.head">
  		  <term><code>head</code></term>
        <listitem>
  		 	  <para><code>def head[A](List[A]) :: A</code></para>
  			  <para>Return the first element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def head[A](List[A]) :: A
def head(x:xs) = x

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.tail">
  		  <term><code>tail</code></term>
        <listitem>
  		 	  <para><code>def tail[A](List[A]) :: List[A]</code></para>
  			  <para>Return all but the first element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def tail[A](List[A]) :: List[A]
def tail(x:xs) = xs

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.init">
  		  <term><code>init</code></term>
        <listitem>
  		 	  <para><code>def init[A](List[A]) :: List[A]</code></para>
  			  <para>Return all but the last element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def init[A](List[A]) :: List[A]
def init([x]) = []
def init(x:xs) = x:init(xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.last">
  		  <term><code>last</code></term>
        <listitem>
  		 	  <para><code>def last[A](List[A]) :: A</code></para>
  			  <para>Return the last element of a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def last[A](List[A]) :: A
def last([x]) = x
def last(x:xs) = last(xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.empty">
  		  <term><code>empty</code></term>
        <listitem>
  		 	  <para><code>def empty[A](List[A]) :: Boolean</code></para>
  			  <para>Is the list empty?
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def empty[A](List[A]) :: Boolean
def empty([]) = true
def empty(_) = false

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.index">
  		  <term><code>index</code></term>
        <listitem>
  		 	  <para><code>def index[A](List[A], Integer) :: A</code></para>
  			  <para>Return the nth element of a list, counting from 0.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def index[A](List[A], Integer) :: A
def index(h:t, 0) = h
def index(h:t, n) = index(t, n-1)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.append">
  		  <term><code>append</code></term>
        <listitem>
  		 	  <para><code>def append[A](List[A], List[A]) :: List[A]</code></para>
  			  <para>Return the first list concatenated with the second.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def append[A](List[A], List[A]) :: List[A]
def append([],l) = l
def append(h:t,l) = h:append(t,l)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.foldl">
  		  <term><code>foldl</code></term>
        <listitem>
  		 	  <para><code>def foldl[A,B](lambda (B, A) :: B, B, List[A]) :: B</code></para>
  			  <para>Reduce a list using the given left-associative binary operation and initial value.
Given the list <code>[x1, x2, x3, ...]</code> and initial value <code>x0</code>,
returns <code>f(... f(f(f(x0, x1), x2), x3) ...)</code>
</para><para>Example using <code>foldl</code> to reverse a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [3, 2, 1]
foldl(flip((:)), [], [1,2,3])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldl[A,B](lambda (B, A) :: B, B, List[A]) :: B
def foldl(f,z,[]) = z
def foldl(f,z,x:xs) = foldl(f,f(z,x),xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.foldl1">
  		  <term><code>foldl1</code></term>
        <listitem>
  		 	  <para><code>def foldl1[A](lambda (A, A) :: A, List[A]) :: A</code></para>
  			  <para>A special case of <code>foldl</code> which uses the last element of the list as the
initial value. It is an error to call this on an empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldl1[A](lambda (A, A) :: A, List[A]) :: A
def foldl1(f,x:xs) = foldl(f,x,xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.foldr">
  		  <term><code>foldr</code></term>
        <listitem>
  		 	  <para><code>def foldr[A,B](lambda (A, B) :: B, B, List[A]) :: B</code></para>
  			  <para>Reduce a list using the given right-associative binary operation and initial value.
Given the list <code>[..., x3, x2, x1]</code> and initial value <code>x0</code>,
returns <code>f(... f(x3, f(x2, f(x1, x0))) ...)</code>
</para><para>Example summing the numbers in a list:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 6
foldr((+), 0, [1,2,3])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldr[A,B](lambda (A, B) :: B, B, List[A]) :: B
def foldr(f,z,xs) = foldl(flip(f),z,reverse(xs))
  
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.foldr1">
  		  <term><code>foldr1</code></term>
        <listitem>
  		 	  <para><code>def foldr1[A](lambda (A, A) :: A, List[A]) :: A</code></para>
  			  <para>A special case of <code>foldr</code> which uses the last element of the list as the
initial value. It is an error to call this on an empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def foldr1[A](lambda (A, A) :: A, List[A]) :: A
def foldr1(f,xs) = foldl1(flip(f),reverse(xs))

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.afold">
  		  <term><code>afold</code></term>
        <listitem>
  		 	  <para><code>def afold[A](lambda (A, A) :: A, List[A]) :: A</code></para>
  			  <para>Reduce a non-empty list using the given associative binary operation.
This function reduces independent subexpressions in parallel; the
calls exhibit a balanced tree structure, so the number of sequential 
reductions performed is O(log n).  For expensive reductions, this
is much more efficient than <code>foldl</code> or <code>foldr</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def afold[A](lambda (A, A) :: A, List[A]) :: A
def afold(f, [x]) = x
{- Here's the interesting part -}
def afold(f, xs) =
  def afold'(List[A]) :: List[A]
  def afold'([]) = []
  def afold'([x]) = [x]
  def afold'(x:y:xs) = f(x,y):afold'(xs)
  afold(f, afold'(xs))


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.cfold">
  		  <term><code>cfold</code></term>
        <listitem>
  		 	  <para><code>def cfold[A](lambda (A, A) :: A, List[A]) :: A</code></para>
  			  <para>Reduce a non-empty list using the given associative and commutative binary operation.
This function opportunistically reduces independent subexpressions in parallel, so the number of
sequential reductions performed is as small as possible.  For expensive reductions, this
is much more efficient than <code>foldl</code> or <code>foldr</code>. In cases
where the reduction does not always take the same amount of time to complete, it 
is also more efficient than <code>afold</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def cfold[A](lambda (A, A) :: A, List[A]) :: A
def cfold(f, []) = stop
def cfold(f, [x]) = x
def cfold(f, [x,y]) = f(x,y)
def cfold(f, L) =
  val c = Buffer[A]()
  def work(Number, List[A]) :: A
  def work(i, x:y:rest) =
    c.put(f(x,y)) >> stop | work(i+1, rest)
  def work(i, [x]) = c.put(x) >> stop | work(i+1, [])
  def work(i, []) =
    if (i <: 2) then c.get() 
    else c.get() >x> c.get() >y>
         ( c.put(f(x,y)) >> stop | work(i-1,[]) ) 
  work(0, L)



]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.zip">
  		  <term><code>zip</code></term>
        <listitem>
  		 	  <para><code>def zip[A,B](List[A], List[B]) :: List[(A,B)]</code></para>
  			  <para>Combine two lists into a list of pairs.
The length of the shortest list determines the length of the result.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def zip[A,B](List[A], List[B]) :: List[(A,B)]
def zip([],_) = []
def zip(_,[]) = []
def zip(x:xs,y:ys) = (x,y):zip(xs,ys)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.unzip">
  		  <term><code>unzip</code></term>
        <listitem>
  		 	  <para><code>def unzip[A,B](List[(A,B)]) :: (List[A], List[B])</code></para>
  			  <para>Split a list of pairs into a pair of lists.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def unzip[A,B](List[(A,B)]) :: (List[A], List[B])
def unzip([]) = ([],[])
def unzip((x,y):z) = (x:xs,y:ys) <(xs,ys)< unzip(z)


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.concat">
  		  <term><code>concat</code></term>
        <listitem>
  		 	  <para><code>def concat[A](List[List[A]]) :: List[A]</code></para>
  			  <para>Concatenate a list of lists into a single list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def concat[A](List[List[A]]) :: List[A]
def concat([]) = []
def concat(h:t) = append(h,concat(t))


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.length">
  		  <term><code>length</code></term>
        <listitem>
  		 	  <para><code>def length[A](List[A]) :: Integer</code></para>
  			  <para>Return the number of elements in a list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def length[A](List[A]) :: Integer
def length([]) = 0
def length(h:t) = 1 + length(t)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.take">
  		  <term><code>take</code></term>
        <listitem>
  		 	  <para><code>def take[A](Integer, List[A]) :: List[A]</code></para>
  			  <para>Given a number <code>n</code> and a list <code>l</code>,
return the first <code>n</code> elements of <code>l</code>.
If <code>n</code> exceeds the length of <code>l</code>,
or <code>n &lt; 0</code>, take halts with an error.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def take[A](Integer, List[A]) :: List[A]
def take(0, _) = []
def take(n, x:xs) =
  if n :> 0 then x:take(n-1, xs)
  else error("Cannot take(" + n + ", _)")

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.drop">
  		  <term><code>drop</code></term>
        <listitem>
  		 	  <para><code>def drop[A](Integer, List[A]) :: List[A]</code></para>
  			  <para>Given a number <code>n</code> and a list <code>l</code>,
return the elements of <code>l</code> after the first <code>n</code>.
If <code>n</code> exceeds the length of <code>l</code>,
or <code>n &lt; 0</code>, drop halts with an error.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def drop[A](Integer, List[A]) :: List[A]
def drop(0, xs) = xs
def drop(n, x:xs) =
  if n :> 0 then drop(n-1, xs)
  else error("Cannot drop(" + n + ", _)")

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.member">
  		  <term><code>member</code></term>
        <listitem>
  		 	  <para><code>def member[A](A, List[A]) :: Boolean</code></para>
  			  <para>Return true if the given item is a member of the given list, and false
otherwise.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def member[A](A, List[A]) :: Boolean
def member(item, []) = false
def member(item, h:t) =
  if item = h then true
  else member(item, t)
  
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.merge">
  		  <term><code>merge</code></term>
        <listitem>
  		 	  <para><code>def merge[A](List[A], List[A]) :: List[A]</code></para>
  			  <para>Merge two sorted lists.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 2, 3, 4, 5]
merge([1,2,3], [2,4,5])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def merge[A](List[A], List[A]) :: List[A]
def merge(xs,ys) = mergeBy((<:), xs, ys)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.mergeBy">
  		  <term><code>mergeBy</code></term>
        <listitem>
  		 	  <para><code>def mergeBy[A](lambda (A,A) :: Boolean, List[A], List[A]) :: List[A]</code></para>
  			  <para>Merge two lists using the given less-than relation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def mergeBy[A](lambda (A,A) :: Boolean,
               List[A], List[A]) :: List[A]
def mergeBy(lt, xs, []) = xs
def mergeBy(lt, [], ys) = ys
def mergeBy(lt, x:xs, y:ys) =
  if lt(y,x) then y:mergeBy(lt,x:xs,ys)
  else x:mergeBy(lt,xs,y:ys)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.sort">
  		  <term><code>sort</code></term>
        <listitem>
  		 	  <para><code>def sort[A](List[A]) :: List[A]</code></para>
  			  <para>Sort a list.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sort([1,3,2])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sort[A](List[A]) :: List[A]
def sort(xs) = sortBy((<:), xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.sortBy">
  		  <term><code>sortBy</code></term>
        <listitem>
  		 	  <para><code>def sortBy[A](lambda (A,A) :: Boolean, List[A]) :: List[A]</code></para>
  			  <para>Sort a list using the given less-than relation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sortBy[A](lambda (A,A) :: Boolean, List[A]) :: List[A]
def sortBy(lt, []) = []
def sortBy(lt, [x]) = [x]
def sortBy(lt, xs) =
  val half = floor(length(xs)/2)
  val front = take(half, xs)
  val back = drop(half, xs)
  mergeBy(lt, sortBy(lt, front), sortBy(lt, back))
 
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.mergeUnique">
  		  <term><code>mergeUnique</code></term>
        <listitem>
  		 	  <para><code>def mergeUnique[A](List[A], List[A]) :: List[A]</code></para>
  			  <para>Merge two sorted lists, discarding duplicates.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3, 4, 5]
mergeUnique([1,2,3], [2,4,5])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def mergeUnique[A](List[A], List[A]) :: List[A]
def mergeUnique(xs,ys) = mergeUniqueBy((=), (<:), xs, ys)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.mergeUniqueBy">
  		  <term><code>mergeUniqueBy</code></term>
        <listitem>
  		 	  <para><code>def mergeUniqueBy[A](lambda (A,A) :: Boolean, lambda (A,A) :: Boolean, List[A], List[A]) :: List[A]</code></para>
  			  <para>Merge two lists, discarding duplicates, using the given equality and less-than relations.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def mergeUniqueBy[A](lambda (A,A) :: Boolean,
                     lambda (A,A) :: Boolean,
                      List[A], List[A])
  :: List[A]
def mergeUniqueBy(eq, lt, xs, []) = xs
def mergeUniqueBy(eq, lt, [], ys) = ys
def mergeUniqueBy(eq, lt, x:xs, y:ys) =
  if eq(y,x) then mergeUniqueBy(eq, lt, xs, y:ys)
  else if lt(y,x) then y:mergeUniqueBy(eq,lt,x:xs,ys)
  else x:mergeUniqueBy(eq,lt,xs,y:ys)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.sortUnique">
  		  <term><code>sortUnique</code></term>
        <listitem>
  		 	  <para><code>def sortUnique[A](List[A]) :: List[A]</code></para>
  			  <para>Sort a list, discarding duplicates.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [1, 2, 3]
sortUnique([1,3,2,3])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sortUnique[A](List[A]) :: List[A]
def sortUnique(xs) = sortUniqueBy((=), (<:), xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.sortUniqueBy">
  		  <term><code>sortUniqueBy</code></term>
        <listitem>
  		 	  <para><code>def sortUniqueBy[A](lambda (A,A) :: Boolean, lambda (A,A) :: Boolean, List[A]) :: List[A]</code></para>
  			  <para>Sort a list, discarding duplicates, using the given equality and less-than relations.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sortUniqueBy[A](lambda (A,A) :: Boolean,
                    lambda (A,A) :: Boolean,
                    List[A])
  :: List[A]
def sortUniqueBy(eq, lt, []) = []
def sortUniqueBy(eq, lt, [x]) = [x]
def sortUniqueBy(eq, lt, xs) =
  val half = floor(length(xs)/2)
  val front = take(half, xs)
  val back = drop(half, xs)
  mergeUniqueBy(eq, lt,
    sortUniqueBy(eq, lt, front),
    sortUniqueBy(eq, lt, back))
  
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.group">
  		  <term><code>group</code></term>
        <listitem>
  		 	  <para><code>def group[A,B](List[(A,B)]) :: List[(A,List[B])]</code></para>
  			  <para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: [(1, [1, 2]), (2, [3]), (3, [4]), (1, [3])]
group([(1,1), (1,2), (2,3), (3,4), (1,3)])]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def group[A,B](List[(A,B)]) :: List[(A,List[B])]
def group(xs) = groupBy((=), xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.groupBy">
  		  <term><code>groupBy</code></term>
        <listitem>
  		 	  <para><code>def groupBy[A,B](lambda (A,A) :: Boolean, List[(A,B)]) :: List[(A,List[B])]</code></para>
  			  <para>Given a list of pairs, group together the second
elements of consecutive pairs with equal first elements,
using the given equality relation.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def groupBy[A,B](lambda (A,A) :: Boolean,
                 List[(A,B)])
  :: List[(A,List[B])]
def groupBy(eq, []) = []
def groupBy(eq, (k,v):kvs) =
  def helper(A, List[B], List[(A,B)]) :: List[(A,List[B])]
  def helper(k,vs, []) = [(k,vs)]
  def helper(k,vs, (k2,v):kvs) =
    if eq(k2,k) then helper(k, v:vs, kvs)
    else (k,vs):helper(k2, [v], kvs)
  helper(k,[v], kvs)
 
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.rangeBy">
  		  <term><code>rangeBy</code></term>
        <listitem>
  		 	  <para><code>def rangeBy(Number, Number, Number) :: List[Number]</code></para>
  			  <para><code>rangeBy(low, high, skip)</code> returns a sorted list of
numbers <code>n</code> which satisfy <code>n = low + skip*i</code> (for some
integer <code>i</code>), <code>n &gt;= low</code>, and <code>n &lt; high</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def rangeBy(Number, Number, Number) :: List[Number]
def rangeBy(low, high, skip) =
  if low <: high
  then low:rangeBy(low+skip, high, skip)
  else []
 
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.range">
  		  <term><code>range</code></term>
        <listitem>
  		 	  <para><code>def range(Number, Number) :: List[Number]</code></para>
  			  <para>Generate a list of numbers in the given half-open range.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def range(Number, Number) :: List[Number]
def range(low, high) = rangeBy(low, high, 1)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.any">
  		  <term><code>any</code></term>
        <listitem>
  		 	  <para><code>def any[A](lambda (A) :: Boolean, List[A]) :: Boolean</code></para>
  			  <para>Return true if any of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def any[A](lambda (A) :: Boolean, List[A]) :: Boolean
def any(p, []) = false
def any(p, x:xs) =
  let(
    val b1 = p(x)
    val b2 = any(p, xs)
    If(b1) >> true | If(b2) >> true | (b1 || b2)
  )
  
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.all">
  		  <term><code>all</code></term>
        <listitem>
  		 	  <para><code>def all[A](lambda (A) :: Boolean, List[A]) :: Boolean</code></para>
  			  <para>Return true if all of the elements of the list match the predicate, and false otherwise.
The predicate is applied to all elements of the list in parellel; the result
is returned as soon as it is known and any unnecessary evaluation of the predicate
terminated.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def all[A](lambda (A) :: Boolean, List[A]) :: Boolean
def all(p, []) = true
def all(p, x:xs) =
  let(
    val b1 = p(x)
    val b2 = all(p, xs)
    Unless(b1) >> false | Unless(b2) >> false | (b1 && b2)
  )

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.sum">
  		  <term><code>sum</code></term>
        <listitem>
  		 	  <para><code>def sum(List[Number]) :: Number</code></para>
  			  <para>Return the sum of all numbers in a list.
The sum of an empty list is 0.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def sum(List[Number]) :: Number
def sum(xs) = foldl(
  (+) :: lambda (Number, Number) :: Number,
  0, xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.product">
  		  <term><code>product</code></term>
        <listitem>
  		 	  <para><code>def product(List[Number]) :: Number</code></para>
  			  <para>Return the product of all numbers in a list.
The product of an empty list is 1.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def product(List[Number]) :: Number
def product(xs) = foldl(
  (*) :: lambda (Number, Number) :: Number,
  1, xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.and">
  		  <term><code>and</code></term>
        <listitem>
  		 	  <para><code>def and(List[Boolean]) :: Boolean</code></para>
  			  <para>Return the boolean conjunction of all boolean values in the list.
The conjunction of an empty list is <code>true</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def and(List[Boolean]) :: Boolean
def and([]) = true
def and(false:xs) = false
def and(true:xs) = and(xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.or">
  		  <term><code>or</code></term>
        <listitem>
  		 	  <para><code>def or(List[Boolean]) :: Boolean</code></para>
  			  <para>Return the boolean disjunction of all boolean values in the list.
The disjunction of an empty list is <code>false</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def or(List[Boolean]) :: Boolean
def or([]) = false
def or(true:xs) = true
def or(false:xs) = or(xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.minimum">
  		  <term><code>minimum</code></term>
        <listitem>
  		 	  <para><code>def minimum[A](List[A]) :: A</code></para>
  			  <para>Return the minimum element of a non-empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def minimum[A](List[A]) :: A
def minimum(xs) =
  -- this def appeases the typechecker
  def minA(x::A,y::A) = min(x,y)
  foldl1(minA, xs)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <varlistentry xml:id="ref.stdlib.list.maximum">
  		  <term><code>maximum</code></term>
        <listitem>
  		 	  <para><code>def maximum[A](List[A]) :: A</code></para>
  			  <para>Return the maximum element of a non-empty list.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def maximum[A](List[A]) :: A
def maximum(xs) =
  -- this def appeases the typechecker
  def maxA(x::A,y::A) = max(x,y)
  foldl1(maxA, xs)
]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist>
      </section>