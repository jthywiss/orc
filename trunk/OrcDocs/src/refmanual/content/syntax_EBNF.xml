<!-- Syntax: EBNF -->
	<section id="ref.syntax.EBNF">
		<title>EBNF Grammar</title>
		<section id="ref.syntax.EBNF.body">
			<para>
				The Orc language grammar can be expressed in Extended Backus-Naur Form (EBNF):
			</para>
			<para>
<table id="full-ebnf-grammar" frame="none" rowsep="0" colsep="0">
<title>Complete Syntax of Orc</title> 
<?dbhtml table-width="80%" ?>
<?dbfo table-width="100%" ?>
<!--  <?dbfo keep-together="always" ?>  -->
<tgroup cols="5" >
<colspec colnum="1" colwidth="1*" align="right"/>
<colspec colnum="2" colwidth="1*" align="center"/>
<colspec colnum="3" colwidth="10*" align="left"/>
<colspec colnum="4" colwidth="5*" align="left"/>
<colspec colnum="5" colwidth="7*" align="left"/>
<tbody>

<row>
<entry>E</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Expression</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant value</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>stop</code></entry>

<entry></entry>
<entry><emphasis>silent expression</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> E <code>,</code> ... <code>,</code> E <code>]</code></entry>

<entry></entry>
<entry><emphasis>list</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E G+</entry>

<entry></entry>
<entry><emphasis>call</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>prefix operator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <emphasis>op</emphasis> E</entry>

<entry></entry>
<entry><emphasis>infix operator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>E</entry>

<entry></entry>
<entry><emphasis>sequential combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>FATBAR</code> E</entry>

<entry></entry>
<entry><emphasis>parallel combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E<code><![CDATA[ <]]></code>P<code><![CDATA[< ]]></code>E</entry>

<entry></entry>
<entry><emphasis>pruning combinator</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>;</code> E</entry>

<entry></entry>
<entry><emphasis>otherwise combinator</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda (</code> P <code>,</code> ... <code>,</code> P <code>)</code> <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>closure (untyped)</emphasis></entry>

</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda</code><code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code><code>::</code> T <code>=</code> E </entry>

<entry></entry>
<entry><emphasis>closure (typed)</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>if</code> E <code>then</code> E <code>else</code> E </entry>

<entry></entry>
<entry><emphasis>conditional</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>D E</entry>

<entry></entry>
<entry><emphasis>scoped declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>type ascription</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>E <code>:!:</code> T</entry>

<entry></entry>
<entry><emphasis>type assertion</emphasis></entry>
</row>

<!--
<row>
<entry></entry>
<entry>|</entry>

<entry>D <code>within</code> E</entry>

<entry></entry>
<entry><emphasis>goal expression w/declarations</emphasis></entry>
</row>
-->

<!-- 
<row>
<entry></entry>
<entry>|</entry>

<entry>T</entry>

<entry></entry>
<entry><emphasis>throw expression</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>TC</entry>

<entry></entry>
<entry><emphasis>try/catch block</emphasis></entry>
</row>

-->

<!--  
 
<row>
<entry>T</entry>
<entry>::=</entry>

<entry> <code>throw </code> E</entry>

<entry><emphasis>Throw</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>TC</entry>
<entry>::=</entry>

<entry> <code>try ( </code> E <code> ) </code> C+</entry>

<entry><emphasis>Try/Catch</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>C</entry>
<entry>::=</entry>

<entry> <code>catch ( </code> P <code> ) </code> E</entry>

<entry><emphasis>Exception Handler</emphasis></entry>
<entry></entry>
</row>
 -->


<row>
<entry>G</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Argument group</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>arguments</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry> <code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code> <code>(</code> E <code>,</code> ... <code>,</code> E <code>)</code> </entry>

<entry></entry>
<entry><emphasis>type parameters plus arguments</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>.</code><emphasis>field</emphasis> </entry>

<entry></entry>
<entry><emphasis>field access</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry> <code>?</code> </entry>

<entry></entry>
<entry><emphasis>dereference</emphasis></entry>
</row>


<row>
<entry>C</entry>
<entry>::=</entry>

<entry><emphasis>Boolean</emphasis> | <emphasis>Number</emphasis> | <emphasis>String</emphasis> | <code>signal</code> | <code>null</code></entry>

<entry><emphasis>Constant</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>X</entry>
<entry>::=</entry>

<entry><emphasis>identifier</emphasis></entry>

<entry><emphasis>Variable</emphasis></entry>
<entry></entry>
</row>


<row>
<entry>D</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Declaration</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry><code>val</code> P <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>value declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>site</code> X <code>=</code> <emphasis>address</emphasis></entry>

<entry></entry>
<entry><emphasis>site declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>class</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>class declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>include</code> <code>"</code> <emphasis>filename</emphasis> <code>"</code></entry>

<entry></entry>
<entry><emphasis>inclusion</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code>+ <code>::</code> T <code>=</code> E</entry>

<entry></entry>
<entry><emphasis>function declaration</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>def</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code>+ <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>function signature</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X <code>=</code> <emphasis>classname</emphasis></entry>

<entry></entry>
<entry><emphasis>type import</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>=</code> T</entry>

<entry></entry>
<entry><emphasis>type alias</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X <code>=</code> UC | ... | UC </entry>

<entry></entry>
<entry><emphasis>datatype declaration (untyped)</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>type</code> X<code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>=</code> TC | ... | TC </entry>

<entry></entry>
<entry><emphasis>datatype declaration (typed)</emphasis></entry>
</row>


<row>
<entry>UC</entry>
<entry>::=</entry>

<entry> X<code>(_,</code> ... <code>,_)</code> </entry>

<entry><emphasis>Constructor (untyped)</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>TC</entry>
<entry>::=</entry>

<entry> X<code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code>  </entry>

<entry><emphasis>Constructor (typed)</emphasis></entry>
<entry></entry>
</row>

<row>
<entry>P</entry>
<entry>::=</entry>

<entry></entry>

<entry><emphasis>Pattern</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>C</entry>

<entry></entry>
<entry><emphasis>constant</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>_</code></entry>

<entry></entry>
<entry><emphasis>wildcard</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X <code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>datatype pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> P <code>,</code> ... <code>,</code> P <code>)</code></entry>

<entry></entry>
<entry><emphasis>tuple pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>[</code> P <code>,</code> ... <code>,</code> P <code>]</code></entry>

<entry></entry>
<entry><emphasis>list pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>:</code> P</entry>

<entry></entry>
<entry><emphasis>cons pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>as</code> X</entry>

<entry></entry>
<entry><emphasis>as pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>=</code>X</entry>

<entry></entry>
<entry><emphasis>equality pattern</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>P <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>type ascription</emphasis></entry>
</row>


<row>
<entry>T</entry>
<entry>::=</entry>

<entry>  </entry>

<entry><emphasis>Type</emphasis></entry>
<entry></entry>
</row>

<row>
<entry></entry>
<entry></entry>

<entry>X</entry>

<entry></entry>
<entry><emphasis>Type variable</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>Integer</code> | <code>Boolean</code> | <code>String</code> | <code>Number</code> | <code>Signal</code> | <code>Top</code> | <code>Bot</code></entry>

<entry></entry>
<entry><emphasis>Ground type</emphasis></entry>
</row>


<row>
<entry></entry>
<entry>|</entry>

<entry><code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code></entry>

<entry></entry>
<entry><emphasis>Tuple type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry><code>lambda</code> <code>[</code> X <code>,</code> ... <code>,</code> X <code>]</code> <code>(</code> T <code>,</code> ... <code>,</code> T <code>)</code> <code>::</code> T</entry>

<entry></entry>
<entry><emphasis>Function type</emphasis></entry>
</row>

<row>
<entry></entry>
<entry>|</entry>

<entry>X<code>[</code> T <code>,</code> ... <code>,</code> T <code>]</code></entry>

<entry></entry>
<entry><emphasis>Type application</emphasis></entry>
</row>


</tbody>
</tgroup>
</table>
</para>
		</section>
		
		<section id="ref.syntax.EBNF.links">
		  <title>Related Links</title>
		  <informaltable frame='all'>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1'/>
			<colspec colname='c2'/>
			<thead>
			<row>
			  <entry align="center">Related Reference Topics</entry>
			  <entry align="center">Related Tutorial Sections</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry><olink targetdoc="refmanual" targetptr="ref.syntax">Syntax</olink></entry>
			  <entry><olink targetdoc="root" targetptr="orc-ebnf-table">Basic Orc Syntax</olink></entry>
			</row>
			<row>
			  <entry><olink targetdoc="refmanual" targetptr="ref.syntax.keywords">Syntax Keywords</olink></entry>
			  <entry><olink targetdoc="root" targetptr="orc-keyword-table">Keywords</olink></entry>
			</row>
			</tbody>
			</tgroup>
		  </informaltable>
	  </section>
	</section>