<?xml version="1.0" encoding="UTF-8"?>
<!-- ref.data.datatype.xml - DocBook source for an Orc reference manual section

     $Id$

     Copyright (c) 2010 The University of Texas at Austin. All rights reserved.

     Use and redistribution of this file is governed by the license terms in
     the LICENSE file found in the project's top-level directory and also found at
     URL: http://orc.csres.utexas.edu/license.shtml .
  -->

<section xml:id="ref.data.datatype">
<title>Algebraic Data Types</title>

<para>An Orc <firstterm>datatype</firstterm> is an algebraic data type, or "tagged union" data type,
where each instance of a datatype has a tag along with a sequence of values.
The set of allowed tags is fixed by the definition of the datatype.
Each tag has a defined number of associated values, similar to a tuple, but, unlike an Orc tuple, the
number of associated values may be zero or more.</para>

<para>When using the Orc type system, datatypes may be polymorphic (taking type parameters).</para>

<para>Datatypes can be recursive; namely, a datatype instance may contain an instance of the same type.</para>

		<section xml:id="ref.expressions.operators.syntax">
		  <title>Syntax</title>
		  <para>
		    <productionset>
		    	<productionrecap linkend="ebnf.declaration.type.datatype"/>
		    	<productionrecap linkend="ebnf.constructor"/>
		    	<productionrecap linkend="ebnf.optionaltype"/>
		    </productionset>
		  </para>
	  </section>

<section xml:id="ref.data.datatype.constructors">
<title>Constructors</title>

<para>Each tag name is declared as a data constructor, which is used to create values of the datatype.</para>

<para>Constructor arguments are executed in parallel, and the first published value of each argument
expression is used as the actual argument to the consructor.  If any argument expression is <link linkend="ref.concepts.silent">silent</link>,
the construtor invocation is silent.</para>

<section xml:id="ref.data.datatype.patterns">
<title>Patterns</title>

<para>Datatype values are inspected by using Orc's <link linkend="ref.patterns">pattern matching</link> facility.</para>

<para>(In the mathematical context of coalgebras, patterns are called "destructors" or "observers",
but those mathematical terms should not be confused with their usage in many object-oriented programming languages.)</para>

</section>

<section xml:id="ref.data.datatype.examples">
<title>Examples</title>


<para></para>

<example xml:id="ref.data.datatypes.examples.shapes">
<title>Enumeration</title>
<programlisting language="orc-demo"><![CDATA[
{- An enumeration, such as Java's enum, can be represented by a datatype
   whose constructors have no arguments. Note that an empty argument list,
   (), is still needed.
-}
type objective = Primary() | Secondary() | Tertiary()

[Secondary(), Tertiary()]

{-
OUTPUT:
[Secondary(), Tertiary()]
-}
]]></programlisting>
</example>

<example xml:id="ref.data.datatypes.examples.shapes">
<title>Geometric shape datatype</title>
<programlisting language="orc-demo"><![CDATA[
{- A Shape type with three data constructors -}
type Shape = Rectangle(_, _) | Circle (_) | Triangle(_, _, _)

{- Create a rectangle -}
Rectangle(2, 3)

{-
OUTPUT:
Rectangle(2, 3)
-}
]]></programlisting>
</example>

<example xml:id="ref.data.datatypes.examples.binarytree">
<title>Binary tree node</title>
<programlisting language="orc"><![CDATA[
{- This is a binary tree datatype
   Leaf nodes carry integer values
-}

type Node = LeafNode(Integer) | InnerNode(Node, Node)

{- Constructing a simple tree
    /\
   1 /\
    2  3
-}
InnerNode(LeafNode(1),InnerNode(LeafNode(2),LeafNode(3)))

{-
OUTPUT:
InnerNode(LeafNode(1), InnerNode(LeafNode(2), LeafNode(3)))
-}
]]></programlisting>
</example>

<example xml:id="ref.data.datatypes.examples.binarytreepoly">
<title>Polymorphic binary tree node</title>
<programlisting language="orc"><![CDATA[
{- This is a binary tree datatype
   Leaf nodes carry values of type T
-}

type Node[T] = LeafNode(T) | InnerNode(Node, Node)

{- Constructing a simple tree
      /\
   "A" /\
    "B"  "C"
-}
InnerNode[String](LeafNode("A"),InnerNode(LeafNode("B"),LeafNode("C")))

{-
NONRUNNABLE
-}
]]></programlisting>
</example>

<example xml:id="ref.data.datatypes.examples.option">
<title>Orc built-in Option type</title>
<programlisting language="orc"><![CDATA[
{- Option is built in to Orc, but if it were
   declared, the declaration would be:
-}

type Option[T] = Some(T) | None

{-
NONRUNNABLE
-}
]]></programlisting>
</example>

</section>

<section xml:id="ref.data.datatype.links">
<title>Related Links</title>

	<informaltable frame="none">
  		<tgroup cols="1" align="left">
    	<thead>
      		<row>
        		<entry align="left">Related Reference Topics</entry>
        	</row>
    	</thead>
    	<tbody valign="top">
     		<row>
        		<entry><itemizedlist>
          			<listitem><para><link linkend="ref.patterns">Patterns</link></para></listitem>
        		</itemizedlist></entry>
        	</row>
    	</tbody>
  		</tgroup>
	  </informaltable>
	  
	  <informaltable frame="none">
  		<tgroup cols="1" align="left">
    	<thead>
      		<row>
        		<entry align="left">Related Tutorial Sections</entry>
        	</row>
    	</thead>
    	<tbody valign="top">
     		<row>
        		<entry><itemizedlist>
          			<listitem><para><olink targetdoc="userguide" targetptr="section.orc.datatypes">Datatypes</olink></para></listitem>
          			<listitem><para><olink targetdoc="userguide" targetptr="section.orc.patterns">Patterns</olink></para></listitem>
          			<listitem><para><olink targetdoc="userguide" targetptr="patterns.extensions">Extensions to Pattern Matching</olink></para></listitem>
        		</itemizedlist></entry>
        	</row>
    	</tbody>
  		</tgroup>
	  </informaltable>

</section>
</section>
</section>
