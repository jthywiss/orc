<?xml version='1.0' encoding='UTF-8'?>
<section xml:id="ref.stdlib.state"> 
        <!--Generated by OrcDocgen from state.inc onJan 31, 2011 5:08:30 PM-->
        <title>state</title>
        <para>General-purpose supplemental data structures.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Some">
  		  <term><code>Some</code></term>
        <listitem>
  		 	  <para><code>site Some[A](A) :: Option[A]</code></para>
  			  <para>An optional value which is available.
This site may also be used in a pattern.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: (3,4)
Some((3,4)) >s> (
    s >Some((x,y))> (x,y)
  | s >None()> signal
)]]></programlisting>
</para>
  			</listitem>
  		</varlistentry><varlistentry xml:id="ref.stdlib.state.None">
  		  <term><code>None</code></term>
        <listitem>
  		 	  <para><code>site None[A]() :: Option[A]</code></para>
  			  <para>An optional value which is not available.
This site may also be used in a pattern.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Cell">
  		  <term><code>Cell</code></term>
        <listitem>
  		 	  <para><code>site Cell[A]() :: Cell[A]</code></para>
  			  <para>Create a write-once storage location.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 5 5
val c = Cell()
  c.write(5) >> c.read()
| Rtimer(1) >> ( c.write(10) ; c.read() )]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Cell</code></term>
        <listitem>
  		 	  <para><code>site Cell[A].read() :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para>Read a value from the cell. If the cell does not yet have a value, block until it receives one.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Cell</code></term>
        <listitem>
  		 	  <para><code>site Cell[A].readnb() :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para>Read a value from the cell. If the cell does not yet have a value, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Cell</code></term>
        <listitem>
  		 	  <para><code>site Cell[A].write(A) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para>Write a value to the cell. If the cell already has a value, halt.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>def (?)[A](Ref[A]) :: A</code></para>
  			  <para>Get the value held by a reference.
<code>x?</code> is equivalent to <code>x.read()</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def (?)[A](Ref[A]) :: A
def (?)(r) = r.read()

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code></code></term>
        <listitem>
  		 	  <para><code>def (:=)[A](Ref[A], A) :: Signal</code></para>
  			  <para>Set the value held by a reference.
<code>x := y</code> is equivalent to <code>x.write(y)</code>.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def (:=)[A](Ref[A], A) :: Signal
def (:=)(r,v) = r.write(v)

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.swap">
  		  <term><code>swap</code></term>
        <listitem>
  		 	  <para><code>def swap[A](Ref[A], Ref[A]) :: Signal</code></para>
  			  <para>Swap the values in two references.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def swap[A](Ref[A], Ref[A]) :: Signal
def swap(r,s) = (r?,s?) >(rval,sval)> (r := sval, s := rval) >> signal


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Semaphore">
  		  <term><code>Semaphore</code></term>
        <listitem>
  		 	  <para><code>site Semaphore(Integer) :: Semaphore</code></para>
  			  <para>Return a semaphore with the given value. The semaphore maintains the invariant
that its value is always non-negative.
</para><para>An example using a semaphore as a lock for a critical section:
<programlisting language="orc-demo"><![CDATA[
-- Prints:
-- Entering critical section
-- Leaving critical section
val lock = Semaphore(1)
lock.acquire() >>
println("Entering critical section") >>
println("Leaving critical section") >>
lock.release()]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Semaphore</code></term>
        <listitem>
  		 	  <para><code>site Semaphore.acquire() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>If the semaphore's value is greater than <code>0</code>, decrement the semaphore and return a signal.
If the semaphore's value is <code>0</code>, block until it becomes greater than <code>0</code>.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Semaphore</code></term>
        <listitem>
  		 	  <para><code>site Semaphore.acquirenb() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>If the semaphore's value is greater than <code>0</code>, decrement the semaphore and return a signal.
If the semaphore's value is <code>0</code>, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Semaphore</code></term>
        <listitem>
  		 	  <para><code>site Semaphore.release() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>If any calls to <code>acquire</code> are blocked, allow the oldest such call
to return.  Otherwise, increment the value of the semaphore.  This may
increment the value beyond that with which the semaphore was constructed.  
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Semaphore</code></term>
        <listitem>
  		 	  <para><code>site Semaphore.snoop() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>If any calls to <code>acquire</code> are blocked, return a signal.
Otherwise, block until some call to <code>acquire</code> blocks.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Semaphore</code></term>
        <listitem>
  		 	  <para><code>site Semaphore.snoopnb() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>If any calls to <code>acquire</code> are blocked, return a signal.
Otherwise, halt.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Buffer">
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A]() :: Buffer[A]</code></para>
  			  <para><!-- XSL/FO doesn't like me using an anchor tag here -->
<para id="orc.lib.Buffer.close">
Create a new buffer (FIFO channel) of unlimited size. A buffer supports
get, put and close operations.
</para>
</para><para>A buffer may be either empty or non-empty, and either open or closed.  When
empty and open, calls to <code>get</code> block.  When empty and closed, calls
to <code>get</code> halt.  When closed, calls to <code>put</code> halt.  In all
other cases, calls return normally.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 10
val b = Buffer()
  Rtimer(1000) >> b.put(10) >> stop
| b.get()]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].get() :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>Get an item from the buffer. If the buffer is open and no items are available,
block until one becomes available. If the buffer is <link
linkend="orc.lib.Buffer.close">closed</link> and no items are available, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].getnb() :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Get an item from the buffer. If no items are available, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].put(A) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Put an item in the buffer. If the buffer is <link
linkend="orc.lib.Buffer.close">closed</link>, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].close() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para>Close the buffer and block until it is empty.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].closenb() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para>Close the buffer and return a signal immediately.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].isClosed() :: Boolean</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>If the buffer is currently closed, return true, otherwise return false.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Buffer</code></term>
        <listitem>
  		 	  <para><code>site Buffer[A].getAll() :: List[A]</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Get all of the items currently in the buffer, emptying the buffer and returning
a list of the items in the order they were added. If there are no items in the
buffer, return an empty list.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.BoundedBuffer">
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A](Integer) :: BoundedBuffer[A]</code></para>
  			  <para>Create a new buffer (FIFO channel) with the given number of slots.
Putting an item into the buffer fills a slot, and getting an item opens a slot.
A buffer with zero slots is equivalent to a synchronous channel.
</para><para>A bounded buffer may be empty, partly filled, or full, and either open or
closed.  When empty and open, calls to <code>get</code> block.  When empty and
closed, calls to <code>get</code> halt. When full and open, calls to
<code>put</code> block. When closed, calls to <code>put</code> halt.  In all
other cases, calls return normally.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: "Put 1" "Got 1" "Put 2" "Got 2"
val c = BoundedBuffer(1)
  c.put(1) >> "Put " + 1
| c.put(2) >> "Put " + 2
| Rtimer(1000) >> (
    c.get() >n> "Got " + n
  | c.get() >n> "Got " + n
  )]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].get() :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>Get an item from the buffer. If the buffer is open and no items are available,
block until one becomes available. If the buffer is <link
linkend="orc.lib.BoundedBuffer.close">closed</link> and no items are available, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].getnb() :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Get an item from the buffer. If no items are available, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].put(A) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>Put an item in the buffer. If no slots are open, block until one becomes open.
If the buffer is <link linkend="orc.lib.BoundedBuffer.close">closed</link>, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].putnb(A) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Put an item in the buffer. If no slots are open, halt.
If the buffer is <link linkend="orc.lib.BoundedBuffer.close">closed</link>, halt.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].close() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para><!-- XSL/FO doesn't like me using an anchor tag here -->
<para id="orc.lib.BoundedBuffer.close">
Close the buffer and block until it is empty.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt. Note that any blocked calls to <code>put</code>
initiated prior to closing the buffer may still be allowed to return as usual.
</para>
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].closenb() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="idempotent"/>
</sitepropset>
</para><para>Close the buffer and return a signal immediately.
This has the effect of immediately causing any blocked calls to
<code>get</code> to halt. In addition, any subsequent calls to <code>put</code>
will halt, and once the buffer becomes empty, any subsequent calls to
<code>get</code> will halt. Note that any blocked calls to <code>put</code>
initiated prior to closing the buffer may still be allowed to return as usual.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].isClosed() :: Boolean</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>If the buffer is currently closed, return true, otherwise return false.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].getOpen() :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return the number of open slots in the buffer. Because of concurrency
this value may become out-of-date so it should only be used for debugging
or statistical measurements.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].getBound() :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Return the total number of slots (open or filled) in the buffer.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>BoundedBuffer</code></term>
        <listitem>
  		 	  <para><code>site BoundedBuffer[A].getAll() :: [A]</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Get all of the items currently in the buffer or waiting to be added, emptying
the buffer and returning a list of the items in the order they were added. If
there are no items in the buffer or waiting to be added, return an empty list.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Array">
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A](Integer) :: Array[A]</code></para>
  			  <para>Create a new native array of the given size. The array is initialized
to contain <code>null</code>s.
</para><para>The resulting array can be called directly with an index, as if
its type were <code>lambda (Integer) :: Ref[A]</code>.
In this case, it returns a <olink targetdoc="root" targetptr="library.state.Ref">Ref</olink>
pointing to the element of the array specified by an index,
counting from 0. Changes to the array are reflected immediately
in the ref and visa versa.
</para><para>Simple example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 3
val a = Array(1)
a(0) := 3 >>
a(0)?]]></programlisting>
</para><para>More complex example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 1 2
val a = Array(3)
for(0, a.length?) >i>
a(i) := i >>
stop
; a(0)? | a(1)? | a(2)?]]></programlisting>
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A](Integer, String) :: Array[A]</code></para>
  			  <para>Create a new primitive array of the given size with the given primitive type.
The initial values in the array depend on the primitive type: for numeric types,
it is <code>0</code>; for booleans, <code>false</code>; for chars, the character
with codepoint <code>0</code>.
</para><para>The element type of the array should be the appropriate wrapper type for the given
primitive type, although a typechecker may not be able to verify this. This
constructor is only necessary when interfacing with certain Java libraries; most
programs will just use the  <code>Array(Integer)</code> constructor.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A].get(Integer) :: A</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>Get the element of the array given by the index, counting from 0.
<code>a.get(i)</code> is equivalent to <code>a(i)?</code>.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A].set(Integer, A) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Set the element of the array given by the index, counting from 0.
<code>a.set(i,v)</code> is equivalent to <code>a(i) := v</code>.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A].slice(Integer, Integer) :: Array[A]</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Return a copy of the portion of the array with indices covered by the given
half-open range. The result array is still indexed counting from 0.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A].length? :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
   <siteprop propname="pure"/>
</sitepropset>
</para><para>Return the size of the array.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Array</code></term>
        <listitem>
  		 	  <para><code>site Array[A].fill(A) :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Set every element of the array to the given value. The given value is not
copied, but is shared by every element of the array, so for example
<code>a.fill(Semaphore(1))</code> would allow you to access the same semaphore
from every element <code>a</code>.
</para><para>This method is primarily useful to initialize or reset an array to a constant
value,
for example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes: 0 0 0
val a = Array(3)
a.fill(0) >> each(a)]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Table">
  		  <term><code>Table</code></term>
        <listitem>
  		 	  <para><code>def Table[A](Integer, lambda (Integer) :: A)(Integer) :: A</code></para>
  			  <para>The call <code>Table(n,f)</code>, where <code>n</code> is a
natural number and <code>f</code> a total function over natural numbers,
creates and returns a partial, pre-computed version of <code>f</code>
restricted to the range (0, <code>n</code>-1). <code>Table</code> does
not return a value until all calls to <code>f</code> have completed.
Consequently, if <code>f</code> halts on any call, the call to 
<code>Table</code> will halt.
</para><para>The user may also think of the call as returning an immutable array whose
<code>i</code>th element is accessed by calling <code>f(i)</code>.
</para><para>This function provides a simple form of memoisation; we avoid recomputing
the value of <code>f(i)</code> by internally storing the result in an array.
</para><para>Example:
<programlisting><![CDATA[
val a = Table(5, fib)
-- Publishes the 4th number of the fibonnaci sequence: 5
a(3)]]></programlisting>
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def Table[A](Integer, lambda (Integer) :: A)(Integer) :: A
def Table(n, f) =
  val a = Array[A](n) :: Array[A]
  def fill(Integer, lambda (Integer) :: A) :: Signal
  def fill(i, f) =
    if i <: 0 then signal
    else ((a(i) := f(i)), fill(i-1, f)) >> signal
  fill(n-1, f) >> (lambda (i :: Integer) = a(i)?)


]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Set">
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A]() :: Set[A]</code></para>
  			  <para>Construct an empty mutable set. The set considers two
values <code>a</code> and <code>b</code> to be the same if
and only if <code>a=b</code>. This site conforms to the Java interface
<code>java.util.Set</code>, except that it obeys Orc rules for equality of
elements rather than Java rules.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A].add(A) :: Boolean</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Add a value to the set, returning true if the set did not already contain the value,
and false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A].remove(Signal) :: Boolean</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Remove a value from the set, returning true if the set contained the value,
and false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A].contains(Signal) :: Boolean</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return true if the set contains the given value, and false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A].isEmpty() :: Boolean</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return true if the set contains no values.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A].clear() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Remove all values from the set.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Set</code></term>
        <listitem>
  		 	  <para><code>site Set[A].size() :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return the number of unique values currently contained in the set.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Counter">
  		  <term><code>Counter</code></term>
        <listitem>
  		 	  <para><code>site Counter(Integer) :: Counter</code></para>
  			  <para>Create a new counter initialized to the given value.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Counter</code></term>
        <listitem>
  		 	  <para><code>site Counter() :: Counter</code></para>
  			  <para>Create a new counter initialized to zero.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Counter</code></term>
        <listitem>
  		 	  <para><code>site Counter.inc() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Increment the counter.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Counter</code></term>
        <listitem>
  		 	  <para><code>site Counter.dec() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>If the counter is already at zero, halt. Otherwise, decrement
the counter and return a signal.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Counter</code></term>
        <listitem>
  		 	  <para><code>site Counter.onZero() :: Signal</code></para>
  			  <para><sitepropset>
   <siteprop propname="blocking"/>
</sitepropset>
</para><para>If the counter is at zero, return a signal. Otherwise
block until the counter reaches zero.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Counter</code></term>
        <listitem>
  		 	  <para><code>site Counter.value() :: Integer</code></para>
  			  <para><sitepropset>
   <siteprop propname="nonblocking"/>
</sitepropset>
</para><para>Return the current value of the counter.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Publishes five signals
val c = Counter(5)
repeat(c.dec)]]></programlisting>
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Dictionary">
  		  <term><code>Dictionary</code></term>
        <listitem>
  		 	  <para><code>site Dictionary() :: Dictionary</code></para>
  			  <para>Create a new dictionary (a mutable map from field names to values), initially
empty.  The first time each field of the dictionary is accessed (using dot
notation), the dictionary creates and returns a new empty 
<olink targetdoc="root" targetptr="library.state.Ref">Ref</olink> which will also be returned on
subsequent accesses of the same field.  Dictionaries allow you to easily create
object-like data structures.
</para><para>Example:
<programlisting language="orc-demo"><![CDATA[
-- Prints: 1 2
val d = Dictionary()
  println(d.one.read()) >>
  println(d.two.read()) >>
  stop
| d.one.write(1) >>
  d.two.write(2) >>
  stop]]></programlisting>
</para><para>Here is the same example rewritten using Orc's reference syntax to improve
clarity:
<programlisting language="orc-demo"><![CDATA[
-- Prints: 1 2
val d = Dictionary()
  println(d.one?) >>
  println(d.two?) >>
  stop
| d.one := 1 >>
  d.two := 2 >>
  stop]]></programlisting>
</para><para>To create a multi-level dictionary, you must explicitly create sub-dictionaries
for each field. For example:
<programlisting language="orc-demo"><![CDATA[
-- Prints: 2
val d = Dictionary()
d.one := Dictionary() >>
d.one?.two := 2 >>
println(d.one?.two?) >>
stop]]></programlisting>
</para><para>Note that you cannot write <code>d.one.two</code>: because <code>d.one</code>
is a reference to a dictionary, and not simply a dictionary, you must
dereference before accessing its fields, as in <code>d.one? >x> x.two</code>.
For readers familiar with the C language, this is the same reason you must
write <code language="c">s->field</code> instead of <code>s.field</code> when
<code>s</code> is a pointer to a struct.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.fst">
  		  <term><code>fst</code></term>
        <listitem>
  		 	  <para><code>def fst[A,B]((A,B)) :: A</code></para>
  			  <para>Return the first element of a pair.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def fst[A,B]((A,B)) :: A
def fst((x,_)) = x

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.snd">
  		  <term><code>snd</code></term>
        <listitem>
  		 	  <para><code>def snd[A,B]((A,B)) :: B</code></para>
  			  <para>Return the second element of a pair.
</para><formalpara>
      <title>Implementation</title>
      <programlisting language="orc-demo">
        <![CDATA[
def snd[A,B]((A,B)) :: B
def snd((_,y)) = y

]]>
      </programlisting>
    </formalpara>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Interval">
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A](A, A) :: Interval[A]</code></para>
  			  <para><code>Interval(a,b)</code> returns an object representing the half-open
interval [<code>a</code>,<code>b</code>).
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A].isEmpty() :: Boolean</code></para>
  			  <para>Return true if this interval is empty.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A].spans(A) :: Boolean</code></para>
  			  <para>Return true if the interval spans the given point, false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A].intersects(Interval[A]) :: Boolean</code></para>
  			  <para>Return true if the given interval has a non-empty intersection with this one,
and false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A].intersect(Interval[A]) :: Interval[A]</code></para>
  			  <para>Return the intersection of this interval with another. If
the two intervals do not intersect, returns an empty interval.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A].contiguous(Interval[A]) :: Boolean</code></para>
  			  <para>Return true if the given interval is contiguous with this one
(overlaps or abuts), and false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Interval</code></term>
        <listitem>
  		 	  <para><code>site Interval[A].union(Interval[A]) :: Interval[A]</code></para>
  			  <para>Return the union of this interval with another. Halts with an error if
the two intervals are not contiguous.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry xml:id="ref.stdlib.state.Intervals">
  		  <term><code>Intervals</code></term>
        <listitem>
  		 	  <para><code>site Intervals[A]() :: Intervals[A]</code></para>
  			  <para>Return an empty set of intervals. An Intervals object is iterable;
iterating over the set returns disjoint intervals in increasing order.
</para><variablelist>
            <?dbfo list-presentation="list"?>
            <?dbhtml list-presentation="table"?>
            <varlistentry>
  		  <term><code>Intervals</code></term>
        <listitem>
  		 	  <para><code>site Intervals[A].isEmpty() :: Boolean</code></para>
  			  <para>Return true if this set of intervals is empty.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Intervals</code></term>
        <listitem>
  		 	  <para><code>site Intervals[A].spans(A) :: Boolean</code></para>
  			  <para>Return true if this set of intervals spans the given point, and false otherwise.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Intervals</code></term>
        <listitem>
  		 	  <para><code>site Intervals[A].intersect(Intervals[A]) :: Intervals[A]</code></para>
  			  <para>Return the intersection of this set of intervals with another.
</para>
  			</listitem>
  		</varlistentry><varlistentry>
  		  <term><code>Intervals</code></term>
        <listitem>
  		 	  <para><code>site Intervals[A].union(Interval[A]) :: Intervals[A]</code></para>
  			  <para>Return the union of this set of intervals with the given interval.
This method is most efficient when the given interval is before
most of the intervals in the set.
</para>
  			</listitem>
  		</varlistentry>
          </variablelist>
  			</listitem>
  		</varlistentry>
          </variablelist>
      </section>