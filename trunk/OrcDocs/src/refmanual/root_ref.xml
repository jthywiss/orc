<!DOCTYPE page [
<!ENTITY ug "../root.xml">  <!-- userguide -->
]>

<book 
	id="refmanual"  
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xi="http://www.w3.org/2001/XInclude">
<title>Orc Reference Manual v<xi:include href="../../VERSION" parse="text"/></title>
	
	<!-- Parallel Combinator -->
   <chapter id="ref.combinators.parallel">
      <title>Parallel Combinator</title>
	  <section id="ref.combinators.parallel.syntax">
		  <title>Syntax</title>
		  <para><emphasis role="strong">EBNF</emphasis>: <emphasis>E ::= ... | . E | E</emphasis></para>
		  <para><emphasis role="strong">Precedence</emphasis>: 
			  <olink targetdoc="root" targetptr="combinators.parallel">parallel</olink> > 
			  <olink targetdoc="root" targetptr="combinators.pruning">pruning</olink> > 
			  <olink targetdoc="root" targetptr="combinators.sequential">sequential</olink> >
			  <olink targetdoc="root" targetptr="combinators.otherwise">otherwise</olink></para>
		  <para><emphasis role="strong">Associativity</emphasis>: left and right </para>
		  <para><emphasis role="strong">Commutative</emphasis>: true </para>
	  </section>
	  <section id="ref.combinators.parallel.behavior">
		  <title>Behavior</title>
		  <itemizedlist><listitem>F | G</listitem></itemizedlist>
		  <para>
			  Orc executes the <olink targetdoc="root" targetptr="terms.expression">expression</olink>
			  F | G by executing F and G concurrently. Whenever F or G communicates with a service or 
			  <olink targetdoc="root" targetptr="terms.publish">publishes</olink> a value, F | G does 
			  so as well. The resulting publications of F | G may be published in arbitrary order. 
		  </para>
	  </section>
	  <section id="ref.combinators.parallel.examples">
		  <title>Examples</title>
		  <examplescript/>
		  <example caption="Parallel Publication" id="ref.combinators.parallel.examples.one">
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
1 | 1+1

-- Note the publication order may be either 1 then 2
-- or 2 then 1
]]></programlisting>
		  </example>

		  <example caption="Parallel Sites" id="ref.combinators.parallel.examples.two">
<programlisting><![CDATA[
{- 
 Access two search sites, Google and Yahoo, in parallel.

 Publish any results they return.

 Since each call may publish a value, the expression
 may publish up to two values.
-}  
Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
		  </example>
		  
	  </section>
	  <section id="ref.combinators.parallel.links">
		  <title>Related Links</title>
		  <informaltable frame='all'>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1'/>
			<colspec colname='c2'/> 
			<thead>
			<row>
			  <entry align="center">Related Reference Topics</entry>
			  <entry align="center">Related Tutorial Sections</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry>Combinators</entry>
			  <entry><olink targetdoc="root" targetptr="special.dot">The . notation</olink></entry>
			</row>
			<row>
			  <entry>Parallel Server Network</entry>
			  <entry><olink targetdoc="root" targetptr="terms.constant">Constants</olink></entry>
			</row>
			<row>
			  <entry>Site</entry>
			  <entry><olink targetdoc="root" targetptr="cor.closures">Closures</olink></entry>
			</row>
			<row>
			  <entry>JavaCall</entry>
			  <!-- Use the following entry to fill up any remaining empty slots in that column -->
			  <entry morerows='1' valign='middle'><para></para></entry>
			</row>
			<row>
			  <entry>Baz</entry>
			</row>
			</tbody>
			</tgroup>
		  </informaltable>
	  </section>
   </chapter>
	
	<!-- Sequential Combinator -->
   <chapter id="ref.combinators.sequential">
      <title>Sequential Combinator</title>
	  <section id="ref.combinators.sequential.syntax">
		  <title>Syntax</title>
		  <para><emphasis role="strong">EBNF</emphasis>: <emphasis>!!!! fix me</emphasis></para>
		  <para><emphasis role="strong">Precedence</emphasis>: 
			  <olink targetdoc="root" targetptr="combinators.parallel">parallel</olink> > 
			  <olink targetdoc="root" targetptr="combinators.pruning">pruning</olink> >
			  <olink targetdoc="root" targetptr="combinators.sequential">sequential</olink> >
			  <olink targetdoc="root" targetptr="combinators.otherwise">otherwise</olink></para>
		  <para><emphasis role="strong">Associativity</emphasis>: right </para>
		  <para><emphasis role="strong">Commutative</emphasis>: no </para>
	  </section>
	  <section id="ref.combinators.parallel.behavior">
		  <title>Behavior</title>
		  <itemizedlist>
			  <listitem>F >x> G
				  <para>
					  The execution of F >x> G starts by executing F. Whenever F publishes a value, a new copy of G is executed in parallel with F (and with any previous copies of G); in that copy of G, variable x is bound to the value published by F. Values published by copies of G are published by the whole expression, but the values published by F are not published by the whole expression; they are consumed by the variable binding. 
				  </para>
			  </listitem>
			  <listitem>F >P> G
				  <para>
					  The sequential combinator may be written as F >P> G, where P is a pattern instead of just a variable name. Any value published by F is matched against the pattern P. If this match is successful, a new copy of G is started with all of the bindings from the match. Otherwise, the published value is simply ignored, and no new copy of G is executed. 
				  </para>
			  </listitem>
			  <listitem>F >> G 
				  <para>
				  This is equivalent to using a wildcard pattern:  >_> 
				  </para>
			  </listitem>		  
		  </itemizedlist>
	  </section>
	  <section id="ref.combinators.sequential.examples">
		  <title>Examples</title>
		  <examplescript/>
		  <example caption="Variable Binding" id="ref.combinators.sequential.examples.one">
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
(0 | 1) >n> n+1
]]></programlisting>
		  </example>

		  <example caption="Variable Binding 2" id="ref.combinators.sequential.examples.two">
<programlisting><![CDATA[
-- Prepend the site name to each published search result
-- The cat site concatenates any number of arguments into one string  
  Google("cupcake") >s> cat("Google: ", s)
| Yahoo("cupcake") >s> cat("Yahoo: ", s)
]]></programlisting>
		  </example>
		  
		  <example caption="Pattern Publication" id="ref.combinators.sequential.examples.three">
<programlisting><![CDATA[
-- Publish 3, 6, and 9 in arbitrary order.
(3,6,9)  >(x,y,z)>  ( x | y | z )
]]></programlisting>
		  </example>
		  
		  <example caption="Filtering" id="ref.combinators.sequential.examples.four">
<programlisting><![CDATA[
-- Filter out values of the form (_,false)
( (4,true) | (5,false) | (6,true) )  >(x,true)> x
-- Publishes 4 and 6 
]]></programlisting>
		  </example>
		  
		  <example caption="Suppressed Publication" id="ref.combinators.sequential.examples.five">
<programlisting><![CDATA[
{- 
  Print two strings to the console,
  but don't publish the return values of the calls.
-}
( println("goodbye") | println("world") ) >> stop
]]></programlisting>
		  </example>
		  
	  </section>
	  <section id="ref.combinators.parallel.links">
		  <title>Related Links</title>
		  <informaltable frame='all'>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1'/>
			<colspec colname='c2'/> 
			<thead>
			<row>
			  <entry align="center">Related Reference Topics</entry>
			  <entry align="center">Related Tutorial Sections</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry>Combinators</entry>
			  <entry><olink targetdoc="root" targetptr="special.dot">The . notation</olink></entry>
			</row>
			<row>
			  <entry>Parallel Server Network</entry>
			  <entry><olink targetdoc="root" targetptr="terms.constant">Constants</olink></entry>
			</row>
			<row>
			  <entry>Site</entry>
			  <entry><olink targetdoc="root" targetptr="cor.closures">Closures</olink></entry>
			</row>
			<row>
			  <entry>JavaCall</entry>
			  <!-- Use the following entry to fill up any remaining empty slots in that column -->
			  <entry morerows='1' valign='middle'><para></para></entry>
			</row>
			<row>
			  <entry>Baz</entry>
			</row>
			</tbody>
			</tgroup>
		  </informaltable>
	  </section>
   </chapter>
	
	<!-- Abstract Concepts -->
	<chapter id="ref.concept">
		<title>Concept</title>
		<section id="ref.concept.body">
			<para>For now, conceptual items are free form and have little to no formatting--a 
				playground for the mind. </para>
		</section>
		<section id="ref.concept.links">
		  <title>Related Links</title>
		  <informaltable frame='all'>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
			<colspec colname='c1'/>
			<colspec colname='c2'/>
			<thead>
			<row>
			  <entry align="center">Related Reference Topics</entry>
			  <entry align="center">Related Tutorial Sections</entry>
			</row>
			</thead>
			<tbody>
			<row>
			  <entry>Combinators</entry>
			  <entry><olink targetdoc="root" targetptr="special.dot">The . notation</olink></entry>
			</row>
			<row>
			  <entry>Parallel Server Network</entry>
			  <entry><olink targetdoc="root" targetptr="terms.constant">Constants</olink></entry>
			</row>
			<row>
			  <entry>Site</entry>
			  <entry><olink targetdoc="root" targetptr="cor.closures">Closures</olink></entry>
			</row>
			<row>
			  <entry>JavaCall</entry>
			  <!-- Use the following entry to fill up any remaining empty slots in that column -->
			  <entry morerows='1' valign='middle'><para></para></entry>
			</row>
			<row>
			  <entry>Baz</entry>
			</row>
			</tbody>
			</tgroup>
		  </informaltable>
	  </section>
	</chapter>
</book>

<!--  Sample xpointer possibilities
   xpointer="xpointer(//section[@id='parallel'])"
   xpointer="xpointer(/book/chapter/section[@id='parallel'])"
   xmlns:xi="http://www.w3.org/2001/XInclude"
-->

<!-- xpointer() scheme examples for direct copy with <frag> tags
	 CAN'T BE USED WITH XALAN (use xsltproc etc.)
	
	  <xi:include
         href="&ug;"
         xpointer="&fx;combinators.parallel.frag.summary&xf;"
      />
	
	 <xi:include
		 href="&ug;"
	     xpointer="&fx;combinators.parallel.frag.examples&xf;"
	  />
-->
