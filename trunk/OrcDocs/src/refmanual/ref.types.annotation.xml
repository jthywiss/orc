<?xml version="1.0" encoding="UTF-8"?>
<!-- ref.types.annotation.xml - DocBook source for an Orc reference manual section

     $Id$

     Copyright (c) 2011 The University of Texas at Austin. All rights reserved.

     Use and redistribution of this file is governed by the license terms in
     the LICENSE file found in the project's top-level directory and also found at
     URL: http://orc.csres.utexas.edu/license.shtml .
  -->

<!-- Type annotation -->
<section xml:id="ref.types.annotation" xmlns="http://docbook.org/ns/docbook">
	<title>Annotations</title>
	
	<!-- Index pointers for unwritten terms -->
	<indexterm><primary>argument type</primary></indexterm>
	
	<para>
	The Orc typechecker uses a <link linkend="ref.types.metatheory.origin">type inference algorithm</link> to deduce
	type information from a program without any help from the programmer. In many contexts, the typechecker can
	find all of the type information it needs; however, there are some cases where extra information is needed.
	For this purpose, there are four kinds of <indexterm significance="preferred"><primary>type annotation</primary></indexterm><firstterm baseform="type annotation">annotations</firstterm> that may be used to
	enrich an Orc program with additional type information. Orc also allows <emphasis>assertions</emphasis>,
	which may be used to override the typechecker.
	</para>
	
	<para>
	Note that due to the <link linkend="ref.types.metatheory.erasure">erasure</link> property of the Orc type system,
	adding an annotation will never change the runtime behavior of the program.
	</para>
	
	<section xml:id="ref.types.annotation.explicitargs">
	<title>Explicit Type Arguments</title>
	
	<para>
		<link linkend="ref.expressions.call">Calls</link> to polymorphic sites or functions 
		may be annotated by providing explicit type arguments, as described for 
		<link linkend="ref.types.polymorphism.calls">polymorphic calls</link>. The typechecker
		can usually infer type parameters, but there are certain cases where it does not have
		enough information, such as when calling polymorphic factory sites like <code>Channel</code>
		or <code>Ref</code>.
	</para>
	
	</section>
	
	<section xml:id="ref.types.annotation.function">
	<title>Function Annotation</title>
	<para>
		Whenever a function is defined (using the <code>def</code> keyword),
		in order for the typechecker to determine its type, 
		the definition must be accompanied by annotations which describe the argument types and return type
		of the function. If the function is polymorphic, the names of its type parameters must also be given.
		This is the same information that a <link linkend="ref.data.closure.type">function type</link> carries.
		There are multiple ways to provide this information, and some of it can be inferred under certain conditions.
  </para>

	<para>
	  The most comprehensive way to provide type information about a function is through a <indexterm significance="preferred"><primary>signature</primary></indexterm><firstterm>signature</firstterm>.
		A signature precedes a function definition, providing a sequence of type parameters, a sequence of argument types,
		and a return type.
	</para>
	
	<para>
	  <productionset>
	    <productionrecap linkend="ebnf.declaration.signature"/>
	    <productionrecap linkend="ebnf.declaration.def"/>
	  </productionset>
	</para>
		
	<para>
	  Annotations may also be written directly into a clause of a function definition. 
	  For example, the following definitions are equivalent:

<programlisting language="orc"><![CDATA[
{- Annotation using a signature -}
def min(Number, Number) :: Number
def min(x,y) = if (x <: y) then x else y

{- Inline annotation -}
def min(x :: Number, y :: Number) :: Number = if (x <: y) then x else y
]]></programlisting>

	</para>  
	  
	<para>
	  If the function is not recursive, then the inline return type annotation is optional, because the typechecker 
	  can infer the return type from the body expression without additional information.
	</para>

	<para>
	  When writing a <link linkend="ref.expressions.lambda"><code>lambda</code> expression</link>, type annotations
	  must be included in this way, since there is no way to write a separate signature. The return type annotation
	  is not needed, since a <code>lambda</code> will never be recursive. The parameter types are required and cannot
	  be inferred, except in one context: when a <code>lambda</code> expression appears as an argument to a call which
	  requires no other inference, then the argument types can be inferred from the type of the target.  
	</para>

	</section>
		
  <section xml:id="ref.types.annotation.pattern">
	<title>Pattern Annotations</title>
	
	<para>
	<productionset>
	  <productionrecap linkend="ebnf.pattern.annotated"/>
	</productionset>
	</para>
	
	<para>
	A pattern may be annotated to specify the type of values that the pattern will match against. The typechecker can
	then verify this stated type, rather than attempting to infer it, which may provide enough type information to
	make other inferences possible or resolve ambiguities. Furthermore, adding extra type information makes it easier 
	to pinpoint the source of a typechecking failure.
	</para>    
	
	</section>
		
	 <section xml:id="ref.types.annotation.expression">
	 <title>Expression Annotations</title>
	 
	 <para>
		 <productionset>
	    <productionrecap linkend="ebnf.expression.annotated"/>
	   </productionset>
   </para>
   
   <para>
		 An expression may be annotated to specify the type of values that it will publish. The typechecker can
		 then verify this stated type, rather than attempting to infer it, which may provide enough type information to
		 make other inferences possible or resolve ambiguities. For example, the typechecker may not be able to infer the correct join type for a parallel combinator,
		 but it is always able to check that both branches are subtypes of an already provided type. Furthermore, adding extra
		 type information makes it easier to pinpoint the source of a typechecking failure.
	 </para>   

	</section>


<section xml:id="ref.types.annotation.assertion">
<title>Assertions</title>

<productionset>
	    <productionrecap linkend="ebnf.expression.asserted"/>
	  </productionset>

<para>
While the typechecker can be helpful, it will not accept programs that are not typesafe according to
its algorithm, which can be burdensome when the programmer knows that an expression will have a
certain type but the typechecker cannot verify it.
</para>

<para>
Since the typechecker is optional, it can always be turned off in these cases. But this is often
too drastic a solution: typechecking difficulties often arise from small segments of a much larger
program, and the rest of the program still benefits from typechecking. 
</para>

<para>
The typechecker may be selectively disabled for parts of a program. For this purpose,
the typechecker supports a special annotation on expressions called an <indexterm significance="preferred"><primary>assertion</primary></indexterm><firstterm>assertion</firstterm>
An assertion is used like an annotation, but rather than verifying that an expression
has the stated type, the typechecker instead assumes that the stated type is correct,
without examining the expression at all. Thus, the programmer can supply any type
without being restricted by the typechecking algorithm.
</para>

<para>
This feature should be used sparingly, with the knowledge that it does compromise the integrity
of the typechecking algorithm. If the supplied type is wrong, runtime type errors could propagate to any
part of the program that depends on that type. Assertions are useful for rapid prototyping, but
they are not recommended for production code.
</para>

</section>

		 
		 
	<section xml:id="ref.types.annotation.links">
	  <title>Related Links</title>
		<itemizedlist>
			<title>Related Reference Topics</title>
			<listitem><para><link linkend="ref.declarations.def"><code>def</code>:  Define Function</link></para></listitem>
			<listitem><para><link linkend="ref.expressions.lambda"><code>lambda</code> Expressions</link></para></listitem>
			<listitem><para><link linkend="ref.patterns">Patterns</link></para></listitem>
		</itemizedlist>
		<!-- 
		<itemizedlist>
			<title>Related Tutorial Sections</title>
			<listitem><para>TODO</para></listitem>
		</itemizedlist>
		-->		  
	  </section>
	  
</section>
