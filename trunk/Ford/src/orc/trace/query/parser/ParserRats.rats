module orc.trace.query.parser.ParserRats;

header {
	import java.math.BigInteger;
	import java.math.BigDecimal;
	import java.io.Serializable;
	import java.util.Map;
	import java.util.HashMap;
	import xtc.util.Utilities;
	//import xtc.util.Action;
	//import xtc.util.Pair;
	
	import orc.trace.Term;
	import orc.trace.values.*;
	import orc.trace.query.patterns.*;
	import orc.trace.query.predicates.*;
	import orc.trace.query.*;
}

body {
	private Map<String, Variable> symbols = new HashMap<String, Variable>();
	private Variable intern(String name) {
		if (symbols.containsKey(name)) {
			return symbols.get(name);
		} else {
			Variable out = new Variable(name);
			symbols.put(name, out);
			return out;
		}
	}
}

option constant;

public Predicate Query = Space yyValue:Disjunction EndOfFile;

Predicate Predicate = Disjunction;

Predicate BinaryTemporal = 
	left:Disjunction void:U right:BinaryTemporal {
		yyValue = new UntilPredicate(left, right, true);
	}
	/ left:Disjunction void:PU right:BinaryTemporal {
		yyValue = new UntilPredicate(left, right, false);
	}
	/ left:Disjunction void:R right:BinaryTemporal {
		yyValue = new ReleasePredicate(left, right, true);
	}
	/ left:Disjunction void:PR right:BinaryTemporal {
		yyValue = new ReleasePredicate(left, right, false);
	}
	/ left:Disjunction void:W right:BinaryTemporal {
		yyValue = new WeakUntilPredicate(left, right, true);
	}
	/ left:Disjunction void:PW right:BinaryTemporal {
		yyValue = new WeakUntilPredicate(left, right, false);
	}
	;

Predicate Disjunction =
	left:Conjunction void:SEMICOLON right:Disjunction {
		yyValue = new OrPredicate(left, right);
	}
	/ Conjunction
	;

Predicate Conjunction =
	left:Negation void:COMMA right:Conjunction {
		yyValue = new AndPredicate(left, right);
	}
	/ Negation
	;

Predicate Negation =
	void:NOT p:UnaryTemporal {
		yyValue = new NotPredicate(p);
	}
	/ UnaryTemporal
	;

Predicate UnaryTemporal =
	void:X p:Predicate {
		yyValue = new NextPredicate(p, true);
	}
	/ void:PX p:Predicate {
		yyValue = new NextPredicate(p, false);
	}
	/ void:F p:Predicate {
		yyValue = new UntilPredicate(TruePredicate.singleton, p, true);
	}
	/ void:PF p:Predicate {
		yyValue = new UntilPredicate(TruePredicate.singleton, p, false);
	}
	/ void:G p:Predicate {
		yyValue = new ReleasePredicate(FalsePredicate.singleton, p, true);
	}
	/ void:PG p:Predicate {
		yyValue = new ReleasePredicate(FalsePredicate.singleton, p, false);
	}
	/ void:AT v:BindingPattern p:Predicate {
		yyValue = new AtPredicate(v, p);
	}
	/ BasicPredicate
	;
	
Predicate BasicPredicate =
	left:Pattern void:EQ right:Pattern {
		yyValue = new EqualPredicate(left, right);
	}
	/ void:LPAREN Predicate void:RPAREN
	/ void:TRUE {
		yyValue = TruePredicate.singleton;
	}
	/ void:FALSE {
		yyValue = FalsePredicate.singleton;
	}
	;

Term Pattern = ConsPattern;

Term ConsPattern =
	left:BasicPattern void:COLON right:Pattern {
		yyValue = new ConsPattern(left, right);
	}
	/ BasicPattern
	;
	
Term BasicPattern =
	BindingPattern
	/ literal:Literal {
		yyValue = new ConstantValue(literal);
	}
	/ LPAREN ps:PatternList RPAREN {
		yyValue = new TuplePattern(ps.list().toArray(new Pattern[]{}));
	}
	;
	
BindingPattern BindingPattern =
	UNDERSCORE {
		yyValue = new Variable();
	}
	/ v:Variable props:(void:DOT Identifier)* {
		BindingPattern out = v;
		for (String key : props) {
			out = new PropertyPattern(out, key);
		}
		yyValue = out;
	}
	;

Variable Variable =
	void:STAR {
		yyValue = Frame.CURRENT_EVENT;
	}
	/ name:Identifier {
		yyValue = intern(name);
	}
	;
	
Pair<Term> PatternList =
	f:Pattern fs:(void:COMMA fs:Pattern)* {
		yyValue = new Pair<Term>(f, fs);
	}
	/ /* empty */ {
		yyValue = Pair.empty();
	}
	;

/////////////////////////////////////////////
// Literals
/////////////////////////////////////////////

Serializable Literal =
	Number
	/ StringLiteral
	/ TRUE { yyValue = true; }
	/ FALSE { yyValue = false; }
	;
	
Number Number = Float / Integer;
BigDecimal Float =
	rep:FloatToken Space {
		try {
			yyValue = BigDecimal.valueOf(Double.parseDouble(rep));
		} catch (NumberFormatException e) {
			// impossible by construction
			throw new AssertionError(e);
		}
	}
	;
// Note that even if a number has no decimal, having an exponent
// is enough to make it floating point
String FloatToken = SignedIntegerToken ('.' [0-9]+ Exponent? / Exponent);
String Exponent = [eE] [+\-]? IntegerToken;
BigInteger Integer =
	rep:SignedIntegerToken Space {
		try {
			yyValue = BigInteger.valueOf(Long.parseLong(rep));
		} catch (NumberFormatException e) {
			// impossible by construction
			throw new AssertionError(e);
		}
	}
	;
String SignedIntegerToken = '-'? IntegerToken;
String IntegerToken = '0' / [1-9] [0-9]*;
	
String StringLiteral =
	string:StringLiteralToken Space {
		yyValue = Utilities.unescape(string.substring(1, string.length()-1));
	}
	;
String StringLiteralToken = ["] ( EscapeSequence / !["\\] _ )* ["] ;
transient String EscapeSequence =
   '\\' [btnfr"'\-\[\\\]] / UnicodeEscape / OctalEscape
   ;
transient String UnicodeEscape = '\\' 'u' HexDigit HexDigit HexDigit HexDigit ;
transient String HexDigit = [0-9a-fA-F] ;
transient String OctalEscape =
	'\\' [0-3] OctalDigit OctalDigit
	/ '\\' OctalDigit OctalDigit
	/ '\\' OctalDigit
	;
transient String OctalDigit = [0-7];
	
String Identifier = VariableToken Space;
String VariableToken = [a-z] [a-zA-Z0-9_]*;

/////////////////////////////////////////////
// Keywords
/////////////////////////////////////////////

transient String U = "U" Space;
transient String X = "X" Space;
transient String R = "R" Space;
transient String F = "F" Space;
transient String G = "G" Space;
transient String W = "W" Space;
// the P* versions of the operators are the ones that
// refer to the past; the regular operators
// refer to the future
transient String PU = "<U" Space;
transient String PX = "<X" Space;
transient String PR = "<R" Space;
transient String PF = "<F" Space;
transient String PG = "<G" Space;
transient String PW = "<W" Space;
transient String STAR = "*" Space;
transient String AT = "at" Space;
transient String TRUE = "true" Space;
transient String FALSE = "false" Space;
transient String EQ = "=" Space;
transient String LPAREN = "(" Space;
transient String RPAREN = ")" Space;
transient String LBRACKET = "[" Space;
transient String RBRACKET = "]" Space;
transient String DOT = "." Space;
transient String UNDERSCORE = "_" Space;
transient String COMMA = "," Space;
transient String SEMICOLON = ";" Space;
// in Prolog this would be \+, but I like ~ much better
transient String NOT = "~" Space;
transient String COLON = ":" Space;
	
/////////////////////////////////////////////
// Whitespace, Comments, etc.
/////////////////////////////////////////////

transient void Space = (' ' / '\t' / '\f' / '\r' / '\n')*;
transient void EndOfFile = !_;